{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+","tags":false},"docs":[{"location":"","text":"<p></p>","title":"Getting started"},{"location":"#what-is-vectorbt","text":"<p>vectorbt is a Python package for quantitative analysis that takes a novel approach to backtesting:  it operates entirely on pandas and NumPy objects, and is accelerated by Numba  to analyze any data at speed and scale. This allows for testing of many thousands of strategies in seconds.</p> <p>In contrast to other backtesters, vectorbt represents complex data as (structured) NumPy arrays. This enables superfast computation using vectorized operations with NumPy and non-vectorized but dynamically  compiled operations with Numba. It also integrates Plotly and  Jupyter Widgets to display complex charts and dashboards akin  to Tableau right in the Jupyter notebook. Due to high performance, vectorbt can process large amounts of  data even without GPU and parallelization and enables the user to interact with data-hungry widgets  without significant delays.</p> <p>With vectorbt, you can</p> <ul> <li> Backtest strategies in a couple of lines of Python code</li> <li> Enjoy the best of both worlds: the ecosystem of Python and the speed of C</li> <li> Retain full control over execution and your data (as opposed to web-based services such as TradingView)</li> <li> Optimize your trading strategy against many parameters, assets, and periods in one go</li> <li> Uncover hidden patterns in financial markets</li> <li> Analyze time series and engineer new features for ML models</li> <li> Supercharge pandas and your favorite tools to run much faster</li> <li> Visualize strategy performance using interactive charts and dashboards (both in Jupyter and browser)</li> <li> Fetch and process data periodically, send Telegram notifications, and more </li> </ul>","title":"What is vectorbt?"},{"location":"#why-vectorbt","text":"<p>While there are many great backtesting packages for Python, vectorbt combines an extremely fast  backtester and a data science tool: it excels at processing performance and offers interactive tools  to explore complex phenomena in trading. With it, you can traverse a huge number of strategy  configurations, time periods, and instruments in little time, to explore where your strategy  performs best and to uncover hidden patterns in data. Accessing and analyzing this information  for yourself could give you an information advantage in your own trading.</p>","title":"Why vectorbt?"},{"location":"#how-it-works","text":"<p>vectorbt was implemented to address common performance shortcomings of backtesting libraries.  It builds upon the idea that each instance of a trading strategy can be represented in a vectorized form,  so multiple strategy instances can be packed into a single multi-dimensional array, processed in a  highly efficient manner, and compared easily. It overhauls the traditional OOP approach that represents  strategies as classes and other data structures, which are easier to write and extend compared to vectors,  but harder to analyze and also require additional effort to do it quickly.</p> <p>Thanks to the time-series nature of trading data, most of the aspects related to backtesting can be  translated into vectors. Instead of processing one element at a time, vectorization allows us to avoid  naive looping and perform the same operation on all elements at the same time. The path-dependency  problem related to vectorization is solved by using Numba - it allows both writing iterative code  and compiling slow Python loops to be run at the native machine code speed.</p>","title":"How it works"},{"location":"#example","text":"<p>Let's say we have a complex strategy that has lots of (hyper-)parameters that have to be tuned. While brute-forcing all combinations seems to be a rather unrealistic attempt, we can still interpolate, and vectorbt makes exactly this possible. It doesn't care whether we have one strategy instance or millions. As soon as their vectors can be concatenated into a matrix and we have enough memory, we can analyze them in one go.</p> <p>Let's start with fetching the daily price of Bitcoin:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from datetime import datetime\n\n&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; # Prepare data\n&gt;&gt;&gt; start = '2019-01-01 UTC'  # crypto is in UTC\n&gt;&gt;&gt; end = '2020-01-01 UTC'\n&gt;&gt;&gt; btc_price = vbt.YFData.download('BTC-USD', start=start, end=end).get('Close')\n\n&gt;&gt;&gt; btc_price\nDate\n2019-01-01 00:00:00+00:00    3843.520020\n2019-01-02 00:00:00+00:00    3943.409424\n2019-01-03 00:00:00+00:00    3836.741211\n...                                  ...\n2019-12-30 00:00:00+00:00    7292.995117\n2019-12-31 00:00:00+00:00    7193.599121\n2020-01-01 00:00:00+00:00    7200.174316\nFreq: D, Name: Close, Length: 366, dtype: float64\n</code></pre> <p>We are going to test a simple Dual Moving Average Crossover (DMAC) strategy. For this, we are going to use <code>MA</code> class for calculating moving averages and generating signals.</p> <p>Our first test is rather simple: buy when the 10-day moving average crosses above the 20-day moving average, and sell when opposite.</p> <pre><code>&gt;&gt;&gt; fast_ma = vbt.MA.run(btc_price, 10, short_name='fast')\n&gt;&gt;&gt; slow_ma = vbt.MA.run(btc_price, 20, short_name='slow')\n\n&gt;&gt;&gt; entries = fast_ma.ma_crossed_above(slow_ma)\n&gt;&gt;&gt; entries\nDate\n2019-01-01 00:00:00+00:00    False\n2019-01-02 00:00:00+00:00    False\n2019-01-03 00:00:00+00:00    False\n...                            ...\n2019-12-30 00:00:00+00:00    False\n2019-12-31 00:00:00+00:00    False\n2020-01-01 00:00:00+00:00    False\nFreq: D, Length: 366, dtype: bool\n\n&gt;&gt;&gt; exits = fast_ma.ma_crossed_below(slow_ma)\n&gt;&gt;&gt; exits\nDate\n2019-01-01 00:00:00+00:00    False\n2019-01-02 00:00:00+00:00    False\n2019-01-03 00:00:00+00:00    False\n...                            ...\n2019-12-30 00:00:00+00:00    False\n2019-12-31 00:00:00+00:00    False\n2020-01-01 00:00:00+00:00    False\nFreq: D, Length: 366, dtype: bool\n\n&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(btc_price, entries, exits)\n&gt;&gt;&gt; pf.total_return()\n0.636680693047752\n</code></pre> <p>One strategy instance of DMAC produced one column in signals and one performance value.</p> <p>Adding one more strategy instance is as simple as adding one more column. Here we are passing an array of window sizes instead of a single value. For each window size in this array, it computes a moving average over the entire price series and stores it in a distinct column.</p> <pre><code>&gt;&gt;&gt; # Multiple strategy instances: (10, 30) and (20, 30)\n&gt;&gt;&gt; fast_ma = vbt.MA.run(btc_price, [10, 20], short_name='fast')\n&gt;&gt;&gt; slow_ma = vbt.MA.run(btc_price, [30, 30], short_name='slow')\n\n&gt;&gt;&gt; entries = fast_ma.ma_crossed_above(slow_ma)\n&gt;&gt;&gt; entries\nfast_window                   10     20\nslow_window                   30     30\nDate\n2019-01-01 00:00:00+00:00  False  False\n2019-01-02 00:00:00+00:00  False  False\n2019-01-03 00:00:00+00:00  False  False\n...                          ...    ...\n2019-12-30 00:00:00+00:00  False  False\n2019-12-31 00:00:00+00:00  False  False\n2020-01-01 00:00:00+00:00  False  False\n\n[366 rows x 2 columns]\n\n&gt;&gt;&gt; exits = fast_ma.ma_crossed_below(slow_ma)\n&gt;&gt;&gt; exits\nfast_window                   10     20\nslow_window                   30     30\nDate\n2019-01-01 00:00:00+00:00  False  False\n2019-01-02 00:00:00+00:00  False  False\n2019-01-03 00:00:00+00:00  False  False\n...                          ...    ...\n2019-12-30 00:00:00+00:00  False  False\n2019-12-31 00:00:00+00:00  False  False\n2020-01-01 00:00:00+00:00  False  False\n\n[366 rows x 2 columns]\n\n&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(btc_price, entries, exits)\n&gt;&gt;&gt; pf.total_return()\nfast_window  slow_window\n10           30             0.848840\n20           30             0.543411\nName: total_return, dtype: float64\n</code></pre> <p>For the sake of convenience, vectorbt has created the column levels <code>fast_window</code> and <code>slow_window</code> for us to easily distinguish which window size corresponds to which column.</p> <p>Notice how signal generation part remains the same for each example - most functions in vectorbt work on time series of any shape. This allows creation of analysis pipelines that are universal to input data.</p> <p>The representation of different features as columns offers endless possibilities for backtesting. We could, for example, go a step further and conduct the same tests for Ethereum. To compare both instruments, combine price series for Bitcoin and Ethereum into one DataFrame and run the same backtesting pipeline.</p> <pre><code>&gt;&gt;&gt; # Multiple strategy instances and instruments\n&gt;&gt;&gt; eth_price = vbt.YFData.download('ETH-USD', start=start, end=end).get('Close')\n&gt;&gt;&gt; comb_price = btc_price.vbt.concat(eth_price,\n...     keys=pd.Index(['BTC', 'ETH'], name='symbol'))\n&gt;&gt;&gt; comb_price.vbt.drop_levels(-1, inplace=True)\n&gt;&gt;&gt; comb_price\nsymbol                             BTC         ETH\nDate\n2019-01-01 00:00:00+00:00  3843.520020  140.819412\n2019-01-02 00:00:00+00:00  3943.409424  155.047684\n2019-01-03 00:00:00+00:00  3836.741211  149.135010\n...                                ...         ...\n2019-12-30 00:00:00+00:00  7292.995117  132.633484\n2019-12-31 00:00:00+00:00  7193.599121  129.610855\n2020-01-01 00:00:00+00:00  7200.174316  130.802002\n\n[366 rows x 2 columns]\n\n&gt;&gt;&gt; fast_ma = vbt.MA.run(comb_price, [10, 20], short_name='fast')\n&gt;&gt;&gt; slow_ma = vbt.MA.run(comb_price, [30, 30], short_name='slow')\n\n&gt;&gt;&gt; entries = fast_ma.ma_crossed_above(slow_ma)\n&gt;&gt;&gt; entries\nfast_window                          10            20\nslow_window                          30            30\nsymbol                       BTC    ETH    BTC    ETH\nDate\n2019-01-01 00:00:00+00:00  False  False  False  False\n2019-01-02 00:00:00+00:00  False  False  False  False\n2019-01-03 00:00:00+00:00  False  False  False  False\n...                          ...    ...    ...    ...\n2019-12-30 00:00:00+00:00  False  False  False  False\n2019-12-31 00:00:00+00:00  False  False  False  False\n2020-01-01 00:00:00+00:00  False  False  False  False\n\n[366 rows x 4 columns]\n\n&gt;&gt;&gt; exits = fast_ma.ma_crossed_below(slow_ma)\n&gt;&gt;&gt; exits\nfast_window                          10            20\nslow_window                          30            30\nsymbol                       BTC    ETH    BTC    ETH\nDate\n2019-01-01 00:00:00+00:00  False  False  False  False\n2019-01-02 00:00:00+00:00  False  False  False  False\n2019-01-03 00:00:00+00:00  False  False  False  False\n...                          ...    ...    ...    ...\n2019-12-30 00:00:00+00:00  False  False  False  False\n2019-12-31 00:00:00+00:00  False  False  False  False\n2020-01-01 00:00:00+00:00  False  False  False  False\n\n[366 rows x 4 columns]\n\n&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(comb_price, entries, exits)\n&gt;&gt;&gt; pf.total_return()\nfast_window  slow_window  symbol\n10           30           BTC       0.848840\n                          ETH       0.244204\n20           30           BTC       0.543411\n                          ETH      -0.319102\nName: total_return, dtype: float64\n\n&gt;&gt;&gt; mean_return = pf.total_return().groupby('symbol').mean()\n&gt;&gt;&gt; mean_return.vbt.barplot(xaxis_title='Symbol', yaxis_title='Mean total return')\n</code></pre> <p></p> <p>Not only strategies and instruments can act as separate features, but also time. If we want to find out when our strategy performs best, it's reasonable to backtest over multiple time periods. vectorbt allows us to split one time period into many, given they have the same length and frequency, and represent them as distinct columns. For example, let's split the whole time period into two equal time periods and backest them at once.</p> <pre><code>&gt;&gt;&gt; # Multiple strategy instances, instruments, and time periods\n&gt;&gt;&gt; mult_comb_price, _ = comb_price.vbt.range_split(n=2)\n&gt;&gt;&gt; mult_comb_price\nsplit_idx                         0                         1\nsymbol              BTC         ETH           BTC         ETH\n0           3843.520020  140.819412  11961.269531  303.099976\n1           3943.409424  155.047684  11215.437500  284.523224\n2           3836.741211  149.135010  10978.459961  287.997528\n...                 ...         ...           ...         ...\n180        10817.155273  290.695984   7292.995117  132.633484\n181        10583.134766  293.641113   7193.599121  129.610855\n182        10801.677734  291.596436   7200.174316  130.802002\n\n[183 rows x 4 columns]\n\n&gt;&gt;&gt; fast_ma = vbt.MA.run(mult_comb_price, [10, 20], short_name='fast')\n&gt;&gt;&gt; slow_ma = vbt.MA.run(mult_comb_price, [30, 30], short_name='slow')\n\n&gt;&gt;&gt; entries = fast_ma.ma_crossed_above(slow_ma)\n&gt;&gt;&gt; exits = fast_ma.ma_crossed_below(slow_ma)\n\n&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(mult_comb_price, entries, exits, freq='1D')\n&gt;&gt;&gt; pf.total_return()\nfast_window  slow_window  split_idx  symbol\n10           30           0          BTC       1.632259\n                                     ETH       0.946786\n                          1          BTC      -0.288720\n                                     ETH      -0.308387\n20           30           0          BTC       1.721449\n                                     ETH       0.343274\n                          1          BTC      -0.418280\n                                     ETH      -0.257947\nName: total_return, dtype: float64\n</code></pre> <p>Notice how index is no more datetime-like, since it captures multiple time periods. That's why it's required here to pass the frequency <code>freq</code> to the <code>Portfolio</code> class in order to be able to compute performance metrics such as the Sharpe ratio.</p> <p>The index hierarchy of the final performance series can be then used to group the performance by any feature, such as window pair, symbol, and time period.</p> <pre><code>&gt;&gt;&gt; mean_return = pf.total_return().groupby(['split_idx', 'symbol']).mean()\n&gt;&gt;&gt; mean_return.unstack(level=-1).vbt.barplot(\n...     xaxis_title='Split index',\n...     yaxis_title='Mean total return',\n...     legend_title_text='Symbol')\n</code></pre> <p></p> <p>There is much more to backtesting than simply stacking columns: vectorbt offers functions for most parts of a backtesting pipeline - from building indicators and generating signals, to modeling portfolio performance and visualizing results.</p>","title":"Example"},{"location":"#disclaimer","text":"<p>This software is for educational purposes only. Do not risk money which you are afraid to lose. USE THE SOFTWARE AT YOUR OWN RISK. THE AUTHORS AND ALL AFFILIATES ASSUME NO RESPONSIBILITY FOR YOUR TRADING RESULTS.</p>","title":"Disclaimer"},{"location":"api/","text":"","title":"API"},{"location":"api/#sub-packages","text":"<ul> <li>vectorbt.base</li> <li>vectorbt.data</li> <li>vectorbt.generic</li> <li>vectorbt.indicators</li> <li>vectorbt.labels</li> <li>vectorbt.messaging</li> <li>vectorbt.portfolio</li> <li>vectorbt.records</li> <li>vectorbt.returns</li> <li>vectorbt.signals</li> <li>vectorbt.utils</li> </ul>","title":"Sub-packages"},{"location":"api/#sub-modules","text":"<ul> <li>vectorbt._settings</li> <li>vectorbt.ohlcv_accessors</li> <li>vectorbt.px_accessors</li> <li>vectorbt.root_accessors</li> </ul>","title":"Sub-modules"},{"location":"api/_settings/","text":"<p>Global settings.</p> <p>settings config is also accessible via <code>vectorbt.settings</code>.</p> <p>Here are the main properties of the settings config:</p> <ul> <li>It's a nested config, that is, a config that consists of multiple sub-configs.     one per sub-package (e.g., 'data'), module (e.g., 'array_wrapper'), or even class (e.g., 'configured').     Each sub-config may consist of other sub-configs.</li> <li>It has frozen keys - you cannot add other sub-configs or remove the existing ones, but you can modify them.</li> <li>Each sub-config can either inherit the properties of the parent one by using <code>dict</code> or overwrite them     by using its own Config. The main reason for defining an own config is to allow     adding new keys (e.g., 'plotting.layout').</li> </ul> <p>For example, you can change default width and height of each plot:</p> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; vbt.settings['plotting']['layout']['width'] = 800\n&gt;&gt;&gt; vbt.settings['plotting']['layout']['height'] = 400\n</code></pre> <p>The main sub-configs such as for plotting can be also accessed/modified using the dot notation:</p> <pre><code>&gt;&gt;&gt; vbt.settings.plotting['layout']['width'] = 800\n</code></pre> <p>Some sub-configs allow the dot notation too but this depends whether they inherit the rules of the root config.</p> <pre><code>&gt;&gt;&gt; vbt.settings.data - ok\n&gt;&gt;&gt; vbt.settings.data.binance - ok\n&gt;&gt;&gt; vbt.settings.data.binance.api_key - error\n&gt;&gt;&gt; vbt.settings.data.binance['api_key'] - ok\n</code></pre> <p>Since this is only visible when looking at the source code, the advice is to always use the bracket notation.</p>  <p>Note</p> <p>Any change takes effect immediately. But whether its reflected immediately depends upon the place that accesses the settings. For example, changing 'array_wrapper.freq` has an immediate effect because the value is resolved every time ArrayWrapper.freq is called. On the other hand, changing 'portfolio.fillna_close' has only effect on Portfolio instances created in the future, not the existing ones, because the value is resolved upon the construction. But mostly you can still force-update the default value by replacing the instance using Configured.replace().</p> <p>All places in vectorbt import settings from settings, not from vectorbt. Overwriting <code>vectorbt.settings</code> only overwrites the reference created for the user. Consider updating the settings config instead of replacing it.</p>","title":"_settings"},{"location":"api/_settings/#saving","text":"<p>Like any other class subclassing Config, we can save settings to the disk, load it back, and update in-place:</p> <pre><code>&gt;&gt;&gt; vbt.settings.save('my_settings')\n&gt;&gt;&gt; vbt.settings['caching']['enabled'] = False\n&gt;&gt;&gt; vbt.settings['caching']['enabled']\nFalse\n\n&gt;&gt;&gt; vbt.settings.load_update('my_settings')  # load() would return a new object!\n&gt;&gt;&gt; vbt.settings['caching']['enabled']\nTrue\n</code></pre> <p>Bonus: You can do the same with any sub-config inside settings!</p>","title":"Saving"},{"location":"api/_settings/#vectorbt._settings.settings","text":"<p>Global settings config.</p> <p>numba</p> <p>Settings applied to Numba.</p> <pre><code>Config({\n    \"check_func_type\": true,\n    \"check_func_suffix\": false\n})\n</code></pre> <p>config</p> <p>Settings applied to Config.</p> <pre><code>Config({})\n</code></pre> <p>configured</p> <p>Settings applied to Configured.</p> <pre><code>Config({\n    \"config\": {\n        \"readonly\": true\n    }\n})\n</code></pre> <p>caching</p> <p>Settings applied across vectorbt.utils.decorators.</p> <p>See should_cache().</p> <pre><code>Config({\n    \"enabled\": true,\n    \"whitelist\": [\n        {\n            \"instance\": null,\n            \"func\": null,\n            \"cls\": null,\n            \"base_cls\": \"&lt;class 'vectorbt.base.array_wrapper.ArrayWrapper'&gt;\",\n            \"flags\": null,\n            \"rank\": null\n        },\n        {\n            \"instance\": null,\n            \"func\": null,\n            \"cls\": null,\n            \"base_cls\": \"&lt;class 'vectorbt.base.column_grouper.ColumnGrouper'&gt;\",\n            \"flags\": null,\n            \"rank\": null\n        },\n        {\n            \"instance\": null,\n            \"func\": null,\n            \"cls\": null,\n            \"base_cls\": \"&lt;class 'vectorbt.records.col_mapper.ColumnMapper'&gt;\",\n            \"flags\": null,\n            \"rank\": null\n        }\n    ],\n    \"blacklist\": []\n})\n</code></pre> <p>broadcasting</p> <p>Settings applied across vectorbt.base.reshape_fns.</p> <pre><code>Config({\n    \"align_index\": false,\n    \"align_columns\": true,\n    \"index_from\": \"strict\",\n    \"columns_from\": \"stack\",\n    \"ignore_sr_names\": true,\n    \"drop_duplicates\": true,\n    \"keep\": \"last\",\n    \"drop_redundant\": true,\n    \"ignore_default\": true\n})\n</code></pre> <p>array_wrapper</p> <p>Settings applied to ArrayWrapper.</p> <pre><code>Config({\n    \"column_only_select\": false,\n    \"group_select\": true,\n    \"freq\": null,\n    \"silence_warnings\": false\n})\n</code></pre> <p>datetime</p> <p>Settings applied across vectorbt.utils.datetime_.</p> <pre><code>Config({\n    \"naive_tz\": \"UTC+01:00\",\n    \"to_py_timezone\": true\n})\n</code></pre> <p>data</p> <p>Settings applied across vectorbt.data.</p> <pre><code>Config({\n    \"tz_localize\": \"UTC\",\n    \"tz_convert\": \"UTC\",\n    \"missing_index\": \"nan\",\n    \"missing_columns\": \"raise\",\n    \"alpaca\": {\n        \"key_id\": null,\n        \"secret_key\": null\n    },\n    \"binance\": {\n        \"api_key\": null,\n        \"api_secret\": null\n    },\n    \"ccxt\": {\n        \"enableRateLimit\": true\n    },\n    \"stats\": {},\n    \"plots\": {}\n})\n</code></pre> <ul> <li> <p>binance:     See <code>binance.client.Client</code>.</p> </li> <li> <p>ccxt:     See Configuring API Keys.      Keys can be defined per exchange. If a key is defined at the root, it applies to all exchanges.</p> </li> </ul> <p>plotting</p> <p>Settings applied to plotting Plotly figures.</p> <pre><code>Config({\n    \"use_widgets\": true,\n    \"show_kwargs\": {},\n    \"color_schema\": {\n        \"increasing\": \"#1b9e76\",\n        \"decreasing\": \"#d95f02\",\n        \"blue\": \"#1f77b4\",\n        \"orange\": \"#ff7f0e\",\n        \"green\": \"#2ca02c\",\n        \"red\": \"#dc3912\",\n        \"purple\": \"#9467bd\",\n        \"brown\": \"#8c564b\",\n        \"pink\": \"#e377c2\",\n        \"gray\": \"#7f7f7f\",\n        \"yellow\": \"#bcbd22\",\n        \"cyan\": \"#17becf\"\n    },\n    \"contrast_color_schema\": {\n        \"blue\": \"#4285F4\",\n        \"orange\": \"#FFAA00\",\n        \"green\": \"#37B13F\",\n        \"red\": \"#EA4335\",\n        \"gray\": \"#E2E2E2\"\n    },\n    \"themes\": {\n        \"light\": {\n            \"color_schema\": {\n                \"blue\": \"#1f77b4\",\n                \"orange\": \"#ff7f0e\",\n                \"green\": \"#2ca02c\",\n                \"red\": \"#dc3912\",\n                \"purple\": \"#9467bd\",\n                \"brown\": \"#8c564b\",\n                \"pink\": \"#e377c2\",\n                \"gray\": \"#7f7f7f\",\n                \"yellow\": \"#bcbd22\",\n                \"cyan\": \"#17becf\"\n            },\n            \"template\": \"{ ... templates/light.json ... }\"\n        },\n        \"dark\": {\n            \"color_schema\": {\n                \"blue\": \"#1f77b4\",\n                \"orange\": \"#ff7f0e\",\n                \"green\": \"#2ca02c\",\n                \"red\": \"#dc3912\",\n                \"purple\": \"#9467bd\",\n                \"brown\": \"#8c564b\",\n                \"pink\": \"#e377c2\",\n                \"gray\": \"#7f7f7f\",\n                \"yellow\": \"#bcbd22\",\n                \"cyan\": \"#17becf\"\n            },\n            \"template\": \"{ ... templates/dark.json ... }\"\n        },\n        \"seaborn\": {\n            \"color_schema\": {\n                \"blue\": \"rgb(76,114,176)\",\n                \"orange\": \"rgb(221,132,82)\",\n                \"green\": \"rgb(129,114,179)\",\n                \"red\": \"rgb(85,168,104)\",\n                \"purple\": \"rgb(218,139,195)\",\n                \"brown\": \"rgb(204,185,116)\",\n                \"pink\": \"rgb(140,140,140)\",\n                \"gray\": \"rgb(100,181,205)\",\n                \"yellow\": \"rgb(147,120,96)\",\n                \"cyan\": \"rgb(196,78,82)\"\n            },\n            \"template\": \"{ ... templates/seaborn.json ... }\"\n        }\n    },\n    \"layout\": {\n        \"width\": 700,\n        \"height\": 350,\n        \"margin\": {\n            \"t\": 30,\n            \"b\": 30,\n            \"l\": 30,\n            \"r\": 30\n        },\n        \"legend\": {\n            \"orientation\": \"h\",\n            \"yanchor\": \"bottom\",\n            \"y\": 1.02,\n            \"xanchor\": \"right\",\n            \"x\": 1,\n            \"traceorder\": \"normal\"\n        },\n        \"template\": \"vbt_light\"\n    }\n})\n</code></pre> <p>stats_builder</p> <p>Settings applied to StatsBuilderMixin.</p> <pre><code>Config({\n    \"metrics\": \"all\",\n    \"tags\": \"all\",\n    \"silence_warnings\": false,\n    \"template_mapping\": {},\n    \"filters\": {\n        \"is_not_grouped\": {\n            \"filter_func\": \"&lt;function &lt;lambda&gt; at 0x7ff500427e18&gt;\",\n            \"warning_message\": \"Sub(template=\\\"Metric '$metric_name' does not support grouped data\\\", mapping={})\"\n        },\n        \"has_freq\": {\n            \"filter_func\": \"&lt;function &lt;lambda&gt; at 0x7ff500259e18&gt;\",\n            \"warning_message\": \"Sub(template=\\\"Metric '$metric_name' requires frequency to be set\\\", mapping={})\"\n        }\n    },\n    \"settings\": {\n        \"to_timedelta\": null,\n        \"use_caching\": true\n    },\n    \"metric_settings\": {}\n})\n</code></pre> <p>plots_builder</p> <p>Settings applied to PlotsBuilderMixin.</p> <pre><code>Config({\n    \"subplots\": \"all\",\n    \"tags\": \"all\",\n    \"silence_warnings\": false,\n    \"template_mapping\": {},\n    \"filters\": {\n        \"is_not_grouped\": {\n            \"filter_func\": \"&lt;function &lt;lambda&gt; at 0x7ff500259ea0&gt;\",\n            \"warning_message\": \"Sub(template=\\\"Subplot '$subplot_name' does not support grouped data\\\", mapping={})\"\n        },\n        \"has_freq\": {\n            \"filter_func\": \"&lt;function &lt;lambda&gt; at 0x7ff500259f28&gt;\",\n            \"warning_message\": \"Sub(template=\\\"Subplot '$subplot_name' requires frequency to be set\\\", mapping={})\"\n        }\n    },\n    \"settings\": {\n        \"use_caching\": true,\n        \"hline_shape_kwargs\": {\n            \"type\": \"line\",\n            \"line\": {\n                \"color\": \"gray\",\n                \"dash\": \"dash\"\n            }\n        }\n    },\n    \"subplot_settings\": {},\n    \"show_titles\": true,\n    \"hide_id_labels\": true,\n    \"group_id_labels\": true,\n    \"make_subplots_kwargs\": {},\n    \"layout_kwargs\": {}\n})\n</code></pre> <p>generic</p> <p>Settings applied across vectorbt.generic.</p> <pre><code>Config({\n    \"stats\": {\n        \"filters\": {\n            \"has_mapping\": {\n                \"filter_func\": \"&lt;function &lt;lambda&gt; at 0x7ff5004b9048&gt;\"\n            }\n        },\n        \"settings\": {\n            \"incl_all_keys\": false\n        }\n    },\n    \"plots\": {}\n})\n</code></pre> <p>ranges</p> <p>Settings applied across vectorbt.generic.ranges.</p> <pre><code>Config({\n    \"stats\": {},\n    \"plots\": {}\n})\n</code></pre> <p>drawdowns</p> <p>Settings applied across vectorbt.generic.drawdowns.</p> <pre><code>Config({\n    \"stats\": {\n        \"settings\": {\n            \"incl_active\": false\n        }\n    },\n    \"plots\": {}\n})\n</code></pre> <p>ohlcv</p> <p>Settings applied across vectorbt.ohlcv_accessors.</p> <pre><code>Config({\n    \"plot_type\": \"OHLC\",\n    \"column_names\": {\n        \"open\": \"Open\",\n        \"high\": \"High\",\n        \"low\": \"Low\",\n        \"close\": \"Close\",\n        \"volume\": \"Volume\"\n    },\n    \"stats\": {},\n    \"plots\": {}\n})\n</code></pre> <p>signals</p> <p>Settings applied across vectorbt.signals.</p> <pre><code>Config({\n    \"stats\": {\n        \"filters\": {\n            \"silent_has_other\": {\n                \"filter_func\": \"&lt;function &lt;lambda&gt; at 0x7ff5004b90d0&gt;\"\n            }\n        },\n        \"settings\": {\n            \"other\": null,\n            \"other_name\": \"Other\",\n            \"from_other\": false\n        }\n    },\n    \"plots\": {}\n})\n</code></pre> <p>returns</p> <p>Settings applied across vectorbt.returns.</p> <pre><code>Config({\n    \"year_freq\": \"365 days\",\n    \"defaults\": {\n        \"start_value\": 0.0,\n        \"window\": 10,\n        \"minp\": null,\n        \"ddof\": 1,\n        \"risk_free\": 0.0,\n        \"levy_alpha\": 2.0,\n        \"required_return\": 0.0,\n        \"cutoff\": 0.05\n    },\n    \"stats\": {\n        \"filters\": {\n            \"has_year_freq\": {\n                \"filter_func\": \"&lt;function &lt;lambda&gt; at 0x7ff5004b9158&gt;\",\n                \"warning_message\": \"Sub(template=\\\"Metric '$metric_name' requires year frequency to be set\\\", mapping={})\"\n            },\n            \"has_benchmark_rets\": {\n                \"filter_func\": \"&lt;function &lt;lambda&gt; at 0x7ff5004b91e0&gt;\",\n                \"warning_message\": \"Sub(template=\\\"Metric '$metric_name' requires benchmark_rets to be set\\\", mapping={})\"\n            }\n        },\n        \"settings\": {\n            \"check_is_not_grouped\": true\n        }\n    },\n    \"plots\": {}\n})\n</code></pre> <p>qs_adapter</p> <p>Settings applied across vectorbt.returns.qs_adapter.</p> <pre><code>Config({\n    \"defaults\": {}\n})\n</code></pre> <p>records</p> <p>Settings applied across vectorbt.records.base.</p> <pre><code>Config({\n    \"stats\": {},\n    \"plots\": {}\n})\n</code></pre> <p>mapped_array</p> <p>Settings applied across vectorbt.records.mapped_array.</p> <pre><code>Config({\n    \"stats\": {\n        \"filters\": {\n            \"has_mapping\": {\n                \"filter_func\": \"&lt;function &lt;lambda&gt; at 0x7ff5004b9268&gt;\"\n            }\n        },\n        \"settings\": {\n            \"incl_all_keys\": false\n        }\n    },\n    \"plots\": {}\n})\n</code></pre> <p>orders</p> <p>Settings applied across vectorbt.portfolio.orders.</p> <pre><code>Config({\n    \"stats\": {},\n    \"plots\": {}\n})\n</code></pre> <p>trades</p> <p>Settings applied across vectorbt.portfolio.trades.</p> <pre><code>Config({\n    \"stats\": {\n        \"settings\": {\n            \"incl_open\": false\n        },\n        \"template_mapping\": {\n            \"incl_open_tags\": \"RepEval(expression=\\\"['open', 'closed'] if incl_open else ['closed']\\\", mapping={})\"\n        }\n    },\n    \"plots\": {}\n})\n</code></pre> <p>logs</p> <p>Settings applied across vectorbt.portfolio.logs.</p> <pre><code>Config({\n    \"stats\": {}\n})\n</code></pre> <p>portfolio</p> <p>Settings applied to Portfolio.</p> <pre><code>Config({\n    \"call_seq\": \"default\",\n    \"init_cash\": 100.0,\n    \"size\": Infinity,\n    \"size_type\": \"amount\",\n    \"fees\": 0.0,\n    \"fixed_fees\": 0.0,\n    \"slippage\": 0.0,\n    \"reject_prob\": 0.0,\n    \"min_size\": 1e-08,\n    \"max_size\": Infinity,\n    \"size_granularity\": NaN,\n    \"lock_cash\": false,\n    \"allow_partial\": true,\n    \"raise_reject\": false,\n    \"val_price\": Infinity,\n    \"accumulate\": false,\n    \"sl_stop\": NaN,\n    \"sl_trail\": false,\n    \"tp_stop\": NaN,\n    \"stop_entry_price\": \"close\",\n    \"stop_exit_price\": \"stoplimit\",\n    \"stop_conflict_mode\": \"exit\",\n    \"upon_stop_exit\": \"close\",\n    \"upon_stop_update\": \"override\",\n    \"use_stops\": null,\n    \"log\": false,\n    \"upon_long_conflict\": \"ignore\",\n    \"upon_short_conflict\": \"ignore\",\n    \"upon_dir_conflict\": \"ignore\",\n    \"upon_opposite_entry\": \"reversereduce\",\n    \"signal_direction\": \"longonly\",\n    \"order_direction\": \"both\",\n    \"cash_sharing\": false,\n    \"call_pre_segment\": false,\n    \"call_post_segment\": false,\n    \"ffill_val_price\": true,\n    \"update_value\": false,\n    \"fill_pos_record\": true,\n    \"row_wise\": false,\n    \"flexible\": false,\n    \"use_numba\": true,\n    \"seed\": null,\n    \"freq\": null,\n    \"attach_call_seq\": false,\n    \"fillna_close\": true,\n    \"trades_type\": \"exittrades\",\n    \"stats\": {\n        \"filters\": {\n            \"has_year_freq\": {\n                \"filter_func\": \"&lt;function &lt;lambda&gt; at 0x7ff5004b92f0&gt;\",\n                \"warning_message\": \"Sub(template=\\\"Metric '$metric_name' requires year frequency to be set\\\", mapping={})\"\n            }\n        },\n        \"settings\": {\n            \"use_asset_returns\": false,\n            \"incl_open\": false\n        },\n        \"template_mapping\": {\n            \"incl_open_tags\": \"RepEval(expression=\\\"['open', 'closed'] if incl_open else ['closed']\\\", mapping={})\"\n        }\n    },\n    \"plots\": {\n        \"subplots\": [\n            \"orders\",\n            \"trade_pnl\",\n            \"cum_returns\"\n        ],\n        \"settings\": {\n            \"use_asset_returns\": false\n        }\n    }\n})\n</code></pre> <p>messaging</p> <p>Settings applied across vectorbt.messaging.</p> <pre><code>Config({\n    \"telegram\": {\n        \"token\": null,\n        \"use_context\": true,\n        \"persistence\": \"telegram_bot.pickle\",\n        \"defaults\": {},\n        \"drop_pending_updates\": true\n    },\n    \"giphy\": {\n        \"api_key\": null,\n        \"weirdness\": 5\n    }\n})\n</code></pre> <ul> <li> <p>telegram:     Settings applied to python-telegram-bot.</p> <p>Set <code>persistence</code> to string to use as <code>filename</code> in <code>telegram.ext.PicklePersistence</code>. For <code>defaults</code>, see <code>telegram.ext.Defaults</code>. Other settings will be distributed across  <code>telegram.ext.Updater</code> and <code>telegram.ext.updater.Updater.start_polling</code>.</p> </li> <li> <p>giphy:     Settings applied to GIPHY Translate Endpoint.</p> </li> </ul>","title":"settings variable"},{"location":"api/_settings/#vectorbt._settings.SettingsConfig","text":"<pre><code>SettingsConfig(\n    dct=None,\n    copy_kwargs=None,\n    reset_dct=None,\n    reset_dct_copy_kwargs=None,\n    frozen_keys=None,\n    readonly=None,\n    nested=None,\n    convert_dicts=None,\n    as_attrs=None\n)\n</code></pre> <p>Extends Config for global settings.</p> <p>Superclasses</p> <ul> <li>Config</li> <li>Documented</li> <li>Pickleable</li> <li>PickleableDict</li> <li><code>builtins.dict</code></li> </ul> <p>Inherited members</p> <ul> <li>Config.as_attrs_</li> <li>Config.clear()</li> <li>Config.convert_dicts_</li> <li>Config.copy()</li> <li>Config.copy_kwargs_</li> <li>Config.dumps()</li> <li>Config.frozen_keys_</li> <li>Config.load_update()</li> <li>Config.loads()</li> <li>Config.make_checkpoint()</li> <li>Config.merge_with()</li> <li>Config.nested_</li> <li>Config.pop()</li> <li>Config.popitem()</li> <li>Config.readonly_</li> <li>Config.reset()</li> <li>Config.reset_dct_</li> <li>Config.reset_dct_copy_kwargs_</li> <li>Config.to_dict()</li> <li>Config.to_doc()</li> <li>Config.update()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> </ul>","title":"SettingsConfig class"},{"location":"api/_settings/#vectorbt._settings.SettingsConfig.register_template","text":"<pre><code>SettingsConfig.register_template(\n    theme\n)\n</code></pre> <p>Register template of a theme.</p>","title":"register_template method"},{"location":"api/_settings/#vectorbt._settings.SettingsConfig.register_templates","text":"<pre><code>SettingsConfig.register_templates()\n</code></pre> <p>Register templates of all themes.</p>","title":"register_templates method"},{"location":"api/_settings/#vectorbt._settings.SettingsConfig.reset_theme","text":"<pre><code>SettingsConfig.reset_theme()\n</code></pre> <p>Reset to default theme.</p>","title":"reset_theme method"},{"location":"api/_settings/#vectorbt._settings.SettingsConfig.set_theme","text":"<pre><code>SettingsConfig.set_theme(\n    theme\n)\n</code></pre> <p>Set default theme.</p>","title":"set_theme method"},{"location":"api/ohlcv_accessors/","text":"<p>Custom pandas accessors for OHLC(V) data.</p> <p>Methods can be accessed as follows:</p> <ul> <li>OHLCVDFAccessor -&gt; <code>pd.DataFrame.vbt.ohlc.*</code></li> <li>OHLCVDFAccessor -&gt; <code>pd.DataFrame.vbt.ohlcv.*</code></li> </ul> <p>The accessors inherit vectorbt.generic.accessors.</p>  <p>Note</p> <p>Accessors do not utilize caching.</p>","title":"ohlcv_accessors"},{"location":"api/ohlcv_accessors/#column-names","text":"<p>By default, vectorbt searches for columns with names 'open', 'high', 'low', 'close', and 'volume' (case doesn't matter). You can change the naming either using <code>ohlcv.column_names</code> in settings, or by providing <code>column_names</code> directly to the accessor.</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; df = pd.DataFrame({\n...     'my_open1': [2, 3, 4, 3.5, 2.5],\n...     'my_high2': [3, 4, 4.5, 4, 3],\n...     'my_low3': [1.5, 2.5, 3.5, 2.5, 1.5],\n...     'my_close4': [2.5, 3.5, 4, 3, 2],\n...     'my_volume5': [10, 11, 10, 9, 10]\n... })\n\n&gt;&gt;&gt; # vectorbt can't find columns\n&gt;&gt;&gt; df.vbt.ohlcv.get_column('open')\nNone\n\n&gt;&gt;&gt; my_column_names = dict(\n...     open='my_open1',\n...     high='my_high2',\n...     low='my_low3',\n...     close='my_close4',\n...     volume='my_volume5',\n... )\n&gt;&gt;&gt; ohlcv_acc = df.vbt.ohlcv(freq='d', column_names=my_column_names)\n&gt;&gt;&gt; ohlcv_acc.get_column('open')\n0    2.0\n1    3.0\n2    4.0\n3    3.5\n4    2.5\nName: my_open1, dtype: float64\n</code></pre>","title":"Column names"},{"location":"api/ohlcv_accessors/#stats","text":"<p>Hint</p> <p>See StatsBuilderMixin.stats() and OHLCVDFAccessor.metrics.</p>  <pre><code>&gt;&gt;&gt; ohlcv_acc.stats()\nStart                           0\nEnd                             4\nPeriod            5 days 00:00:00\nFirst Price                   2.0\nLowest Price                  1.5\nHighest Price                 4.5\nLast Price                    2.0\nFirst Volume                   10\nLowest Volume                   9\nHighest Volume                 11\nLast Volume                    10\nName: agg_func_mean, dtype: object\n</code></pre>","title":"Stats"},{"location":"api/ohlcv_accessors/#plots","text":"<p>Hint</p> <p>See PlotsBuilderMixin.plots() and OHLCVDFAccessor.subplots.</p>  <p>OHLCVDFAccessor class has a single subplot based on OHLCVDFAccessor.plot() (without volume):</p> <pre><code>&gt;&gt;&gt; ohlcv_acc.plots(settings=dict(plot_type='candlestick'))\n</code></pre> <p></p>","title":"Plots"},{"location":"api/ohlcv_accessors/#vectorbt.ohlcv_accessors.OHLCVDFAccessor","text":"<pre><code>OHLCVDFAccessor(\n    obj,\n    column_names=None,\n    **kwargs\n)\n</code></pre> <p>Accessor on top of OHLCV data. For DataFrames only.</p> <p>Accessible through <code>pd.DataFrame.vbt.ohlcv</code>.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>BaseAccessor</li> <li>BaseDFAccessor</li> <li>Configured</li> <li>Documented</li> <li>GenericAccessor</li> <li>GenericDFAccessor</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>BaseAccessor.align_to()</li> <li>BaseAccessor.apply()</li> <li>BaseAccessor.apply_and_concat()</li> <li>BaseAccessor.apply_on_index()</li> <li>BaseAccessor.broadcast()</li> <li>BaseAccessor.broadcast_to()</li> <li>BaseAccessor.combine()</li> <li>BaseAccessor.concat()</li> <li>BaseAccessor.drop_duplicate_levels()</li> <li>BaseAccessor.drop_levels()</li> <li>BaseAccessor.drop_redundant_levels()</li> <li>BaseAccessor.empty()</li> <li>BaseAccessor.empty_like()</li> <li>BaseAccessor.indexing_func()</li> <li>BaseAccessor.make_symmetric()</li> <li>BaseAccessor.rename_levels()</li> <li>BaseAccessor.repeat()</li> <li>BaseAccessor.select_levels()</li> <li>BaseAccessor.stack_index()</li> <li>BaseAccessor.tile()</li> <li>BaseAccessor.to_1d_array()</li> <li>BaseAccessor.to_2d_array()</li> <li>BaseAccessor.to_dict()</li> <li>BaseAccessor.unstack_to_array()</li> <li>BaseAccessor.unstack_to_df()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>GenericAccessor.apply_along_axis()</li> <li>GenericAccessor.apply_and_reduce()</li> <li>GenericAccessor.apply_mapping()</li> <li>GenericAccessor.applymap()</li> <li>GenericAccessor.barplot()</li> <li>GenericAccessor.bfill()</li> <li>GenericAccessor.binarize()</li> <li>GenericAccessor.boxplot()</li> <li>GenericAccessor.bshift()</li> <li>GenericAccessor.count()</li> <li>GenericAccessor.crossed_above()</li> <li>GenericAccessor.crossed_below()</li> <li>GenericAccessor.cumprod()</li> <li>GenericAccessor.cumsum()</li> <li>GenericAccessor.describe()</li> <li>GenericAccessor.diff()</li> <li>GenericAccessor.drawdown()</li> <li>GenericAccessor.ewm_mean()</li> <li>GenericAccessor.ewm_std()</li> <li>GenericAccessor.expanding_apply()</li> <li>GenericAccessor.expanding_max()</li> <li>GenericAccessor.expanding_mean()</li> <li>GenericAccessor.expanding_min()</li> <li>GenericAccessor.expanding_split()</li> <li>GenericAccessor.expanding_std()</li> <li>GenericAccessor.ffill()</li> <li>GenericAccessor.fillna()</li> <li>GenericAccessor.filter()</li> <li>GenericAccessor.fshift()</li> <li>GenericAccessor.get_drawdowns()</li> <li>GenericAccessor.get_ranges()</li> <li>GenericAccessor.groupby_apply()</li> <li>GenericAccessor.histplot()</li> <li>GenericAccessor.idxmax()</li> <li>GenericAccessor.idxmin()</li> <li>GenericAccessor.lineplot()</li> <li>GenericAccessor.max()</li> <li>GenericAccessor.maxabs_scale()</li> <li>GenericAccessor.mean()</li> <li>GenericAccessor.median()</li> <li>GenericAccessor.min()</li> <li>GenericAccessor.minmax_scale()</li> <li>GenericAccessor.normalize()</li> <li>GenericAccessor.pct_change()</li> <li>GenericAccessor.power_transform()</li> <li>GenericAccessor.product()</li> <li>GenericAccessor.quantile_transform()</li> <li>GenericAccessor.range_split()</li> <li>GenericAccessor.rebase()</li> <li>GenericAccessor.reduce()</li> <li>GenericAccessor.resample_apply()</li> <li>GenericAccessor.resolve_self()</li> <li>GenericAccessor.robust_scale()</li> <li>GenericAccessor.rolling_apply()</li> <li>GenericAccessor.rolling_max()</li> <li>GenericAccessor.rolling_mean()</li> <li>GenericAccessor.rolling_min()</li> <li>GenericAccessor.rolling_split()</li> <li>GenericAccessor.rolling_std()</li> <li>GenericAccessor.scale()</li> <li>GenericAccessor.scatterplot()</li> <li>GenericAccessor.shuffle()</li> <li>GenericAccessor.split()</li> <li>GenericAccessor.std()</li> <li>GenericAccessor.sum()</li> <li>GenericAccessor.to_mapped()</li> <li>GenericAccessor.to_returns()</li> <li>GenericAccessor.transform()</li> <li>GenericAccessor.value_counts()</li> <li>GenericAccessor.zscore()</li> <li>GenericDFAccessor.config</li> <li>GenericDFAccessor.df_accessor_cls</li> <li>GenericDFAccessor.drawdowns</li> <li>GenericDFAccessor.flatten_grouped()</li> <li>GenericDFAccessor.heatmap()</li> <li>GenericDFAccessor.iloc</li> <li>GenericDFAccessor.indexing_kwargs</li> <li>GenericDFAccessor.loc</li> <li>GenericDFAccessor.mapping</li> <li>GenericDFAccessor.obj</li> <li>GenericDFAccessor.ranges</li> <li>GenericDFAccessor.self_aliases</li> <li>GenericDFAccessor.squeeze_grouped()</li> <li>GenericDFAccessor.sr_accessor_cls</li> <li>GenericDFAccessor.ts_heatmap()</li> <li>GenericDFAccessor.wrapper</li> <li>GenericDFAccessor.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul>","title":"OHLCVDFAccessor class"},{"location":"api/ohlcv_accessors/#vectorbt.ohlcv_accessors.OHLCVDFAccessor.metrics","text":"<p>Metrics supported by OHLCVDFAccessor.</p> <pre><code>Config({\n    \"start\": {\n        \"title\": \"Start\",\n        \"calc_func\": \"&lt;function OHLCVDFAccessor.&lt;lambda&gt; at 0x7ff5363f8a60&gt;\",\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"end\": {\n        \"title\": \"End\",\n        \"calc_func\": \"&lt;function OHLCVDFAccessor.&lt;lambda&gt; at 0x7ff5363f8ae8&gt;\",\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"period\": {\n        \"title\": \"Period\",\n        \"calc_func\": \"&lt;function OHLCVDFAccessor.&lt;lambda&gt; at 0x7ff5363f8b70&gt;\",\n        \"apply_to_timedelta\": true,\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"first_price\": {\n        \"title\": \"First Price\",\n        \"calc_func\": \"&lt;function OHLCVDFAccessor.&lt;lambda&gt; at 0x7ff5363f8bf8&gt;\",\n        \"resolve_ohlc\": true,\n        \"tags\": [\n            \"ohlcv\",\n            \"ohlc\"\n        ]\n    },\n    \"lowest_price\": {\n        \"title\": \"Lowest Price\",\n        \"calc_func\": \"&lt;function OHLCVDFAccessor.&lt;lambda&gt; at 0x7ff5363f8c80&gt;\",\n        \"resolve_ohlc\": true,\n        \"tags\": [\n            \"ohlcv\",\n            \"ohlc\"\n        ]\n    },\n    \"highest_price\": {\n        \"title\": \"Highest Price\",\n        \"calc_func\": \"&lt;function OHLCVDFAccessor.&lt;lambda&gt; at 0x7ff5363f8d08&gt;\",\n        \"resolve_ohlc\": true,\n        \"tags\": [\n            \"ohlcv\",\n            \"ohlc\"\n        ]\n    },\n    \"last_price\": {\n        \"title\": \"Last Price\",\n        \"calc_func\": \"&lt;function OHLCVDFAccessor.&lt;lambda&gt; at 0x7ff5363f8d90&gt;\",\n        \"resolve_ohlc\": true,\n        \"tags\": [\n            \"ohlcv\",\n            \"ohlc\"\n        ]\n    },\n    \"first_volume\": {\n        \"title\": \"First Volume\",\n        \"calc_func\": \"&lt;function OHLCVDFAccessor.&lt;lambda&gt; at 0x7ff5363f8e18&gt;\",\n        \"resolve_volume\": true,\n        \"tags\": [\n            \"ohlcv\",\n            \"volume\"\n        ]\n    },\n    \"lowest_volume\": {\n        \"title\": \"Lowest Volume\",\n        \"calc_func\": \"&lt;function OHLCVDFAccessor.&lt;lambda&gt; at 0x7ff5363f8ea0&gt;\",\n        \"resolve_volume\": true,\n        \"tags\": [\n            \"ohlcv\",\n            \"volume\"\n        ]\n    },\n    \"highest_volume\": {\n        \"title\": \"Highest Volume\",\n        \"calc_func\": \"&lt;function OHLCVDFAccessor.&lt;lambda&gt; at 0x7ff5363f8f28&gt;\",\n        \"resolve_volume\": true,\n        \"tags\": [\n            \"ohlcv\",\n            \"volume\"\n        ]\n    },\n    \"last_volume\": {\n        \"title\": \"Last Volume\",\n        \"calc_func\": \"&lt;function OHLCVDFAccessor.&lt;lambda&gt; at 0x7ff536401048&gt;\",\n        \"resolve_volume\": true,\n        \"tags\": [\n            \"ohlcv\",\n            \"volume\"\n        ]\n    }\n})\n</code></pre> <p>Returns <code>OHLCVDFAccessor._metrics</code>, which gets (deep) copied upon creation of each instance. Thus, changing this config won't affect the class.</p> <p>To change metrics, you can either change the config in-place, override this property, or overwrite the instance variable <code>OHLCVDFAccessor._metrics</code>.</p>","title":"metrics class variable"},{"location":"api/ohlcv_accessors/#vectorbt.ohlcv_accessors.OHLCVDFAccessor.subplots","text":"<p>Subplots supported by OHLCVDFAccessor.</p> <pre><code>Config({\n    \"plot\": {\n        \"title\": \"OHLC\",\n        \"xaxis_kwargs\": {\n            \"showgrid\": true,\n            \"rangeslider_visible\": false\n        },\n        \"yaxis_kwargs\": {\n            \"showgrid\": true\n        },\n        \"check_is_not_grouped\": true,\n        \"plot_func\": \"plot\",\n        \"show_volume\": false,\n        \"tags\": \"ohlcv\"\n    }\n})\n</code></pre> <p>Returns <code>OHLCVDFAccessor._subplots</code>, which gets (deep) copied upon creation of each instance. Thus, changing this config won't affect the class.</p> <p>To change subplots, you can either change the config in-place, override this property, or overwrite the instance variable <code>OHLCVDFAccessor._subplots</code>.</p>","title":"subplots class variable"},{"location":"api/ohlcv_accessors/#vectorbt.ohlcv_accessors.OHLCVDFAccessor.close","text":"<p>Close series.</p>","title":"close property"},{"location":"api/ohlcv_accessors/#vectorbt.ohlcv_accessors.OHLCVDFAccessor.column_names","text":"<p>Column names.</p>","title":"column_names property"},{"location":"api/ohlcv_accessors/#vectorbt.ohlcv_accessors.OHLCVDFAccessor.high","text":"<p>High series.</p>","title":"high property"},{"location":"api/ohlcv_accessors/#vectorbt.ohlcv_accessors.OHLCVDFAccessor.low","text":"<p>Low series.</p>","title":"low property"},{"location":"api/ohlcv_accessors/#vectorbt.ohlcv_accessors.OHLCVDFAccessor.ohlc","text":"<p>Open, high, low, and close series.</p>","title":"ohlc property"},{"location":"api/ohlcv_accessors/#vectorbt.ohlcv_accessors.OHLCVDFAccessor.open","text":"<p>Open series.</p>","title":"open property"},{"location":"api/ohlcv_accessors/#vectorbt.ohlcv_accessors.OHLCVDFAccessor.plots_defaults","text":"<p>Defaults for PlotsBuilderMixin.plots().</p> <p>Merges GenericAccessor.plots_defaults and <code>ohlcv.plots</code> from settings.</p>","title":"plots_defaults property"},{"location":"api/ohlcv_accessors/#vectorbt.ohlcv_accessors.OHLCVDFAccessor.stats_defaults","text":"<p>Defaults for StatsBuilderMixin.stats().</p> <p>Merges GenericAccessor.stats_defaults and <code>ohlcv.stats</code> from settings.</p>","title":"stats_defaults property"},{"location":"api/ohlcv_accessors/#vectorbt.ohlcv_accessors.OHLCVDFAccessor.volume","text":"<p>Volume series.</p>","title":"volume property"},{"location":"api/ohlcv_accessors/#vectorbt.ohlcv_accessors.OHLCVDFAccessor.get_column","text":"<pre><code>OHLCVDFAccessor.get_column(\n    col_name\n)\n</code></pre> <p>Get column from OHLCVDFAccessor.column_names.</p>","title":"get_column method"},{"location":"api/ohlcv_accessors/#vectorbt.ohlcv_accessors.OHLCVDFAccessor.plot","text":"<pre><code>OHLCVDFAccessor.plot(\n    plot_type=None,\n    show_volume=None,\n    ohlc_kwargs=None,\n    volume_kwargs=None,\n    ohlc_add_trace_kwargs=None,\n    volume_add_trace_kwargs=None,\n    fig=None,\n    **layout_kwargs\n)\n</code></pre> <p>Plot OHLCV data.</p> <p>Args</p>  <code>plot_type</code>  <p>Either 'OHLC', 'Candlestick' or Plotly trace.</p> <p>Pass None to use the default.</p>  <code>show_volume</code> :\u2002<code>bool</code> If True, shows volume as bar chart. <code>ohlc_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plot_type</code>. <code>volume_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Bar</code>. <code>ohlc_add_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>add_trace</code> for OHLC. <code>volume_add_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>add_trace</code> for volume. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**layout_kwargs</code> Keyword arguments for layout.  <p>Usage</p> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; vbt.YFData.download(\"BTC-USD\").get().vbt.ohlcv.plot()\n</code></pre> <p></p>","title":"plot method"},{"location":"api/px_accessors/","text":"<p>Plotly Express pandas accessors.</p>  <p>Note</p> <p>Accessors do not utilize caching.</p>","title":"px_accessors"},{"location":"api/px_accessors/#vectorbt.px_accessors.attach_px_methods","text":"<pre><code>attach_px_methods(\n    cls\n)\n</code></pre> <p>Class decorator to attach Plotly Express methods.</p>","title":"attach_px_methods function"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor","text":"<pre><code>PXAccessor(\n    obj,\n    **kwargs\n)\n</code></pre> <p>Accessor for running Plotly Express functions.</p> <p>Accessible through <code>pd.Series.vbt.px</code> and <code>pd.DataFrame.vbt.px</code>.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; vbt.settings.set_theme('seaborn')\n\n&gt;&gt;&gt; pd.Series([1, 2, 3]).vbt.px.bar()\n</code></pre> <p></p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>BaseAccessor</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>BaseAccessor.align_to()</li> <li>BaseAccessor.apply()</li> <li>BaseAccessor.apply_and_concat()</li> <li>BaseAccessor.apply_on_index()</li> <li>BaseAccessor.broadcast()</li> <li>BaseAccessor.broadcast_to()</li> <li>BaseAccessor.combine()</li> <li>BaseAccessor.concat()</li> <li>BaseAccessor.config</li> <li>BaseAccessor.df_accessor_cls</li> <li>BaseAccessor.drop_duplicate_levels()</li> <li>BaseAccessor.drop_levels()</li> <li>BaseAccessor.drop_redundant_levels()</li> <li>BaseAccessor.empty()</li> <li>BaseAccessor.empty_like()</li> <li>BaseAccessor.iloc</li> <li>BaseAccessor.indexing_func()</li> <li>BaseAccessor.indexing_kwargs</li> <li>BaseAccessor.loc</li> <li>BaseAccessor.make_symmetric()</li> <li>BaseAccessor.obj</li> <li>BaseAccessor.rename_levels()</li> <li>BaseAccessor.repeat()</li> <li>BaseAccessor.select_levels()</li> <li>BaseAccessor.self_aliases</li> <li>BaseAccessor.sr_accessor_cls</li> <li>BaseAccessor.stack_index()</li> <li>BaseAccessor.tile()</li> <li>BaseAccessor.to_1d_array()</li> <li>BaseAccessor.to_2d_array()</li> <li>BaseAccessor.to_dict()</li> <li>BaseAccessor.unstack_to_array()</li> <li>BaseAccessor.unstack_to_df()</li> <li>BaseAccessor.wrapper</li> <li>BaseAccessor.writeable_attrs</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li>PXDFAccessor</li> <li>PXSRAccessor</li> </ul>","title":"PXAccessor class"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.area","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"area method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.bar","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"bar method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.bar_polar","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"bar_polar method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.box","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"box method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.choropleth","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"choropleth method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.choropleth_mapbox","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"choropleth_mapbox method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.density_contour","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"density_contour method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.density_heatmap","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"density_heatmap method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.density_mapbox","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"density_mapbox method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.ecdf","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"ecdf method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.funnel","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"funnel method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.funnel_area","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"funnel_area method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.histogram","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"histogram method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.icicle","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"icicle method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.imshow","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"imshow method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.line","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"line method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.line_3d","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"line_3d method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.line_geo","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"line_geo method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.line_mapbox","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"line_mapbox method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.line_polar","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"line_polar method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.line_ternary","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"line_ternary method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.parallel_categories","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"parallel_categories method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.parallel_coordinates","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"parallel_coordinates method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.pie","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"pie method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.scatter","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"scatter method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.scatter_3d","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"scatter_3d method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.scatter_geo","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"scatter_geo method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.scatter_mapbox","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"scatter_mapbox method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.scatter_matrix","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"scatter_matrix method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.scatter_polar","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"scatter_polar method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.scatter_ternary","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"scatter_ternary method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.strip","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"strip method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.sunburst","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"sunburst method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.timeline","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"timeline method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.treemap","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"treemap method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXAccessor.violin","text":"<pre><code>attach_px_methods.&lt;locals&gt;.plot_func(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"violin method"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXDFAccessor","text":"<pre><code>PXDFAccessor(\n    obj,\n    **kwargs\n)\n</code></pre> <p>Accessor for running Plotly Express functions. For DataFrames only.</p> <p>Accessible through <code>pd.DataFrame.vbt.px</code>.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>BaseAccessor</li> <li>BaseDFAccessor</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>PXAccessor</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>BaseAccessor.align_to()</li> <li>BaseAccessor.apply()</li> <li>BaseAccessor.apply_and_concat()</li> <li>BaseAccessor.apply_on_index()</li> <li>BaseAccessor.broadcast()</li> <li>BaseAccessor.broadcast_to()</li> <li>BaseAccessor.combine()</li> <li>BaseAccessor.concat()</li> <li>BaseAccessor.drop_duplicate_levels()</li> <li>BaseAccessor.drop_levels()</li> <li>BaseAccessor.drop_redundant_levels()</li> <li>BaseAccessor.empty()</li> <li>BaseAccessor.empty_like()</li> <li>BaseAccessor.indexing_func()</li> <li>BaseAccessor.make_symmetric()</li> <li>BaseAccessor.rename_levels()</li> <li>BaseAccessor.repeat()</li> <li>BaseAccessor.select_levels()</li> <li>BaseAccessor.stack_index()</li> <li>BaseAccessor.tile()</li> <li>BaseAccessor.to_1d_array()</li> <li>BaseAccessor.to_2d_array()</li> <li>BaseAccessor.to_dict()</li> <li>BaseAccessor.unstack_to_array()</li> <li>BaseAccessor.unstack_to_df()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>PXAccessor.config</li> <li>PXAccessor.df_accessor_cls</li> <li>PXAccessor.iloc</li> <li>PXAccessor.indexing_kwargs</li> <li>PXAccessor.loc</li> <li>PXAccessor.obj</li> <li>PXAccessor.self_aliases</li> <li>PXAccessor.sr_accessor_cls</li> <li>PXAccessor.wrapper</li> <li>PXAccessor.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul>","title":"PXDFAccessor class"},{"location":"api/px_accessors/#vectorbt.px_accessors.PXSRAccessor","text":"<pre><code>PXSRAccessor(\n    obj,\n    **kwargs\n)\n</code></pre> <p>Accessor for running Plotly Express functions. For Series only.</p> <p>Accessible through <code>pd.Series.vbt.px</code>.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>BaseAccessor</li> <li>BaseSRAccessor</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>PXAccessor</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>BaseAccessor.align_to()</li> <li>BaseAccessor.apply()</li> <li>BaseAccessor.apply_and_concat()</li> <li>BaseAccessor.apply_on_index()</li> <li>BaseAccessor.broadcast()</li> <li>BaseAccessor.broadcast_to()</li> <li>BaseAccessor.combine()</li> <li>BaseAccessor.concat()</li> <li>BaseAccessor.drop_duplicate_levels()</li> <li>BaseAccessor.drop_levels()</li> <li>BaseAccessor.drop_redundant_levels()</li> <li>BaseAccessor.empty()</li> <li>BaseAccessor.empty_like()</li> <li>BaseAccessor.indexing_func()</li> <li>BaseAccessor.make_symmetric()</li> <li>BaseAccessor.rename_levels()</li> <li>BaseAccessor.repeat()</li> <li>BaseAccessor.select_levels()</li> <li>BaseAccessor.stack_index()</li> <li>BaseAccessor.tile()</li> <li>BaseAccessor.to_1d_array()</li> <li>BaseAccessor.to_2d_array()</li> <li>BaseAccessor.to_dict()</li> <li>BaseAccessor.unstack_to_array()</li> <li>BaseAccessor.unstack_to_df()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>PXAccessor.config</li> <li>PXAccessor.df_accessor_cls</li> <li>PXAccessor.iloc</li> <li>PXAccessor.indexing_kwargs</li> <li>PXAccessor.loc</li> <li>PXAccessor.obj</li> <li>PXAccessor.self_aliases</li> <li>PXAccessor.sr_accessor_cls</li> <li>PXAccessor.wrapper</li> <li>PXAccessor.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul>","title":"PXSRAccessor class"},{"location":"api/root_accessors/","text":"<p>Root pandas accessors.</p> <p>An accessor adds additional \u201cnamespace\u201d to pandas objects.</p> <p>The vectorbt.root_accessors registers a custom <code>vbt</code> accessor on top of each <code>pd.Series</code> and <code>pd.DataFrame</code> object. It is the main entry point for all other accessors:</p> <pre><code>vbt.base.accessors.BaseSR/DFAccessor           -&gt; pd.Series/DataFrame.vbt.*\nvbt.generic.accessors.GenericSR/DFAccessor     -&gt; pd.Series/DataFrame.vbt.*\nvbt.signals.accessors.SignalsSR/DFAccessor     -&gt; pd.Series/DataFrame.vbt.signals.*\nvbt.returns.accessors.ReturnsSR/DFAccessor     -&gt; pd.Series/DataFrame.vbt.returns.*\nvbt.ohlcv.accessors.OHLCVDFAccessor            -&gt; pd.DataFrame.vbt.ohlc.* and pd.DataFrame.vbt.ohlcv.*\nvbt.px_accessors.PXAccessor                    -&gt; pd.DataFrame.vbt.px.*\n</code></pre> <p>Additionally, some accessors subclass other accessors building the following inheritance hiearchy:</p> <pre><code>vbt.base.accessors.BaseSR/DFAccessor\n    -&gt; vbt.generic.accessors.GenericSR/DFAccessor\n        -&gt; vbt.cat_accessors.CatSR/DFAccessor\n        -&gt; vbt.signals.accessors.SignalsSR/DFAccessor\n        -&gt; vbt.returns.accessors.ReturnsSR/DFAccessor\n        -&gt; vbt.ohlcv_accessors.OHLCVDFAccessor\n    -&gt; vbt.px_accessors.PXSR/DFAccessor\n</code></pre> <p>So, for example, the method <code>pd.Series.vbt.to_2d_array</code> is also available as <code>pd.Series.vbt.returns.to_2d_array</code>.</p>  <p>Note</p> <p>Accessors in vectorbt are not cached, so querying <code>df.vbt</code> twice will also call Vbt_DFAccessor twice.</p>","title":"root_accessors"},{"location":"api/root_accessors/#vectorbt.root_accessors.register_accessor","text":"<pre><code>register_accessor(\n    name,\n    cls\n)\n</code></pre> <p>Register a custom accessor.</p> <p><code>cls</code> should subclass <code>pandas.core.accessor.DirNamesMixin</code>.</p>","title":"register_accessor function"},{"location":"api/root_accessors/#vectorbt.root_accessors.register_dataframe_accessor","text":"<pre><code>register_dataframe_accessor(\n    name\n)\n</code></pre> <p>Decorator to register a custom <code>pd.DataFrame</code> accessor on top of the <code>pd.DataFrame</code>.</p>","title":"register_dataframe_accessor function"},{"location":"api/root_accessors/#vectorbt.root_accessors.register_dataframe_vbt_accessor","text":"<pre><code>register_dataframe_vbt_accessor(\n    name,\n    parent=vectorbt.root_accessors.Vbt_DFAccessor\n)\n</code></pre> <p>Decorator to register a <code>pd.DataFrame</code> accessor on top of a parent accessor.</p>","title":"register_dataframe_vbt_accessor function"},{"location":"api/root_accessors/#vectorbt.root_accessors.register_series_accessor","text":"<pre><code>register_series_accessor(\n    name\n)\n</code></pre> <p>Decorator to register a custom <code>pd.Series</code> accessor on top of the <code>pd.Series</code>.</p>","title":"register_series_accessor function"},{"location":"api/root_accessors/#vectorbt.root_accessors.register_series_vbt_accessor","text":"<pre><code>register_series_vbt_accessor(\n    name,\n    parent=vectorbt.root_accessors.Vbt_SRAccessor\n)\n</code></pre> <p>Decorator to register a <code>pd.Series</code> accessor on top of a parent accessor.</p>","title":"register_series_vbt_accessor function"},{"location":"api/root_accessors/#vectorbt.root_accessors.Accessor","text":"<pre><code>Accessor(\n    name,\n    accessor\n)\n</code></pre> <p>Custom property-like object.</p>  <p>Note</p> <p>In contrast to other pandas accessors, this accessor is not cached!</p> <p>This prevents from using old data if the object has been changed in-place.</p>","title":"Accessor class"},{"location":"api/root_accessors/#vectorbt.root_accessors.Vbt_DFAccessor","text":"<pre><code>Vbt_DFAccessor(\n    obj,\n    **kwargs\n)\n</code></pre> <p>The main vectorbt accessor for <code>pd.DataFrame</code>.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>BaseAccessor</li> <li>BaseDFAccessor</li> <li>Configured</li> <li>Documented</li> <li>GenericAccessor</li> <li>GenericDFAccessor</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> <li><code>pandas.core.accessor.DirNamesMixin</code></li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>BaseAccessor.align_to()</li> <li>BaseAccessor.apply()</li> <li>BaseAccessor.apply_and_concat()</li> <li>BaseAccessor.apply_on_index()</li> <li>BaseAccessor.broadcast()</li> <li>BaseAccessor.broadcast_to()</li> <li>BaseAccessor.combine()</li> <li>BaseAccessor.concat()</li> <li>BaseAccessor.drop_duplicate_levels()</li> <li>BaseAccessor.drop_levels()</li> <li>BaseAccessor.drop_redundant_levels()</li> <li>BaseAccessor.empty()</li> <li>BaseAccessor.empty_like()</li> <li>BaseAccessor.indexing_func()</li> <li>BaseAccessor.make_symmetric()</li> <li>BaseAccessor.rename_levels()</li> <li>BaseAccessor.repeat()</li> <li>BaseAccessor.select_levels()</li> <li>BaseAccessor.stack_index()</li> <li>BaseAccessor.tile()</li> <li>BaseAccessor.to_1d_array()</li> <li>BaseAccessor.to_2d_array()</li> <li>BaseAccessor.to_dict()</li> <li>BaseAccessor.unstack_to_array()</li> <li>BaseAccessor.unstack_to_df()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>GenericAccessor.apply_along_axis()</li> <li>GenericAccessor.apply_and_reduce()</li> <li>GenericAccessor.apply_mapping()</li> <li>GenericAccessor.applymap()</li> <li>GenericAccessor.barplot()</li> <li>GenericAccessor.bfill()</li> <li>GenericAccessor.binarize()</li> <li>GenericAccessor.boxplot()</li> <li>GenericAccessor.bshift()</li> <li>GenericAccessor.count()</li> <li>GenericAccessor.crossed_above()</li> <li>GenericAccessor.crossed_below()</li> <li>GenericAccessor.cumprod()</li> <li>GenericAccessor.cumsum()</li> <li>GenericAccessor.describe()</li> <li>GenericAccessor.diff()</li> <li>GenericAccessor.drawdown()</li> <li>GenericAccessor.ewm_mean()</li> <li>GenericAccessor.ewm_std()</li> <li>GenericAccessor.expanding_apply()</li> <li>GenericAccessor.expanding_max()</li> <li>GenericAccessor.expanding_mean()</li> <li>GenericAccessor.expanding_min()</li> <li>GenericAccessor.expanding_split()</li> <li>GenericAccessor.expanding_std()</li> <li>GenericAccessor.ffill()</li> <li>GenericAccessor.fillna()</li> <li>GenericAccessor.filter()</li> <li>GenericAccessor.fshift()</li> <li>GenericAccessor.get_drawdowns()</li> <li>GenericAccessor.get_ranges()</li> <li>GenericAccessor.groupby_apply()</li> <li>GenericAccessor.histplot()</li> <li>GenericAccessor.idxmax()</li> <li>GenericAccessor.idxmin()</li> <li>GenericAccessor.lineplot()</li> <li>GenericAccessor.max()</li> <li>GenericAccessor.maxabs_scale()</li> <li>GenericAccessor.mean()</li> <li>GenericAccessor.median()</li> <li>GenericAccessor.min()</li> <li>GenericAccessor.minmax_scale()</li> <li>GenericAccessor.normalize()</li> <li>GenericAccessor.pct_change()</li> <li>GenericAccessor.plot()</li> <li>GenericAccessor.power_transform()</li> <li>GenericAccessor.product()</li> <li>GenericAccessor.quantile_transform()</li> <li>GenericAccessor.range_split()</li> <li>GenericAccessor.rebase()</li> <li>GenericAccessor.reduce()</li> <li>GenericAccessor.resample_apply()</li> <li>GenericAccessor.resolve_self()</li> <li>GenericAccessor.robust_scale()</li> <li>GenericAccessor.rolling_apply()</li> <li>GenericAccessor.rolling_max()</li> <li>GenericAccessor.rolling_mean()</li> <li>GenericAccessor.rolling_min()</li> <li>GenericAccessor.rolling_split()</li> <li>GenericAccessor.rolling_std()</li> <li>GenericAccessor.scale()</li> <li>GenericAccessor.scatterplot()</li> <li>GenericAccessor.shuffle()</li> <li>GenericAccessor.split()</li> <li>GenericAccessor.std()</li> <li>GenericAccessor.sum()</li> <li>GenericAccessor.to_mapped()</li> <li>GenericAccessor.to_returns()</li> <li>GenericAccessor.transform()</li> <li>GenericAccessor.value_counts()</li> <li>GenericAccessor.zscore()</li> <li>GenericDFAccessor.config</li> <li>GenericDFAccessor.df_accessor_cls</li> <li>GenericDFAccessor.drawdowns</li> <li>GenericDFAccessor.flatten_grouped()</li> <li>GenericDFAccessor.heatmap()</li> <li>GenericDFAccessor.iloc</li> <li>GenericDFAccessor.indexing_kwargs</li> <li>GenericDFAccessor.loc</li> <li>GenericDFAccessor.mapping</li> <li>GenericDFAccessor.obj</li> <li>GenericDFAccessor.plots_defaults</li> <li>GenericDFAccessor.ranges</li> <li>GenericDFAccessor.self_aliases</li> <li>GenericDFAccessor.squeeze_grouped()</li> <li>GenericDFAccessor.sr_accessor_cls</li> <li>GenericDFAccessor.stats_defaults</li> <li>GenericDFAccessor.ts_heatmap()</li> <li>GenericDFAccessor.wrapper</li> <li>GenericDFAccessor.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul>","title":"Vbt_DFAccessor class"},{"location":"api/root_accessors/#vectorbt.root_accessors.Vbt_DFAccessor.ohlc","text":"<p>Accessor on top of OHLCV data. For DataFrames only.</p> <p>Accessible through <code>pd.DataFrame.vbt.ohlcv</code>.</p>","title":"ohlc class variable"},{"location":"api/root_accessors/#vectorbt.root_accessors.Vbt_DFAccessor.ohlcv","text":"<p>Accessor on top of OHLCV data. For DataFrames only.</p> <p>Accessible through <code>pd.DataFrame.vbt.ohlcv</code>.</p>","title":"ohlcv class variable"},{"location":"api/root_accessors/#vectorbt.root_accessors.Vbt_DFAccessor.px","text":"<p>Accessor for running Plotly Express functions. For DataFrames only.</p> <p>Accessible through <code>pd.DataFrame.vbt.px</code>.</p>","title":"px class variable"},{"location":"api/root_accessors/#vectorbt.root_accessors.Vbt_DFAccessor.returns","text":"<p>Accessor on top of return series. For DataFrames only.</p> <p>Accessible through <code>pd.DataFrame.vbt.returns</code>.</p>","title":"returns class variable"},{"location":"api/root_accessors/#vectorbt.root_accessors.Vbt_DFAccessor.signals","text":"<p>Accessor on top of signal series. For DataFrames only.</p> <p>Accessible through <code>pd.DataFrame.vbt.signals</code>.</p>","title":"signals class variable"},{"location":"api/root_accessors/#vectorbt.root_accessors.Vbt_SRAccessor","text":"<pre><code>Vbt_SRAccessor(\n    obj,\n    **kwargs\n)\n</code></pre> <p>The main vectorbt accessor for <code>pd.Series</code>.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>BaseAccessor</li> <li>BaseSRAccessor</li> <li>Configured</li> <li>Documented</li> <li>GenericAccessor</li> <li>GenericSRAccessor</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> <li><code>pandas.core.accessor.DirNamesMixin</code></li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>BaseAccessor.align_to()</li> <li>BaseAccessor.apply()</li> <li>BaseAccessor.apply_and_concat()</li> <li>BaseAccessor.apply_on_index()</li> <li>BaseAccessor.broadcast()</li> <li>BaseAccessor.broadcast_to()</li> <li>BaseAccessor.combine()</li> <li>BaseAccessor.concat()</li> <li>BaseAccessor.drop_duplicate_levels()</li> <li>BaseAccessor.drop_levels()</li> <li>BaseAccessor.drop_redundant_levels()</li> <li>BaseAccessor.empty()</li> <li>BaseAccessor.empty_like()</li> <li>BaseAccessor.indexing_func()</li> <li>BaseAccessor.make_symmetric()</li> <li>BaseAccessor.rename_levels()</li> <li>BaseAccessor.repeat()</li> <li>BaseAccessor.select_levels()</li> <li>BaseAccessor.stack_index()</li> <li>BaseAccessor.tile()</li> <li>BaseAccessor.to_1d_array()</li> <li>BaseAccessor.to_2d_array()</li> <li>BaseAccessor.to_dict()</li> <li>BaseAccessor.unstack_to_array()</li> <li>BaseAccessor.unstack_to_df()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>GenericAccessor.apply_along_axis()</li> <li>GenericAccessor.apply_and_reduce()</li> <li>GenericAccessor.apply_mapping()</li> <li>GenericAccessor.applymap()</li> <li>GenericAccessor.barplot()</li> <li>GenericAccessor.bfill()</li> <li>GenericAccessor.binarize()</li> <li>GenericAccessor.boxplot()</li> <li>GenericAccessor.bshift()</li> <li>GenericAccessor.count()</li> <li>GenericAccessor.crossed_above()</li> <li>GenericAccessor.crossed_below()</li> <li>GenericAccessor.cumprod()</li> <li>GenericAccessor.cumsum()</li> <li>GenericAccessor.describe()</li> <li>GenericAccessor.diff()</li> <li>GenericAccessor.drawdown()</li> <li>GenericAccessor.ewm_mean()</li> <li>GenericAccessor.ewm_std()</li> <li>GenericAccessor.expanding_apply()</li> <li>GenericAccessor.expanding_max()</li> <li>GenericAccessor.expanding_mean()</li> <li>GenericAccessor.expanding_min()</li> <li>GenericAccessor.expanding_split()</li> <li>GenericAccessor.expanding_std()</li> <li>GenericAccessor.ffill()</li> <li>GenericAccessor.fillna()</li> <li>GenericAccessor.filter()</li> <li>GenericAccessor.fshift()</li> <li>GenericAccessor.get_drawdowns()</li> <li>GenericAccessor.get_ranges()</li> <li>GenericAccessor.groupby_apply()</li> <li>GenericAccessor.histplot()</li> <li>GenericAccessor.idxmax()</li> <li>GenericAccessor.idxmin()</li> <li>GenericAccessor.lineplot()</li> <li>GenericAccessor.max()</li> <li>GenericAccessor.maxabs_scale()</li> <li>GenericAccessor.mean()</li> <li>GenericAccessor.median()</li> <li>GenericAccessor.min()</li> <li>GenericAccessor.minmax_scale()</li> <li>GenericAccessor.normalize()</li> <li>GenericAccessor.pct_change()</li> <li>GenericAccessor.plot()</li> <li>GenericAccessor.power_transform()</li> <li>GenericAccessor.product()</li> <li>GenericAccessor.quantile_transform()</li> <li>GenericAccessor.range_split()</li> <li>GenericAccessor.rebase()</li> <li>GenericAccessor.reduce()</li> <li>GenericAccessor.resample_apply()</li> <li>GenericAccessor.resolve_self()</li> <li>GenericAccessor.robust_scale()</li> <li>GenericAccessor.rolling_apply()</li> <li>GenericAccessor.rolling_max()</li> <li>GenericAccessor.rolling_mean()</li> <li>GenericAccessor.rolling_min()</li> <li>GenericAccessor.rolling_split()</li> <li>GenericAccessor.rolling_std()</li> <li>GenericAccessor.scale()</li> <li>GenericAccessor.scatterplot()</li> <li>GenericAccessor.shuffle()</li> <li>GenericAccessor.split()</li> <li>GenericAccessor.std()</li> <li>GenericAccessor.sum()</li> <li>GenericAccessor.to_mapped()</li> <li>GenericAccessor.to_returns()</li> <li>GenericAccessor.transform()</li> <li>GenericAccessor.value_counts()</li> <li>GenericAccessor.zscore()</li> <li>GenericSRAccessor.config</li> <li>GenericSRAccessor.df_accessor_cls</li> <li>GenericSRAccessor.drawdowns</li> <li>GenericSRAccessor.flatten_grouped()</li> <li>GenericSRAccessor.heatmap()</li> <li>GenericSRAccessor.iloc</li> <li>GenericSRAccessor.indexing_kwargs</li> <li>GenericSRAccessor.loc</li> <li>GenericSRAccessor.mapping</li> <li>GenericSRAccessor.obj</li> <li>GenericSRAccessor.overlay_with_heatmap()</li> <li>GenericSRAccessor.plot_against()</li> <li>GenericSRAccessor.plots_defaults</li> <li>GenericSRAccessor.qqplot()</li> <li>GenericSRAccessor.ranges</li> <li>GenericSRAccessor.self_aliases</li> <li>GenericSRAccessor.squeeze_grouped()</li> <li>GenericSRAccessor.sr_accessor_cls</li> <li>GenericSRAccessor.stats_defaults</li> <li>GenericSRAccessor.ts_heatmap()</li> <li>GenericSRAccessor.volume()</li> <li>GenericSRAccessor.wrapper</li> <li>GenericSRAccessor.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul>","title":"Vbt_SRAccessor class"},{"location":"api/root_accessors/#vectorbt.root_accessors.Vbt_SRAccessor.px","text":"<p>Accessor for running Plotly Express functions. For Series only.</p> <p>Accessible through <code>pd.Series.vbt.px</code>.</p>","title":"px class variable"},{"location":"api/root_accessors/#vectorbt.root_accessors.Vbt_SRAccessor.returns","text":"<p>Accessor on top of return series. For Series only.</p> <p>Accessible through <code>pd.Series.vbt.returns</code>.</p>","title":"returns class variable"},{"location":"api/root_accessors/#vectorbt.root_accessors.Vbt_SRAccessor.signals","text":"<p>Accessor on top of signal series. For Series only.</p> <p>Accessible through <code>pd.Series.vbt.signals</code>.</p>","title":"signals class variable"},{"location":"api/base/","text":"<p>Modules with base classes and utilities for pandas objects, such as broadcasting.</p>","title":"base"},{"location":"api/base/#sub-modules","text":"<ul> <li>vectorbt.base.accessors</li> <li>vectorbt.base.array_wrapper</li> <li>vectorbt.base.column_grouper</li> <li>vectorbt.base.combine_fns</li> <li>vectorbt.base.index_fns</li> <li>vectorbt.base.indexing</li> <li>vectorbt.base.reshape_fns</li> </ul>","title":"Sub-modules"},{"location":"api/base/accessors/","text":"<p>Custom pandas accessors.</p> <p>Methods can be accessed as follows:</p> <ul> <li>BaseSRAccessor -&gt; <code>pd.Series.vbt.*</code></li> <li>BaseDFAccessor -&gt; <code>pd.DataFrame.vbt.*</code></li> </ul> <p>For example:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; # vectorbt.base.accessors.BaseAccessor.make_symmetric\n&gt;&gt;&gt; pd.Series([1, 2, 3]).vbt.make_symmetric()\n     0    1    2\n0  1.0  2.0  3.0\n1  2.0  NaN  NaN\n2  3.0  NaN  NaN\n</code></pre> <p>It contains base methods for working with pandas objects. Most of these methods are adaptations of combine/reshape/index functions that can work with pandas objects. For example, broadcast() can take an arbitrary number of pandas objects, thus you can find its variations as accessor methods.</p> <pre><code>&gt;&gt;&gt; sr = pd.Series([1])\n&gt;&gt;&gt; df = pd.DataFrame([1, 2, 3])\n\n&gt;&gt;&gt; vbt.base.reshape_fns.broadcast_to(sr, df)\n   0\n0  1\n1  1\n2  1\n&gt;&gt;&gt; sr.vbt.broadcast_to(df)\n   0\n0  1\n1  1\n2  1\n</code></pre> <p>Additionally, BaseAccessor implements arithmetic (such as <code>+</code>), comparison (such as <code>&gt;</code>) and logical operators (such as <code>&amp;</code>) by doing 1) NumPy-like broadcasting and 2) the compuation with NumPy under the hood, which is mostly much faster than with pandas.</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(size=(1000, 1000)))\n\n&gt;&gt;&gt; %timeit df * 2  # pandas\n296 ms \u00b1 27.4 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n&gt;&gt;&gt; %timeit df.vbt * 2  # vectorbt\n5.48 ms \u00b1 1.12 ms per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n</code></pre>  <p>Note</p> <p>You should ensure that your <code>*.vbt</code> operand is on the left if the other operand is an array.</p> <p>Accessors do not utilize caching.</p> <p>Grouping is only supported by the methods that accept the <code>group_by</code> argument.</p>","title":"accessors"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseAccessor","text":"<pre><code>BaseAccessor(\n    obj,\n    wrapper=None,\n    **kwargs\n)\n</code></pre> <p>Accessor on top of Series and DataFrames.</p> <p>Accessible through <code>pd.Series.vbt</code> and <code>pd.DataFrame.vbt</code>, and all child accessors.</p> <p>Series is just a DataFrame with one column, hence to avoid defining methods exclusively for 1-dim data, we will convert any Series to a DataFrame and perform matrix computation on it. Afterwards, by using BaseAccessor.wrapper, we will convert the 2-dim output back to a Series.</p> <p><code>**kwargs</code> will be passed to ArrayWrapper.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>Wrapping.config</li> <li>Wrapping.iloc</li> <li>Wrapping.indexing_kwargs</li> <li>Wrapping.loc</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> <li>Wrapping.self_aliases</li> <li>Wrapping.wrapper</li> <li>Wrapping.writeable_attrs</li> </ul> <p>Subclasses</p> <ul> <li>BaseDFAccessor</li> <li>BaseSRAccessor</li> <li>GenericAccessor</li> <li>PXAccessor</li> </ul>","title":"BaseAccessor class"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseAccessor.broadcast","text":"<pre><code>BaseAccessor.broadcast(\n    *others,\n    **kwargs\n)\n</code></pre> <p>See broadcast().</p>","title":"broadcast class method"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseAccessor.concat","text":"<pre><code>BaseAccessor.concat(\n    *others,\n    broadcast_kwargs=None,\n    keys=None\n)\n</code></pre> <p>Concatenate with <code>others</code> along columns.</p> <p>Args</p>  <code>*others</code> :\u2002<code>array_like</code> List of objects to be concatenated with this array. <code>broadcast_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to broadcast(). <code>keys</code> :\u2002<code>index_like</code> Outermost column level.  <p>Usage</p> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n&gt;&gt;&gt; import pandas as pd\n\n&gt;&gt;&gt; sr = pd.Series([1, 2], index=['x', 'y'])\n&gt;&gt;&gt; df = pd.DataFrame([[3, 4], [5, 6]], index=['x', 'y'], columns=['a', 'b'])\n&gt;&gt;&gt; sr.vbt.concat(df, keys=['c', 'd'])\n      c     d\n   a  b  a  b\nx  1  1  3  4\ny  2  2  5  6\n</code></pre>","title":"concat class method"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseAccessor.empty","text":"<pre><code>BaseAccessor.empty(\n    shape,\n    fill_value=nan,\n    **kwargs\n)\n</code></pre> <p>Generate an empty Series/DataFrame of shape <code>shape</code> and fill with <code>fill_value</code>.</p>","title":"empty class method"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseAccessor.empty_like","text":"<pre><code>BaseAccessor.empty_like(\n    other,\n    fill_value=nan,\n    **kwargs\n)\n</code></pre> <p>Generate an empty Series/DataFrame like <code>other</code> and fill with <code>fill_value</code>.</p>","title":"empty_like class method"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseAccessor.is_frame","text":"<pre><code>BaseAccessor.is_frame()\n</code></pre>","title":"is_frame class method"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseAccessor.is_series","text":"<pre><code>BaseAccessor.is_series()\n</code></pre>","title":"is_series class method"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseAccessor.df_accessor_cls","text":"<p>Accessor class for <code>pd.DataFrame</code>.</p>","title":"df_accessor_cls property"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseAccessor.obj","text":"<p>Pandas object.</p>","title":"obj property"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseAccessor.sr_accessor_cls","text":"<p>Accessor class for <code>pd.Series</code>.</p>","title":"sr_accessor_cls property"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseAccessor.align_to","text":"<pre><code>BaseAccessor.align_to(\n    other,\n    wrap_kwargs=None\n)\n</code></pre> <p>Align to <code>other</code> on their axes.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n&gt;&gt;&gt; import pandas as pd\n\n&gt;&gt;&gt; df1 = pd.DataFrame([[1, 2], [3, 4]], index=['x', 'y'], columns=['a', 'b'])\n&gt;&gt;&gt; df1\n   a  b\nx  1  2\ny  3  4\n\n&gt;&gt;&gt; df2 = pd.DataFrame([[5, 6, 7, 8], [9, 10, 11, 12]], index=['x', 'y'],\n...     columns=pd.MultiIndex.from_arrays([[1, 1, 2, 2], ['a', 'b', 'a', 'b']]))\n&gt;&gt;&gt; df2\n       1       2\n   a   b   a   b\nx  5   6   7   8\ny  9  10  11  12\n\n&gt;&gt;&gt; df1.vbt.align_to(df2)\n      1     2\n   a  b  a  b\nx  1  2  1  2\ny  3  4  3  4\n</code></pre>","title":"align_to method"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseAccessor.apply","text":"<pre><code>BaseAccessor.apply(\n    *args,\n    apply_func=None,\n    keep_pd=False,\n    to_2d=False,\n    wrap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Apply a function <code>apply_func</code>.</p> <p>Args</p>  <code>*args</code> Variable arguments passed to <code>apply_func</code>. <code>apply_func</code> :\u2002<code>callable</code>  <p>Apply function.</p> <p>Can be Numba-compiled.</p>  <code>keep_pd</code> :\u2002<code>bool</code> Whether to keep inputs as pandas objects, otherwise convert to NumPy arrays. <code>to_2d</code> :\u2002<code>bool</code> Whether to reshape inputs to 2-dim arrays, otherwise keep as-is. <code>wrap_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to ArrayWrapper.wrap(). <code>**kwargs</code> Keyword arguments passed to <code>combine_func</code>.   <p>Note</p> <p>The resulted array must have the same shape as the original array.</p>  <p>Usage</p> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n&gt;&gt;&gt; import pandas as pd\n\n&gt;&gt;&gt; sr = pd.Series([1, 2], index=['x', 'y'])\n&gt;&gt;&gt; sr2.vbt.apply(apply_func=lambda x: x ** 2)\ni2\nx2    1\ny2    4\nz2    9\nName: a2, dtype: int64\n</code></pre>","title":"apply method"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseAccessor.apply_and_concat","text":"<pre><code>BaseAccessor.apply_and_concat(\n    ntimes,\n    *args,\n    apply_func=None,\n    keep_pd=False,\n    to_2d=False,\n    numba_loop=False,\n    use_ray=False,\n    keys=None,\n    wrap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Apply <code>apply_func</code> <code>ntimes</code> times and concatenate the results along columns. See apply_and_concat_one().</p> <p>Args</p>  <code>ntimes</code> :\u2002<code>int</code> Number of times to call <code>apply_func</code>. <code>*args</code> Variable arguments passed to <code>apply_func</code>. <code>apply_func</code> :\u2002<code>callable</code>  <p>Apply function.</p> <p>Can be Numba-compiled.</p>  <code>keep_pd</code> :\u2002<code>bool</code> Whether to keep inputs as pandas objects, otherwise convert to NumPy arrays. <code>to_2d</code> :\u2002<code>bool</code> Whether to reshape inputs to 2-dim arrays, otherwise keep as-is. <code>numba_loop</code> :\u2002<code>bool</code>  <p>Whether to loop using Numba.</p> <p>Set to True when iterating large number of times over small input, but note that Numba doesn't support variable keyword arguments.</p>  <code>use_ray</code> :\u2002<code>bool</code>  <p>Whether to use Ray to execute <code>combine_func</code> in parallel.</p> <p>Only works with <code>numba_loop</code> set to False and <code>concat</code> is set to True. See ray_apply() for related keyword arguments.</p>  <code>keys</code> :\u2002<code>index_like</code> Outermost column level. <code>wrap_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to ArrayWrapper.wrap(). <code>**kwargs</code> Keyword arguments passed to <code>combine_func</code>.   <p>Note</p> <p>The resulted arrays to be concatenated must have the same shape as broadcast input arrays.</p>  <p>Usage</p> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n&gt;&gt;&gt; import pandas as pd\n\n&gt;&gt;&gt; df = pd.DataFrame([[3, 4], [5, 6]], index=['x', 'y'], columns=['a', 'b'])\n&gt;&gt;&gt; df.vbt.apply_and_concat(3, [1, 2, 3],\n...     apply_func=lambda i, a, b: a * b[i], keys=['c', 'd', 'e'])\n      c       d       e\n   a  b   a   b   a   b\nx  3  4   6   8   9  12\ny  5  6  10  12  15  18\n</code></pre> <ul> <li>Use Ray for small inputs and large processing times:</li> </ul> <pre><code>&gt;&gt;&gt; def apply_func(i, a):\n...     time.sleep(1)\n...     return a\n\n&gt;&gt;&gt; sr = pd.Series([1, 2, 3])\n\n&gt;&gt;&gt; %timeit sr.vbt.apply_and_concat(3, apply_func=apply_func)\n3.01 s \u00b1 2.15 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n\n&gt;&gt;&gt; %timeit sr.vbt.apply_and_concat(3, apply_func=apply_func, use_ray=True)\n1.01 s \u00b1 2.31 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</code></pre>","title":"apply_and_concat method"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseAccessor.apply_on_index","text":"<pre><code>BaseAccessor.apply_on_index(\n    apply_func,\n    *args,\n    axis=1,\n    inplace=False,\n    **kwargs\n)\n</code></pre> <p>Apply function <code>apply_func</code> on index of the pandas object.</p> <p>Set <code>axis</code> to 1 for columns and 0 for index. If <code>inplace</code> is True, modifies the pandas object. Otherwise, returns a copy.</p>","title":"apply_on_index method"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseAccessor.broadcast_to","text":"<pre><code>BaseAccessor.broadcast_to(\n    other,\n    **kwargs\n)\n</code></pre> <p>See broadcast_to().</p>","title":"broadcast_to method"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseAccessor.combine","text":"<pre><code>BaseAccessor.combine(\n    other,\n    *args,\n    allow_multiple=True,\n    combine_func=None,\n    keep_pd=False,\n    to_2d=False,\n    concat=False,\n    numba_loop=False,\n    use_ray=False,\n    broadcast=True,\n    broadcast_kwargs=None,\n    keys=None,\n    wrap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Combine with <code>other</code> using <code>combine_func</code>.</p> <p>Args</p>  <code>other</code> :\u2002<code>array_like</code> Object to combine this array with. <code>*args</code> Variable arguments passed to <code>combine_func</code>. <code>allow_multiple</code> :\u2002<code>bool</code> Whether a tuple/list will be considered as multiple objects in <code>other</code>. <code>combine_func</code> :\u2002<code>callable</code>  <p>Function to combine two arrays.</p> <p>Can be Numba-compiled.</p>  <code>keep_pd</code> :\u2002<code>bool</code> Whether to keep inputs as pandas objects, otherwise convert to NumPy arrays. <code>to_2d</code> :\u2002<code>bool</code> Whether to reshape inputs to 2-dim arrays, otherwise keep as-is. <code>concat</code> :\u2002<code>bool</code>  <p>Whether to concatenate the results along the column axis. Otherwise, pairwise combine into a Series/DataFrame of the same shape.</p> <p>If True, see combine_and_concat(). If False, see combine_multiple().</p>  <code>numba_loop</code> :\u2002<code>bool</code>  <p>Whether to loop using Numba.</p> <p>Set to True when iterating large number of times over small input, but note that Numba doesn't support variable keyword arguments.</p>  <code>use_ray</code> :\u2002<code>bool</code>  <p>Whether to use Ray to execute <code>combine_func</code> in parallel.</p> <p>Only works with <code>numba_loop</code> set to False and <code>concat</code> is set to True. See ray_apply() for related keyword arguments.</p>  <code>broadcast</code> :\u2002<code>bool</code> Whether to broadcast all inputs. <code>broadcast_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to broadcast(). <code>keys</code> :\u2002<code>index_like</code> Outermost column level. <code>wrap_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to ArrayWrapper.wrap(). <code>**kwargs</code> Keyword arguments passed to <code>combine_func</code>.   <p>Note</p> <p>If <code>combine_func</code> is Numba-compiled, will broadcast using <code>WRITEABLE</code> and <code>C_CONTIGUOUS</code> flags, which can lead to an expensive computation overhead if passed objects are large and have different shape/memory order. You also must ensure that all objects have the same data type.</p> <p>Also remember to bring each in <code>*args</code> to a Numba-compatible format.</p>  <p>Usage</p> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n&gt;&gt;&gt; import pandas as pd\n\n&gt;&gt;&gt; sr = pd.Series([1, 2], index=['x', 'y'])\n&gt;&gt;&gt; df = pd.DataFrame([[3, 4], [5, 6]], index=['x', 'y'], columns=['a', 'b'])\n\n&gt;&gt;&gt; sr.vbt.combine(df, combine_func=lambda x, y: x + y)\n   a  b\nx  4  5\ny  7  8\n\n&gt;&gt;&gt; sr.vbt.combine([df, df*2], combine_func=lambda x, y: x + y)\n    a   b\nx  10  13\ny  17  20\n\n&gt;&gt;&gt; sr.vbt.combine([df, df*2], combine_func=lambda x, y: x + y, concat=True, keys=['c', 'd'])\n      c       d\n   a  b   a   b\nx  4  5   7   9\ny  7  8  12  14\n</code></pre> <ul> <li>Use Ray for small inputs and large processing times:</li> </ul> <pre><code>&gt;&gt;&gt; def combine_func(a, b):\n...     time.sleep(1)\n...     return a + b\n\n&gt;&gt;&gt; sr = pd.Series([1, 2, 3])\n\n&gt;&gt;&gt; %timeit sr.vbt.combine([1, 1, 1], combine_func=combine_func)\n3.01 s \u00b1 2.98 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n\n&gt;&gt;&gt; %timeit sr.vbt.combine([1, 1, 1], combine_func=combine_func, concat=True, use_ray=True)\n1.02 s \u00b1 2.32 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</code></pre>","title":"combine method"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseAccessor.drop_duplicate_levels","text":"<pre><code>BaseAccessor.drop_duplicate_levels(\n    keep=None,\n    axis=1,\n    inplace=False\n)\n</code></pre> <p>See drop_duplicate_levels().</p> <p>See BaseAccessor.apply_on_index() for other keyword arguments.</p>","title":"drop_duplicate_levels method"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseAccessor.drop_levels","text":"<pre><code>BaseAccessor.drop_levels(\n    levels,\n    axis=1,\n    inplace=False,\n    strict=True\n)\n</code></pre> <p>See drop_levels().</p> <p>See BaseAccessor.apply_on_index() for other keyword arguments.</p>","title":"drop_levels method"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseAccessor.drop_redundant_levels","text":"<pre><code>BaseAccessor.drop_redundant_levels(\n    axis=1,\n    inplace=False\n)\n</code></pre> <p>See drop_redundant_levels().</p> <p>See BaseAccessor.apply_on_index() for other keyword arguments.</p>","title":"drop_redundant_levels method"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseAccessor.indexing_func","text":"<pre><code>BaseAccessor.indexing_func(\n    pd_indexing_func,\n    **kwargs\n)\n</code></pre> <p>Perform indexing on BaseAccessor.</p>","title":"indexing_func method"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseAccessor.make_symmetric","text":"<pre><code>BaseAccessor.make_symmetric()\n</code></pre> <p>See make_symmetric().</p>","title":"make_symmetric method"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseAccessor.rename_levels","text":"<pre><code>BaseAccessor.rename_levels(\n    name_dict,\n    axis=1,\n    inplace=False,\n    strict=True\n)\n</code></pre> <p>See rename_levels().</p> <p>See BaseAccessor.apply_on_index() for other keyword arguments.</p>","title":"rename_levels method"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseAccessor.repeat","text":"<pre><code>BaseAccessor.repeat(\n    n,\n    keys=None,\n    axis=1,\n    wrap_kwargs=None\n)\n</code></pre> <p>See repeat().</p> <p>Set <code>axis</code> to 1 for columns and 0 for index. Use <code>keys</code> as the outermost level.</p>","title":"repeat method"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseAccessor.select_levels","text":"<pre><code>BaseAccessor.select_levels(\n    level_names,\n    axis=1,\n    inplace=False\n)\n</code></pre> <p>See select_levels().</p> <p>See BaseAccessor.apply_on_index() for other keyword arguments.</p>","title":"select_levels method"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseAccessor.stack_index","text":"<pre><code>BaseAccessor.stack_index(\n    index,\n    on_top=True,\n    axis=1,\n    inplace=False,\n    **kwargs\n)\n</code></pre> <p>See stack_indexes().</p> <p>Set <code>on_top</code> to False to stack at bottom.</p> <p>See BaseAccessor.apply_on_index() for other keyword arguments.</p>","title":"stack_index method"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseAccessor.tile","text":"<pre><code>BaseAccessor.tile(\n    n,\n    keys=None,\n    axis=1,\n    wrap_kwargs=None\n)\n</code></pre> <p>See tile().</p> <p>Set <code>axis</code> to 1 for columns and 0 for index. Use <code>keys</code> as the outermost level.</p>","title":"tile method"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseAccessor.to_1d_array","text":"<pre><code>BaseAccessor.to_1d_array()\n</code></pre> <p>Convert to 1-dim NumPy array</p> <p>See to_1d().</p>","title":"to_1d_array method"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseAccessor.to_2d_array","text":"<pre><code>BaseAccessor.to_2d_array()\n</code></pre> <p>Convert to 2-dim NumPy array.</p> <p>See to_2d().</p>","title":"to_2d_array method"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseAccessor.to_dict","text":"<pre><code>BaseAccessor.to_dict(\n    **kwargs\n)\n</code></pre> <p>See to_dict().</p>","title":"to_dict method"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseAccessor.unstack_to_array","text":"<pre><code>BaseAccessor.unstack_to_array(\n    **kwargs\n)\n</code></pre> <p>See unstack_to_array().</p>","title":"unstack_to_array method"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseAccessor.unstack_to_df","text":"<pre><code>BaseAccessor.unstack_to_df(\n    **kwargs\n)\n</code></pre> <p>See unstack_to_df().</p>","title":"unstack_to_df method"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseDFAccessor","text":"<pre><code>BaseDFAccessor(\n    obj,\n    **kwargs\n)\n</code></pre> <p>Accessor on top of DataFrames.</p> <p>Accessible through <code>pd.DataFrame.vbt</code> and all child accessors.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>BaseAccessor</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>BaseAccessor.align_to()</li> <li>BaseAccessor.apply()</li> <li>BaseAccessor.apply_and_concat()</li> <li>BaseAccessor.apply_on_index()</li> <li>BaseAccessor.broadcast()</li> <li>BaseAccessor.broadcast_to()</li> <li>BaseAccessor.combine()</li> <li>BaseAccessor.concat()</li> <li>BaseAccessor.config</li> <li>BaseAccessor.df_accessor_cls</li> <li>BaseAccessor.drop_duplicate_levels()</li> <li>BaseAccessor.drop_levels()</li> <li>BaseAccessor.drop_redundant_levels()</li> <li>BaseAccessor.empty()</li> <li>BaseAccessor.empty_like()</li> <li>BaseAccessor.iloc</li> <li>BaseAccessor.indexing_func()</li> <li>BaseAccessor.indexing_kwargs</li> <li>BaseAccessor.loc</li> <li>BaseAccessor.make_symmetric()</li> <li>BaseAccessor.obj</li> <li>BaseAccessor.rename_levels()</li> <li>BaseAccessor.repeat()</li> <li>BaseAccessor.select_levels()</li> <li>BaseAccessor.self_aliases</li> <li>BaseAccessor.sr_accessor_cls</li> <li>BaseAccessor.stack_index()</li> <li>BaseAccessor.tile()</li> <li>BaseAccessor.to_1d_array()</li> <li>BaseAccessor.to_2d_array()</li> <li>BaseAccessor.to_dict()</li> <li>BaseAccessor.unstack_to_array()</li> <li>BaseAccessor.unstack_to_df()</li> <li>BaseAccessor.wrapper</li> <li>BaseAccessor.writeable_attrs</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li>GenericDFAccessor</li> <li>PXDFAccessor</li> </ul>","title":"BaseDFAccessor class"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseDFAccessor.is_frame","text":"<pre><code>BaseDFAccessor.is_frame()\n</code></pre>","title":"is_frame class method"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseDFAccessor.is_series","text":"<pre><code>BaseDFAccessor.is_series()\n</code></pre>","title":"is_series class method"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseSRAccessor","text":"<pre><code>BaseSRAccessor(\n    obj,\n    **kwargs\n)\n</code></pre> <p>Accessor on top of Series.</p> <p>Accessible through <code>pd.Series.vbt</code> and all child accessors.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>BaseAccessor</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>BaseAccessor.align_to()</li> <li>BaseAccessor.apply()</li> <li>BaseAccessor.apply_and_concat()</li> <li>BaseAccessor.apply_on_index()</li> <li>BaseAccessor.broadcast()</li> <li>BaseAccessor.broadcast_to()</li> <li>BaseAccessor.combine()</li> <li>BaseAccessor.concat()</li> <li>BaseAccessor.config</li> <li>BaseAccessor.df_accessor_cls</li> <li>BaseAccessor.drop_duplicate_levels()</li> <li>BaseAccessor.drop_levels()</li> <li>BaseAccessor.drop_redundant_levels()</li> <li>BaseAccessor.empty()</li> <li>BaseAccessor.empty_like()</li> <li>BaseAccessor.iloc</li> <li>BaseAccessor.indexing_func()</li> <li>BaseAccessor.indexing_kwargs</li> <li>BaseAccessor.loc</li> <li>BaseAccessor.make_symmetric()</li> <li>BaseAccessor.obj</li> <li>BaseAccessor.rename_levels()</li> <li>BaseAccessor.repeat()</li> <li>BaseAccessor.select_levels()</li> <li>BaseAccessor.self_aliases</li> <li>BaseAccessor.sr_accessor_cls</li> <li>BaseAccessor.stack_index()</li> <li>BaseAccessor.tile()</li> <li>BaseAccessor.to_1d_array()</li> <li>BaseAccessor.to_2d_array()</li> <li>BaseAccessor.to_dict()</li> <li>BaseAccessor.unstack_to_array()</li> <li>BaseAccessor.unstack_to_df()</li> <li>BaseAccessor.wrapper</li> <li>BaseAccessor.writeable_attrs</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li>GenericSRAccessor</li> <li>PXSRAccessor</li> </ul>","title":"BaseSRAccessor class"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseSRAccessor.is_frame","text":"<pre><code>BaseSRAccessor.is_frame()\n</code></pre>","title":"is_frame class method"},{"location":"api/base/accessors/#vectorbt.base.accessors.BaseSRAccessor.is_series","text":"<pre><code>BaseSRAccessor.is_series()\n</code></pre>","title":"is_series class method"},{"location":"api/base/array_wrapper/","text":"<p>Class for wrapping NumPy arrays into Series/DataFrames.</p> <p>vectorbt's functionality is based upon the ability to perform the most essential pandas operations using NumPy+Numba stack. One has to convert the Series/DataFrame into the NumPy format, perform the computation, and put the array back into the pandas format. The last step is done using ArrayWrapper.</p> <p>It stores metadata of the original pandas object and offers methods <code>wrap</code> and <code>wrap_reduced</code> for wrapping NumPy arrays to match the stored metadata as closest as possible.</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import vectorbt as vbt\n&gt;&gt;&gt; from vectorbt.base.array_wrapper import ArrayWrapper\n\n&gt;&gt;&gt; aw = ArrayWrapper(index=['x', 'y', 'z'], columns=['a', 'b', 'c'], ndim=2)\n&gt;&gt;&gt; aw._config\n{\n    'columns': Index(['a', 'b', 'c'], dtype='object'),\n    'group_select': None,\n    'ndim': 2,\n    'freq': None,\n    'column_only_select': None,\n    'grouped_ndim': None,\n    'index': ['x', 'y', 'z'],\n    'allow_modify': True,\n    'allow_enable': True,\n    'group_by': None,\n    'allow_disable': True\n}\n\n&gt;&gt;&gt; np.random.seed(42)\n&gt;&gt;&gt; a = np.random.uniform(size=(3, 3))\n&gt;&gt;&gt; aw.wrap(a)\n          a         b         c\nx  0.374540  0.950714  0.731994\ny  0.598658  0.156019  0.155995\nz  0.058084  0.866176  0.601115\n\n&gt;&gt;&gt; aw.wrap_reduced(np.sum(a, axis=0))\na    1.031282\nb    1.972909\nc    1.489103\ndtype: float64\n</code></pre> <p>It can also be indexed as a regular pandas object and integrates ColumnGrouper:</p> <pre><code>&gt;&gt;&gt; aw.loc['x':'y', 'a']._config\n{\n    'columns': Index(['a'], dtype='object'),\n    'group_select': None,\n    'ndim': 1,\n    'freq': None,\n    'column_only_select': None,\n    'grouped_ndim': None,\n    'index': Index(['x', 'y'], dtype='object'),\n    'allow_modify': True,\n    'allow_enable': True,\n    'group_by': None,\n    'allow_disable': True\n}\n\n&gt;&gt;&gt; aw.regroup(np.array([0, 0, 1]))._config\n{\n    'columns': Index(['a', 'b', 'c'], dtype='object'),\n    'group_select': None,\n    'ndim': 2,\n    'freq': None,\n    'column_only_select': None,\n    'grouped_ndim': None,\n    'index': ['x', 'y', 'z'],\n    'allow_modify': True,\n    'allow_enable': True,\n    'group_by': array([0, 0, 1]),\n    'allow_disable': True\n}\n</code></pre> <p>Class Wrapping is a convenience class meant to be subclassed by classes that do not want to subclass ArrayWrapper but rather use it as an attribute (which is a better SE design pattern anyway!).</p>","title":"array_wrapper"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.ArrayWrapper","text":"<pre><code>ArrayWrapper(\n    index,\n    columns,\n    ndim,\n    freq=None,\n    column_only_select=None,\n    group_select=None,\n    grouped_ndim=None,\n    **kwargs\n)\n</code></pre> <p>Class that stores index, columns and shape metadata for wrapping NumPy arrays. Tightly integrated with ColumnGrouper.</p> <p>If the underlying object is a Series, pass <code>[sr.name]</code> as <code>columns</code>.</p> <p><code>**kwargs</code> are passed to ColumnGrouper.</p>  <p>Note</p> <p>This class is meant to be immutable. To change any attribute, use Configured.replace().</p> <p>Use methods that begin with <code>get_</code> to get group-aware results.</p>  <p>Superclasses</p> <ul> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> </ul> <p>Inherited members</p> <ul> <li>Configured.config</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>Configured.writeable_attrs</li> <li>PandasIndexer.iloc</li> <li>PandasIndexer.indexing_kwargs</li> <li>PandasIndexer.loc</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> </ul>","title":"ArrayWrapper class"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.ArrayWrapper.from_obj","text":"<pre><code>ArrayWrapper.from_obj(\n    obj,\n    *args,\n    **kwargs\n)\n</code></pre> <p>Derive metadata from an object.</p>","title":"from_obj class method"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.ArrayWrapper.from_shape","text":"<pre><code>ArrayWrapper.from_shape(\n    shape,\n    *args,\n    **kwargs\n)\n</code></pre> <p>Derive metadata from shape.</p>","title":"from_shape class method"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.ArrayWrapper.column_only_select","text":"<p>Whether to perform indexing on columns only.</p>","title":"column_only_select property"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.ArrayWrapper.columns","text":"<p>Columns.</p>","title":"columns property"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.ArrayWrapper.freq","text":"<p>Index frequency.</p>","title":"freq property"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.ArrayWrapper.group_select","text":"<p>Whether to perform indexing on groups.</p>","title":"group_select property"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.ArrayWrapper.grouped_ndim","text":"<p>Number of dimensions under column grouping.</p>","title":"grouped_ndim property"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.ArrayWrapper.grouper","text":"<p>Column grouper.</p>","title":"grouper property"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.ArrayWrapper.index","text":"<p>Index.</p>","title":"index property"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.ArrayWrapper.name","text":"<p>Name.</p>","title":"name property"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.ArrayWrapper.ndim","text":"<p>Number of dimensions.</p>","title":"ndim property"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.ArrayWrapper.shape","text":"<p>Shape.</p>","title":"shape property"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.ArrayWrapper.shape_2d","text":"<p>Shape as if the object was two-dimensional.</p>","title":"shape_2d property"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.ArrayWrapper.dummy","text":"<pre><code>ArrayWrapper.dummy(\n    group_by=None,\n    **kwargs\n)\n</code></pre> <p>Create a dummy Series/DataFrame.</p>","title":"dummy method"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.ArrayWrapper.fill","text":"<pre><code>ArrayWrapper.fill(\n    fill_value,\n    group_by=None,\n    **kwargs\n)\n</code></pre> <p>Fill a Series/DataFrame.</p>","title":"fill method"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.ArrayWrapper.fill_reduced","text":"<pre><code>ArrayWrapper.fill_reduced(\n    fill_value,\n    group_by=None,\n    **kwargs\n)\n</code></pre> <p>Fill a reduced Series/DataFrame.</p>","title":"fill_reduced method"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.ArrayWrapper.get_columns","text":"<pre><code>ArrayWrapper.get_columns(\n    group_by=None\n)\n</code></pre> <p>Get group-aware ArrayWrapper.columns.</p>","title":"get_columns method"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.ArrayWrapper.get_name","text":"<pre><code>ArrayWrapper.get_name(\n    group_by=None\n)\n</code></pre> <p>Get group-aware ArrayWrapper.name.</p>","title":"get_name method"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.ArrayWrapper.get_ndim","text":"<pre><code>ArrayWrapper.get_ndim(\n    group_by=None\n)\n</code></pre> <p>Get group-aware ArrayWrapper.ndim.</p>","title":"get_ndim method"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.ArrayWrapper.get_shape","text":"<pre><code>ArrayWrapper.get_shape(\n    group_by=None\n)\n</code></pre> <p>Get group-aware ArrayWrapper.shape.</p>","title":"get_shape method"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.ArrayWrapper.get_shape_2d","text":"<pre><code>ArrayWrapper.get_shape_2d(\n    group_by=None\n)\n</code></pre> <p>Get group-aware ArrayWrapper.shape_2d.</p>","title":"get_shape_2d method"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.ArrayWrapper.indexing_func","text":"<pre><code>ArrayWrapper.indexing_func(\n    pd_indexing_func,\n    **kwargs\n)\n</code></pre> <p>Perform indexing on ArrayWrapper</p>","title":"indexing_func method"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.ArrayWrapper.indexing_func_meta","text":"<pre><code>ArrayWrapper.indexing_func_meta(\n    pd_indexing_func,\n    index=None,\n    columns=None,\n    column_only_select=None,\n    group_select=None,\n    group_by=None\n)\n</code></pre> <p>Perform indexing on ArrayWrapper and also return indexing metadata.</p> <p>Takes into account column grouping.</p> <p>Set <code>column_only_select</code> to True to index the array wrapper as a Series of columns. This way, selection of index (axis 0) can be avoided. Set <code>group_select</code> to True to select groups rather than columns. Takes effect only if grouping is enabled.</p>  <p>Note</p> <p>If <code>column_only_select</code> is True, make sure to index the array wrapper as a Series of columns rather than a DataFrame. For example, the operation <code>.iloc[:, :2]</code> should become <code>.iloc[:2]</code>. Operations are not allowed if the object is already a Series and thus has only one column/group.</p>","title":"indexing_func_meta method"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.ArrayWrapper.regroup","text":"<pre><code>ArrayWrapper.regroup(\n    group_by,\n    **kwargs\n)\n</code></pre> <p>Regroup this object.</p> <p>Only creates a new instance if grouping has changed, otherwise returns itself.</p>","title":"regroup method"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.ArrayWrapper.resolve","text":"<pre><code>ArrayWrapper.resolve(\n    group_by=None,\n    **kwargs\n)\n</code></pre> <p>Resolve this object.</p> <p>Replaces columns and other metadata with groups.</p>","title":"resolve method"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.ArrayWrapper.to_timedelta","text":"<pre><code>ArrayWrapper.to_timedelta(\n    a,\n    to_pd=False,\n    silence_warnings=None\n)\n</code></pre> <p>Convert array to duration using ArrayWrapper.freq.</p>","title":"to_timedelta method"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.ArrayWrapper.wrap","text":"<pre><code>ArrayWrapper.wrap(\n    arr,\n    index=None,\n    columns=None,\n    fillna=None,\n    dtype=None,\n    group_by=None,\n    to_timedelta=False,\n    to_index=False,\n    silence_warnings=None\n)\n</code></pre> <p>Wrap a NumPy array using the stored metadata.</p> <p>Runs the following pipeline:</p> <p>1) Converts to NumPy array 2) Fills NaN (optional) 3) Wraps using index, columns, and dtype (optional) 4) Converts to index (optional) 5) Converts to timedelta using ArrayWrapper.to_timedelta() (optional)</p>","title":"wrap method"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.ArrayWrapper.wrap_reduced","text":"<pre><code>ArrayWrapper.wrap_reduced(\n    arr,\n    name_or_index=None,\n    columns=None,\n    fillna=None,\n    dtype=None,\n    group_by=None,\n    to_timedelta=False,\n    to_index=False,\n    silence_warnings=None\n)\n</code></pre> <p>Wrap result of reduction.</p> <p><code>name_or_index</code> can be the name of the resulting series if reducing to a scalar per column, or the index of the resulting series/dataframe if reducing to an array per column. <code>columns</code> can be set to override object's default columns.</p> <p>See ArrayWrapper.wrap() for the pipeline.</p>","title":"wrap_reduced method"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.Wrapping","text":"<pre><code>Wrapping(\n    wrapper,\n    **kwargs\n)\n</code></pre> <p>Class that uses ArrayWrapper globally.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>AttrResolver.self_aliases</li> <li>Configured.config</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>Configured.writeable_attrs</li> <li>PandasIndexer.iloc</li> <li>PandasIndexer.indexing_kwargs</li> <li>PandasIndexer.loc</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> </ul> <p>Subclasses</p> <ul> <li>BaseAccessor</li> <li>ColumnMapper</li> <li>Data</li> <li>IndicatorBase</li> <li>MappedArray</li> <li>Portfolio</li> <li>Records</li> </ul>","title":"Wrapping class"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.Wrapping.select_one_from_obj","text":"<pre><code>Wrapping.select_one_from_obj(\n    obj,\n    wrapper,\n    column=None\n)\n</code></pre> <p>Select one column/group from a pandas object.</p> <p><code>column</code> can be a label-based position as well as an integer position (if label fails).</p>","title":"select_one_from_obj static method"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.Wrapping.wrapper","text":"<p>Array wrapper.</p>","title":"wrapper property"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.Wrapping.indexing_func","text":"<pre><code>Wrapping.indexing_func(\n    pd_indexing_func,\n    **kwargs\n)\n</code></pre> <p>Perform indexing on Wrapping.</p>","title":"indexing_func method"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.Wrapping.regroup","text":"<pre><code>Wrapping.regroup(\n    group_by,\n    **kwargs\n)\n</code></pre> <p>Regroup this object.</p> <p>Only creates a new instance if grouping has changed, otherwise returns itself.</p> <p><code>**kwargs</code> will be passed to ArrayWrapper.regroup().</p>","title":"regroup method"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.Wrapping.resolve_self","text":"<pre><code>Wrapping.resolve_self(\n    cond_kwargs=None,\n    custom_arg_names=None,\n    impacts_caching=True,\n    silence_warnings=None\n)\n</code></pre> <p>Resolve self.</p> <p>Creates a copy of this instance if a different <code>freq</code> can be found in <code>cond_kwargs</code>.</p>","title":"resolve_self method"},{"location":"api/base/array_wrapper/#vectorbt.base.array_wrapper.Wrapping.select_one","text":"<pre><code>Wrapping.select_one(\n    column=None,\n    group_by=None,\n    **kwargs\n)\n</code></pre> <p>Select one column/group.</p> <p><code>column</code> can be a label-based position as well as an integer position (if label fails).</p>","title":"select_one method"},{"location":"api/base/column_grouper/","text":"<p>Class that exposes methods to group columns.</p> <p>Class ColumnGrouper stores metadata related to grouping columns. It can return, for example, the number of groups, the start indices of groups, and other information useful for reducing operations that utilize grouping. It also allows to dynamically enable/disable/modify groups and checks whether a certain operation is permitted.</p>","title":"column_grouper"},{"location":"api/base/column_grouper/#vectorbt.base.column_grouper.get_group_lens_nb","text":"<pre><code>get_group_lens_nb(\n    groups\n)\n</code></pre> <p>Return count per group.</p>","title":"get_group_lens_nb function"},{"location":"api/base/column_grouper/#vectorbt.base.column_grouper.get_groups_and_index","text":"<pre><code>get_groups_and_index(\n    index,\n    group_by\n)\n</code></pre> <p>Return array of group indices pointing to the original index, and grouped index.</p>","title":"get_groups_and_index function"},{"location":"api/base/column_grouper/#vectorbt.base.column_grouper.group_by_to_index","text":"<pre><code>group_by_to_index(\n    index,\n    group_by\n)\n</code></pre> <p>Convert mapper <code>group_by</code> to <code>pd.Index</code>.</p>  <p>Note</p> <p>Index and mapper must have the same length.</p>","title":"group_by_to_index function"},{"location":"api/base/column_grouper/#vectorbt.base.column_grouper.ColumnGrouper","text":"<pre><code>ColumnGrouper(\n    columns,\n    group_by=None,\n    allow_enable=True,\n    allow_disable=True,\n    allow_modify=True\n)\n</code></pre> <p>Class that exposes methods to group columns.</p> <p><code>group_by</code> can be:</p> <ul> <li>boolean (False for no grouping, True for one group),</li> <li>integer (level by position),</li> <li>string (level by name),</li> <li>sequence of integers or strings that is shorter than <code>columns</code> (multiple levels),</li> <li>any other sequence that has the same length as <code>columns</code> (group per column).</li> </ul> <p>Set <code>allow_enable</code> to False to prohibit grouping if ColumnGrouper.group_by is None. Set <code>allow_disable</code> to False to prohibit disabling of grouping if ColumnGrouper.group_by is not None. Set <code>allow_modify</code> to False to prohibit modifying groups (you can still change their labels).</p> <p>All properties are read-only to enable caching.</p>  <p>Note</p> <p>Columns should build groups that are coherent and sorted for using get_group_lens_nb().</p>   <p>Note</p> <p>This class is meant to be immutable. To change any attribute, use Configured.replace().</p>  <p>Superclasses</p> <ul> <li>Configured</li> <li>Documented</li> <li>Pickleable</li> </ul> <p>Inherited members</p> <ul> <li>Configured.config</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>Configured.writeable_attrs</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> </ul>","title":"ColumnGrouper class"},{"location":"api/base/column_grouper/#vectorbt.base.column_grouper.ColumnGrouper.allow_disable","text":"<p>Whether to allow disabling grouping.</p>","title":"allow_disable property"},{"location":"api/base/column_grouper/#vectorbt.base.column_grouper.ColumnGrouper.allow_enable","text":"<p>Whether to allow enabling grouping.</p>","title":"allow_enable property"},{"location":"api/base/column_grouper/#vectorbt.base.column_grouper.ColumnGrouper.allow_modify","text":"<p>Whether to allow changing groups.</p>","title":"allow_modify property"},{"location":"api/base/column_grouper/#vectorbt.base.column_grouper.ColumnGrouper.columns","text":"<p>Original columns.</p>","title":"columns property"},{"location":"api/base/column_grouper/#vectorbt.base.column_grouper.ColumnGrouper.group_by","text":"<p>Mapper for grouping.</p>","title":"group_by property"},{"location":"api/base/column_grouper/#vectorbt.base.column_grouper.ColumnGrouper.check_group_by","text":"<pre><code>ColumnGrouper.check_group_by(\n    group_by=None,\n    allow_enable=None,\n    allow_disable=None,\n    allow_modify=None\n)\n</code></pre> <p>Check passed <code>group_by</code> object against restrictions.</p>","title":"check_group_by method"},{"location":"api/base/column_grouper/#vectorbt.base.column_grouper.ColumnGrouper.get_columns","text":"<pre><code>ColumnGrouper.get_columns(\n    **kwargs\n)\n</code></pre> <p>Return grouped columns.</p>","title":"get_columns method"},{"location":"api/base/column_grouper/#vectorbt.base.column_grouper.ColumnGrouper.get_group_count","text":"<pre><code>ColumnGrouper.get_group_count(\n    **kwargs\n)\n</code></pre> <p>Get number of groups.</p>","title":"get_group_count method"},{"location":"api/base/column_grouper/#vectorbt.base.column_grouper.ColumnGrouper.get_group_end_idxs","text":"<pre><code>ColumnGrouper.get_group_end_idxs(\n    **kwargs\n)\n</code></pre> <p>Get end index of each group as an array.</p>","title":"get_group_end_idxs method"},{"location":"api/base/column_grouper/#vectorbt.base.column_grouper.ColumnGrouper.get_group_lens","text":"<pre><code>ColumnGrouper.get_group_lens(\n    group_by=None,\n    **kwargs\n)\n</code></pre> <p>See get_group_lens_nb.</p>","title":"get_group_lens method"},{"location":"api/base/column_grouper/#vectorbt.base.column_grouper.ColumnGrouper.get_group_start_idxs","text":"<pre><code>ColumnGrouper.get_group_start_idxs(\n    **kwargs\n)\n</code></pre> <p>Get first index of each group as an array.</p>","title":"get_group_start_idxs method"},{"location":"api/base/column_grouper/#vectorbt.base.column_grouper.ColumnGrouper.get_groups","text":"<pre><code>ColumnGrouper.get_groups(\n    **kwargs\n)\n</code></pre> <p>Return groups array.</p>","title":"get_groups method"},{"location":"api/base/column_grouper/#vectorbt.base.column_grouper.ColumnGrouper.get_groups_and_columns","text":"<pre><code>ColumnGrouper.get_groups_and_columns(\n    group_by=None,\n    **kwargs\n)\n</code></pre> <p>See get_groups_and_index().</p>","title":"get_groups_and_columns method"},{"location":"api/base/column_grouper/#vectorbt.base.column_grouper.ColumnGrouper.is_group_count_changed","text":"<pre><code>ColumnGrouper.is_group_count_changed(\n    group_by=None\n)\n</code></pre> <p>Check whether the number of groups has changed.</p>","title":"is_group_count_changed method"},{"location":"api/base/column_grouper/#vectorbt.base.column_grouper.ColumnGrouper.is_grouped","text":"<pre><code>ColumnGrouper.is_grouped(\n    group_by=None\n)\n</code></pre> <p>Check whether columns are grouped.</p>","title":"is_grouped method"},{"location":"api/base/column_grouper/#vectorbt.base.column_grouper.ColumnGrouper.is_grouping_changed","text":"<pre><code>ColumnGrouper.is_grouping_changed(\n    group_by=None\n)\n</code></pre> <p>Check whether column grouping has changed in any way.</p>","title":"is_grouping_changed method"},{"location":"api/base/column_grouper/#vectorbt.base.column_grouper.ColumnGrouper.is_grouping_disabled","text":"<pre><code>ColumnGrouper.is_grouping_disabled(\n    group_by=None\n)\n</code></pre> <p>Check whether column grouping has been disabled.</p>","title":"is_grouping_disabled method"},{"location":"api/base/column_grouper/#vectorbt.base.column_grouper.ColumnGrouper.is_grouping_enabled","text":"<pre><code>ColumnGrouper.is_grouping_enabled(\n    group_by=None\n)\n</code></pre> <p>Check whether column grouping has been enabled.</p>","title":"is_grouping_enabled method"},{"location":"api/base/column_grouper/#vectorbt.base.column_grouper.ColumnGrouper.is_grouping_modified","text":"<pre><code>ColumnGrouper.is_grouping_modified(\n    group_by=None\n)\n</code></pre> <p>Check whether column grouping has been modified.</p> <p>Doesn't care if grouping labels have been changed.</p>","title":"is_grouping_modified method"},{"location":"api/base/column_grouper/#vectorbt.base.column_grouper.ColumnGrouper.is_sorted","text":"<pre><code>ColumnGrouper.is_sorted(\n    group_by=None,\n    **kwargs\n)\n</code></pre> <p>Return whether groups are coherent and sorted.</p>","title":"is_sorted method"},{"location":"api/base/column_grouper/#vectorbt.base.column_grouper.ColumnGrouper.resolve_group_by","text":"<pre><code>ColumnGrouper.resolve_group_by(\n    group_by=None,\n    **kwargs\n)\n</code></pre> <p>Resolve <code>group_by</code> from either object variable or keyword argument.</p>","title":"resolve_group_by method"},{"location":"api/base/combine_fns/","text":"<p>Functions for combining arrays.</p> <p>Combine functions combine two or more NumPy arrays using a custom function. The emphasis here is done upon stacking the results into one NumPy array - since vectorbt is all about brute-forcing large spaces of hyperparameters, concatenating the results of each hyperparameter combination into a single DataFrame is important. All functions are available in both Python and Numba-compiled form.</p>","title":"combine_fns"},{"location":"api/base/combine_fns/#vectorbt.base.combine_fns.apply_and_concat_multiple","text":"<pre><code>apply_and_concat_multiple(\n    n,\n    apply_func,\n    *args,\n    show_progress=False,\n    tqdm_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Identical to apply_and_concat_one(), except that the result of <code>apply_func</code> must be multiple 1-dim or 2-dim arrays. Each of these arrays at <code>i</code> will be concatenated with the array at the same position at <code>i+1</code>.</p>","title":"apply_and_concat_multiple function"},{"location":"api/base/combine_fns/#vectorbt.base.combine_fns.apply_and_concat_multiple_nb","text":"<pre><code>apply_and_concat_multiple_nb(\n    n,\n    apply_func_nb,\n    *args\n)\n</code></pre> <p>A Numba-compiled version of apply_and_concat_multiple().</p>  <p>Note</p> <ul> <li>Output of <code>apply_func_nb</code> must be strictly homogeneous</li> <li><code>apply_func_nb</code> must be Numba-compiled</li> <li><code>*args</code> must be Numba-compatible</li> <li>No support for <code>**kwargs</code></li> </ul>","title":"apply_and_concat_multiple_nb function"},{"location":"api/base/combine_fns/#vectorbt.base.combine_fns.apply_and_concat_multiple_ray","text":"<pre><code>apply_and_concat_multiple_ray(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Distributed version of apply_and_concat_multiple().</p>","title":"apply_and_concat_multiple_ray function"},{"location":"api/base/combine_fns/#vectorbt.base.combine_fns.apply_and_concat_none","text":"<pre><code>apply_and_concat_none(\n    n,\n    apply_func,\n    *args,\n    show_progress=False,\n    tqdm_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>For each value <code>i</code> from 0 to <code>n</code>, apply <code>apply_func</code> with arguments <code>*args</code> and <code>**kwargs</code>, and output nothing. Meant for in-place outputs.</p> <p><code>apply_func</code> must accept arguments <code>i</code>, <code>*args</code> and <code>**kwargs</code>.</p>","title":"apply_and_concat_none function"},{"location":"api/base/combine_fns/#vectorbt.base.combine_fns.apply_and_concat_none_nb","text":"<pre><code>apply_and_concat_none_nb(\n    n,\n    apply_func_nb,\n    *args\n)\n</code></pre> <p>A Numba-compiled version of apply_and_concat_none().</p>  <p>Note</p> <ul> <li><code>apply_func_nb</code> must be Numba-compiled</li> <li><code>*args</code> must be Numba-compatible</li> <li>No support for <code>**kwargs</code></li> </ul>","title":"apply_and_concat_none_nb function"},{"location":"api/base/combine_fns/#vectorbt.base.combine_fns.apply_and_concat_one","text":"<pre><code>apply_and_concat_one(\n    n,\n    apply_func,\n    *args,\n    show_progress=False,\n    tqdm_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>For each value <code>i</code> from 0 to <code>n</code>, apply <code>apply_func</code> with arguments <code>*args</code> and <code>**kwargs</code>, and concat the results along axis 1.</p> <p>The result of <code>apply_func</code> must be a single 1-dim or 2-dim array.</p> <p><code>apply_func</code> must accept arguments <code>i</code>, <code>*args</code> and <code>**kwargs</code>.</p>","title":"apply_and_concat_one function"},{"location":"api/base/combine_fns/#vectorbt.base.combine_fns.apply_and_concat_one_nb","text":"<pre><code>apply_and_concat_one_nb(\n    n,\n    apply_func_nb,\n    *args\n)\n</code></pre> <p>A Numba-compiled version of apply_and_concat_one().</p>  <p>Note</p> <ul> <li><code>apply_func_nb</code> must be Numba-compiled</li> <li><code>*args</code> must be Numba-compatible</li> <li>No support for <code>**kwargs</code></li> </ul>","title":"apply_and_concat_one_nb function"},{"location":"api/base/combine_fns/#vectorbt.base.combine_fns.apply_and_concat_one_ray","text":"<pre><code>apply_and_concat_one_ray(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Distributed version of apply_and_concat_one().</p>","title":"apply_and_concat_one_ray function"},{"location":"api/base/combine_fns/#vectorbt.base.combine_fns.combine_and_concat","text":"<pre><code>combine_and_concat(\n    obj,\n    others,\n    combine_func,\n    *args,\n    **kwargs\n)\n</code></pre> <p>Use apply_and_concat_one() to combine <code>obj</code> with each element from <code>others</code> using <code>combine_func</code>.</p>","title":"combine_and_concat function"},{"location":"api/base/combine_fns/#vectorbt.base.combine_fns.combine_and_concat_nb","text":"<pre><code>combine_and_concat_nb(\n    obj,\n    others,\n    combine_func_nb,\n    *args\n)\n</code></pre> <p>A Numba-compiled version of combine_and_concat().</p>","title":"combine_and_concat_nb function"},{"location":"api/base/combine_fns/#vectorbt.base.combine_fns.combine_and_concat_ray","text":"<pre><code>combine_and_concat_ray(\n    obj,\n    others,\n    combine_func,\n    *args,\n    **kwargs\n)\n</code></pre> <p>Distributed version of combine_and_concat().</p>","title":"combine_and_concat_ray function"},{"location":"api/base/combine_fns/#vectorbt.base.combine_fns.combine_multiple","text":"<pre><code>combine_multiple(\n    objs,\n    combine_func,\n    *args,\n    **kwargs\n)\n</code></pre> <p>Combine <code>objs</code> pairwise into a single object.</p>","title":"combine_multiple function"},{"location":"api/base/combine_fns/#vectorbt.base.combine_fns.combine_multiple_nb","text":"<pre><code>combine_multiple_nb(\n    objs,\n    combine_func_nb,\n    *args\n)\n</code></pre> <p>A Numba-compiled version of combine_multiple().</p>  <p>Note</p> <ul> <li><code>combine_func_nb</code> must be Numba-compiled</li> <li><code>objs</code> and <code>*args</code> must be Numba-compatible</li> <li><code>objs</code> must be strictly homogeneous</li> <li>No support for <code>**kwargs</code></li> </ul>","title":"combine_multiple_nb function"},{"location":"api/base/combine_fns/#vectorbt.base.combine_fns.ray_apply","text":"<pre><code>ray_apply(\n    n,\n    apply_func,\n    *args,\n    ray_force_init=False,\n    ray_func_kwargs=None,\n    ray_init_kwargs=None,\n    ray_shutdown=False,\n    **kwargs\n)\n</code></pre> <p>Run <code>apply_func</code> in distributed manner.</p> <p>Set <code>ray_reinit</code> to True to terminate the Ray runtime and initialize a new one. <code>ray_func_kwargs</code> will be passed to <code>ray.remote</code> and <code>ray_init_kwargs</code> to <code>ray.init</code>. Set <code>ray_shutdown</code> to True to terminate the Ray runtime upon the job end.</p>","title":"ray_apply function"},{"location":"api/base/combine_fns/#vectorbt.base.combine_fns.select_and_combine","text":"<pre><code>select_and_combine(\n    i,\n    obj,\n    others,\n    combine_func,\n    *args,\n    **kwargs\n)\n</code></pre> <p>Combine <code>obj</code> and an element from <code>others</code> at <code>i</code> using <code>combine_func</code>.</p>","title":"select_and_combine function"},{"location":"api/base/combine_fns/#vectorbt.base.combine_fns.select_and_combine_nb","text":"<pre><code>select_and_combine_nb(\n    i,\n    obj,\n    others,\n    combine_func_nb,\n    *args\n)\n</code></pre> <p>A Numba-compiled version of select_and_combine().</p>  <p>Note</p> <ul> <li><code>combine_func_nb</code> must be Numba-compiled</li> <li><code>obj</code>, <code>others</code> and <code>*args</code> must be Numba-compatible</li> <li><code>others</code> must be strictly homogeneous</li> <li>No support for <code>**kwargs</code></li> </ul>","title":"select_and_combine_nb function"},{"location":"api/base/combine_fns/#vectorbt.base.combine_fns.to_2d_multiple_nb","text":"<pre><code>to_2d_multiple_nb(\n    a\n)\n</code></pre> <p>Expand the dimensions of each array in <code>a</code> along axis 1.</p>  <p>Note</p> <ul> <li><code>a</code> must be strictly homogeneous</li> </ul>","title":"to_2d_multiple_nb function"},{"location":"api/base/combine_fns/#vectorbt.base.combine_fns.to_2d_one_nb","text":"<pre><code>to_2d_one_nb(\n    a\n)\n</code></pre> <p>Expand the dimensions of array <code>a</code> along axis 1.</p>  <p>Note</p> <ul> <li><code>a</code> must be strictly homogeneous</li> </ul>","title":"to_2d_one_nb function"},{"location":"api/base/index_fns/","text":"<p>Functions for working with index/columns.</p> <p>Index functions perform operations on index objects, such as stacking, combining, and cleansing MultiIndex levels. \"Index\" in pandas context is referred to both index and columns.</p>","title":"index_fns"},{"location":"api/base/index_fns/#vectorbt.base.index_fns.align_index_to","text":"<pre><code>align_index_to(\n    index1,\n    index2\n)\n</code></pre> <p>Align <code>index1</code> to have the same shape as <code>index2</code> if they have any levels in common.</p> <p>Returns index slice for the aligning.</p>","title":"align_index_to function"},{"location":"api/base/index_fns/#vectorbt.base.index_fns.align_indexes","text":"<pre><code>align_indexes(\n    indexes\n)\n</code></pre> <p>Align multiple indexes to each other.</p>","title":"align_indexes function"},{"location":"api/base/index_fns/#vectorbt.base.index_fns.combine_indexes","text":"<pre><code>combine_indexes(\n    indexes,\n    ignore_default=None,\n    **kwargs\n)\n</code></pre> <p>Combine each index in <code>indexes</code> using Cartesian product.</p> <p>Keyword arguments will be passed to stack_indexes().</p>","title":"combine_indexes function"},{"location":"api/base/index_fns/#vectorbt.base.index_fns.drop_duplicate_levels","text":"<pre><code>drop_duplicate_levels(\n    index,\n    keep=None\n)\n</code></pre> <p>Drop levels in <code>index</code> with the same name and values.</p> <p>Set <code>keep</code> to 'last' to keep last levels, otherwise 'first'.</p> <p>Set <code>keep</code> to None to use the default.</p>","title":"drop_duplicate_levels function"},{"location":"api/base/index_fns/#vectorbt.base.index_fns.drop_levels","text":"<pre><code>drop_levels(\n    index,\n    levels,\n    strict=True\n)\n</code></pre> <p>Drop <code>levels</code> in <code>index</code> by their name/position.</p>","title":"drop_levels function"},{"location":"api/base/index_fns/#vectorbt.base.index_fns.drop_redundant_levels","text":"<pre><code>drop_redundant_levels(\n    index\n)\n</code></pre> <p>Drop levels in <code>index</code> that either have a single unnamed value or a range from 0 to n.</p>","title":"drop_redundant_levels function"},{"location":"api/base/index_fns/#vectorbt.base.index_fns.find_first_occurrence","text":"<pre><code>find_first_occurrence(\n    index_value,\n    index\n)\n</code></pre> <p>Return index of the first occurrence in <code>index</code>.</p>","title":"find_first_occurrence function"},{"location":"api/base/index_fns/#vectorbt.base.index_fns.get_index","text":"<pre><code>get_index(\n    arg,\n    axis\n)\n</code></pre> <p>Get index of <code>arg</code> by <code>axis</code>.</p>","title":"get_index function"},{"location":"api/base/index_fns/#vectorbt.base.index_fns.index_from_values","text":"<pre><code>index_from_values(\n    values,\n    name=None\n)\n</code></pre> <p>Create a new <code>pd.Index</code> with <code>name</code> by parsing an iterable <code>values</code>.</p> <p>Each in <code>values</code> will correspond to an element in the new index.</p>","title":"index_from_values function"},{"location":"api/base/index_fns/#vectorbt.base.index_fns.pick_levels","text":"<pre><code>pick_levels(\n    index,\n    required_levels=None,\n    optional_levels=None\n)\n</code></pre> <p>Pick optional and required levels and return their indices.</p> <p>Raises an exception if index has less or more levels than expected.</p>","title":"pick_levels function"},{"location":"api/base/index_fns/#vectorbt.base.index_fns.rename_levels","text":"<pre><code>rename_levels(\n    index,\n    name_dict,\n    strict=True\n)\n</code></pre> <p>Rename levels in <code>index</code> by <code>name_dict</code>.</p>","title":"rename_levels function"},{"location":"api/base/index_fns/#vectorbt.base.index_fns.repeat_index","text":"<pre><code>repeat_index(\n    index,\n    n,\n    ignore_default=None\n)\n</code></pre> <p>Repeat each element in <code>index</code> <code>n</code> times.</p> <p>Set <code>ignore_default</code> to None to use the default.</p>","title":"repeat_index function"},{"location":"api/base/index_fns/#vectorbt.base.index_fns.select_levels","text":"<pre><code>select_levels(\n    index,\n    level_names\n)\n</code></pre> <p>Build a new index by selecting one or multiple <code>level_names</code> from <code>index</code>.</p>","title":"select_levels function"},{"location":"api/base/index_fns/#vectorbt.base.index_fns.stack_indexes","text":"<pre><code>stack_indexes(\n    indexes,\n    drop_duplicates=None,\n    keep=None,\n    drop_redundant=None\n)\n</code></pre> <p>Stack each index in <code>indexes</code> on top of each other, from top to bottom.</p> <p>Set <code>drop_duplicates</code>, <code>keep</code>, or <code>drop_redundant</code> to None to use the default.</p>","title":"stack_indexes function"},{"location":"api/base/index_fns/#vectorbt.base.index_fns.tile_index","text":"<pre><code>tile_index(\n    index,\n    n,\n    ignore_default=None\n)\n</code></pre> <p>Tile the whole <code>index</code> <code>n</code> times.</p> <p>Set <code>ignore_default</code> to None to use the default.</p>","title":"tile_index function"},{"location":"api/base/index_fns/#vectorbt.base.index_fns.to_any_index","text":"<pre><code>to_any_index(\n    index_like\n)\n</code></pre> <p>Convert any index-like object to an index.</p> <p>Index objects are kept as-is.</p>","title":"to_any_index function"},{"location":"api/base/indexing/","text":"<p>Classes for indexing.</p> <p>The main purpose of indexing classes is to provide pandas-like indexing to user-defined classes holding objects that have rows and/or columns. This is done by forwarding indexing commands to each structured object and constructing the new user-defined class using them. This way, one can manipulate complex classes with dozens of pandas objects using a single command.</p>","title":"indexing"},{"location":"api/base/indexing/#vectorbt.base.indexing.build_param_indexer","text":"<pre><code>build_param_indexer(\n    param_names,\n    class_name='ParamIndexer',\n    module_name=None\n)\n</code></pre> <p>A factory to create a class with parameter indexing.</p> <p>Parameter indexer enables accessing a group of rows and columns by a parameter array (similar to <code>loc</code>). This way, one can query index/columns by another Series called a parameter mapper, which is just a <code>pd.Series</code> that maps columns (its index) to params (its values).</p> <p>Parameter indexing is important, since querying by column/index labels alone is not always the best option. For example, <code>pandas</code> doesn't let you query by list at a specific index/column level.</p> <p>Args</p>  <code>param_names</code> :\u2002<code>list</code> of <code>str</code> Names of the parameters. <code>class_name</code> :\u2002<code>str</code> Name of the generated class. <code>module_name</code> :\u2002<code>str</code> Name of the module to which the class should be bound.  <p>Usage</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from vectorbt.base.indexing import build_param_indexer, indexing_on_mapper\n\n&gt;&gt;&gt; MyParamIndexer = build_param_indexer(['my_param'])\n&gt;&gt;&gt; class C(MyParamIndexer):\n...     def __init__(self, df, param_mapper):\n...         self.df = df\n...         self._my_param_mapper = param_mapper\n...         super().__init__([param_mapper])\n...\n...     def indexing_func(self, pd_indexing_func):\n...         return self.__class__(\n...             pd_indexing_func(self.df),\n...             indexing_on_mapper(self._my_param_mapper, self.df, pd_indexing_func)\n...         )\n\n&gt;&gt;&gt; df = pd.DataFrame({'a': [1, 2], 'b': [3, 4]})\n&gt;&gt;&gt; param_mapper = pd.Series(['First', 'Second'], index=['a', 'b'])\n&gt;&gt;&gt; c = C(df, param_mapper)\n\n&gt;&gt;&gt; c.my_param_loc['First'].df\n0    1\n1    2\nName: a, dtype: int64\n\n&gt;&gt;&gt; c.my_param_loc['Second'].df\n0    3\n1    4\nName: b, dtype: int64\n\n&gt;&gt;&gt; c.my_param_loc[['First', 'First', 'Second', 'Second']].df\n      a     b\n0  1  1  3  3\n1  2  2  4  4\n</code></pre>","title":"build_param_indexer function"},{"location":"api/base/indexing/#vectorbt.base.indexing.indexing_on_mapper","text":"<pre><code>indexing_on_mapper(\n    mapper,\n    ref_obj,\n    pd_indexing_func\n)\n</code></pre> <p>Broadcast <code>mapper</code> Series to <code>ref_obj</code> and perform pandas indexing using <code>pd_indexing_func</code>.</p>","title":"indexing_on_mapper function"},{"location":"api/base/indexing/#vectorbt.base.indexing.IndexingBase","text":"<pre><code>IndexingBase()\n</code></pre> <p>Class that supports indexing through IndexingBase.indexing_func().</p> <p>Subclasses</p> <ul> <li>PandasIndexer</li> <li><code>vectorbt.indicators.basic.ParamIndexer</code></li> <li><code>vectorbt.indicators.basic.ParamIndexer</code></li> <li><code>vectorbt.indicators.basic.ParamIndexer</code></li> <li><code>vectorbt.indicators.basic.ParamIndexer</code></li> <li><code>vectorbt.indicators.basic.ParamIndexer</code></li> <li><code>vectorbt.indicators.basic.ParamIndexer</code></li> <li><code>vectorbt.indicators.basic.ParamIndexer</code></li> <li><code>vectorbt.indicators.basic.ParamIndexer</code></li> <li><code>vectorbt.labels.generators.ParamIndexer</code></li> <li><code>vectorbt.labels.generators.ParamIndexer</code></li> <li><code>vectorbt.labels.generators.ParamIndexer</code></li> <li><code>vectorbt.labels.generators.ParamIndexer</code></li> <li><code>vectorbt.labels.generators.ParamIndexer</code></li> <li><code>vectorbt.labels.generators.ParamIndexer</code></li> <li><code>vectorbt.labels.generators.ParamIndexer</code></li> <li><code>vectorbt.labels.generators.ParamIndexer</code></li> <li><code>vectorbt.labels.generators.ParamIndexer</code></li> <li><code>vectorbt.signals.generators.ParamIndexer</code></li> <li><code>vectorbt.signals.generators.ParamIndexer</code></li> <li><code>vectorbt.signals.generators.ParamIndexer</code></li> <li><code>vectorbt.signals.generators.ParamIndexer</code></li> <li><code>vectorbt.signals.generators.ParamIndexer</code></li> <li><code>vectorbt.signals.generators.ParamIndexer</code></li> <li><code>vectorbt.signals.generators.ParamIndexer</code></li> <li><code>vectorbt.signals.generators.ParamIndexer</code></li> <li><code>vectorbt.signals.generators.ParamIndexer</code></li> <li><code>vectorbt.signals.generators.ParamIndexer</code></li> <li><code>vectorbt.signals.generators.ParamIndexer</code></li> </ul>","title":"IndexingBase class"},{"location":"api/base/indexing/#vectorbt.base.indexing.IndexingBase.indexing_func","text":"<pre><code>IndexingBase.indexing_func(\n    pd_indexing_func,\n    **kwargs\n)\n</code></pre> <p>Apply <code>pd_indexing_func</code> on all pandas objects in question and return a new instance of the class.</p> <p>Should be overridden.</p>","title":"indexing_func method"},{"location":"api/base/indexing/#vectorbt.base.indexing.IndexingError","text":"<pre><code>IndexingError(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Exception raised when an indexing error has occurred.</p> <p>Superclasses</p> <ul> <li><code>builtins.BaseException</code></li> <li><code>builtins.Exception</code></li> </ul>","title":"IndexingError class"},{"location":"api/base/indexing/#vectorbt.base.indexing.Loc","text":"<pre><code>Loc(\n    indexing_func,\n    **kwargs\n)\n</code></pre> <p>Forwards <code>pd.Series.loc</code>/<code>pd.DataFrame.loc</code> operation to each Series/DataFrame and returns a new class instance.</p> <p>Superclasses</p> <ul> <li>LocBase</li> </ul> <p>Inherited members</p> <ul> <li>LocBase.indexing_func</li> <li>LocBase.indexing_kwargs</li> </ul>","title":"Loc class"},{"location":"api/base/indexing/#vectorbt.base.indexing.LocBase","text":"<pre><code>LocBase(\n    indexing_func,\n    **kwargs\n)\n</code></pre> <p>Class that implements location-based indexing.</p> <p>Subclasses</p> <ul> <li>Loc</li> <li>ParamLoc</li> <li>iLoc</li> </ul>","title":"LocBase class"},{"location":"api/base/indexing/#vectorbt.base.indexing.LocBase.indexing_func","text":"<p>Indexing function.</p>","title":"indexing_func property"},{"location":"api/base/indexing/#vectorbt.base.indexing.LocBase.indexing_kwargs","text":"<p>Keyword arguments passed to LocBase.indexing_func.</p>","title":"indexing_kwargs property"},{"location":"api/base/indexing/#vectorbt.base.indexing.PandasIndexer","text":"<pre><code>PandasIndexer(\n    **kwargs\n)\n</code></pre> <p>Implements indexing using <code>iloc</code>, <code>loc</code>, <code>xs</code> and <code>__getitem__</code>.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from vectorbt.base.indexing import PandasIndexer\n\n&gt;&gt;&gt; class C(PandasIndexer):\n...     def __init__(self, df1, df2):\n...         self.df1 = df1\n...         self.df2 = df2\n...         super().__init__()\n...\n...     def indexing_func(self, pd_indexing_func):\n...         return self.__class__(\n...             pd_indexing_func(self.df1),\n...             pd_indexing_func(self.df2)\n...         )\n\n&gt;&gt;&gt; df1 = pd.DataFrame({'a': [1, 2], 'b': [3, 4]})\n&gt;&gt;&gt; df2 = pd.DataFrame({'a': [5, 6], 'b': [7, 8]})\n&gt;&gt;&gt; c = C(df1, df2)\n\n&gt;&gt;&gt; c.iloc[:, 0]\n&lt;__main__.C object at 0x1a1cacbbe0&gt;\n\n&gt;&gt;&gt; c.iloc[:, 0].df1\n0    1\n1    2\nName: a, dtype: int64\n\n&gt;&gt;&gt; c.iloc[:, 0].df2\n0    5\n1    6\nName: a, dtype: int64\n</code></pre> <p>Superclasses</p> <ul> <li>IndexingBase</li> </ul> <p>Inherited members</p> <ul> <li>IndexingBase.indexing_func()</li> </ul> <p>Subclasses</p> <ul> <li>ArrayWrapper</li> <li>Wrapping</li> </ul>","title":"PandasIndexer class"},{"location":"api/base/indexing/#vectorbt.base.indexing.PandasIndexer.iloc","text":"<p>Forwards <code>pd.Series.iloc</code>/<code>pd.DataFrame.iloc</code> operation to each Series/DataFrame and returns a new class instance.</p>","title":"iloc property"},{"location":"api/base/indexing/#vectorbt.base.indexing.PandasIndexer.indexing_kwargs","text":"<p>Indexing keyword arguments.</p>","title":"indexing_kwargs property"},{"location":"api/base/indexing/#vectorbt.base.indexing.PandasIndexer.loc","text":"<p>Forwards <code>pd.Series.loc</code>/<code>pd.DataFrame.loc</code> operation to each Series/DataFrame and returns a new class instance.</p>","title":"loc property"},{"location":"api/base/indexing/#vectorbt.base.indexing.PandasIndexer.xs","text":"<pre><code>PandasIndexer.xs(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Forwards <code>pd.Series.xs</code>/<code>pd.DataFrame.xs</code> operation to each Series/DataFrame and returns a new class instance.</p>","title":"xs method"},{"location":"api/base/indexing/#vectorbt.base.indexing.ParamLoc","text":"<pre><code>ParamLoc(\n    mapper,\n    indexing_func,\n    level_name=None,\n    **kwargs\n)\n</code></pre> <p>Access a group of columns by parameter using <code>pd.Series.loc</code>.</p> <p>Uses <code>mapper</code> to establish link between columns and parameter values.</p> <p>Superclasses</p> <ul> <li>LocBase</li> </ul> <p>Inherited members</p> <ul> <li>LocBase.indexing_func</li> <li>LocBase.indexing_kwargs</li> </ul>","title":"ParamLoc class"},{"location":"api/base/indexing/#vectorbt.base.indexing.ParamLoc.level_name","text":"<p>Level name.</p>","title":"level_name property"},{"location":"api/base/indexing/#vectorbt.base.indexing.ParamLoc.mapper","text":"<p>Mapper.</p>","title":"mapper property"},{"location":"api/base/indexing/#vectorbt.base.indexing.ParamLoc.get_indices","text":"<pre><code>ParamLoc.get_indices(\n    key\n)\n</code></pre> <p>Get array of indices affected by this key.</p>","title":"get_indices method"},{"location":"api/base/indexing/#vectorbt.base.indexing.iLoc","text":"<pre><code>iLoc(\n    indexing_func,\n    **kwargs\n)\n</code></pre> <p>Forwards <code>pd.Series.iloc</code>/<code>pd.DataFrame.iloc</code> operation to each Series/DataFrame and returns a new class instance.</p> <p>Superclasses</p> <ul> <li>LocBase</li> </ul> <p>Inherited members</p> <ul> <li>LocBase.indexing_func</li> <li>LocBase.indexing_kwargs</li> </ul>","title":"iLoc class"},{"location":"api/base/reshape_fns/","text":"<p>Functions for reshaping arrays.</p> <p>Reshape functions transform a pandas object/NumPy array in some way, such as tiling, broadcasting, and unstacking.</p>","title":"reshape_fns"},{"location":"api/base/reshape_fns/#vectorbt.base.reshape_fns.IndexFromLike","text":"<p>Any object that can be coerced into a <code>index_from</code> argument.</p>","title":"IndexFromLike variable"},{"location":"api/base/reshape_fns/#vectorbt.base.reshape_fns.broadcast","text":"<pre><code>broadcast(\n    *args,\n    to_shape=None,\n    to_pd=None,\n    to_frame=None,\n    align_index=None,\n    align_columns=None,\n    index_from=None,\n    columns_from=None,\n    require_kwargs=None,\n    keep_raw=False,\n    return_meta=False,\n    **kwargs\n)\n</code></pre> <p>Bring any array-like object in <code>args</code> to the same shape by using NumPy broadcasting.</p> <p>See Broadcasting.</p> <p>Can broadcast pandas objects by broadcasting their index/columns with broadcast_index().</p> <p>Args</p>  <code>*args</code> :\u2002<code>array_like</code> Array-like objects. <code>to_shape</code> :\u2002<code>tuple</code> of <code>int</code> Target shape. If set, will broadcast every element in <code>args</code> to <code>to_shape</code>. <code>to_pd</code> :\u2002<code>bool</code> or <code>list</code> of <code>bool</code>  <p>Whether to convert all output arrays to pandas, otherwise returns raw NumPy arrays. If None, converts only if there is at least one pandas object among them.</p> <p>If sequence, applies to each argument.</p>  <code>to_frame</code> :\u2002<code>bool</code> Whether to convert all Series to DataFrames. <code>align_index</code> :\u2002<code>bool</code>  <p>Whether to align index of pandas objects using multi-index.</p> <p>Pass None to use the default.</p>  <code>align_columns</code> :\u2002<code>bool</code>  <p>Whether to align columns of pandas objects using multi-index.</p> <p>Pass None to use the default.</p>  <code>index_from</code> :\u2002<code>any</code>  <p>Broadcasting rule for index.</p> <p>Pass None to use the default.</p>  <code>columns_from</code> :\u2002<code>any</code>  <p>Broadcasting rule for columns.</p> <p>Pass None to use the default.</p>  <code>require_kwargs</code> :\u2002<code>dict</code> or <code>list</code> of <code>dict</code>  <p>Keyword arguments passed to <code>np.require</code>.</p> <p>If sequence, applies to each argument.</p>  <code>keep_raw</code> :\u2002<code>bool</code> or <code>list</code> of <code>bool</code>  <p>Whether to keep the unbroadcasted version of the array.</p> <p>Only makes sure that the array can be broadcast to the target shape.</p> <p>If sequence, applies to each argument.</p>  <code>return_meta</code> :\u2002<code>bool</code> Whether to also return new shape, index and columns. <code>**kwargs</code> Keyword arguments passed to broadcast_index().  <p>For defaults, see <code>broadcasting</code> in settings.</p> <p>Usage</p> <ul> <li>Without broadcasting index and columns:</li> </ul> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from vectorbt.base.reshape_fns import broadcast\n\n&gt;&gt;&gt; v = 0\n&gt;&gt;&gt; a = np.array([1, 2, 3])\n&gt;&gt;&gt; sr = pd.Series([1, 2, 3], index=pd.Index(['x', 'y', 'z']), name='a')\n&gt;&gt;&gt; df = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n...     index=pd.Index(['x2', 'y2', 'z2']),\n...     columns=pd.Index(['a2', 'b2', 'c2']))\n\n&gt;&gt;&gt; for i in broadcast(\n...     v, a, sr, df,\n...     index_from='keep',\n...     columns_from='keep',\n... ): print(i)\n   0  1  2\n0  0  0  0\n1  0  0  0\n2  0  0  0\n   0  1  2\n0  1  2  3\n1  1  2  3\n2  1  2  3\n   a  a  a\nx  1  1  1\ny  2  2  2\nz  3  3  3\n    a2  b2  c2\nx2   1   2   3\ny2   4   5   6\nz2   7   8   9\n</code></pre> <ul> <li>Taking new index and columns from position:</li> </ul> <pre><code>&gt;&gt;&gt; for i in broadcast(\n...     v, a, sr, df,\n...     index_from=2,\n...     columns_from=3\n... ): print(i)\n   a2  b2  c2\nx   0   0   0\ny   0   0   0\nz   0   0   0\n   a2  b2  c2\nx   1   2   3\ny   1   2   3\nz   1   2   3\n   a2  b2  c2\nx   1   1   1\ny   2   2   2\nz   3   3   3\n   a2  b2  c2\nx   1   2   3\ny   4   5   6\nz   7   8   9\n</code></pre> <ul> <li>Broadcasting index and columns through stacking:</li> </ul> <pre><code>&gt;&gt;&gt; for i in broadcast(\n...     v, a, sr, df,\n...     index_from='stack',\n...     columns_from='stack'\n... ): print(i)\n      a2  b2  c2\nx x2   0   0   0\ny y2   0   0   0\nz z2   0   0   0\n      a2  b2  c2\nx x2   1   2   3\ny y2   1   2   3\nz z2   1   2   3\n      a2  b2  c2\nx x2   1   1   1\ny y2   2   2   2\nz z2   3   3   3\n      a2  b2  c2\nx x2   1   2   3\ny y2   4   5   6\nz z2   7   8   9\n</code></pre> <ul> <li>Setting index and columns manually:</li> </ul> <pre><code>&gt;&gt;&gt; for i in broadcast(\n...     v, a, sr, df,\n...     index_from=['a', 'b', 'c'],\n...     columns_from=['d', 'e', 'f']\n... ): print(i)\n   d  e  f\na  0  0  0\nb  0  0  0\nc  0  0  0\n   d  e  f\na  1  2  3\nb  1  2  3\nc  1  2  3\n   d  e  f\na  1  1  1\nb  2  2  2\nc  3  3  3\n   d  e  f\na  1  2  3\nb  4  5  6\nc  7  8  9\n</code></pre>","title":"broadcast function"},{"location":"api/base/reshape_fns/#vectorbt.base.reshape_fns.broadcast_index","text":"<pre><code>broadcast_index(\n    args,\n    to_shape,\n    index_from=None,\n    axis=0,\n    ignore_sr_names=None,\n    **kwargs\n)\n</code></pre> <p>Produce a broadcast index/columns.</p> <p>Args</p>  <code>args</code> :\u2002<code>list</code> of <code>array_like</code> Array-like objects. <code>to_shape</code> :\u2002<code>tuple</code> of <code>int</code> Target shape. <code>index_from</code> :\u2002<code>any</code>  <p>Broadcasting rule for this index/these columns.</p> <p>Accepts the following values:</p> <ul> <li>'keep' or None - keep the original index/columns of the objects in <code>args</code></li> <li>'stack' - stack different indexes/columns using stack_indexes()</li> <li>'strict' - ensure that all pandas objects have the same index/columns</li> <li>'reset' - reset any index/columns (they become a simple range)</li> <li>integer - use the index/columns of the i-th object in <code>args</code></li> <li>everything else will be converted to <code>pd.Index</code></li> </ul>  <code>axis</code> :\u2002<code>int</code> Set to 0 for index and 1 for columns. <code>ignore_sr_names</code> :\u2002<code>bool</code>  <p>Whether to ignore Series names if they are in conflict.</p> <p>Conflicting Series names are those that are different but not None.</p>  <code>**kwargs</code> Keyword arguments passed to stack_indexes().  <p>For defaults, see <code>broadcasting</code> in settings.</p>  <p>Note</p> <p>Series names are treated as columns with a single element but without a name. If a column level without a name loses its meaning, better to convert Series to DataFrames with one column prior to broadcasting. If the name of a Series is not that important, better to drop it altogether by setting it to None.</p>","title":"broadcast_index function"},{"location":"api/base/reshape_fns/#vectorbt.base.reshape_fns.broadcast_to","text":"<pre><code>broadcast_to(\n    arg1,\n    arg2,\n    to_pd=None,\n    index_from=None,\n    columns_from=None,\n    **kwargs\n)\n</code></pre> <p>Broadcast <code>arg1</code> to <code>arg2</code>.</p> <p>Pass None to <code>index_from</code>/<code>columns_from</code> to use index/columns of the second argument.</p> <p>Keyword arguments <code>**kwargs</code> are passed to broadcast().</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from vectorbt.base.reshape_fns import broadcast_to\n\n&gt;&gt;&gt; a = np.array([1, 2, 3])\n&gt;&gt;&gt; sr = pd.Series([4, 5, 6], index=pd.Index(['x', 'y', 'z']), name='a')\n\n&gt;&gt;&gt; broadcast_to(a, sr)\nx    1\ny    2\nz    3\nName: a, dtype: int64\n\n&gt;&gt;&gt; broadcast_to(sr, a)\narray([4, 5, 6])\n</code></pre>","title":"broadcast_to function"},{"location":"api/base/reshape_fns/#vectorbt.base.reshape_fns.broadcast_to_array_of","text":"<pre><code>broadcast_to_array_of(\n    arg1,\n    arg2\n)\n</code></pre> <p>Broadcast <code>arg1</code> to the shape <code>(1, *arg2.shape)</code>.</p> <p><code>arg1</code> must be either a scalar, a 1-dim array, or have 1 dimension more than <code>arg2</code>.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from vectorbt.base.reshape_fns import broadcast_to_array_of\n\n&gt;&gt;&gt; broadcast_to_array_of([0.1, 0.2], np.empty((2, 2)))\n[[[0.1 0.1]\n  [0.1 0.1]]\n\n [[0.2 0.2]\n  [0.2 0.2]]]\n</code></pre>","title":"broadcast_to_array_of function"},{"location":"api/base/reshape_fns/#vectorbt.base.reshape_fns.broadcast_to_axis_of","text":"<pre><code>broadcast_to_axis_of(\n    arg1,\n    arg2,\n    axis,\n    require_kwargs=None\n)\n</code></pre> <p>Broadcast <code>arg1</code> to an axis of <code>arg2</code>.</p> <p>If <code>arg2</code> has less dimensions than requested, will broadcast <code>arg1</code> to a single number.</p> <p>For other keyword arguments, see broadcast().</p>","title":"broadcast_to_axis_of function"},{"location":"api/base/reshape_fns/#vectorbt.base.reshape_fns.flex_choose_i_and_col_nb","text":"<pre><code>flex_choose_i_and_col_nb(\n    a,\n    flex_2d=True\n)\n</code></pre> <p>Choose selection index and column based on the array's shape.</p> <p>Instead of expensive broadcasting, keep the original shape and do indexing in a smart way. A nice feature of this is that it has almost no memory footprint and can broadcast in any direction infinitely.</p> <p>Call it once before using flex_select_nb().</p> <p>if <code>flex_2d</code> is True, 1-dim array will correspond to columns, otherwise to rows.</p>","title":"flex_choose_i_and_col_nb function"},{"location":"api/base/reshape_fns/#vectorbt.base.reshape_fns.flex_select_auto_nb","text":"<pre><code>flex_select_auto_nb(\n    a,\n    i,\n    col,\n    flex_2d=True\n)\n</code></pre> <p>Combines flex_choose_i_and_col_nb() and flex_select_nb().</p>","title":"flex_select_auto_nb function"},{"location":"api/base/reshape_fns/#vectorbt.base.reshape_fns.flex_select_nb","text":"<pre><code>flex_select_nb(\n    a,\n    i,\n    col,\n    flex_i,\n    flex_col,\n    flex_2d=True\n)\n</code></pre> <p>Select element of <code>a</code> as if it has been broadcast.</p>","title":"flex_select_nb function"},{"location":"api/base/reshape_fns/#vectorbt.base.reshape_fns.get_multiindex_series","text":"<pre><code>get_multiindex_series(\n    arg\n)\n</code></pre> <p>Get Series with a multi-index.</p> <p>If DataFrame has been passed, should at maximum have one row or column.</p>","title":"get_multiindex_series function"},{"location":"api/base/reshape_fns/#vectorbt.base.reshape_fns.make_symmetric","text":"<pre><code>make_symmetric(\n    arg,\n    sort=True\n)\n</code></pre> <p>Make <code>arg</code> symmetric.</p> <p>The index and columns of the resulting DataFrame will be identical.</p> <p>Requires the index and columns to have the same number of levels.</p> <p>Pass <code>sort=False</code> if index and columns should not be sorted, but concatenated and get duplicates removed.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from vectorbt.base.reshape_fns import make_symmetric\n\n&gt;&gt;&gt; df = pd.DataFrame([[1, 2], [3, 4]], index=['a', 'b'], columns=['c', 'd'])\n\n&gt;&gt;&gt; make_symmetric(df)\n     a    b    c    d\na  NaN  NaN  1.0  2.0\nb  NaN  NaN  3.0  4.0\nc  1.0  3.0  NaN  NaN\nd  2.0  4.0  NaN  NaN\n</code></pre>","title":"make_symmetric function"},{"location":"api/base/reshape_fns/#vectorbt.base.reshape_fns.repeat","text":"<pre><code>repeat(\n    arg,\n    n,\n    axis=1,\n    raw=False\n)\n</code></pre> <p>Repeat each element in <code>arg</code> <code>n</code> times along the specified axis.</p>","title":"repeat function"},{"location":"api/base/reshape_fns/#vectorbt.base.reshape_fns.soft_to_ndim","text":"<pre><code>soft_to_ndim(\n    arg,\n    ndim,\n    raw=False\n)\n</code></pre> <p>Try to softly bring <code>arg</code> to the specified number of dimensions <code>ndim</code> (max 2).</p>","title":"soft_to_ndim function"},{"location":"api/base/reshape_fns/#vectorbt.base.reshape_fns.tile","text":"<pre><code>tile(\n    arg,\n    n,\n    axis=1,\n    raw=False\n)\n</code></pre> <p>Repeat the whole <code>arg</code> <code>n</code> times along the specified axis.</p>","title":"tile function"},{"location":"api/base/reshape_fns/#vectorbt.base.reshape_fns.to_1d","text":"<pre><code>to_1d(\n    arg,\n    raw=False\n)\n</code></pre> <p>Reshape argument to one dimension. </p> <p>If <code>raw</code> is True, returns NumPy array. If 2-dim, will collapse along axis 1 (i.e., DataFrame with one column to Series).</p>","title":"to_1d function"},{"location":"api/base/reshape_fns/#vectorbt.base.reshape_fns.to_2d","text":"<pre><code>to_2d(\n    arg,\n    raw=False,\n    expand_axis=1\n)\n</code></pre> <p>Reshape argument to two dimensions. </p> <p>If <code>raw</code> is True, returns NumPy array. If 1-dim, will expand along axis 1 (i.e., Series to DataFrame with one column).</p>","title":"to_2d function"},{"location":"api/base/reshape_fns/#vectorbt.base.reshape_fns.to_any_array","text":"<pre><code>to_any_array(\n    arg,\n    raw=False\n)\n</code></pre> <p>Convert any array-like object to an array.</p> <p>Pandas objects are kept as-is.</p>","title":"to_any_array function"},{"location":"api/base/reshape_fns/#vectorbt.base.reshape_fns.to_dict","text":"<pre><code>to_dict(\n    arg,\n    orient='dict'\n)\n</code></pre> <p>Convert object to dict.</p>","title":"to_dict function"},{"location":"api/base/reshape_fns/#vectorbt.base.reshape_fns.to_pd_array","text":"<pre><code>to_pd_array(\n    arg\n)\n</code></pre> <p>Convert any array-like object to a pandas object.</p>","title":"to_pd_array function"},{"location":"api/base/reshape_fns/#vectorbt.base.reshape_fns.unstack_to_array","text":"<pre><code>unstack_to_array(\n    arg,\n    levels=None\n)\n</code></pre> <p>Reshape <code>arg</code> based on its multi-index into a multi-dimensional array.</p> <p>Use <code>levels</code> to specify what index levels to unstack and in which order.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from vectorbt.base.reshape_fns import unstack_to_array\n\n&gt;&gt;&gt; index = pd.MultiIndex.from_arrays(\n...     [[1, 1, 2, 2], [3, 4, 3, 4], ['a', 'b', 'c', 'd']])\n&gt;&gt;&gt; sr = pd.Series([1, 2, 3, 4], index=index)\n\n&gt;&gt;&gt; unstack_to_array(sr).shape\n(2, 2, 4)\n\n&gt;&gt;&gt; unstack_to_array(sr)\n[[[ 1. nan nan nan]\n [nan  2. nan nan]]\n\n [[nan nan  3. nan]\n[nan nan nan  4.]]]\n\n&gt;&gt;&gt; unstack_to_array(sr, levels=(2, 0))\n[[ 1. nan]\n [ 2. nan]\n [nan  3.]\n [nan  4.]]\n</code></pre>","title":"unstack_to_array function"},{"location":"api/base/reshape_fns/#vectorbt.base.reshape_fns.unstack_to_df","text":"<pre><code>unstack_to_df(\n    arg,\n    index_levels=None,\n    column_levels=None,\n    symmetric=False,\n    sort=True\n)\n</code></pre> <p>Reshape <code>arg</code> based on its multi-index into a DataFrame.</p> <p>Use <code>index_levels</code> to specify what index levels will form new index, and <code>column_levels</code>  for new columns. Set <code>symmetric</code> to True to make DataFrame symmetric.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from vectorbt.base.reshape_fns import unstack_to_df\n\n&gt;&gt;&gt; index = pd.MultiIndex.from_arrays(\n...     [[1, 1, 2, 2], [3, 4, 3, 4], ['a', 'b', 'c', 'd']],\n...     names=['x', 'y', 'z'])\n&gt;&gt;&gt; sr = pd.Series([1, 2, 3, 4], index=index)\n\n&gt;&gt;&gt; unstack_to_df(sr, index_levels=(0, 1), column_levels=2)\nz      a    b    c    d\nx y\n1 3  1.0  NaN  NaN  NaN\n1 4  NaN  2.0  NaN  NaN\n2 3  NaN  NaN  3.0  NaN\n2 4  NaN  NaN  NaN  4.0\n</code></pre>","title":"unstack_to_df function"},{"location":"api/base/reshape_fns/#vectorbt.base.reshape_fns.wrap_broadcasted","text":"<pre><code>wrap_broadcasted(\n    old_arg,\n    new_arg,\n    is_pd=False,\n    new_index=None,\n    new_columns=None\n)\n</code></pre> <p>If the newly brodcasted array was originally a pandas object, make it pandas object again  and assign it the newly broadcast index/columns.</p>","title":"wrap_broadcasted function"},{"location":"api/data/","text":"<p>Modules for working with data sources.</p>","title":"data"},{"location":"api/data/#sub-modules","text":"<ul> <li>vectorbt.data.base</li> <li>vectorbt.data.custom</li> <li>vectorbt.data.updater</li> </ul>","title":"Sub-modules"},{"location":"api/data/base/","text":"<p>Base data class.</p> <p>Class Data allows storing, downloading, updating, and managing data. It stores data as a dictionary of Series/DataFrames keyed by symbol, and makes sure that all pandas objects have the same index and columns by aligning them.</p>","title":"base"},{"location":"api/data/base/#downloading","text":"<p>Data can be downloaded by overriding the Data.download_symbol() class method. What Data does under the hood is iterating over all symbols and calling this method.</p> <p>Let's create a simple data class <code>RandomData</code> that generates price based on random returns with provided mean and standard deviation:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; class RandomData(vbt.Data):\n...     @classmethod\n...     def download_symbol(cls, symbol, mean=0., stdev=0.1, start_value=100,\n...                         start_dt='2021-01-01', end_dt='2021-01-10'):\n...         index = pd.date_range(start_dt, end_dt)\n...         rand_returns = np.random.normal(mean, stdev, size=len(index))\n...         rand_price = start_value + np.cumprod(rand_returns + 1)\n...         return pd.Series(rand_price, index=index)\n\n&gt;&gt;&gt; rand_data = RandomData.download(['RANDNX1', 'RANDNX2'])\n&gt;&gt;&gt; rand_data.get()\nsymbol         RANDNX1     RANDNX2\n2021-01-01  101.042956  100.920462\n2021-01-02  100.987327  100.956455\n2021-01-03  101.022333  100.955128\n2021-01-04  101.084243  100.791793\n2021-01-05  101.158619  100.781000\n2021-01-06  101.172688  100.786198\n2021-01-07  101.311609  100.848192\n2021-01-08  101.331841  100.861500\n2021-01-09  101.440530  100.944935\n2021-01-10  101.585689  100.993223\n</code></pre> <p>To provide different keyword arguments for different symbols, we can use symbol_dict:</p> <pre><code>&gt;&gt;&gt; start_value = vbt.symbol_dict({'RANDNX2': 200})\n&gt;&gt;&gt; rand_data = RandomData.download(['RANDNX1', 'RANDNX2'], start_value=start_value)\n&gt;&gt;&gt; rand_data.get()\nsymbol         RANDNX1     RANDNX2\n2021-01-01  101.083324  200.886078\n2021-01-02  101.113405  200.791934\n2021-01-03  101.169194  200.852877\n2021-01-04  101.164033  200.820111\n2021-01-05  101.326248  201.060448\n2021-01-06  101.394482  200.876984\n2021-01-07  101.494227  200.845519\n2021-01-08  101.422012  200.963474\n2021-01-09  101.493162  200.790369\n2021-01-10  101.606052  200.752296\n</code></pre> <p>In case two symbols have different index or columns, they are automatically aligned based on <code>missing_index</code> and <code>missing_columns</code> respectively (see <code>data</code> in settings):</p> <pre><code>&gt;&gt;&gt; start_dt = vbt.symbol_dict({'RANDNX2': '2021-01-03'})\n&gt;&gt;&gt; end_dt = vbt.symbol_dict({'RANDNX2': '2021-01-07'})\n&gt;&gt;&gt; rand_data = RandomData.download(\n...     ['RANDNX1', 'RANDNX2'], start_value=start_value,\n...     start_dt=start_dt, end_dt=end_dt)\n&gt;&gt;&gt; rand_data.get()\nsymbol         RANDNX1     RANDNX2\n2021-01-01  101.028054         NaN\n2021-01-02  101.032090         NaN\n2021-01-03  101.038531  200.936283\n2021-01-04  101.068265  200.926764\n2021-01-05  100.878492  200.898898\n2021-01-06  100.857444  200.922368\n2021-01-07  100.933123  200.987094\n2021-01-08  100.938034         NaN\n2021-01-09  101.044736         NaN\n2021-01-10  101.098133         NaN\n</code></pre>","title":"Downloading"},{"location":"api/data/base/#updating","text":"<p>Updating can be implemented by overriding the Data.update_symbol() instance method, which takes the same arguments as Data.download_symbol(). In contrast to the download method, the update method is an instance method and can access the data downloaded earlier. It can also access the keyword arguments initially passed to the download method, accessible under Data.download_kwargs. Those arguments can be used as default arguments and overriden by arguments passed directly to the update method, using merge_dicts().</p> <p>Let's define an update method that updates the latest data point and adds two news data points. Note that updating data always returns a new Data instance.</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; from vectorbt.utils.config import merge_dicts\n\n&gt;&gt;&gt; class RandomData(vbt.Data):\n...     @classmethod\n...     def download_symbol(cls, symbol, mean=0., stdev=0.1, start_value=100,\n...                         start_dt='2021-01-01', end_dt='2021-01-10'):\n...         index = pd.date_range(start_dt, end_dt)\n...         rand_returns = np.random.normal(mean, stdev, size=len(index))\n...         rand_price = start_value + np.cumprod(rand_returns + 1)\n...         return pd.Series(rand_price, index=index)\n...\n...     def update_symbol(self, symbol, **kwargs):\n...         download_kwargs = self.select_symbol_kwargs(symbol, self.download_kwargs)\n...         download_kwargs['start_dt'] = self.data[symbol].index[-1]\n...         download_kwargs['end_dt'] = download_kwargs['start_dt'] + timedelta(days=2)\n...         kwargs = merge_dicts(download_kwargs, kwargs)\n...         return self.download_symbol(symbol, **kwargs)\n\n&gt;&gt;&gt; rand_data = RandomData.download(['RANDNX1', 'RANDNX2'], end_dt='2021-01-05')\n&gt;&gt;&gt; rand_data.get()\nsymbol         RANDNX1     RANDNX2\n2021-01-01  100.956601  100.970865\n2021-01-02  100.919011  100.987026\n2021-01-03  101.062733  100.835376\n2021-01-04  100.960535  100.820817\n2021-01-05  100.834387  100.866549\n\n&gt;&gt;&gt; rand_data = rand_data.update()\n&gt;&gt;&gt; rand_data.get()\nsymbol         RANDNX1     RANDNX2\n2021-01-01  100.956601  100.970865\n2021-01-02  100.919011  100.987026\n2021-01-03  101.062733  100.835376\n2021-01-04  100.960535  100.820817\n2021-01-05  101.011255  100.887049 &lt; updated from here\n2021-01-06  101.004149  100.808410\n2021-01-07  101.023673  100.714583\n\n&gt;&gt;&gt; rand_data = rand_data.update()\n&gt;&gt;&gt; rand_data.get()\nsymbol         RANDNX1     RANDNX2\n2021-01-01  100.956601  100.970865\n2021-01-02  100.919011  100.987026\n2021-01-03  101.062733  100.835376\n2021-01-04  100.960535  100.820817\n2021-01-05  101.011255  100.887049\n2021-01-06  101.004149  100.808410\n2021-01-07  100.883400  100.874922 &lt; updated from here\n2021-01-08  101.011738  100.780188\n2021-01-09  100.912639  100.934014\n</code></pre>","title":"Updating"},{"location":"api/data/base/#merging","text":"<p>You can merge symbols from different Data instances either by subclassing Data and defining custom download and update methods, or by manually merging their data dicts into one data dict and passing it to the Data.from_data() class method.</p> <pre><code>&gt;&gt;&gt; rand_data1 = RandomData.download('RANDNX1', mean=0.2)\n&gt;&gt;&gt; rand_data2 = RandomData.download('RANDNX2', start_value=200, start_dt='2021-01-05')\n&gt;&gt;&gt; merged_data = vbt.Data.from_data(vbt.merge_dicts(rand_data1.data, rand_data2.data))\n&gt;&gt;&gt; merged_data.get()\nsymbol         RANDNX1     RANDNX2\n2021-01-01  101.160718         NaN\n2021-01-02  101.421020         NaN\n2021-01-03  101.959176         NaN\n2021-01-04  102.076670         NaN\n2021-01-05  102.447234  200.916198\n2021-01-06  103.195187  201.033907\n2021-01-07  103.595915  200.908229\n2021-01-08  104.332550  201.000497\n2021-01-09  105.159708  201.019157\n2021-01-10  106.729495  200.910210\n</code></pre>","title":"Merging"},{"location":"api/data/base/#indexing","text":"<p>Like any other class subclassing Wrapping, we can do pandas indexing on a Data instance, which forwards indexing operation to each Series/DataFrame:</p> <pre><code>&gt;&gt;&gt; rand_data.loc['2021-01-07':'2021-01-09']\n&lt;__main__.RandomData at 0x7fdba4e36198&gt;\n\n&gt;&gt;&gt; rand_data.loc['2021-01-07':'2021-01-09'].get()\nsymbol         RANDNX1     RANDNX2\n2021-01-07  100.883400  100.874922\n2021-01-08  101.011738  100.780188\n2021-01-09  100.912639  100.934014\n</code></pre>","title":"Indexing"},{"location":"api/data/base/#saving-and-loading","text":"<p>Like any other class subclassing Pickleable, we can save a Data instance to the disk with Pickleable.save() and load it with Pickleable.load():</p> <pre><code>&gt;&gt;&gt; rand_data.save('rand_data')\n&gt;&gt;&gt; rand_data = RandomData.load('rand_data')\n&gt;&gt;&gt; rand_data.get()\nsymbol         RANDNX1     RANDNX2\n2021-01-01  100.956601  100.970865\n2021-01-02  100.919011  100.987026\n2021-01-03  101.062733  100.835376\n2021-01-04  100.960535  100.820817\n2021-01-05  101.011255  100.887049\n2021-01-06  101.004149  100.808410\n2021-01-07  100.883400  100.874922\n2021-01-08  101.011738  100.780188\n2021-01-09  100.912639  100.934014\n</code></pre>","title":"Saving and loading"},{"location":"api/data/base/#stats","text":"<p>Hint</p> <p>See StatsBuilderMixin.stats() and Data.metrics.</p>  <pre><code>&gt;&gt;&gt; rand_data = RandomData.download(['RANDNX1', 'RANDNX2'])\n\n&gt;&gt;&gt; rand_data.stats(column='a')\nStart                   2021-01-01 00:00:00+00:00\nEnd                     2021-01-10 00:00:00+00:00\nPeriod                           10 days 00:00:00\nTotal Symbols                                   2\nNull Counts: RANDNX1                            0\nNull Counts: RANDNX2                            0\ndtype: object\n</code></pre> <p>StatsBuilderMixin.stats() also supports (re-)grouping:</p> <pre><code>&gt;&gt;&gt; rand_data.stats(group_by=True)\nStart                   2021-01-01 00:00:00+00:00\nEnd                     2021-01-10 00:00:00+00:00\nPeriod                           10 days 00:00:00\nTotal Symbols                                   2\nNull Counts: RANDNX1                            0\nNull Counts: RANDNX2                            0\nName: group, dtype: object\n</code></pre>","title":"Stats"},{"location":"api/data/base/#plots","text":"<p>Hint</p> <p>See PlotsBuilderMixin.plots() and Data.subplots.</p>  <p>Data class has a single subplot based on Data.plot():</p> <pre><code>&gt;&gt;&gt; rand_data.plots(settings=dict(base=100)).show_svg()\n</code></pre> <p></p>","title":"Plots"},{"location":"api/data/base/#vectorbt.data.base.Data","text":"<pre><code>Data(\n    wrapper,\n    data,\n    tz_localize,\n    tz_convert,\n    missing_index,\n    missing_columns,\n    download_kwargs,\n    **kwargs\n)\n</code></pre> <p>Class that downloads, updates, and manages data coming from a data source.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.config</li> <li>Wrapping.iloc</li> <li>Wrapping.indexing_kwargs</li> <li>Wrapping.loc</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> <li>Wrapping.self_aliases</li> <li>Wrapping.wrapper</li> <li>Wrapping.writeable_attrs</li> </ul> <p>Subclasses</p> <ul> <li>AlpacaData</li> <li>BinanceData</li> <li>CCXTData</li> <li>SyntheticData</li> <li>YFData</li> </ul>","title":"Data class"},{"location":"api/data/base/#vectorbt.data.base.Data.metrics","text":"<p>Metrics supported by Data.</p> <pre><code>Config({\n    \"start\": {\n        \"title\": \"Start\",\n        \"calc_func\": \"&lt;function Data.&lt;lambda&gt; at 0x7ff5209ffbf8&gt;\",\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"end\": {\n        \"title\": \"End\",\n        \"calc_func\": \"&lt;function Data.&lt;lambda&gt; at 0x7ff5209ffc80&gt;\",\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"period\": {\n        \"title\": \"Period\",\n        \"calc_func\": \"&lt;function Data.&lt;lambda&gt; at 0x7ff5209ffd08&gt;\",\n        \"apply_to_timedelta\": true,\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"total_symbols\": {\n        \"title\": \"Total Symbols\",\n        \"calc_func\": \"&lt;function Data.&lt;lambda&gt; at 0x7ff5209ffd90&gt;\",\n        \"agg_func\": null,\n        \"tags\": \"data\"\n    },\n    \"null_counts\": {\n        \"title\": \"Null Counts\",\n        \"calc_func\": \"&lt;function Data.&lt;lambda&gt; at 0x7ff5209ffe18&gt;\",\n        \"tags\": \"data\"\n    }\n})\n</code></pre> <p>Returns <code>Data._metrics</code>, which gets (deep) copied upon creation of each instance. Thus, changing this config won't affect the class.</p> <p>To change metrics, you can either change the config in-place, override this property, or overwrite the instance variable <code>Data._metrics</code>.</p>","title":"metrics class variable"},{"location":"api/data/base/#vectorbt.data.base.Data.subplots","text":"<p>Subplots supported by Data.</p> <pre><code>Config({\n    \"plot\": {\n        \"check_is_not_grouped\": true,\n        \"plot_func\": \"plot\",\n        \"pass_add_trace_kwargs\": true,\n        \"tags\": \"data\"\n    }\n})\n</code></pre> <p>Returns <code>Data._subplots</code>, which gets (deep) copied upon creation of each instance. Thus, changing this config won't affect the class.</p> <p>To change subplots, you can either change the config in-place, override this property, or overwrite the instance variable <code>Data._subplots</code>.</p>","title":"subplots class variable"},{"location":"api/data/base/#vectorbt.data.base.Data.align_columns","text":"<pre><code>Data.align_columns(\n    data,\n    missing='raise'\n)\n</code></pre> <p>Align data to have the same columns.</p> <p>See Data.align_index() for <code>missing</code>.</p>","title":"align_columns class method"},{"location":"api/data/base/#vectorbt.data.base.Data.align_index","text":"<pre><code>Data.align_index(\n    data,\n    missing='nan'\n)\n</code></pre> <p>Align data to have the same index.</p> <p>The argument <code>missing</code> accepts the following values:</p> <ul> <li>'nan': set missing data points to NaN</li> <li>'drop': remove missing data points</li> <li>'raise': raise an error</li> </ul>","title":"align_index class method"},{"location":"api/data/base/#vectorbt.data.base.Data.download","text":"<pre><code>Data.download(\n    symbols,\n    tz_localize=None,\n    tz_convert=None,\n    missing_index=None,\n    missing_columns=None,\n    wrapper_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Download data using Data.download_symbol().</p> <p>Args</p>  <code>symbols</code> :\u2002<code>hashable</code> or <code>sequence</code> of <code>hashable</code>  <p>One or multiple symbols.</p>  <p>Note</p> <p>Tuple is considered as a single symbol (since hashable).</p>   <code>tz_localize</code> :\u2002<code>any</code> See Data.from_data(). <code>tz_convert</code> :\u2002<code>any</code> See Data.from_data(). <code>missing_index</code> :\u2002<code>str</code> See Data.from_data(). <code>missing_columns</code> :\u2002<code>str</code> See Data.from_data(). <code>wrapper_kwargs</code> :\u2002<code>dict</code> See Data.from_data(). <code>**kwargs</code>  <p>Passed to Data.download_symbol().</p> <p>If two symbols require different keyword arguments, pass symbol_dict for each argument.</p>","title":"download class method"},{"location":"api/data/base/#vectorbt.data.base.Data.download_symbol","text":"<pre><code>Data.download_symbol(\n    symbol,\n    **kwargs\n)\n</code></pre> <p>Abstract method to download a symbol.</p>","title":"download_symbol class method"},{"location":"api/data/base/#vectorbt.data.base.Data.from_data","text":"<pre><code>Data.from_data(\n    data,\n    tz_localize=None,\n    tz_convert=None,\n    missing_index=None,\n    missing_columns=None,\n    wrapper_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Create a new Data instance from (aligned) data.</p> <p>Args</p>  <code>data</code> :\u2002<code>dict</code> Dictionary of array-like objects keyed by symbol. <code>tz_localize</code> :\u2002<code>timezone_like</code>  <p>If the index is tz-naive, convert to a timezone.</p> <p>See to_timezone().</p>  <code>tz_convert</code> :\u2002<code>timezone_like</code>  <p>Convert the index from one timezone to another.</p> <p>See to_timezone().</p>  <code>missing_index</code> :\u2002<code>str</code> See Data.align_index(). <code>missing_columns</code> :\u2002<code>str</code> See Data.align_columns(). <code>wrapper_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to ArrayWrapper. <code>**kwargs</code> Keyword arguments passed to the <code>__init__</code> method.  <p>For defaults, see <code>data</code> in settings.</p>","title":"from_data class method"},{"location":"api/data/base/#vectorbt.data.base.Data.select_symbol_kwargs","text":"<pre><code>Data.select_symbol_kwargs(\n    symbol,\n    kwargs\n)\n</code></pre> <p>Select keyword arguments belonging to <code>symbol</code>.</p>","title":"select_symbol_kwargs class method"},{"location":"api/data/base/#vectorbt.data.base.Data.data","text":"<p>Data dictionary keyed by symbol.</p>","title":"data property"},{"location":"api/data/base/#vectorbt.data.base.Data.download_kwargs","text":"<p>Keyword arguments initially passed to Data.download_symbol().</p>","title":"download_kwargs property"},{"location":"api/data/base/#vectorbt.data.base.Data.missing_columns","text":"<p><code>missing_columns</code> initially passed to Data.download_symbol().</p>","title":"missing_columns property"},{"location":"api/data/base/#vectorbt.data.base.Data.missing_index","text":"<p><code>missing_index</code> initially passed to Data.download_symbol().</p>","title":"missing_index property"},{"location":"api/data/base/#vectorbt.data.base.Data.plots_defaults","text":"<p>Defaults for PlotsBuilderMixin.plots().</p> <p>Merges PlotsBuilderMixin.plots_defaults and <code>data.plots</code> from settings.</p>","title":"plots_defaults property"},{"location":"api/data/base/#vectorbt.data.base.Data.stats_defaults","text":"<p>Defaults for StatsBuilderMixin.stats().</p> <p>Merges StatsBuilderMixin.stats_defaults and <code>data.stats</code> from settings.</p>","title":"stats_defaults property"},{"location":"api/data/base/#vectorbt.data.base.Data.symbols","text":"<p>List of symbols.</p>","title":"symbols property"},{"location":"api/data/base/#vectorbt.data.base.Data.tz_convert","text":"<p><code>tz_convert</code> initially passed to Data.download_symbol().</p>","title":"tz_convert property"},{"location":"api/data/base/#vectorbt.data.base.Data.tz_localize","text":"<p><code>tz_localize</code> initially passed to Data.download_symbol().</p>","title":"tz_localize property"},{"location":"api/data/base/#vectorbt.data.base.Data.concat","text":"<pre><code>Data.concat(\n    level_name='symbol'\n)\n</code></pre> <p>Return a dict of Series/DataFrames with symbols as columns, keyed by column name.</p>","title":"concat method"},{"location":"api/data/base/#vectorbt.data.base.Data.get","text":"<pre><code>Data.get(\n    column=None,\n    **kwargs\n)\n</code></pre> <p>Get column data.</p> <p>If one symbol, returns data for that symbol. If multiple symbols, performs concatenation first and returns a DataFrame if one column and a tuple of DataFrames if a list of columns passed.</p>","title":"get method"},{"location":"api/data/base/#vectorbt.data.base.Data.indexing_func","text":"<pre><code>Data.indexing_func(\n    pd_indexing_func,\n    **kwargs\n)\n</code></pre> <p>Perform indexing on Data.</p>","title":"indexing_func method"},{"location":"api/data/base/#vectorbt.data.base.Data.plot","text":"<pre><code>Data.plot(\n    column=None,\n    base=None,\n    **kwargs\n)\n</code></pre> <p>Plot orders.</p> <p>Args</p>  <code>column</code> :\u2002<code>str</code> Name of the column to plot. <code>base</code> :\u2002<code>float</code>  <p>Rebase all series of a column to a given intial base.</p>  <p>Note</p> <p>The column should contain prices.</p>   <code>kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to GenericAccessor.plot().  <p>Usage</p> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; start = '2021-01-01 UTC'  # crypto is in UTC\n&gt;&gt;&gt; end = '2021-06-01 UTC'\n&gt;&gt;&gt; data = vbt.YFData.download(['BTC-USD', 'ETH-USD', 'ADA-USD'], start=start, end=end)\n\n&gt;&gt;&gt; data.plot(column='Close', base=1)\n</code></pre> <p></p>","title":"plot method"},{"location":"api/data/base/#vectorbt.data.base.Data.update","text":"<pre><code>Data.update(\n    **kwargs\n)\n</code></pre> <p>Update the data using Data.update_symbol().</p> <p>Args</p>  <code>**kwargs</code>  <p>Passed to Data.update_symbol().</p> <p>If two symbols require different keyword arguments, pass symbol_dict for each argument.</p>    <p>Note</p> <p>Returns a new Data instance.</p>","title":"update method"},{"location":"api/data/base/#vectorbt.data.base.Data.update_symbol","text":"<pre><code>Data.update_symbol(\n    symbol,\n    **kwargs\n)\n</code></pre> <p>Abstract method to update a symbol.</p>","title":"update_symbol method"},{"location":"api/data/base/#vectorbt.data.base.MetaData","text":"<pre><code>MetaData(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Meta class that exposes a read-only class property <code>StatsBuilderMixin.metrics</code>.</p> <p>Superclasses</p> <ul> <li>MetaPlotsBuilderMixin</li> <li>MetaStatsBuilderMixin</li> <li><code>builtins.type</code></li> </ul> <p>Inherited members</p> <ul> <li>MetaPlotsBuilderMixin.subplots</li> <li>MetaStatsBuilderMixin.metrics</li> </ul>","title":"MetaData class"},{"location":"api/data/base/#vectorbt.data.base.symbol_dict","text":"<pre><code>symbol_dict(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Dict that contains symbols as keys.</p> <p>Superclasses</p> <ul> <li><code>builtins.dict</code></li> </ul>","title":"symbol_dict class"},{"location":"api/data/custom/","text":"<p>Custom data classes that subclass Data.</p>","title":"custom"},{"location":"api/data/custom/#vectorbt.data.custom.generate_gbm_paths","text":"<pre><code>generate_gbm_paths(\n    S0,\n    mu,\n    sigma,\n    T,\n    M,\n    I,\n    seed=None\n)\n</code></pre> <p>Generate using Geometric Brownian Motion (GBM).</p> <p>See https://stackoverflow.com/a/45036114/8141780.</p>","title":"generate_gbm_paths function"},{"location":"api/data/custom/#vectorbt.data.custom.AlpacaData","text":"<pre><code>AlpacaData(\n    wrapper,\n    data,\n    tz_localize,\n    tz_convert,\n    missing_index,\n    missing_columns,\n    download_kwargs,\n    **kwargs\n)\n</code></pre> <p><code>Data</code> for data coming from <code>alpaca-trade-api</code>.  Sign up for Alpaca API keys here: https://app.alpaca.markets/signup</p> <p>Usage</p> <ul> <li>Fetch the 1-minute data of the last 2 hours, wait 1 minute, and update:</li> </ul> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; alpaca_data = vbt.AlpacaData.download(\n...     \"AAPL\",\n...     start='2 hours ago UTC',\n...     end='15 minutes ago UTC',\n...     interval='1m'\n... )\n&gt;&gt;&gt; alpaca_data.get()\n                            Open      High       Low     Close      Volume\ntimestamp\n2021-12-27 14:04:00+00:00  177.0500  177.0500  177.0500  177.0500    1967\n2021-12-27 14:05:00+00:00  177.0500  177.0500  177.0300  177.0500    3218\n2021-12-27 14:06:00+00:00  177.0400  177.0400  177.0400  177.0400     873\n2021-12-27 14:07:00+00:00  177.0399  177.0400  177.0300  177.0400    1100\n2021-12-27 14:08:00+00:00  177.0400  177.0400  176.9700  176.9900   19943\n...                             ...       ...       ...       ...     ...\n2021-12-27 15:44:00+00:00  178.0000  178.0079  177.9311  177.9710  106395\n2021-12-27 15:45:00+00:00  177.9700  178.0564  177.9430  177.9600  153325\n2021-12-27 15:46:00+00:00  177.9500  178.0000  177.8289  177.8850  162778\n2021-12-27 15:47:00+00:00  177.8810  177.9600  177.8400  177.9515  123284\n2021-12-27 15:48:00+00:00  177.9600  178.0500  177.9600  178.0100  159700\n\n[105 rows x 5 columns]\n\n&gt;&gt;&gt; import time\n&gt;&gt;&gt; time.sleep(60)\n\n&gt;&gt;&gt; alpaca_data = alpaca_data.update()\n&gt;&gt;&gt; alpaca_data.get()\n                            Open      High       Low     Close      Volume\ntimestamp\n2021-12-27 14:04:00+00:00  177.0500  177.0500  177.0500  177.0500    1967\n2021-12-27 14:05:00+00:00  177.0500  177.0500  177.0300  177.0500    3218\n2021-12-27 14:06:00+00:00  177.0400  177.0400  177.0400  177.0400     873\n2021-12-27 14:07:00+00:00  177.0399  177.0400  177.0300  177.0400    1100\n2021-12-27 14:08:00+00:00  177.0400  177.0400  176.9700  176.9900   19943\n...                             ...       ...       ...       ...     ...\n2021-12-27 15:45:00+00:00  177.9700  178.0564  177.9430  177.9600  153325\n2021-12-27 15:46:00+00:00  177.9500  178.0000  177.8289  177.8850  162778\n2021-12-27 15:47:00+00:00  177.8810  177.9600  177.8400  177.9515  123284\n2021-12-27 15:48:00+00:00  177.9600  178.0500  177.9600  178.0100  159700\n2021-12-27 15:49:00+00:00  178.0100  178.0700  177.9700  178.0650  185037\n\n[106 rows x 5 columns]\n</code></pre> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Data</li> <li>Documented</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>Data.align_columns()</li> <li>Data.align_index()</li> <li>Data.concat()</li> <li>Data.config</li> <li>Data.data</li> <li>Data.download()</li> <li>Data.download_kwargs</li> <li>Data.from_data()</li> <li>Data.get()</li> <li>Data.iloc</li> <li>Data.indexing_func()</li> <li>Data.indexing_kwargs</li> <li>Data.loc</li> <li>Data.missing_columns</li> <li>Data.missing_index</li> <li>Data.plot()</li> <li>Data.plots_defaults</li> <li>Data.select_symbol_kwargs()</li> <li>Data.self_aliases</li> <li>Data.stats_defaults</li> <li>Data.symbols</li> <li>Data.tz_convert</li> <li>Data.tz_localize</li> <li>Data.update()</li> <li>Data.wrapper</li> <li>Data.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul>","title":"AlpacaData class"},{"location":"api/data/custom/#vectorbt.data.custom.AlpacaData.download_symbol","text":"<pre><code>AlpacaData.download_symbol(\n    symbol,\n    timeframe='1d',\n    start=0,\n    end='now UTC',\n    adjustment='all',\n    limit=500,\n    exchange='CBSE',\n    **kwargs\n)\n</code></pre> <p>Download the symbol.</p> <p>Args</p>  <code>symbol</code> :\u2002<code>str</code> Symbol. <code>timeframe</code> :\u2002<code>str</code> Timeframe of data. Must be integer multiple of 'm' (minute), 'h' (hour) or 'd' (day). i.e. '15m'  Note: Data from the latest 15 minutes is not available with a free data plan. See: https://alpaca.markets/data <code>start</code> :\u2002<code>any</code>  <p>Start datetime.</p> <p>See to_tzaware_datetime().</p>  <code>end</code> :\u2002<code>any</code>  <p>End datetime.</p> <p>See to_tzaware_datetime().</p>  <code>adjustment</code> :\u2002<code>str</code> Specifies the corporate action adjustment for the stocks.  Enum: <code>raw</code>, <code>split</code>, <code>dividend</code> or <code>all</code>. <code>limit</code> :\u2002<code>int</code> The maximum number of returned items. <code>exchange</code> :\u2002<code>str</code> For crypto symbols. Which exchange you wish to retrieve data from. Enum: <code>FTX</code>, <code>ERSX</code>, <code>CBSE</code>  <p>For defaults, see <code>data.alpaca</code> in settings.</p>","title":"download_symbol class method"},{"location":"api/data/custom/#vectorbt.data.custom.AlpacaData.update_symbol","text":"<pre><code>AlpacaData.update_symbol(\n    symbol,\n    **kwargs\n)\n</code></pre> <p>Update the symbol.</p> <p><code>**kwargs</code> will override keyword arguments passed to AlpacaData.download_symbol().</p>","title":"update_symbol method"},{"location":"api/data/custom/#vectorbt.data.custom.BinanceData","text":"<pre><code>BinanceData(\n    wrapper,\n    data,\n    tz_localize,\n    tz_convert,\n    missing_index,\n    missing_columns,\n    download_kwargs,\n    **kwargs\n)\n</code></pre> <p><code>Data</code> for data coming from <code>python-binance</code>.</p> <p>Usage</p> <ul> <li>Fetch the 1-minute data of the last 2 hours, wait 1 minute, and update:</li> </ul> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; binance_data = vbt.BinanceData.download(\n...     \"BTCUSDT\",\n...     start='2 hours ago UTC',\n...     end='now UTC',\n...     interval='1m'\n... )\n&gt;&gt;&gt; binance_data.get()\n2021-05-02 14:47:20.478000+00:00 - 2021-05-02 16:47:00+00:00: : 1it [00:00,  3.42it/s]\n                               Open      High       Low     Close     Volume  \\\nOpen time\n2021-05-02 14:48:00+00:00  56867.44  56913.57  56857.40  56913.56  28.709976\n2021-05-02 14:49:00+00:00  56913.56  56913.57  56845.94  56888.00  19.734841\n2021-05-02 14:50:00+00:00  56888.00  56947.32  56879.78  56934.71  23.150163\n...                             ...       ...       ...       ...        ...\n2021-05-02 16:45:00+00:00  56664.13  56666.77  56641.11  56644.03  40.852719\n2021-05-02 16:46:00+00:00  56644.02  56663.43  56605.17  56605.18  27.573654\n2021-05-02 16:47:00+00:00  56605.18  56657.55  56605.17  56627.12   7.719933\n\n                                                Close time  Quote volume  \\\nOpen time\n2021-05-02 14:48:00+00:00 2021-05-02 14:48:59.999000+00:00  1.633534e+06\n2021-05-02 14:49:00+00:00 2021-05-02 14:49:59.999000+00:00  1.122519e+06\n2021-05-02 14:50:00+00:00 2021-05-02 14:50:59.999000+00:00  1.317969e+06\n...                                                    ...           ...\n2021-05-02 16:45:00+00:00 2021-05-02 16:45:59.999000+00:00  2.314579e+06\n2021-05-02 16:46:00+00:00 2021-05-02 16:46:59.999000+00:00  1.561548e+06\n2021-05-02 16:47:00+00:00 2021-05-02 16:47:59.999000+00:00  4.371848e+05\n\n                           Number of trades  Taker base volume  \\\nOpen time\n2021-05-02 14:48:00+00:00               991          13.771152\n2021-05-02 14:49:00+00:00               816           5.981942\n2021-05-02 14:50:00+00:00              1086          10.813757\n...                                     ...                ...\n2021-05-02 16:45:00+00:00              1006          18.106933\n2021-05-02 16:46:00+00:00               916          14.869411\n2021-05-02 16:47:00+00:00               353           3.903321\n\n                           Taker quote volume\nOpen time\n2021-05-02 14:48:00+00:00        7.835391e+05\n2021-05-02 14:49:00+00:00        3.402170e+05\n2021-05-02 14:50:00+00:00        6.156418e+05\n...                                       ...\n2021-05-02 16:45:00+00:00        1.025892e+06\n2021-05-02 16:46:00+00:00        8.421173e+05\n2021-05-02 16:47:00+00:00        2.210323e+05\n\n[120 rows x 10 columns]\n\n&gt;&gt;&gt; import time\n&gt;&gt;&gt; time.sleep(60)\n\n&gt;&gt;&gt; binance_data = binance_data.update()\n&gt;&gt;&gt; binance_data.get()\n                               Open      High       Low     Close     Volume  \\\nOpen time\n2021-05-02 14:48:00+00:00  56867.44  56913.57  56857.40  56913.56  28.709976\n2021-05-02 14:49:00+00:00  56913.56  56913.57  56845.94  56888.00  19.734841\n2021-05-02 14:50:00+00:00  56888.00  56947.32  56879.78  56934.71  23.150163\n...                             ...       ...       ...       ...        ...\n2021-05-02 16:46:00+00:00  56644.02  56663.43  56605.17  56605.18  27.573654\n2021-05-02 16:47:00+00:00  56605.18  56657.55  56605.17  56625.76  14.615437\n2021-05-02 16:48:00+00:00  56625.75  56643.60  56614.32  56623.01   5.895843\n\n                                                Close time  Quote volume  \\\nOpen time\n2021-05-02 14:48:00+00:00 2021-05-02 14:48:59.999000+00:00  1.633534e+06\n2021-05-02 14:49:00+00:00 2021-05-02 14:49:59.999000+00:00  1.122519e+06\n2021-05-02 14:50:00+00:00 2021-05-02 14:50:59.999000+00:00  1.317969e+06\n...                                                    ...           ...\n2021-05-02 16:46:00+00:00 2021-05-02 16:46:59.999000+00:00  1.561548e+06\n2021-05-02 16:47:00+00:00 2021-05-02 16:47:59.999000+00:00  8.276017e+05\n2021-05-02 16:48:00+00:00 2021-05-02 16:48:59.999000+00:00  3.338702e+05\n\n                           Number of trades  Taker base volume  \\\nOpen time\n2021-05-02 14:48:00+00:00               991          13.771152\n2021-05-02 14:49:00+00:00               816           5.981942\n2021-05-02 14:50:00+00:00              1086          10.813757\n...                                     ...                ...\n2021-05-02 16:46:00+00:00               916          14.869411\n2021-05-02 16:47:00+00:00               912           7.778489\n2021-05-02 16:48:00+00:00               308           2.358130\n\n                           Taker quote volume\nOpen time\n2021-05-02 14:48:00+00:00        7.835391e+05\n2021-05-02 14:49:00+00:00        3.402170e+05\n2021-05-02 14:50:00+00:00        6.156418e+05\n...                                       ...\n2021-05-02 16:46:00+00:00        8.421173e+05\n2021-05-02 16:47:00+00:00        4.404362e+05\n2021-05-02 16:48:00+00:00        1.335474e+05\n\n[121 rows x 10 columns]\n</code></pre> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Data</li> <li>Documented</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>Data.align_columns()</li> <li>Data.align_index()</li> <li>Data.concat()</li> <li>Data.config</li> <li>Data.data</li> <li>Data.download_kwargs</li> <li>Data.from_data()</li> <li>Data.get()</li> <li>Data.iloc</li> <li>Data.indexing_func()</li> <li>Data.indexing_kwargs</li> <li>Data.loc</li> <li>Data.missing_columns</li> <li>Data.missing_index</li> <li>Data.plot()</li> <li>Data.plots_defaults</li> <li>Data.select_symbol_kwargs()</li> <li>Data.self_aliases</li> <li>Data.stats_defaults</li> <li>Data.symbols</li> <li>Data.tz_convert</li> <li>Data.tz_localize</li> <li>Data.update()</li> <li>Data.wrapper</li> <li>Data.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul>","title":"BinanceData class"},{"location":"api/data/custom/#vectorbt.data.custom.BinanceData.download","text":"<pre><code>BinanceData.download(\n    symbols,\n    client=None,\n    **kwargs\n)\n</code></pre> <p>Override Data.download() to instantiate a Binance client.</p>","title":"download class method"},{"location":"api/data/custom/#vectorbt.data.custom.BinanceData.download_symbol","text":"<pre><code>BinanceData.download_symbol(\n    symbol,\n    client=None,\n    interval='1d',\n    start=0,\n    end='now UTC',\n    delay=500,\n    limit=500,\n    show_progress=True,\n    tqdm_kwargs=None\n)\n</code></pre> <p>Download the symbol.</p> <p>Args</p>  <code>symbol</code> :\u2002<code>str</code> Symbol. <code>client</code> :\u2002<code>binance.client.Client</code> Binance client of type <code>binance.client.Client</code>. <code>interval</code> :\u2002<code>str</code>  <p>Kline interval.</p> <p>See <code>binance.enums</code>.</p>  <code>start</code> :\u2002<code>any</code>  <p>Start datetime.</p> <p>See to_tzaware_datetime().</p>  <code>end</code> :\u2002<code>any</code>  <p>End datetime.</p> <p>See to_tzaware_datetime().</p>  <code>delay</code> :\u2002<code>float</code> Time to sleep after each request (in milliseconds). <code>limit</code> :\u2002<code>int</code> The maximum number of returned items. <code>show_progress</code> :\u2002<code>bool</code> Whether to show the progress bar. <code>tqdm_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>tqdm</code>.  <p>For defaults, see <code>data.binance</code> in settings.</p>","title":"download_symbol class method"},{"location":"api/data/custom/#vectorbt.data.custom.BinanceData.update_symbol","text":"<pre><code>BinanceData.update_symbol(\n    symbol,\n    **kwargs\n)\n</code></pre> <p>Update the symbol.</p> <p><code>**kwargs</code> will override keyword arguments passed to BinanceData.download_symbol().</p>","title":"update_symbol method"},{"location":"api/data/custom/#vectorbt.data.custom.CCXTData","text":"<pre><code>CCXTData(\n    wrapper,\n    data,\n    tz_localize,\n    tz_convert,\n    missing_index,\n    missing_columns,\n    download_kwargs,\n    **kwargs\n)\n</code></pre> <p><code>Data</code> for data coming from <code>ccxt</code>.</p> <p>Usage</p> <ul> <li>Fetch the 1-minute data of the last 2 hours, wait 1 minute, and update:</li> </ul> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; ccxt_data = vbt.CCXTData.download(\n...     \"BTC/USDT\",\n...     start='2 hours ago UTC',\n...     end='now UTC',\n...     timeframe='1m'\n... )\n&gt;&gt;&gt; ccxt_data.get()\n2021-05-02 14:50:26.305000+00:00 - 2021-05-02 16:50:00+00:00: : 1it [00:00,  1.96it/s]\n                               Open      High       Low     Close     Volume\nOpen time\n2021-05-02 14:51:00+00:00  56934.70  56964.59  56910.00  56948.99  22.158319\n2021-05-02 14:52:00+00:00  56948.99  56999.00  56940.04  56977.62  46.958464\n2021-05-02 14:53:00+00:00  56977.61  56987.09  56882.98  56885.42  27.752200\n...                             ...       ...       ...       ...        ...\n2021-05-02 16:48:00+00:00  56625.75  56643.60  56595.47  56596.01  15.452510\n2021-05-02 16:49:00+00:00  56596.00  56664.14  56596.00  56640.35  12.777475\n2021-05-02 16:50:00+00:00  56640.35  56675.82  56640.35  56670.65   6.882321\n\n[120 rows x 5 columns]\n\n&gt;&gt;&gt; import time\n&gt;&gt;&gt; time.sleep(60)\n\n&gt;&gt;&gt; ccxt_data = ccxt_data.update()\n&gt;&gt;&gt; ccxt_data.get()\n                               Open      High       Low     Close     Volume\nOpen time\n2021-05-02 14:51:00+00:00  56934.70  56964.59  56910.00  56948.99  22.158319\n2021-05-02 14:52:00+00:00  56948.99  56999.00  56940.04  56977.62  46.958464\n2021-05-02 14:53:00+00:00  56977.61  56987.09  56882.98  56885.42  27.752200\n...                             ...       ...       ...       ...        ...\n2021-05-02 16:49:00+00:00  56596.00  56664.14  56596.00  56640.35  12.777475\n2021-05-02 16:50:00+00:00  56640.35  56689.99  56640.35  56678.33  14.610231\n2021-05-02 16:51:00+00:00  56678.33  56688.99  56636.89  56653.42  11.647158\n\n[121 rows x 5 columns]\n</code></pre> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Data</li> <li>Documented</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>Data.align_columns()</li> <li>Data.align_index()</li> <li>Data.concat()</li> <li>Data.config</li> <li>Data.data</li> <li>Data.download()</li> <li>Data.download_kwargs</li> <li>Data.from_data()</li> <li>Data.get()</li> <li>Data.iloc</li> <li>Data.indexing_func()</li> <li>Data.indexing_kwargs</li> <li>Data.loc</li> <li>Data.missing_columns</li> <li>Data.missing_index</li> <li>Data.plot()</li> <li>Data.plots_defaults</li> <li>Data.select_symbol_kwargs()</li> <li>Data.self_aliases</li> <li>Data.stats_defaults</li> <li>Data.symbols</li> <li>Data.tz_convert</li> <li>Data.tz_localize</li> <li>Data.update()</li> <li>Data.wrapper</li> <li>Data.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul>","title":"CCXTData class"},{"location":"api/data/custom/#vectorbt.data.custom.CCXTData.download_symbol","text":"<pre><code>CCXTData.download_symbol(\n    symbol,\n    exchange='binance',\n    config=None,\n    timeframe='1d',\n    start=0,\n    end='now UTC',\n    delay=None,\n    limit=500,\n    retries=3,\n    show_progress=True,\n    params=None,\n    tqdm_kwargs=None\n)\n</code></pre> <p>Download the symbol.</p> <p>Args</p>  <code>symbol</code> :\u2002<code>str</code> Symbol. <code>exchange</code> :\u2002<code>str</code> or <code>object</code> Exchange identifier or an exchange object of type <code>ccxt.base.exchange.Exchange</code>. <code>config</code> :\u2002<code>dict</code>  <p>Config passed to the exchange upon instantiation.</p> <p>Will raise an exception if exchange has been already instantiated.</p>  <code>timeframe</code> :\u2002<code>str</code> Timeframe supported by the exchange. <code>start</code> :\u2002<code>any</code>  <p>Start datetime.</p> <p>See to_tzaware_datetime().</p>  <code>end</code> :\u2002<code>any</code>  <p>End datetime.</p> <p>See to_tzaware_datetime().</p>  <code>delay</code> :\u2002<code>float</code>  <p>Time to sleep after each request (in milliseconds).</p>  <p>Note</p> <p>Use only if <code>enableRateLimit</code> is not set.</p>   <code>limit</code> :\u2002<code>int</code> The maximum number of returned items. <code>retries</code> :\u2002<code>int</code> The number of retries on failure to fetch data. <code>show_progress</code> :\u2002<code>bool</code> Whether to show the progress bar. <code>tqdm_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>tqdm</code>. <code>params</code> :\u2002<code>dict</code> Exchange-specific key-value parameters.  <p>For defaults, see <code>data.ccxt</code> in settings.</p>","title":"download_symbol class method"},{"location":"api/data/custom/#vectorbt.data.custom.CCXTData.update_symbol","text":"<pre><code>CCXTData.update_symbol(\n    symbol,\n    **kwargs\n)\n</code></pre> <p>Update the symbol.</p> <p><code>**kwargs</code> will override keyword arguments passed to CCXTData.download_symbol().</p>","title":"update_symbol method"},{"location":"api/data/custom/#vectorbt.data.custom.GBMData","text":"<pre><code>GBMData(\n    wrapper,\n    data,\n    tz_localize,\n    tz_convert,\n    missing_index,\n    missing_columns,\n    download_kwargs,\n    **kwargs\n)\n</code></pre> <p>SyntheticData for data generated using Geometric Brownian Motion (GBM).</p> <p>Usage</p> <ul> <li>See the example under BinanceData.</li> </ul> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; gbm_data = vbt.GBMData.download('GBM', start='2 hours ago', end='now', freq='1min', seed=42)\n&gt;&gt;&gt; gbm_data.get()\n2021-05-02 14:14:15.182089+00:00    102.386605\n2021-05-02 14:15:15.182089+00:00    101.554203\n2021-05-02 14:16:15.182089+00:00    104.765771\n...                                        ...\n2021-05-02 16:12:15.182089+00:00     51.614839\n2021-05-02 16:13:15.182089+00:00     53.525376\n2021-05-02 16:14:15.182089+00:00     55.615250\nFreq: T, Length: 121, dtype: float64\n\n&gt;&gt;&gt; import time\n&gt;&gt;&gt; time.sleep(60)\n\n&gt;&gt;&gt; gbm_data = gbm_data.update()\n&gt;&gt;&gt; gbm_data.get()\n2021-05-02 14:14:15.182089+00:00    102.386605\n2021-05-02 14:15:15.182089+00:00    101.554203\n2021-05-02 14:16:15.182089+00:00    104.765771\n...                                        ...\n2021-05-02 16:13:15.182089+00:00     53.525376\n2021-05-02 16:14:15.182089+00:00     51.082220\n2021-05-02 16:15:15.182089+00:00     54.725304\nFreq: T, Length: 122, dtype: float64\n</code></pre> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Data</li> <li>Documented</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>SyntheticData</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>Data.align_columns()</li> <li>Data.align_index()</li> <li>Data.concat()</li> <li>Data.download()</li> <li>Data.from_data()</li> <li>Data.get()</li> <li>Data.indexing_func()</li> <li>Data.plot()</li> <li>Data.select_symbol_kwargs()</li> <li>Data.update()</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>SyntheticData.config</li> <li>SyntheticData.data</li> <li>SyntheticData.download_kwargs</li> <li>SyntheticData.download_symbol()</li> <li>SyntheticData.iloc</li> <li>SyntheticData.indexing_kwargs</li> <li>SyntheticData.loc</li> <li>SyntheticData.missing_columns</li> <li>SyntheticData.missing_index</li> <li>SyntheticData.plots_defaults</li> <li>SyntheticData.self_aliases</li> <li>SyntheticData.stats_defaults</li> <li>SyntheticData.symbols</li> <li>SyntheticData.tz_convert</li> <li>SyntheticData.tz_localize</li> <li>SyntheticData.wrapper</li> <li>SyntheticData.writeable_attrs</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul>","title":"GBMData class"},{"location":"api/data/custom/#vectorbt.data.custom.GBMData.generate_symbol","text":"<pre><code>GBMData.generate_symbol(\n    symbol,\n    index,\n    S0=100.0,\n    mu=0.0,\n    sigma=0.05,\n    T=None,\n    I=1,\n    seed=None\n)\n</code></pre> <p>Generate the symbol using generate_gbm_paths().</p> <p>Args</p>  <code>symbol</code> :\u2002<code>str</code> Symbol. <code>index</code> :\u2002<code>pd.Index</code> Pandas index. <code>S0</code> :\u2002<code>float</code>  <p>Value at time 0.</p> <p>Does not appear as the first value in the output data.</p>  <code>mu</code> :\u2002<code>float</code> Drift, or mean of the percentage change. <code>sigma</code> :\u2002<code>float</code> Standard deviation of the percentage change. <code>T</code> :\u2002<code>int</code>  <p>Number of time steps.</p> <p>Defaults to the length of <code>index</code>.</p>  <code>I</code> :\u2002<code>int</code> Number of generated paths (columns in our case). <code>seed</code> :\u2002<code>int</code> Set seed to make the results deterministic.","title":"generate_symbol class method"},{"location":"api/data/custom/#vectorbt.data.custom.GBMData.update_symbol","text":"<pre><code>GBMData.update_symbol(\n    symbol,\n    **kwargs\n)\n</code></pre> <p>Update the symbol.</p> <p><code>**kwargs</code> will override keyword arguments passed to SyntheticData.download_symbol().</p>","title":"update_symbol method"},{"location":"api/data/custom/#vectorbt.data.custom.SyntheticData","text":"<pre><code>SyntheticData(\n    wrapper,\n    data,\n    tz_localize,\n    tz_convert,\n    missing_index,\n    missing_columns,\n    download_kwargs,\n    **kwargs\n)\n</code></pre> <p><code>Data</code> for synthetically generated data.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Data</li> <li>Documented</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>Data.align_columns()</li> <li>Data.align_index()</li> <li>Data.concat()</li> <li>Data.config</li> <li>Data.data</li> <li>Data.download()</li> <li>Data.download_kwargs</li> <li>Data.from_data()</li> <li>Data.get()</li> <li>Data.iloc</li> <li>Data.indexing_func()</li> <li>Data.indexing_kwargs</li> <li>Data.loc</li> <li>Data.missing_columns</li> <li>Data.missing_index</li> <li>Data.plot()</li> <li>Data.plots_defaults</li> <li>Data.select_symbol_kwargs()</li> <li>Data.self_aliases</li> <li>Data.stats_defaults</li> <li>Data.symbols</li> <li>Data.tz_convert</li> <li>Data.tz_localize</li> <li>Data.update()</li> <li>Data.wrapper</li> <li>Data.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li>GBMData</li> </ul>","title":"SyntheticData class"},{"location":"api/data/custom/#vectorbt.data.custom.SyntheticData.download_symbol","text":"<pre><code>SyntheticData.download_symbol(\n    symbol,\n    start=0,\n    end='now',\n    freq=None,\n    date_range_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Download the symbol.</p> <p>Generates datetime index and passes it to SyntheticData.generate_symbol() to fill the Series/DataFrame with generated data.</p>","title":"download_symbol class method"},{"location":"api/data/custom/#vectorbt.data.custom.SyntheticData.generate_symbol","text":"<pre><code>SyntheticData.generate_symbol(\n    symbol,\n    index,\n    **kwargs\n)\n</code></pre> <p>Abstract method to generate a symbol.</p>","title":"generate_symbol class method"},{"location":"api/data/custom/#vectorbt.data.custom.SyntheticData.update_symbol","text":"<pre><code>SyntheticData.update_symbol(\n    symbol,\n    **kwargs\n)\n</code></pre> <p>Update the symbol.</p> <p><code>**kwargs</code> will override keyword arguments passed to SyntheticData.download_symbol().</p>","title":"update_symbol method"},{"location":"api/data/custom/#vectorbt.data.custom.YFData","text":"<pre><code>YFData(\n    wrapper,\n    data,\n    tz_localize,\n    tz_convert,\n    missing_index,\n    missing_columns,\n    download_kwargs,\n    **kwargs\n)\n</code></pre> <p><code>Data</code> for data coming from <code>yfinance</code>.</p> <p>Stocks are usually in the timezone \"+0500\" and cryptocurrencies in UTC.</p>  <p>Warning</p> <p>Data coming from Yahoo is not the most stable data out there. Yahoo may manipulate data how they want, add noise, return missing data points (see volume in the example below), etc. It's only used in vectorbt for demonstration purposes.</p>  <p>Usage</p> <ul> <li>Fetch the business day except the last 5 minutes of trading data, and then update with the missing 5 minutes:</li> </ul> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; yf_data = vbt.YFData.download(\n...     \"TSLA\",\n...     start='2021-04-12 09:30:00 -0400',\n...     end='2021-04-12 09:35:00 -0400',\n...     interval='1m'\n... )\n&gt;&gt;&gt; yf_data.get())\n                                 Open        High         Low       Close  \\\nDatetime\n2021-04-12 13:30:00+00:00  685.080017  685.679993  684.765015  685.679993\n2021-04-12 13:31:00+00:00  684.625000  686.500000  684.010010  685.500000\n2021-04-12 13:32:00+00:00  685.646790  686.820007  683.190002  686.455017\n2021-04-12 13:33:00+00:00  686.455017  687.000000  685.000000  685.565002\n2021-04-12 13:34:00+00:00  685.690002  686.400024  683.200012  683.715027\n\n                           Volume  Dividends  Stock Splits\nDatetime\n2021-04-12 13:30:00+00:00       0          0             0\n2021-04-12 13:31:00+00:00  152276          0             0\n2021-04-12 13:32:00+00:00  168363          0             0\n2021-04-12 13:33:00+00:00  129607          0             0\n2021-04-12 13:34:00+00:00  134620          0             0\n\n&gt;&gt;&gt; yf_data = yf_data.update(end='2021-04-12 09:40:00 -0400')\n&gt;&gt;&gt; yf_data.get()\n                                 Open        High         Low       Close  \\\nDatetime\n2021-04-12 13:30:00+00:00  685.080017  685.679993  684.765015  685.679993\n2021-04-12 13:31:00+00:00  684.625000  686.500000  684.010010  685.500000\n2021-04-12 13:32:00+00:00  685.646790  686.820007  683.190002  686.455017\n2021-04-12 13:33:00+00:00  686.455017  687.000000  685.000000  685.565002\n2021-04-12 13:34:00+00:00  685.690002  686.400024  683.200012  683.715027\n2021-04-12 13:35:00+00:00  683.604980  684.340027  682.760071  684.135010\n2021-04-12 13:36:00+00:00  684.130005  686.640015  683.333984  686.563904\n2021-04-12 13:37:00+00:00  686.530029  688.549988  686.000000  686.635010\n2021-04-12 13:38:00+00:00  686.593201  689.500000  686.409973  688.179993\n2021-04-12 13:39:00+00:00  688.500000  689.347595  687.710022  688.070007\n\n                           Volume  Dividends  Stock Splits\nDatetime\n2021-04-12 13:30:00+00:00       0          0             0\n2021-04-12 13:31:00+00:00  152276          0             0\n2021-04-12 13:32:00+00:00  168363          0             0\n2021-04-12 13:33:00+00:00  129607          0             0\n2021-04-12 13:34:00+00:00       0          0             0\n2021-04-12 13:35:00+00:00  110500          0             0\n2021-04-12 13:36:00+00:00  148384          0             0\n2021-04-12 13:37:00+00:00  243851          0             0\n2021-04-12 13:38:00+00:00  203569          0             0\n2021-04-12 13:39:00+00:00   93308          0             0\n</code></pre> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Data</li> <li>Documented</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>Data.align_columns()</li> <li>Data.align_index()</li> <li>Data.concat()</li> <li>Data.config</li> <li>Data.data</li> <li>Data.download()</li> <li>Data.download_kwargs</li> <li>Data.from_data()</li> <li>Data.get()</li> <li>Data.iloc</li> <li>Data.indexing_func()</li> <li>Data.indexing_kwargs</li> <li>Data.loc</li> <li>Data.missing_columns</li> <li>Data.missing_index</li> <li>Data.plot()</li> <li>Data.plots_defaults</li> <li>Data.select_symbol_kwargs()</li> <li>Data.self_aliases</li> <li>Data.stats_defaults</li> <li>Data.symbols</li> <li>Data.tz_convert</li> <li>Data.tz_localize</li> <li>Data.update()</li> <li>Data.wrapper</li> <li>Data.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul>","title":"YFData class"},{"location":"api/data/custom/#vectorbt.data.custom.YFData.download_symbol","text":"<pre><code>YFData.download_symbol(\n    symbol,\n    period='max',\n    start=None,\n    end=None,\n    **kwargs\n)\n</code></pre> <p>Download the symbol.</p> <p>Args</p>  <code>symbol</code> :\u2002<code>str</code> Symbol. <code>period</code> :\u2002<code>str</code> Period. <code>start</code> :\u2002<code>any</code>  <p>Start datetime.</p> <p>See to_tzaware_datetime().</p>  <code>end</code> :\u2002<code>any</code>  <p>End datetime.</p> <p>See to_tzaware_datetime().</p>  <code>**kwargs</code> Keyword arguments passed to <code>yfinance.base.TickerBase.history</code>.","title":"download_symbol class method"},{"location":"api/data/custom/#vectorbt.data.custom.YFData.update_symbol","text":"<pre><code>YFData.update_symbol(\n    symbol,\n    **kwargs\n)\n</code></pre> <p>Update the symbol.</p> <p><code>**kwargs</code> will override keyword arguments passed to YFData.download_symbol().</p>","title":"update_symbol method"},{"location":"api/data/updater/","text":"<p>Class for scheduling data updates.</p>","title":"updater"},{"location":"api/data/updater/#vectorbt.data.updater.DataUpdater","text":"<pre><code>DataUpdater(\n    data,\n    schedule_manager=None,\n    **kwargs\n)\n</code></pre> <p>Class for scheduling data updates.</p> <p>Usage</p> <ul> <li>Update in the foreground:</li> </ul> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; class MyDataUpdater(vbt.DataUpdater):\n...     def __init__(self, *args, **kwargs):\n...         super().__init__(*args, **kwargs)\n...         self.update_count = 0\n...\n...     def update(self, count_limit=None):\n...         prev_index_len = len(self.data.wrapper.index)\n...         super().update()\n...         new_index_len = len(self.data.wrapper.index)\n...         print(f\"Data updated with {new_index_len - prev_index_len} data points\")\n...         self.update_count += 1\n...         if count_limit is not None and self.update_count &gt;= count_limit:\n...             raise vbt.CancelledError\n\n&gt;&gt;&gt; data = vbt.GBMData.download('SYMBOL', start='1 minute ago', freq='1s')\n&gt;&gt;&gt; my_updater = MyDataUpdater(data)\n&gt;&gt;&gt; my_updater.update_every(count_limit=10)\nData updated with 1 data points\nData updated with 1 data points\nData updated with 1 data points\nData updated with 1 data points\nData updated with 1 data points\nData updated with 1 data points\nData updated with 1 data points\nData updated with 1 data points\nData updated with 1 data points\nData updated with 1 data points\n\n&gt;&gt;&gt; my_updater.data.get()\n2021-05-02 16:53:51.755347+00:00    96.830482\n2021-05-02 16:53:52.755347+00:00    94.481883\n2021-05-02 16:53:53.755347+00:00    94.327835\n2021-05-02 16:53:54.755347+00:00    90.178038\n2021-05-02 16:53:55.755347+00:00    88.260168\n                                      ...\n2021-05-02 16:54:57.755347+00:00    99.342590\n2021-05-02 16:54:58.755347+00:00    94.872893\n2021-05-02 16:54:59.755347+00:00    93.212823\n2021-05-02 16:55:00.755347+00:00    95.199882\n2021-05-02 16:55:01.755347+00:00    93.070532\nFreq: S, Length: 71, dtype: float64\n</code></pre> <ul> <li>Update in the background:</li> </ul> <pre><code>&gt;&gt;&gt; my_updater = MyDataUpdater(my_updater.data)\n&gt;&gt;&gt; my_updater.update_every(in_background=True, count_limit=10)\nData updated with 1 data points\nData updated with 1 data points\nData updated with 1 data points\nData updated with 1 data points\nData updated with 1 data points\nData updated with 1 data points\nData updated with 1 data points\nData updated with 1 data points\nData updated with 1 data points\nData updated with 1 data points\n\n&gt;&gt;&gt; my_updater.data.get()\n2021-05-02 16:53:51.755347+00:00    96.830482\n2021-05-02 16:53:52.755347+00:00    94.481883\n2021-05-02 16:53:53.755347+00:00    94.327835\n2021-05-02 16:53:54.755347+00:00    90.178038\n2021-05-02 16:53:55.755347+00:00    88.260168\n                                      ...\n2021-05-02 16:55:07.755347+00:00    94.502885\n2021-05-02 16:55:08.755347+00:00    94.823707\n2021-05-02 16:55:09.755347+00:00    92.570025\n2021-05-02 16:55:10.755347+00:00    84.239018\n2021-05-02 16:55:11.755347+00:00    81.294486\nFreq: S, Length: 81, dtype: float64\n</code></pre> <p>Superclasses</p> <ul> <li>Configured</li> <li>Documented</li> <li>Pickleable</li> </ul> <p>Inherited members</p> <ul> <li>Configured.config</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>Configured.writeable_attrs</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> </ul>","title":"DataUpdater class"},{"location":"api/data/updater/#vectorbt.data.updater.DataUpdater.data","text":"<p>Data instance.</p> <p>See Data.</p>","title":"data property"},{"location":"api/data/updater/#vectorbt.data.updater.DataUpdater.schedule_manager","text":"<p>Schedule manager instance.</p> <p>See ScheduleManager.</p>","title":"schedule_manager property"},{"location":"api/data/updater/#vectorbt.data.updater.DataUpdater.update","text":"<pre><code>DataUpdater.update(\n    **kwargs\n)\n</code></pre> <p>Method that updates data.</p> <p>Override to do pre- and postprocessing.</p> <p>To stop this method from running again, raise CancelledError.</p>","title":"update method"},{"location":"api/data/updater/#vectorbt.data.updater.DataUpdater.update_every","text":"<pre><code>DataUpdater.update_every(\n    *args,\n    to=None,\n    tags=None,\n    in_background=False,\n    start_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Schedule DataUpdater.update().</p> <p>For <code>*args</code>, <code>to</code> and <code>tags</code>, see ScheduleManager.every().</p> <p>If <code>in_background</code> is set to True, starts in the background as an <code>asyncio</code> task. The task can be stopped with ScheduleManager.stop().</p> <p><code>**kwargs</code> are passed to DataUpdater.update().</p>","title":"update_every method"},{"location":"api/generic/","text":"<p>Modules for working with any time series.</p> <p>In contrast to the vectorbt.base sub-package, focuses on the data itself.</p>","title":"generic"},{"location":"api/generic/#sub-modules","text":"<ul> <li>vectorbt.generic.accessors</li> <li>vectorbt.generic.decorators</li> <li>vectorbt.generic.drawdowns</li> <li>vectorbt.generic.enums</li> <li>vectorbt.generic.nb</li> <li>vectorbt.generic.plots_builder</li> <li>vectorbt.generic.plotting</li> <li>vectorbt.generic.ranges</li> <li>vectorbt.generic.splitters</li> <li>vectorbt.generic.stats_builder</li> </ul>","title":"Sub-modules"},{"location":"api/generic/accessors/","text":"<p>Custom pandas accessors for generic data.</p> <p>Methods can be accessed as follows:</p> <ul> <li>GenericSRAccessor -&gt; <code>pd.Series.vbt.*</code></li> <li>GenericDFAccessor -&gt; <code>pd.DataFrame.vbt.*</code></li> </ul> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; # vectorbt.generic.accessors.GenericAccessor.rolling_mean\n&gt;&gt;&gt; pd.Series([1, 2, 3, 4]).vbt.rolling_mean(2)\n0    NaN\n1    1.5\n2    2.5\n3    3.5\ndtype: float64\n</code></pre> <p>The accessors inherit vectorbt.base.accessors and are inherited by more specialized accessors, such as vectorbt.signals.accessors and vectorbt.returns.accessors.</p>  <p>Note</p> <p>Grouping is only supported by the methods that accept the <code>group_by</code> argument.</p> <p>Accessors do not utilize caching.</p>  <p>Run for the examples below</p> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from numba import njit\n&gt;&gt;&gt; from datetime import datetime, timedelta\n\n&gt;&gt;&gt; df = pd.DataFrame({\n...     'a': [1, 2, 3, 4, 5],\n...     'b': [5, 4, 3, 2, 1],\n...     'c': [1, 2, 3, 2, 1]\n... }, index=pd.Index([\n...     datetime(2020, 1, 1),\n...     datetime(2020, 1, 2),\n...     datetime(2020, 1, 3),\n...     datetime(2020, 1, 4),\n...     datetime(2020, 1, 5)\n... ]))\n&gt;&gt;&gt; df\n            a  b  c\n2020-01-01  1  5  1\n2020-01-02  2  4  2\n2020-01-03  3  3  3\n2020-01-04  4  2  2\n2020-01-05  5  1  1\n\n&gt;&gt;&gt; index = [datetime(2020, 1, 1) + timedelta(days=i) for i in range(10)]\n&gt;&gt;&gt; sr = pd.Series(np.arange(len(index)), index=index)\n&gt;&gt;&gt; sr\n2020-01-01    0\n2020-01-02    1\n2020-01-03    2\n2020-01-04    3\n2020-01-05    4\n2020-01-06    5\n2020-01-07    6\n2020-01-08    7\n2020-01-09    8\n2020-01-10    9\ndtype: int64\n</code></pre>","title":"accessors"},{"location":"api/generic/accessors/#stats","text":"<p>Hint</p> <p>See StatsBuilderMixin.stats() and GenericAccessor.metrics.</p>  <pre><code>&gt;&gt;&gt; df2 = pd.DataFrame({\n...     'a': [np.nan, 2, 3],\n...     'b': [4, np.nan, 5],\n...     'c': [6, 7, np.nan]\n... }, index=['x', 'y', 'z'])\n\n&gt;&gt;&gt; df2.vbt(freq='d').stats(column='a')\nStart                      x\nEnd                        z\nPeriod       3 days 00:00:00\nCount                      2\nMean                     2.5\nStd                 0.707107\nMin                      2.0\nMedian                   2.5\nMax                      3.0\nMin Index                  y\nMax Index                  z\nName: a, dtype: object\n</code></pre>","title":"Stats"},{"location":"api/generic/accessors/#mapping","text":"<p>Mapping can be set both in GenericAccessor (preferred) and StatsBuilderMixin.stats():</p> <pre><code>&gt;&gt;&gt; mapping = {x: 'test_' + str(x) for x in pd.unique(df2.values.flatten())}\n&gt;&gt;&gt; df2.vbt(freq='d', mapping=mapping).stats(column='a')\nStart                                   x\nEnd                                     z\nPeriod                    3 days 00:00:00\nCount                                   2\nValue Counts: test_2.0                  1\nValue Counts: test_3.0                  1\nValue Counts: test_4.0                  0\nValue Counts: test_5.0                  0\nValue Counts: test_6.0                  0\nValue Counts: test_7.0                  0\nValue Counts: test_nan                  1\nName: a, dtype: object\n\n&gt;&gt;&gt; df2.vbt(freq='d').stats(column='a', settings=dict(mapping=mapping))\nUserWarning: Changing the mapping will create a copy of this object.\nConsider setting it upon object creation to re-use existing cache.\n\nStart                                   x\nEnd                                     z\nPeriod                    3 days 00:00:00\nCount                                   2\nValue Counts: test_2.0                  1\nValue Counts: test_3.0                  1\nValue Counts: test_4.0                  0\nValue Counts: test_5.0                  0\nValue Counts: test_6.0                  0\nValue Counts: test_7.0                  0\nValue Counts: test_nan                  1\nName: a, dtype: object\n</code></pre> <p>Selecting a column before calling <code>stats</code> will consider uniques from this column only:</p> <pre><code>&gt;&gt;&gt; df2['a'].vbt(freq='d', mapping=mapping).stats()\nStart                                   x\nEnd                                     z\nPeriod                    3 days 00:00:00\nCount                                   2\nValue Counts: test_2.0                  1\nValue Counts: test_3.0                  1\nValue Counts: test_nan                  1\nName: a, dtype: object\n</code></pre> <p>To include all keys from <code>mapping</code>, pass <code>incl_all_keys=True</code>:</p>    <p>df2['a'].vbt(freq='d', mapping=mapping).stats(settings=dict(incl_all_keys=True)) Start                                   x End                                     z Period                    3 days 00:00:00 Count                                   2 Value Counts: test_2.0                  1 Value Counts: test_3.0                  1 Value Counts: test_4.0                  0 Value Counts: test_5.0                  0 Value Counts: test_6.0                  0 Value Counts: test_7.0                  0 Value Counts: test_nan                  1 Name: a, dtype: object <pre><code>`GenericAccessor.stats` also supports (re-)grouping:\n\n```pycon\n&gt;&gt;&gt; df2.vbt(freq='d').stats(column=0, group_by=[0, 0, 1])\nStart                      x\nEnd                        z\nPeriod       3 days 00:00:00\nCount                      4\nMean                     3.5\nStd                 1.290994\nMin                      2.0\nMedian                   3.5\nMax                      5.0\nMin Index                  y\nMax Index                  z\nName: 0, dtype: object\n</code></pre></p>","title":"Mapping"},{"location":"api/generic/accessors/#plots","text":"<p>Hint</p> <p>See PlotsBuilderMixin.plots() and GenericAccessor.subplots.</p>  <p>GenericAccessor class has a single subplot based on GenericAccessor.plot():</p> <pre><code>&gt;&gt;&gt; df2.vbt.plots()\n</code></pre> <p></p>","title":"Plots"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.nb_config","text":"<p>Config of Numba methods to be added to GenericAccessor.</p> <pre><code>Config({\n    \"shuffle\": {\n        \"func\": \"CPUDispatcher(&lt;function shuffle_nb at 0x7ff5002cbb70&gt;)\",\n        \"path\": \"vectorbt.generic.nb.shuffle_nb\"\n    },\n    \"fillna\": {\n        \"func\": \"CPUDispatcher(&lt;function fillna_nb at 0x7ff5002cb6a8&gt;)\",\n        \"path\": \"vectorbt.generic.nb.fillna_nb\"\n    },\n    \"bshift\": {\n        \"func\": \"CPUDispatcher(&lt;function bshift_nb at 0x7ff5002f18c8&gt;)\",\n        \"path\": \"vectorbt.generic.nb.bshift_nb\"\n    },\n    \"fshift\": {\n        \"func\": \"CPUDispatcher(&lt;function fshift_nb at 0x7ff5002f1e18&gt;)\",\n        \"path\": \"vectorbt.generic.nb.fshift_nb\"\n    },\n    \"diff\": {\n        \"func\": \"CPUDispatcher(&lt;function diff_nb at 0x7ff50045f400&gt;)\",\n        \"path\": \"vectorbt.generic.nb.diff_nb\"\n    },\n    \"pct_change\": {\n        \"func\": \"CPUDispatcher(&lt;function pct_change_nb at 0x7ff50045f950&gt;)\",\n        \"path\": \"vectorbt.generic.nb.pct_change_nb\"\n    },\n    \"bfill\": {\n        \"func\": \"CPUDispatcher(&lt;function bfill_nb at 0x7ff50045fea0&gt;)\",\n        \"path\": \"vectorbt.generic.nb.bfill_nb\"\n    },\n    \"ffill\": {\n        \"func\": \"CPUDispatcher(&lt;function ffill_nb at 0x7ff500469488&gt;)\",\n        \"path\": \"vectorbt.generic.nb.ffill_nb\"\n    },\n    \"cumsum\": {\n        \"func\": \"CPUDispatcher(&lt;function nancumsum_nb at 0x7ff5004699d8&gt;)\",\n        \"path\": \"vectorbt.generic.nb.nancumsum_nb\"\n    },\n    \"cumprod\": {\n        \"func\": \"CPUDispatcher(&lt;function nancumprod_nb at 0x7ff500469c80&gt;)\",\n        \"path\": \"vectorbt.generic.nb.nancumprod_nb\"\n    },\n    \"rolling_min\": {\n        \"func\": \"CPUDispatcher(&lt;function rolling_min_nb at 0x7ff500477840&gt;)\",\n        \"path\": \"vectorbt.generic.nb.rolling_min_nb\"\n    },\n    \"rolling_max\": {\n        \"func\": \"CPUDispatcher(&lt;function rolling_max_nb at 0x7ff500477d90&gt;)\",\n        \"path\": \"vectorbt.generic.nb.rolling_max_nb\"\n    },\n    \"rolling_mean\": {\n        \"func\": \"CPUDispatcher(&lt;function rolling_mean_nb at 0x7ff500484378&gt;)\",\n        \"path\": \"vectorbt.generic.nb.rolling_mean_nb\"\n    },\n    \"expanding_min\": {\n        \"func\": \"CPUDispatcher(&lt;function expanding_min_nb at 0x7ff50048a950&gt;)\",\n        \"path\": \"vectorbt.generic.nb.expanding_min_nb\"\n    },\n    \"expanding_max\": {\n        \"func\": \"CPUDispatcher(&lt;function expanding_max_nb at 0x7ff50048aea0&gt;)\",\n        \"path\": \"vectorbt.generic.nb.expanding_max_nb\"\n    },\n    \"expanding_mean\": {\n        \"func\": \"CPUDispatcher(&lt;function expanding_mean_nb at 0x7ff500490488&gt;)\",\n        \"path\": \"vectorbt.generic.nb.expanding_mean_nb\"\n    },\n    \"product\": {\n        \"func\": \"CPUDispatcher(&lt;function nanprod_nb at 0x7ff500469730&gt;)\",\n        \"is_reducing\": true,\n        \"path\": \"vectorbt.generic.nb.nanprod_nb\"\n    }\n})\n</code></pre>","title":"nb_config variable"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.transform_config","text":"<p>Config of transform methods to be added to GenericAccessor.</p> <pre><code>Config({\n    \"binarize\": {\n        \"transformer\": \"&lt;class 'sklearn.preprocessing._data.Binarizer'&gt;\",\n        \"docstring\": \"See `sklearn.preprocessing.Binarizer`.\"\n    },\n    \"minmax_scale\": {\n        \"transformer\": \"&lt;class 'sklearn.preprocessing._data.MinMaxScaler'&gt;\",\n        \"docstring\": \"See `sklearn.preprocessing.MinMaxScaler`.\"\n    },\n    \"maxabs_scale\": {\n        \"transformer\": \"&lt;class 'sklearn.preprocessing._data.MaxAbsScaler'&gt;\",\n        \"docstring\": \"See `sklearn.preprocessing.MaxAbsScaler`.\"\n    },\n    \"normalize\": {\n        \"transformer\": \"&lt;class 'sklearn.preprocessing._data.Normalizer'&gt;\",\n        \"docstring\": \"See `sklearn.preprocessing.Normalizer`.\"\n    },\n    \"robust_scale\": {\n        \"transformer\": \"&lt;class 'sklearn.preprocessing._data.RobustScaler'&gt;\",\n        \"docstring\": \"See `sklearn.preprocessing.RobustScaler`.\"\n    },\n    \"scale\": {\n        \"transformer\": \"&lt;class 'sklearn.preprocessing._data.StandardScaler'&gt;\",\n        \"docstring\": \"See `sklearn.preprocessing.StandardScaler`.\"\n    },\n    \"quantile_transform\": {\n        \"transformer\": \"&lt;class 'sklearn.preprocessing._data.QuantileTransformer'&gt;\",\n        \"docstring\": \"See `sklearn.preprocessing.QuantileTransformer`.\"\n    },\n    \"power_transform\": {\n        \"transformer\": \"&lt;class 'sklearn.preprocessing._data.PowerTransformer'&gt;\",\n        \"docstring\": \"See `sklearn.preprocessing.PowerTransformer`.\"\n    }\n})\n</code></pre>","title":"transform_config variable"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor","text":"<pre><code>GenericAccessor(\n    obj,\n    mapping=None,\n    **kwargs\n)\n</code></pre> <p>Accessor on top of data of any type. For both, Series and DataFrames.</p> <p>Accessible through <code>pd.Series.vbt</code> and <code>pd.DataFrame.vbt</code>.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>BaseAccessor</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>BaseAccessor.align_to()</li> <li>BaseAccessor.apply()</li> <li>BaseAccessor.apply_and_concat()</li> <li>BaseAccessor.apply_on_index()</li> <li>BaseAccessor.broadcast()</li> <li>BaseAccessor.broadcast_to()</li> <li>BaseAccessor.combine()</li> <li>BaseAccessor.concat()</li> <li>BaseAccessor.config</li> <li>BaseAccessor.df_accessor_cls</li> <li>BaseAccessor.drop_duplicate_levels()</li> <li>BaseAccessor.drop_levels()</li> <li>BaseAccessor.drop_redundant_levels()</li> <li>BaseAccessor.empty()</li> <li>BaseAccessor.empty_like()</li> <li>BaseAccessor.iloc</li> <li>BaseAccessor.indexing_func()</li> <li>BaseAccessor.indexing_kwargs</li> <li>BaseAccessor.loc</li> <li>BaseAccessor.make_symmetric()</li> <li>BaseAccessor.obj</li> <li>BaseAccessor.rename_levels()</li> <li>BaseAccessor.repeat()</li> <li>BaseAccessor.select_levels()</li> <li>BaseAccessor.self_aliases</li> <li>BaseAccessor.sr_accessor_cls</li> <li>BaseAccessor.stack_index()</li> <li>BaseAccessor.tile()</li> <li>BaseAccessor.to_1d_array()</li> <li>BaseAccessor.to_2d_array()</li> <li>BaseAccessor.to_dict()</li> <li>BaseAccessor.unstack_to_array()</li> <li>BaseAccessor.unstack_to_df()</li> <li>BaseAccessor.wrapper</li> <li>BaseAccessor.writeable_attrs</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li>GenericDFAccessor</li> <li>GenericSRAccessor</li> <li>ReturnsAccessor</li> <li>SignalsAccessor</li> </ul>","title":"GenericAccessor class"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.metrics","text":"<p>Metrics supported by GenericAccessor.</p> <pre><code>Config({\n    \"start\": {\n        \"title\": \"Start\",\n        \"calc_func\": \"&lt;function GenericAccessor.&lt;lambda&gt; at 0x7ff535456d90&gt;\",\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"end\": {\n        \"title\": \"End\",\n        \"calc_func\": \"&lt;function GenericAccessor.&lt;lambda&gt; at 0x7ff535456e18&gt;\",\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"period\": {\n        \"title\": \"Period\",\n        \"calc_func\": \"&lt;function GenericAccessor.&lt;lambda&gt; at 0x7ff535456ea0&gt;\",\n        \"apply_to_timedelta\": true,\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"count\": {\n        \"title\": \"Count\",\n        \"calc_func\": \"count\",\n        \"inv_check_has_mapping\": true,\n        \"tags\": [\n            \"generic\",\n            \"describe\"\n        ]\n    },\n    \"mean\": {\n        \"title\": \"Mean\",\n        \"calc_func\": \"mean\",\n        \"inv_check_has_mapping\": true,\n        \"tags\": [\n            \"generic\",\n            \"describe\"\n        ]\n    },\n    \"std\": {\n        \"title\": \"Std\",\n        \"calc_func\": \"std\",\n        \"inv_check_has_mapping\": true,\n        \"tags\": [\n            \"generic\",\n            \"describe\"\n        ]\n    },\n    \"min\": {\n        \"title\": \"Min\",\n        \"calc_func\": \"min\",\n        \"inv_check_has_mapping\": true,\n        \"tags\": [\n            \"generic\",\n            \"describe\"\n        ]\n    },\n    \"median\": {\n        \"title\": \"Median\",\n        \"calc_func\": \"median\",\n        \"inv_check_has_mapping\": true,\n        \"tags\": [\n            \"generic\",\n            \"describe\"\n        ]\n    },\n    \"max\": {\n        \"title\": \"Max\",\n        \"calc_func\": \"max\",\n        \"inv_check_has_mapping\": true,\n        \"tags\": [\n            \"generic\",\n            \"describe\"\n        ]\n    },\n    \"idx_min\": {\n        \"title\": \"Min Index\",\n        \"calc_func\": \"idxmin\",\n        \"agg_func\": null,\n        \"inv_check_has_mapping\": true,\n        \"tags\": [\n            \"generic\",\n            \"index\"\n        ]\n    },\n    \"idx_max\": {\n        \"title\": \"Max Index\",\n        \"calc_func\": \"idxmax\",\n        \"agg_func\": null,\n        \"inv_check_has_mapping\": true,\n        \"tags\": [\n            \"generic\",\n            \"index\"\n        ]\n    },\n    \"value_counts\": {\n        \"title\": \"Value Counts\",\n        \"calc_func\": \"&lt;function GenericAccessor.&lt;lambda&gt; at 0x7ff535456f28&gt;\",\n        \"resolve_value_counts\": true,\n        \"check_has_mapping\": true,\n        \"tags\": [\n            \"generic\",\n            \"value_counts\"\n        ]\n    }\n})\n</code></pre> <p>Returns <code>GenericAccessor._metrics</code>, which gets (deep) copied upon creation of each instance. Thus, changing this config won't affect the class.</p> <p>To change metrics, you can either change the config in-place, override this property, or overwrite the instance variable <code>GenericAccessor._metrics</code>.</p>","title":"metrics class variable"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.subplots","text":"<p>Subplots supported by GenericAccessor.</p> <pre><code>Config({\n    \"plot\": {\n        \"check_is_not_grouped\": true,\n        \"plot_func\": \"plot\",\n        \"pass_trace_names\": false,\n        \"tags\": \"generic\"\n    }\n})\n</code></pre> <p>Returns <code>GenericAccessor._subplots</code>, which gets (deep) copied upon creation of each instance. Thus, changing this config won't affect the class.</p> <p>To change subplots, you can either change the config in-place, override this property, or overwrite the instance variable <code>GenericAccessor._subplots</code>.</p>","title":"subplots class variable"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.drawdowns","text":"<p>GenericAccessor.get_drawdowns() with default arguments.</p>","title":"drawdowns property"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.mapping","text":"<p>Mapping.</p>","title":"mapping property"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.plots_defaults","text":"<p>Defaults for PlotsBuilderMixin.plots().</p> <p>Merges PlotsBuilderMixin.plots_defaults and <code>generic.plots</code> from settings.</p>","title":"plots_defaults property"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.ranges","text":"<p>GenericAccessor.get_ranges() with default arguments.</p>","title":"ranges property"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.stats_defaults","text":"<p>Defaults for StatsBuilderMixin.stats().</p> <p>Merges StatsBuilderMixin.stats_defaults and <code>generic.stats</code> from settings.</p>","title":"stats_defaults property"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.apply_along_axis","text":"<pre><code>GenericAccessor.apply_along_axis(\n    apply_func_nb,\n    *args,\n    axis=0,\n    wrap_kwargs=None\n)\n</code></pre> <p>Apply a function <code>apply_func_nb</code> along an axis.</p>","title":"apply_along_axis method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.apply_and_reduce","text":"<pre><code>GenericAccessor.apply_and_reduce(\n    apply_func_nb,\n    reduce_func_nb,\n    apply_args=None,\n    reduce_args=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>See apply_and_reduce_nb().</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; greater_nb = njit(lambda col, a: a[a &gt; 2])\n&gt;&gt;&gt; mean_nb = njit(lambda col, a: np.nanmean(a))\n&gt;&gt;&gt; df.vbt.apply_and_reduce(greater_nb, mean_nb)\na    4.0\nb    4.0\nc    3.0\ndtype: float64\n</code></pre>","title":"apply_and_reduce method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.apply_mapping","text":"<pre><code>GenericAccessor.apply_mapping(\n    **kwargs\n)\n</code></pre> <p>See apply_mapping().</p>","title":"apply_mapping method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.applymap","text":"<pre><code>GenericAccessor.applymap(\n    apply_func_nb,\n    *args,\n    wrap_kwargs=None\n)\n</code></pre> <p>See applymap_nb().</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; multiply_nb = njit(lambda i, col, a: a ** 2)\n&gt;&gt;&gt; df.vbt.applymap(multiply_nb)\n               a     b    c\n2020-01-01   1.0  25.0  1.0\n2020-01-02   4.0  16.0  4.0\n2020-01-03   9.0   9.0  9.0\n2020-01-04  16.0   4.0  4.0\n2020-01-05  25.0   1.0  1.0\n</code></pre>","title":"applymap method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.barplot","text":"<pre><code>GenericAccessor.barplot(\n    trace_names=None,\n    x_labels=None,\n    return_fig=True,\n    **kwargs\n)\n</code></pre> <p>Create Bar and return the figure.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; df.vbt.barplot()\n</code></pre> <p></p>","title":"barplot method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.bfill","text":"<pre><code>GenericAccessor.bfill(\n    *,\n    wrap_kwargs=None\n)\n</code></pre> <p>See bfill_nb().</p>","title":"bfill method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.binarize","text":"<pre><code>GenericAccessor.binarize(\n    *,\n    threshold=0.0,\n    copy=True,\n    **kwargs\n)\n</code></pre> <p>See <code>sklearn.preprocessing.Binarizer</code>.</p>","title":"binarize method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.boxplot","text":"<pre><code>GenericAccessor.boxplot(\n    trace_names=None,\n    group_by=None,\n    return_fig=True,\n    **kwargs\n)\n</code></pre> <p>Create Box and return the figure.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; df.vbt.boxplot()\n</code></pre> <p></p>","title":"boxplot method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.bshift","text":"<pre><code>GenericAccessor.bshift(\n    n=1,\n    fill_value=nan,\n    *,\n    wrap_kwargs=None\n)\n</code></pre> <p>See bshift_nb().</p>","title":"bshift method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.count","text":"<pre><code>GenericAccessor.count(\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Return count of non-NaN elements.</p>","title":"count method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.crossed_above","text":"<pre><code>GenericAccessor.crossed_above(\n    other,\n    wait=0,\n    broadcast_kwargs=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Generate crossover above another array.</p> <p>See crossed_above_nb().</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; df['b'].vbt.crossed_above(df['c'])\n2020-01-01    False\n2020-01-02    False\n2020-01-03    False\n2020-01-04    False\n2020-01-05    False\ndtype: bool\n&gt;&gt;&gt; df['a'].vbt.crossed_above(df['b'])\n2020-01-01    False\n2020-01-02    False\n2020-01-03    False\n2020-01-04     True\n2020-01-05    False\ndtype: bool\n&gt;&gt;&gt; df['a'].vbt.crossed_above(df['b'], wait=1)\n2020-01-01    False\n2020-01-02    False\n2020-01-03    False\n2020-01-04    False\n2020-01-05     True\ndtype: bool\n</code></pre>","title":"crossed_above method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.crossed_below","text":"<pre><code>GenericAccessor.crossed_below(\n    other,\n    wait=0,\n    broadcast_kwargs=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Generate crossover below another array.</p> <p>See crossed_above_nb() but in reversed order.</p>","title":"crossed_below method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.cumprod","text":"<pre><code>GenericAccessor.cumprod(\n    *,\n    wrap_kwargs=None\n)\n</code></pre> <p>See nancumprod_nb().</p>","title":"cumprod method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.cumsum","text":"<pre><code>GenericAccessor.cumsum(\n    *,\n    wrap_kwargs=None\n)\n</code></pre> <p>See nancumsum_nb().</p>","title":"cumsum method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.describe","text":"<pre><code>GenericAccessor.describe(\n    percentiles=None,\n    ddof=1,\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>See describe_reduce_nb().</p> <p>For <code>percentiles</code>, see <code>pd.DataFrame.describe</code>.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; df.vbt.describe()\n              a         b        c\ncount  5.000000  5.000000  5.00000\nmean   3.000000  3.000000  1.80000\nstd    1.581139  1.581139  0.83666\nmin    1.000000  1.000000  1.00000\n25%    2.000000  2.000000  1.00000\n50%    3.000000  3.000000  2.00000\n75%    4.000000  4.000000  2.00000\nmax    5.000000  5.000000  3.00000\n</code></pre>","title":"describe method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.diff","text":"<pre><code>GenericAccessor.diff(\n    n=1,\n    *,\n    wrap_kwargs=None\n)\n</code></pre> <p>See diff_nb().</p>","title":"diff method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.drawdown","text":"<pre><code>GenericAccessor.drawdown(\n    wrap_kwargs=None\n)\n</code></pre> <p>Drawdown series.</p>","title":"drawdown method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.ewm_mean","text":"<pre><code>GenericAccessor.ewm_mean(\n    span,\n    minp=0,\n    adjust=True,\n    wrap_kwargs=None\n)\n</code></pre> <p>See ewm_mean_nb().</p>","title":"ewm_mean method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.ewm_std","text":"<pre><code>GenericAccessor.ewm_std(\n    span,\n    minp=0,\n    adjust=True,\n    ddof=1,\n    wrap_kwargs=None\n)\n</code></pre> <p>See ewm_std_nb().</p>","title":"ewm_std method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.expanding_apply","text":"<pre><code>GenericAccessor.expanding_apply(\n    apply_func_nb,\n    *args,\n    minp=1,\n    on_matrix=False,\n    wrap_kwargs=None\n)\n</code></pre> <p>See expanding_apply_nb() and expanding_matrix_apply_nb() for <code>on_matrix=True</code>.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; mean_nb = njit(lambda i, col, a: np.nanmean(a))\n&gt;&gt;&gt; df.vbt.expanding_apply(mean_nb)\n              a    b    c\n2020-01-01  1.0  5.0  1.0\n2020-01-02  1.5  4.5  1.5\n2020-01-03  2.0  4.0  2.0\n2020-01-04  2.5  3.5  2.0\n2020-01-05  3.0  3.0  1.8\n\n&gt;&gt;&gt; mean_matrix_nb = njit(lambda i, a: np.nanmean(a))\n&gt;&gt;&gt; df.vbt.expanding_apply(mean_matrix_nb, on_matrix=True)\n                   a         b         c\n2020-01-01  2.333333  2.333333  2.333333\n2020-01-02  2.500000  2.500000  2.500000\n2020-01-03  2.666667  2.666667  2.666667\n2020-01-04  2.666667  2.666667  2.666667\n2020-01-05  2.600000  2.600000  2.600000\n</code></pre>","title":"expanding_apply method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.expanding_max","text":"<pre><code>GenericAccessor.expanding_max(\n    minp=1,\n    *,\n    wrap_kwargs=None\n)\n</code></pre> <p>See expanding_max_nb().</p>","title":"expanding_max method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.expanding_mean","text":"<pre><code>GenericAccessor.expanding_mean(\n    minp=1,\n    *,\n    wrap_kwargs=None\n)\n</code></pre> <p>See expanding_mean_nb().</p>","title":"expanding_mean method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.expanding_min","text":"<pre><code>GenericAccessor.expanding_min(\n    minp=1,\n    *,\n    wrap_kwargs=None\n)\n</code></pre> <p>See expanding_min_nb().</p>","title":"expanding_min method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.expanding_split","text":"<pre><code>GenericAccessor.expanding_split(\n    **kwargs\n)\n</code></pre> <p>Split using GenericAccessor.split() on ExpandingSplitter.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; train_set, valid_set, test_set = sr.vbt.expanding_split(\n...     n=5, set_lens=(1, 1), min_len=3, left_to_right=False)\n&gt;&gt;&gt; train_set[0]\nsplit_idx    0    1    2    3    4    5    6  7\n0          0.0  0.0  0.0  0.0  0.0  0.0  0.0  0\n1          NaN  1.0  1.0  1.0  1.0  1.0  1.0  1\n2          NaN  NaN  2.0  2.0  2.0  2.0  2.0  2\n3          NaN  NaN  NaN  3.0  3.0  3.0  3.0  3\n4          NaN  NaN  NaN  NaN  4.0  4.0  4.0  4\n5          NaN  NaN  NaN  NaN  NaN  5.0  5.0  5\n6          NaN  NaN  NaN  NaN  NaN  NaN  6.0  6\n7          NaN  NaN  NaN  NaN  NaN  NaN  NaN  7\n&gt;&gt;&gt; valid_set[0]\nsplit_idx  0  1  2  3  4  5  6  7\n0          1  2  3  4  5  6  7  8\n&gt;&gt;&gt; test_set[0]\nsplit_idx  0  1  2  3  4  5  6  7\n0          2  3  4  5  6  7  8  9\n\n&gt;&gt;&gt; sr.vbt.expanding_split(\n...     set_lens=(1, 1), min_len=3, left_to_right=False,\n...     plot=True, trace_names=['train', 'valid', 'test'])\n</code></pre> <p></p>","title":"expanding_split method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.expanding_std","text":"<pre><code>GenericAccessor.expanding_std(\n    minp=1,\n    ddof=1,\n    wrap_kwargs=None\n)\n</code></pre> <p>See expanding_std_nb().</p>","title":"expanding_std method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.ffill","text":"<pre><code>GenericAccessor.ffill(\n    *,\n    wrap_kwargs=None\n)\n</code></pre> <p>See ffill_nb().</p>","title":"ffill method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.fillna","text":"<pre><code>GenericAccessor.fillna(\n    value,\n    *,\n    wrap_kwargs=None\n)\n</code></pre> <p>See fillna_nb().</p>","title":"fillna method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.filter","text":"<pre><code>GenericAccessor.filter(\n    filter_func_nb,\n    *args,\n    wrap_kwargs=None\n)\n</code></pre> <p>See filter_nb().</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; greater_nb = njit(lambda i, col, a: a &gt; 2)\n&gt;&gt;&gt; df.vbt.filter(greater_nb)\n              a    b    c\n2020-01-01  NaN  5.0  NaN\n2020-01-02  NaN  4.0  NaN\n2020-01-03  3.0  3.0  3.0\n2020-01-04  4.0  NaN  NaN\n2020-01-05  5.0  NaN  NaN\n</code></pre>","title":"filter method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.fshift","text":"<pre><code>GenericAccessor.fshift(\n    n=1,\n    fill_value=nan,\n    *,\n    wrap_kwargs=None\n)\n</code></pre> <p>See fshift_nb().</p>","title":"fshift method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.get_drawdowns","text":"<pre><code>GenericAccessor.get_drawdowns(\n    wrapper_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Generate drawdown records.</p> <p>See Drawdowns.</p>","title":"get_drawdowns method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.get_ranges","text":"<pre><code>GenericAccessor.get_ranges(\n    wrapper_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Generate range records.</p> <p>See Ranges.</p>","title":"get_ranges method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.groupby_apply","text":"<pre><code>GenericAccessor.groupby_apply(\n    by,\n    apply_func_nb,\n    *args,\n    on_matrix=False,\n    wrap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>See groupby_apply_nb() and groupby_matrix_apply_nb() for <code>on_matrix=True</code>.</p> <p>For <code>by</code>, see <code>pd.DataFrame.groupby</code>.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; mean_nb = njit(lambda i, col, a: np.nanmean(a))\n&gt;&gt;&gt; df.vbt.groupby_apply([1, 1, 2, 2, 3], mean_nb)\n     a    b    c\n1  1.5  4.5  1.5\n2  3.5  2.5  2.5\n3  5.0  1.0  1.0\n\n&gt;&gt;&gt; mean_matrix_nb = njit(lambda i, a: np.nanmean(a))\n&gt;&gt;&gt; df.vbt.groupby_apply([1, 1, 2, 2, 3], mean_matrix_nb, on_matrix=True)\n          a         b         c\n1  2.500000  2.500000  2.500000\n2  2.833333  2.833333  2.833333\n3  2.333333  2.333333  2.333333\n</code></pre>","title":"groupby_apply method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.histplot","text":"<pre><code>GenericAccessor.histplot(\n    trace_names=None,\n    group_by=None,\n    return_fig=True,\n    **kwargs\n)\n</code></pre> <p>Create Histogram and return the figure.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; df.vbt.histplot()\n</code></pre> <p></p>","title":"histplot method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.idxmax","text":"<pre><code>GenericAccessor.idxmax(\n    group_by=None,\n    order='C',\n    wrap_kwargs=None\n)\n</code></pre> <p>Return labeled index of max of non-NaN elements.</p>","title":"idxmax method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.idxmin","text":"<pre><code>GenericAccessor.idxmin(\n    group_by=None,\n    order='C',\n    wrap_kwargs=None\n)\n</code></pre> <p>Return labeled index of min of non-NaN elements.</p>","title":"idxmin method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.lineplot","text":"<pre><code>GenericAccessor.lineplot(\n    **kwargs\n)\n</code></pre> <p>GenericAccessor.plot() with 'lines' mode.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; df.vbt.lineplot()\n</code></pre> <p></p>","title":"lineplot method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.max","text":"<pre><code>GenericAccessor.max(\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Return max of non-NaN elements.</p>","title":"max method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.maxabs_scale","text":"<pre><code>GenericAccessor.maxabs_scale(\n    *,\n    copy=True,\n    **kwargs\n)\n</code></pre> <p>See <code>sklearn.preprocessing.MaxAbsScaler</code>.</p>","title":"maxabs_scale method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.mean","text":"<pre><code>GenericAccessor.mean(\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Return mean of non-NaN elements.</p>","title":"mean method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.median","text":"<pre><code>GenericAccessor.median(\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Return median of non-NaN elements.</p>","title":"median method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.min","text":"<pre><code>GenericAccessor.min(\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Return min of non-NaN elements.</p>","title":"min method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.minmax_scale","text":"<pre><code>GenericAccessor.minmax_scale(\n    feature_range=(0, 1),\n    *,\n    copy=True,\n    clip=False,\n    **kwargs\n)\n</code></pre> <p>See <code>sklearn.preprocessing.MinMaxScaler</code>.</p>","title":"minmax_scale method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.normalize","text":"<pre><code>GenericAccessor.normalize(\n    norm='l2',\n    *,\n    copy=True,\n    **kwargs\n)\n</code></pre> <p>See <code>sklearn.preprocessing.Normalizer</code>.</p>","title":"normalize method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.pct_change","text":"<pre><code>GenericAccessor.pct_change(\n    n=1,\n    *,\n    wrap_kwargs=None\n)\n</code></pre> <p>See pct_change_nb().</p>","title":"pct_change method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.plot","text":"<pre><code>GenericAccessor.plot(\n    trace_names=None,\n    x_labels=None,\n    return_fig=True,\n    **kwargs\n)\n</code></pre> <p>Create Scatter and return the figure.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; df.vbt.plot()\n</code></pre> <p></p>","title":"plot method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.power_transform","text":"<pre><code>GenericAccessor.power_transform(\n    method='yeo-johnson',\n    *,\n    standardize=True,\n    copy=True,\n    **kwargs\n)\n</code></pre> <p>See <code>sklearn.preprocessing.PowerTransformer</code>.</p>","title":"power_transform method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.product","text":"<pre><code>GenericAccessor.product(\n    *,\n    wrap_kwargs=None\n)\n</code></pre> <p>See nanprod_nb().</p>","title":"product method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.quantile_transform","text":"<pre><code>GenericAccessor.quantile_transform(\n    *,\n    n_quantiles=1000,\n    output_distribution='uniform',\n    ignore_implicit_zeros=False,\n    subsample=100000,\n    random_state=None,\n    copy=True,\n    **kwargs\n)\n</code></pre> <p>See <code>sklearn.preprocessing.QuantileTransformer</code>.</p>","title":"quantile_transform method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.range_split","text":"<pre><code>GenericAccessor.range_split(\n    **kwargs\n)\n</code></pre> <p>Split using GenericAccessor.split() on RangeSplitter.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; range_df, range_indexes = sr.vbt.range_split(n=2)\n&gt;&gt;&gt; range_df\nsplit_idx  0  1\n0          0  5\n1          1  6\n2          2  7\n3          3  8\n4          4  9\n&gt;&gt;&gt; range_indexes\n[DatetimeIndex(['2020-01-01', ..., '2020-01-05'], dtype='datetime64[ns]', name='split_0'),\n DatetimeIndex(['2020-01-06', ..., '2020-01-10'], dtype='datetime64[ns]', name='split_1')]\n\n&gt;&gt;&gt; range_df, range_indexes = sr.vbt.range_split(range_len=4)\n&gt;&gt;&gt; range_df\nsplit_idx  0  1  2  3  4  5  6\n0          0  1  2  3  4  5  6\n1          1  2  3  4  5  6  7\n2          2  3  4  5  6  7  8\n3          3  4  5  6  7  8  9\n&gt;&gt;&gt; range_indexes\n[DatetimeIndex(['2020-01-01', ..., '2020-01-04'], dtype='datetime64[ns]', name='split_0'),\n DatetimeIndex(['2020-01-02', ..., '2020-01-05'], dtype='datetime64[ns]', name='split_1'),\n DatetimeIndex(['2020-01-03', ..., '2020-01-06'], dtype='datetime64[ns]', name='split_2'),\n DatetimeIndex(['2020-01-04', ..., '2020-01-07'], dtype='datetime64[ns]', name='split_3'),\n DatetimeIndex(['2020-01-05', ..., '2020-01-08'], dtype='datetime64[ns]', name='split_4'),\n DatetimeIndex(['2020-01-06', ..., '2020-01-09'], dtype='datetime64[ns]', name='split_5'),\n DatetimeIndex(['2020-01-07', ..., '2020-01-10'], dtype='datetime64[ns]', name='split_6')]\n\n&gt;&gt;&gt; range_df, range_indexes = sr.vbt.range_split(start_idxs=[0, 2], end_idxs=[5, 7])\n&gt;&gt;&gt; range_df\nsplit_idx  0  1\n0          0  2\n1          1  3\n2          2  4\n3          3  5\n4          4  6\n5          5  7\n&gt;&gt;&gt; range_indexes\n[DatetimeIndex(['2020-01-01', ..., '2020-01-06'], dtype='datetime64[ns]', name='split_0'),\n DatetimeIndex(['2020-01-03', ..., '2020-01-08'], dtype='datetime64[ns]', name='split_1')]\n\n&gt;&gt;&gt; range_df, range_indexes = sr.vbt.range_split(start_idxs=[0], end_idxs=[2, 3, 4])\n&gt;&gt;&gt; range_df\nsplit_idx    0    1  2\n0          0.0  0.0  0\n1          1.0  1.0  1\n2          2.0  2.0  2\n3          NaN  3.0  3\n4          NaN  NaN  4\n&gt;&gt;&gt; range_indexes\n[DatetimeIndex(['2020-01-01', ..., '2020-01-03'], dtype='datetime64[ns]', name='split_0'),\n DatetimeIndex(['2020-01-01', ..., '2020-01-04'], dtype='datetime64[ns]', name='split_1'),\n DatetimeIndex(['2020-01-01', ..., '2020-01-05'], dtype='datetime64[ns]', name='split_2')]\n\n&gt;&gt;&gt; range_df, range_indexes = sr.vbt.range_split(\n...     start_idxs=pd.Index(['2020-01-01', '2020-01-02']),\n...     end_idxs=pd.Index(['2020-01-04', '2020-01-05'])\n... )\n&gt;&gt;&gt; range_df\nsplit_idx  0  1\n0          0  1\n1          1  2\n2          2  3\n3          3  4\n&gt;&gt;&gt; range_indexes\n[DatetimeIndex(['2020-01-01', ..., '2020-01-04'], dtype='datetime64[ns]', name='split_0'),\n DatetimeIndex(['2020-01-02', ..., '2020-01-05'], dtype='datetime64[ns]', name='split_1')]\n\n &gt;&gt;&gt; sr.vbt.range_split(\n ...    start_idxs=pd.Index(['2020-01-01', '2020-01-02', '2020-01-01']),\n ...    end_idxs=pd.Index(['2020-01-08', '2020-01-04', '2020-01-07']),\n ...    plot=True\n ... )\n</code></pre> <p></p>","title":"range_split method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.rebase","text":"<pre><code>GenericAccessor.rebase(\n    base,\n    wrap_kwargs=None\n)\n</code></pre> <p>Rebase all series to a given intial base.</p> <p>This makes comparing/plotting different series together easier. Will forward and backward fill NaN values.</p>","title":"rebase method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.reduce","text":"<pre><code>GenericAccessor.reduce(\n    reduce_func_nb,\n    *args,\n    returns_array=False,\n    returns_idx=False,\n    flatten=False,\n    order='C',\n    to_index=True,\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Reduce by column.</p> <p>See flat_reduce_grouped_to_array_nb() if grouped, <code>returns_array</code> is True and <code>flatten</code> is True. See flat_reduce_grouped_nb() if grouped, <code>returns_array</code> is False and <code>flatten</code> is True. See reduce_grouped_to_array_nb() if grouped, <code>returns_array</code> is True and <code>flatten</code> is False. See reduce_grouped_nb() if grouped, <code>returns_array</code> is False and <code>flatten</code> is False. See reduce_to_array_nb() if not grouped and <code>returns_array</code> is True. See reduce_nb() if not grouped and <code>returns_array</code> is False.</p> <p>Set <code>returns_idx</code> to True if values returned by <code>reduce_func_nb</code> are indices/positions. Set <code>to_index</code> to False to return raw positions instead of labels.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; mean_nb = njit(lambda col, a: np.nanmean(a))\n&gt;&gt;&gt; df.vbt.reduce(mean_nb)\na    3.0\nb    3.0\nc    1.8\ndtype: float64\n\n&gt;&gt;&gt; argmax_nb = njit(lambda col, a: np.argmax(a))\n&gt;&gt;&gt; df.vbt.reduce(argmax_nb, returns_idx=True)\na   2020-01-05\nb   2020-01-01\nc   2020-01-03\ndtype: datetime64[ns]\n\n&gt;&gt;&gt; argmax_nb = njit(lambda col, a: np.argmax(a))\n&gt;&gt;&gt; df.vbt.reduce(argmax_nb, returns_idx=True, to_index=False)\na    4\nb    0\nc    2\ndtype: int64\n\n&gt;&gt;&gt; min_max_nb = njit(lambda col, a: np.array([np.nanmin(a), np.nanmax(a)]))\n&gt;&gt;&gt; df.vbt.reduce(min_max_nb, returns_array=True, wrap_kwargs=dict(name_or_index=['min', 'max']))\n       a    b    c\nmin  1.0  1.0  1.0\nmax  5.0  5.0  3.0\n\n&gt;&gt;&gt; group_by = pd.Series(['first', 'first', 'second'], name='group')\n&gt;&gt;&gt; df.vbt.reduce(mean_nb, group_by=group_by)\ngroup\nfirst     3.0\nsecond    1.8\ndtype: float64\n\n&gt;&gt;&gt; df.vbt.reduce(min_max_nb, name_or_index=['min', 'max'],\n...     returns_array=True, group_by=group_by)\ngroup  first  second\nmin      1.0     1.0\nmax      5.0     3.0\n</code></pre>","title":"reduce method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.resample_apply","text":"<pre><code>GenericAccessor.resample_apply(\n    freq,\n    apply_func_nb,\n    *args,\n    on_matrix=False,\n    wrap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>See groupby_apply_nb() and groupby_matrix_apply_nb() for <code>on_matrix=True</code>.</p> <p>For <code>freq</code>, see <code>pd.DataFrame.resample</code>.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; mean_nb = njit(lambda i, col, a: np.nanmean(a))\n&gt;&gt;&gt; df.vbt.resample_apply('2d', mean_nb)\n              a    b    c\n2020-01-01  1.5  4.5  1.5\n2020-01-03  3.5  2.5  2.5\n2020-01-05  5.0  1.0  1.0\n\n&gt;&gt;&gt; mean_matrix_nb = njit(lambda i, a: np.nanmean(a))\n&gt;&gt;&gt; df.vbt.resample_apply('2d', mean_matrix_nb, on_matrix=True)\n                   a         b         c\n2020-01-01  2.500000  2.500000  2.500000\n2020-01-03  2.833333  2.833333  2.833333\n2020-01-05  2.333333  2.333333  2.333333\n</code></pre>","title":"resample_apply method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.resolve_self","text":"<pre><code>GenericAccessor.resolve_self(\n    cond_kwargs=None,\n    custom_arg_names=None,\n    impacts_caching=True,\n    silence_warnings=False\n)\n</code></pre> <p>Resolve self.</p> <p>See Wrapping.resolve_self().</p> <p>Creates a copy of this instance <code>mapping</code> is different in <code>cond_kwargs</code>.</p>","title":"resolve_self method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.robust_scale","text":"<pre><code>GenericAccessor.robust_scale(\n    *,\n    with_centering=True,\n    with_scaling=True,\n    quantile_range=(25.0, 75.0),\n    copy=True,\n    unit_variance=False,\n    **kwargs\n)\n</code></pre> <p>See <code>sklearn.preprocessing.RobustScaler</code>.</p>","title":"robust_scale method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.rolling_apply","text":"<pre><code>GenericAccessor.rolling_apply(\n    window,\n    apply_func_nb,\n    *args,\n    minp=None,\n    on_matrix=False,\n    wrap_kwargs=None\n)\n</code></pre> <p>See rolling_apply_nb() and rolling_matrix_apply_nb() for <code>on_matrix=True</code>.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; mean_nb = njit(lambda i, col, a: np.nanmean(a))\n&gt;&gt;&gt; df.vbt.rolling_apply(3, mean_nb)\n              a    b         c\n2020-01-01  1.0  5.0  1.000000\n2020-01-02  1.5  4.5  1.500000\n2020-01-03  2.0  4.0  2.000000\n2020-01-04  3.0  3.0  2.333333\n2020-01-05  4.0  2.0  2.000000\n\n&gt;&gt;&gt; mean_matrix_nb = njit(lambda i, a: np.nanmean(a))\n&gt;&gt;&gt; df.vbt.rolling_apply(3, mean_matrix_nb, on_matrix=True)\n                   a         b         c\n2020-01-01  2.333333  2.333333  2.333333\n2020-01-02  2.500000  2.500000  2.500000\n2020-01-03  2.666667  2.666667  2.666667\n2020-01-04  2.777778  2.777778  2.777778\n2020-01-05  2.666667  2.666667  2.666667\n</code></pre>","title":"rolling_apply method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.rolling_max","text":"<pre><code>GenericAccessor.rolling_max(\n    window,\n    minp=None,\n    *,\n    wrap_kwargs=None\n)\n</code></pre> <p>See rolling_max_nb().</p>","title":"rolling_max method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.rolling_mean","text":"<pre><code>GenericAccessor.rolling_mean(\n    window,\n    minp=None,\n    *,\n    wrap_kwargs=None\n)\n</code></pre> <p>See rolling_mean_nb().</p>","title":"rolling_mean method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.rolling_min","text":"<pre><code>GenericAccessor.rolling_min(\n    window,\n    minp=None,\n    *,\n    wrap_kwargs=None\n)\n</code></pre> <p>See rolling_min_nb().</p>","title":"rolling_min method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.rolling_split","text":"<pre><code>GenericAccessor.rolling_split(\n    **kwargs\n)\n</code></pre> <p>Split using GenericAccessor.split() on RollingSplitter.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; train_set, valid_set, test_set = sr.vbt.rolling_split(\n...     window_len=5, set_lens=(1, 1), left_to_right=False)\n&gt;&gt;&gt; train_set[0]\nsplit_idx  0  1  2  3  4  5\n0          0  1  2  3  4  5\n1          1  2  3  4  5  6\n2          2  3  4  5  6  7\n&gt;&gt;&gt; valid_set[0]\nsplit_idx  0  1  2  3  4  5\n0          3  4  5  6  7  8\n&gt;&gt;&gt; test_set[0]\nsplit_idx  0  1  2  3  4  5\n0          4  5  6  7  8  9\n\n&gt;&gt;&gt; sr.vbt.rolling_split(\n...     window_len=5, set_lens=(1, 1), left_to_right=False,\n...     plot=True, trace_names=['train', 'valid', 'test'])\n</code></pre> <p></p>","title":"rolling_split method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.rolling_std","text":"<pre><code>GenericAccessor.rolling_std(\n    window,\n    minp=None,\n    ddof=1,\n    wrap_kwargs=None\n)\n</code></pre> <p>See rolling_std_nb().</p>","title":"rolling_std method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.scale","text":"<pre><code>GenericAccessor.scale(\n    *,\n    copy=True,\n    with_mean=True,\n    with_std=True,\n    **kwargs\n)\n</code></pre> <p>See <code>sklearn.preprocessing.StandardScaler</code>.</p>","title":"scale method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.scatterplot","text":"<pre><code>GenericAccessor.scatterplot(\n    **kwargs\n)\n</code></pre> <p>GenericAccessor.plot() with 'markers' mode.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; df.vbt.scatterplot()\n</code></pre> <p></p>","title":"scatterplot method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.shuffle","text":"<pre><code>GenericAccessor.shuffle(\n    seed=None,\n    *,\n    wrap_kwargs=None\n)\n</code></pre> <p>See shuffle_nb().</p>","title":"shuffle method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.split","text":"<pre><code>GenericAccessor.split(\n    splitter,\n    stack_kwargs=None,\n    keys=None,\n    plot=False,\n    trace_names=None,\n    heatmap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Split using a splitter.</p> <p>Returns a tuple of tuples, each corresponding to a set and composed of a dataframe and split indexes.</p> <p>A splitter can be any class instance that has <code>split</code> method, ideally subclassing <code>sklearn.model_selection.BaseCrossValidator</code> or BaseSplitter.</p> <p><code>heatmap_kwargs</code> are passed to Heatmap if <code>plot</code> is True, can be a dictionary or a list per set, for example, to set trace name for each set ('train', 'test', etc.).</p> <p><code>**kwargs</code> are passed to the <code>split</code> method.</p>  <p>Note</p> <p>The datetime-like format of the index will be lost as result of this operation. Make sure to store the index metadata such as frequency information beforehand.</p>  <p>Usage</p> <pre><code>&gt;&gt;&gt; from sklearn.model_selection import TimeSeriesSplit\n\n&gt;&gt;&gt; splitter = TimeSeriesSplit(n_splits=3)\n&gt;&gt;&gt; (train_df, train_indexes), (test_df, test_indexes) = sr.vbt.split(splitter)\n\n&gt;&gt;&gt; train_df\nsplit_idx    0    1  2\n0          0.0  0.0  0\n1          1.0  1.0  1\n2          2.0  2.0  2\n3          3.0  3.0  3\n4          NaN  4.0  4\n5          NaN  5.0  5\n6          NaN  NaN  6\n7          NaN  NaN  7\n&gt;&gt;&gt; train_indexes\n[DatetimeIndex(['2020-01-01', ..., '2020-01-04'], dtype='datetime64[ns]', name='split_0'),\n DatetimeIndex(['2020-01-01', ..., '2020-01-06'], dtype='datetime64[ns]', name='split_1'),\n DatetimeIndex(['2020-01-01', ..., '2020-01-08'], dtype='datetime64[ns]', name='split_2')]\n&gt;&gt;&gt; test_df\nsplit_idx  0  1  2\n0          4  6  8\n1          5  7  9\n&gt;&gt;&gt; test_indexes\n[DatetimeIndex(['2020-01-05', '2020-01-06'], dtype='datetime64[ns]', name='split_0'),\n DatetimeIndex(['2020-01-07', '2020-01-08'], dtype='datetime64[ns]', name='split_1'),\n DatetimeIndex(['2020-01-09', '2020-01-10'], dtype='datetime64[ns]', name='split_2')]\n\n&gt;&gt;&gt; sr.vbt.split(splitter, plot=True, trace_names=['train', 'test'])\n</code></pre> <p></p>","title":"split method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.std","text":"<pre><code>GenericAccessor.std(\n    ddof=1,\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Return standard deviation of non-NaN elements.</p>","title":"std method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.sum","text":"<pre><code>GenericAccessor.sum(\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Return sum of non-NaN elements.</p>","title":"sum method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.to_mapped","text":"<pre><code>GenericAccessor.to_mapped(\n    dropna=True,\n    dtype=None,\n    group_by=None,\n    **kwargs\n)\n</code></pre> <p>Convert this object into an instance of MappedArray.</p>","title":"to_mapped method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.to_returns","text":"<pre><code>GenericAccessor.to_returns(\n    **kwargs\n)\n</code></pre> <p>Get returns of this object.</p>","title":"to_returns method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.transform","text":"<pre><code>GenericAccessor.transform(\n    transformer,\n    wrap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Transform using a transformer.</p> <p>A transformer can be any class instance that has <code>transform</code> and <code>fit_transform</code> methods, ideally subclassing <code>sklearn.base.TransformerMixin</code> and <code>sklearn.base.BaseEstimator</code>.</p> <p>Will fit <code>transformer</code> if not fitted.</p> <p><code>**kwargs</code> are passed to the <code>transform</code> or <code>fit_transform</code> method.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; from sklearn.preprocessing import MinMaxScaler\n\n&gt;&gt;&gt; df.vbt.transform(MinMaxScaler((-1, 1)))\n              a    b    c\n2020-01-01 -1.0  1.0 -1.0\n2020-01-02 -0.5  0.5  0.0\n2020-01-03  0.0  0.0  1.0\n2020-01-04  0.5 -0.5  0.0\n2020-01-05  1.0 -1.0 -1.0\n\n&gt;&gt;&gt; fitted_scaler = MinMaxScaler((-1, 1)).fit(np.array([[2], [4]]))\n&gt;&gt;&gt; df.vbt.transform(fitted_scaler)\n              a    b    c\n2020-01-01 -2.0  2.0 -2.0\n2020-01-02 -1.0  1.0 -1.0\n2020-01-03  0.0  0.0  0.0\n2020-01-04  1.0 -1.0 -1.0\n2020-01-05  2.0 -2.0 -2.0\n</code></pre>","title":"transform method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.value_counts","text":"<pre><code>GenericAccessor.value_counts(\n    normalize=False,\n    sort_uniques=True,\n    sort=False,\n    ascending=False,\n    dropna=False,\n    group_by=None,\n    mapping=None,\n    incl_all_keys=False,\n    wrap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Return a Series/DataFrame containing counts of unique values.</p> <ul> <li>Enable <code>normalize</code> flag to return the relative frequencies of the unique values.</li> <li>Enable <code>sort_uniques</code> flag to sort uniques.</li> <li>Enable <code>sort</code> flag to sort by frequencies.</li> <li>Enable <code>ascending</code> flag to sort in ascending order.</li> <li>Enable <code>dropna</code> flag to exclude counts of NaN.</li> <li>Enable <code>incl_all_keys</code> to include all mapping keys, no only those that are present in the array.</li> </ul> <p>Mapping will be applied using apply_mapping() with <code>**kwargs</code>.</p>","title":"value_counts method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericAccessor.zscore","text":"<pre><code>GenericAccessor.zscore(\n    **kwargs\n)\n</code></pre> <p>Compute z-score using <code>sklearn.preprocessing.StandardScaler</code>.</p>","title":"zscore method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericDFAccessor","text":"<pre><code>GenericDFAccessor(\n    obj,\n    mapping=None,\n    **kwargs\n)\n</code></pre> <p>Accessor on top of data of any type. For DataFrames only.</p> <p>Accessible through <code>pd.DataFrame.vbt</code>.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>BaseAccessor</li> <li>BaseDFAccessor</li> <li>Configured</li> <li>Documented</li> <li>GenericAccessor</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>BaseAccessor.align_to()</li> <li>BaseAccessor.apply()</li> <li>BaseAccessor.apply_and_concat()</li> <li>BaseAccessor.apply_on_index()</li> <li>BaseAccessor.broadcast()</li> <li>BaseAccessor.broadcast_to()</li> <li>BaseAccessor.combine()</li> <li>BaseAccessor.concat()</li> <li>BaseAccessor.drop_duplicate_levels()</li> <li>BaseAccessor.drop_levels()</li> <li>BaseAccessor.drop_redundant_levels()</li> <li>BaseAccessor.empty()</li> <li>BaseAccessor.empty_like()</li> <li>BaseAccessor.indexing_func()</li> <li>BaseAccessor.make_symmetric()</li> <li>BaseAccessor.rename_levels()</li> <li>BaseAccessor.repeat()</li> <li>BaseAccessor.select_levels()</li> <li>BaseAccessor.stack_index()</li> <li>BaseAccessor.tile()</li> <li>BaseAccessor.to_1d_array()</li> <li>BaseAccessor.to_2d_array()</li> <li>BaseAccessor.to_dict()</li> <li>BaseAccessor.unstack_to_array()</li> <li>BaseAccessor.unstack_to_df()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>GenericAccessor.apply_along_axis()</li> <li>GenericAccessor.apply_and_reduce()</li> <li>GenericAccessor.apply_mapping()</li> <li>GenericAccessor.applymap()</li> <li>GenericAccessor.barplot()</li> <li>GenericAccessor.bfill()</li> <li>GenericAccessor.binarize()</li> <li>GenericAccessor.boxplot()</li> <li>GenericAccessor.bshift()</li> <li>GenericAccessor.config</li> <li>GenericAccessor.count()</li> <li>GenericAccessor.crossed_above()</li> <li>GenericAccessor.crossed_below()</li> <li>GenericAccessor.cumprod()</li> <li>GenericAccessor.cumsum()</li> <li>GenericAccessor.describe()</li> <li>GenericAccessor.df_accessor_cls</li> <li>GenericAccessor.diff()</li> <li>GenericAccessor.drawdown()</li> <li>GenericAccessor.drawdowns</li> <li>GenericAccessor.ewm_mean()</li> <li>GenericAccessor.ewm_std()</li> <li>GenericAccessor.expanding_apply()</li> <li>GenericAccessor.expanding_max()</li> <li>GenericAccessor.expanding_mean()</li> <li>GenericAccessor.expanding_min()</li> <li>GenericAccessor.expanding_split()</li> <li>GenericAccessor.expanding_std()</li> <li>GenericAccessor.ffill()</li> <li>GenericAccessor.fillna()</li> <li>GenericAccessor.filter()</li> <li>GenericAccessor.fshift()</li> <li>GenericAccessor.get_drawdowns()</li> <li>GenericAccessor.get_ranges()</li> <li>GenericAccessor.groupby_apply()</li> <li>GenericAccessor.histplot()</li> <li>GenericAccessor.idxmax()</li> <li>GenericAccessor.idxmin()</li> <li>GenericAccessor.iloc</li> <li>GenericAccessor.indexing_kwargs</li> <li>GenericAccessor.lineplot()</li> <li>GenericAccessor.loc</li> <li>GenericAccessor.mapping</li> <li>GenericAccessor.max()</li> <li>GenericAccessor.maxabs_scale()</li> <li>GenericAccessor.mean()</li> <li>GenericAccessor.median()</li> <li>GenericAccessor.min()</li> <li>GenericAccessor.minmax_scale()</li> <li>GenericAccessor.normalize()</li> <li>GenericAccessor.obj</li> <li>GenericAccessor.pct_change()</li> <li>GenericAccessor.plot()</li> <li>GenericAccessor.plots_defaults</li> <li>GenericAccessor.power_transform()</li> <li>GenericAccessor.product()</li> <li>GenericAccessor.quantile_transform()</li> <li>GenericAccessor.range_split()</li> <li>GenericAccessor.ranges</li> <li>GenericAccessor.rebase()</li> <li>GenericAccessor.reduce()</li> <li>GenericAccessor.resample_apply()</li> <li>GenericAccessor.resolve_self()</li> <li>GenericAccessor.robust_scale()</li> <li>GenericAccessor.rolling_apply()</li> <li>GenericAccessor.rolling_max()</li> <li>GenericAccessor.rolling_mean()</li> <li>GenericAccessor.rolling_min()</li> <li>GenericAccessor.rolling_split()</li> <li>GenericAccessor.rolling_std()</li> <li>GenericAccessor.scale()</li> <li>GenericAccessor.scatterplot()</li> <li>GenericAccessor.self_aliases</li> <li>GenericAccessor.shuffle()</li> <li>GenericAccessor.split()</li> <li>GenericAccessor.sr_accessor_cls</li> <li>GenericAccessor.stats_defaults</li> <li>GenericAccessor.std()</li> <li>GenericAccessor.sum()</li> <li>GenericAccessor.to_mapped()</li> <li>GenericAccessor.to_returns()</li> <li>GenericAccessor.transform()</li> <li>GenericAccessor.value_counts()</li> <li>GenericAccessor.wrapper</li> <li>GenericAccessor.writeable_attrs</li> <li>GenericAccessor.zscore()</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li>OHLCVDFAccessor</li> <li>ReturnsDFAccessor</li> <li>SignalsDFAccessor</li> <li>Vbt_DFAccessor</li> </ul>","title":"GenericDFAccessor class"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericDFAccessor.flatten_grouped","text":"<pre><code>GenericDFAccessor.flatten_grouped(\n    group_by=None,\n    order='C',\n    wrap_kwargs=None\n)\n</code></pre> <p>Flatten each group of columns.</p> <p>See flatten_grouped_nb(). If all groups have the same length, see flatten_uniform_grouped_nb().</p>  <p>Warning</p> <p>Make sure that the distribution of group lengths is close to uniform, otherwise groups with less columns will be filled with NaN and needlessly occupy memory.</p>  <p>Usage</p> <pre><code>&gt;&gt;&gt; group_by = pd.Series(['first', 'first', 'second'], name='group')\n&gt;&gt;&gt; df.vbt.flatten_grouped(group_by=group_by, order='C')\ngroup       first  second\n2020-01-01    1.0     1.0\n2020-01-01    5.0     NaN\n2020-01-02    2.0     2.0\n2020-01-02    4.0     NaN\n2020-01-03    3.0     3.0\n2020-01-03    3.0     NaN\n2020-01-04    4.0     2.0\n2020-01-04    2.0     NaN\n2020-01-05    5.0     1.0\n2020-01-05    1.0     NaN\n\n&gt;&gt;&gt; df.vbt.flatten_grouped(group_by=group_by, order='F')\ngroup       first  second\n2020-01-01    1.0     1.0\n2020-01-02    2.0     2.0\n2020-01-03    3.0     3.0\n2020-01-04    4.0     2.0\n2020-01-05    5.0     1.0\n2020-01-01    5.0     NaN\n2020-01-02    4.0     NaN\n2020-01-03    3.0     NaN\n2020-01-04    2.0     NaN\n2020-01-05    1.0     NaN\n</code></pre>","title":"flatten_grouped method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericDFAccessor.heatmap","text":"<pre><code>GenericDFAccessor.heatmap(\n    x_labels=None,\n    y_labels=None,\n    return_fig=True,\n    **kwargs\n)\n</code></pre> <p>Create Heatmap and return the figure.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame([\n...     [0, np.nan, np.nan],\n...     [np.nan, 1, np.nan],\n...     [np.nan, np.nan, 2]\n... ])\n&gt;&gt;&gt; df.vbt.heatmap()\n</code></pre> <p></p>","title":"heatmap method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericDFAccessor.squeeze_grouped","text":"<pre><code>GenericDFAccessor.squeeze_grouped(\n    squeeze_func_nb,\n    *args,\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Squeeze each group of columns into a single column.</p> <p>See squeeze_grouped_nb().</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; group_by = pd.Series(['first', 'first', 'second'], name='group')\n&gt;&gt;&gt; mean_squeeze_nb = njit(lambda i, group, a: np.nanmean(a))\n&gt;&gt;&gt; df.vbt.squeeze_grouped(mean_squeeze_nb, group_by=group_by)\ngroup       first  second\n2020-01-01    3.0     1.0\n2020-01-02    3.0     2.0\n2020-01-03    3.0     3.0\n2020-01-04    3.0     2.0\n2020-01-05    3.0     1.0\n</code></pre>","title":"squeeze_grouped method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericDFAccessor.ts_heatmap","text":"<pre><code>GenericDFAccessor.ts_heatmap(\n    is_y_category=True,\n    **kwargs\n)\n</code></pre> <p>Heatmap of time-series data.</p>","title":"ts_heatmap method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericSRAccessor","text":"<pre><code>GenericSRAccessor(\n    obj,\n    mapping=None,\n    **kwargs\n)\n</code></pre> <p>Accessor on top of data of any type. For Series only.</p> <p>Accessible through <code>pd.Series.vbt</code>.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>BaseAccessor</li> <li>BaseSRAccessor</li> <li>Configured</li> <li>Documented</li> <li>GenericAccessor</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>BaseAccessor.align_to()</li> <li>BaseAccessor.apply()</li> <li>BaseAccessor.apply_and_concat()</li> <li>BaseAccessor.apply_on_index()</li> <li>BaseAccessor.broadcast()</li> <li>BaseAccessor.broadcast_to()</li> <li>BaseAccessor.combine()</li> <li>BaseAccessor.concat()</li> <li>BaseAccessor.drop_duplicate_levels()</li> <li>BaseAccessor.drop_levels()</li> <li>BaseAccessor.drop_redundant_levels()</li> <li>BaseAccessor.empty()</li> <li>BaseAccessor.empty_like()</li> <li>BaseAccessor.indexing_func()</li> <li>BaseAccessor.make_symmetric()</li> <li>BaseAccessor.rename_levels()</li> <li>BaseAccessor.repeat()</li> <li>BaseAccessor.select_levels()</li> <li>BaseAccessor.stack_index()</li> <li>BaseAccessor.tile()</li> <li>BaseAccessor.to_1d_array()</li> <li>BaseAccessor.to_2d_array()</li> <li>BaseAccessor.to_dict()</li> <li>BaseAccessor.unstack_to_array()</li> <li>BaseAccessor.unstack_to_df()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>GenericAccessor.apply_along_axis()</li> <li>GenericAccessor.apply_and_reduce()</li> <li>GenericAccessor.apply_mapping()</li> <li>GenericAccessor.applymap()</li> <li>GenericAccessor.barplot()</li> <li>GenericAccessor.bfill()</li> <li>GenericAccessor.binarize()</li> <li>GenericAccessor.boxplot()</li> <li>GenericAccessor.bshift()</li> <li>GenericAccessor.config</li> <li>GenericAccessor.count()</li> <li>GenericAccessor.crossed_above()</li> <li>GenericAccessor.crossed_below()</li> <li>GenericAccessor.cumprod()</li> <li>GenericAccessor.cumsum()</li> <li>GenericAccessor.describe()</li> <li>GenericAccessor.df_accessor_cls</li> <li>GenericAccessor.diff()</li> <li>GenericAccessor.drawdown()</li> <li>GenericAccessor.drawdowns</li> <li>GenericAccessor.ewm_mean()</li> <li>GenericAccessor.ewm_std()</li> <li>GenericAccessor.expanding_apply()</li> <li>GenericAccessor.expanding_max()</li> <li>GenericAccessor.expanding_mean()</li> <li>GenericAccessor.expanding_min()</li> <li>GenericAccessor.expanding_split()</li> <li>GenericAccessor.expanding_std()</li> <li>GenericAccessor.ffill()</li> <li>GenericAccessor.fillna()</li> <li>GenericAccessor.filter()</li> <li>GenericAccessor.fshift()</li> <li>GenericAccessor.get_drawdowns()</li> <li>GenericAccessor.get_ranges()</li> <li>GenericAccessor.groupby_apply()</li> <li>GenericAccessor.histplot()</li> <li>GenericAccessor.idxmax()</li> <li>GenericAccessor.idxmin()</li> <li>GenericAccessor.iloc</li> <li>GenericAccessor.indexing_kwargs</li> <li>GenericAccessor.lineplot()</li> <li>GenericAccessor.loc</li> <li>GenericAccessor.mapping</li> <li>GenericAccessor.max()</li> <li>GenericAccessor.maxabs_scale()</li> <li>GenericAccessor.mean()</li> <li>GenericAccessor.median()</li> <li>GenericAccessor.min()</li> <li>GenericAccessor.minmax_scale()</li> <li>GenericAccessor.normalize()</li> <li>GenericAccessor.obj</li> <li>GenericAccessor.pct_change()</li> <li>GenericAccessor.plot()</li> <li>GenericAccessor.plots_defaults</li> <li>GenericAccessor.power_transform()</li> <li>GenericAccessor.product()</li> <li>GenericAccessor.quantile_transform()</li> <li>GenericAccessor.range_split()</li> <li>GenericAccessor.ranges</li> <li>GenericAccessor.rebase()</li> <li>GenericAccessor.reduce()</li> <li>GenericAccessor.resample_apply()</li> <li>GenericAccessor.resolve_self()</li> <li>GenericAccessor.robust_scale()</li> <li>GenericAccessor.rolling_apply()</li> <li>GenericAccessor.rolling_max()</li> <li>GenericAccessor.rolling_mean()</li> <li>GenericAccessor.rolling_min()</li> <li>GenericAccessor.rolling_split()</li> <li>GenericAccessor.rolling_std()</li> <li>GenericAccessor.scale()</li> <li>GenericAccessor.scatterplot()</li> <li>GenericAccessor.self_aliases</li> <li>GenericAccessor.shuffle()</li> <li>GenericAccessor.split()</li> <li>GenericAccessor.sr_accessor_cls</li> <li>GenericAccessor.stats_defaults</li> <li>GenericAccessor.std()</li> <li>GenericAccessor.sum()</li> <li>GenericAccessor.to_mapped()</li> <li>GenericAccessor.to_returns()</li> <li>GenericAccessor.transform()</li> <li>GenericAccessor.value_counts()</li> <li>GenericAccessor.wrapper</li> <li>GenericAccessor.writeable_attrs</li> <li>GenericAccessor.zscore()</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li>ReturnsSRAccessor</li> <li>SignalsSRAccessor</li> <li>Vbt_SRAccessor</li> </ul>","title":"GenericSRAccessor class"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericSRAccessor.flatten_grouped","text":"<pre><code>GenericSRAccessor.flatten_grouped(\n    group_by=None,\n    order='C',\n    wrap_kwargs=None\n)\n</code></pre> <p>Flatten each group of elements.</p> <p>Based on GenericDFAccessor.flatten_grouped().</p>","title":"flatten_grouped method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericSRAccessor.heatmap","text":"<pre><code>GenericSRAccessor.heatmap(\n    x_level=None,\n    y_level=None,\n    symmetric=False,\n    sort=True,\n    x_labels=None,\n    y_labels=None,\n    slider_level=None,\n    active=0,\n    slider_labels=None,\n    return_fig=True,\n    fig=None,\n    **kwargs\n)\n</code></pre> <p>Create a heatmap figure based on object's multi-index and values.</p> <p>If index is not a multi-index, converts Series into a DataFrame and calls GenericDFAccessor.heatmap().</p> <p>If multi-index contains more than two levels or you want them in specific order, pass <code>x_level</code> and <code>y_level</code>, each (<code>int</code> if index or <code>str</code> if name) corresponding to an axis of the heatmap. Optionally, pass <code>slider_level</code> to use a level as a slider.</p> <p>Creates Heatmap and returns the figure.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; multi_index = pd.MultiIndex.from_tuples([\n...     (1, 1),\n...     (2, 2),\n...     (3, 3)\n... ])\n&gt;&gt;&gt; sr = pd.Series(np.arange(len(multi_index)), index=multi_index)\n&gt;&gt;&gt; sr\n1  1    0\n2  2    1\n3  3    2\ndtype: int64\n\n&gt;&gt;&gt; sr.vbt.heatmap()\n</code></pre> <p></p> <ul> <li>Using one level as a slider:</li> </ul> <pre><code>&gt;&gt;&gt; multi_index = pd.MultiIndex.from_tuples([\n...     (1, 1, 1),\n...     (1, 2, 2),\n...     (1, 3, 3),\n...     (2, 3, 3),\n...     (2, 2, 2),\n...     (2, 1, 1)\n... ])\n&gt;&gt;&gt; sr = pd.Series(np.arange(len(multi_index)), index=multi_index)\n&gt;&gt;&gt; sr\n1  1  1    0\n   2  2    1\n   3  3    2\n2  3  3    3\n   2  2    4\n   1  1    5\ndtype: int64\n\n&gt;&gt;&gt; sr.vbt.heatmap(slider_level=0)\n</code></pre> <p></p>","title":"heatmap method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericSRAccessor.overlay_with_heatmap","text":"<pre><code>GenericSRAccessor.overlay_with_heatmap(\n    other,\n    trace_kwargs=None,\n    heatmap_kwargs=None,\n    add_trace_kwargs=None,\n    fig=None,\n    **layout_kwargs\n)\n</code></pre> <p>Plot Series as a line and overlays it with a heatmap.</p> <p>Args</p>  <code>other</code> :\u2002<code>array_like</code> Second array. Will broadcast. <code>trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code>. <code>heatmap_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to GenericDFAccessor.heatmap(). <code>add_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>add_trace</code>. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**layout_kwargs</code> Keyword arguments for layout.  <p>Usage</p> <pre><code>&gt;&gt;&gt; df['a'].vbt.overlay_with_heatmap(df['b'])\n</code></pre> <p></p>","title":"overlay_with_heatmap method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericSRAccessor.plot_against","text":"<pre><code>GenericSRAccessor.plot_against(\n    other,\n    trace_kwargs=None,\n    other_trace_kwargs=None,\n    pos_trace_kwargs=None,\n    neg_trace_kwargs=None,\n    hidden_trace_kwargs=None,\n    add_trace_kwargs=None,\n    fig=None,\n    **layout_kwargs\n)\n</code></pre> <p>Plot Series as a line against another line.</p> <p>Args</p>  <code>other</code> :\u2002<code>array_like</code> Second array. Will broadcast. <code>trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code>. <code>other_trace_kwargs</code> :\u2002<code>dict</code>  <p>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code>other</code>.</p> <p>Set to 'hidden' to hide.</p>  <code>pos_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for positive line. <code>neg_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for negative line. <code>hidden_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for hidden lines. <code>add_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>add_trace</code>. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**layout_kwargs</code> Keyword arguments for layout.  <p>Usage</p> <pre><code>&gt;&gt;&gt; df['a'].vbt.plot_against(df['b'])\n</code></pre> <p></p>","title":"plot_against method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericSRAccessor.qqplot","text":"<pre><code>GenericSRAccessor.qqplot(\n    sparams=(),\n    dist='norm',\n    plot_line=True,\n    line_shape_kwargs=None,\n    xref='x',\n    yref='y',\n    fig=None,\n    **kwargs\n)\n</code></pre> <p>Plot probability plot using <code>scipy.stats.probplot</code>.</p> <p><code>**kwargs</code> are passed to GenericAccessor.scatterplot().</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; pd.Series(np.random.standard_normal(100)).vbt.qqplot()\n</code></pre> <p></p>","title":"qqplot method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericSRAccessor.squeeze_grouped","text":"<pre><code>GenericSRAccessor.squeeze_grouped(\n    squeeze_func_nb,\n    *args,\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Squeeze each group of elements into a single element.</p> <p>Based on GenericDFAccessor.squeeze_grouped().</p>","title":"squeeze_grouped method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericSRAccessor.ts_heatmap","text":"<pre><code>GenericSRAccessor.ts_heatmap(\n    **kwargs\n)\n</code></pre> <p>Heatmap of time-series data.</p>","title":"ts_heatmap method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.GenericSRAccessor.volume","text":"<pre><code>GenericSRAccessor.volume(\n    x_level=None,\n    y_level=None,\n    z_level=None,\n    x_labels=None,\n    y_labels=None,\n    z_labels=None,\n    slider_level=None,\n    slider_labels=None,\n    active=0,\n    scene_name='scene',\n    fillna=None,\n    fig=None,\n    return_fig=True,\n    **kwargs\n)\n</code></pre> <p>Create a 3D volume figure based on object's multi-index and values.</p> <p>If multi-index contains more than three levels or you want them in specific order, pass <code>x_level</code>, <code>y_level</code>, and <code>z_level</code>, each (<code>int</code> if index or <code>str</code> if name) corresponding to an axis of the volume. Optionally, pass <code>slider_level</code> to use a level as a slider.</p> <p>Creates Volume and returns the figure.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; multi_index = pd.MultiIndex.from_tuples([\n...     (1, 1, 1),\n...     (2, 2, 2),\n...     (3, 3, 3)\n... ])\n&gt;&gt;&gt; sr = pd.Series(np.arange(len(multi_index)), index=multi_index)\n&gt;&gt;&gt; sr\n1  1  1    0\n2  2  2    1\n3  3  3    2\ndtype: int64\n\n&gt;&gt;&gt; sr.vbt.volume().show()\n</code></pre> <p></p>","title":"volume method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.MetaGenericAccessor","text":"<pre><code>MetaGenericAccessor(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Meta class that exposes a read-only class property <code>StatsBuilderMixin.metrics</code>.</p> <p>Superclasses</p> <ul> <li>MetaPlotsBuilderMixin</li> <li>MetaStatsBuilderMixin</li> <li><code>builtins.type</code></li> </ul> <p>Inherited members</p> <ul> <li>MetaPlotsBuilderMixin.subplots</li> <li>MetaStatsBuilderMixin.metrics</li> </ul>","title":"MetaGenericAccessor class"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.TransformerT","text":"<pre><code>TransformerT(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Base class for protocol classes. Protocol classes are defined as::</p> <pre><code>class Proto(Protocol):\n    def meth(self) -&gt; int:\n        ...\n</code></pre> <p>Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example::</p> <p>    class C</p> <pre><code>def meth(self) -&gt; int:\n    return 0\n</code></pre> <p>def func(x: Proto) -&gt; int:     return x.meth()</p> <p>func(C())  # Passes static type check</p> <p>See PEP 544 for details. Protocol classes decorated with @typing_extensions.runtime act as simple-minded runtime protocol that checks only the presence of given attributes, ignoring their type signatures.</p> <p>Protocol classes can be generic, they are defined as::</p> <pre><code>class GenProto(Protocol[T]):\n    def meth(self) -&gt; T:\n        ...\n</code></pre> <p>Superclasses</p> <ul> <li><code>typing_extensions.Protocol</code></li> </ul>","title":"TransformerT class"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.TransformerT.fit_transform","text":"<pre><code>TransformerT.fit_transform(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"fit_transform method"},{"location":"api/generic/accessors/#vectorbt.generic.accessors.TransformerT.transform","text":"<pre><code>TransformerT.transform(\n    *args,\n    **kwargs\n)\n</code></pre>","title":"transform method"},{"location":"api/generic/decorators/","text":"<p>Class and function decorators.</p>","title":"decorators"},{"location":"api/generic/decorators/#vectorbt.generic.decorators.attach_nb_methods","text":"<pre><code>attach_nb_methods(\n    config\n)\n</code></pre> <p>Class decorator to add Numba methods.</p> <p><code>config</code> should contain target method names (keys) and dictionaries (values) with the following keys:</p> <ul> <li><code>func</code>: Function that should be wrapped. The first argument should expect a 2-dim array.</li> <li><code>is_reducing</code>: Whether the function is reducing. Defaults to False.</li> <li><code>path</code>: Path to the function for documentation. Defaults to <code>func.__name__</code>.</li> <li><code>replace_signature</code>: Whether to replace the target signature with the source signature. Defaults to True.</li> <li><code>wrap_kwargs</code>: Default keyword arguments for wrapping. Will be merged with the dict supplied by the user.     Defaults to <code>dict(name_or_index=target_name)</code> for reducing functions.</li> </ul> <p>The class should be a subclass of Wrapping.</p>","title":"attach_nb_methods function"},{"location":"api/generic/decorators/#vectorbt.generic.decorators.attach_transform_methods","text":"<pre><code>attach_transform_methods(\n    config\n)\n</code></pre> <p>Class decorator to add transformation methods.</p> <p><code>config</code> should contain target method names (keys) and dictionaries (values) with the following keys:</p> <ul> <li><code>transformer</code>: Transformer class/object.</li> <li><code>docstring</code>: Method docstring. Defaults to \"See <code>{transformer}.__name__</code>.\".</li> <li><code>replace_signature</code>: Whether to replace the target signature. Defaults to True.</li> </ul> <p>The class should be a subclass of GenericAccessor.</p>","title":"attach_transform_methods function"},{"location":"api/generic/drawdowns/","text":"<p>Base class for working with drawdown records.</p> <p>Drawdown records capture information on drawdowns. Since drawdowns are ranges, they subclass Ranges.</p>  <p>Warning</p> <p>Drawdowns return both recovered AND active drawdowns, which may skew your performance results. To only consider recovered drawdowns, you should explicitly query <code>recovered</code> attribute.</p>  <p>Using Drawdowns.from_ts(), you can generate drawdown records for any time series and analyze them right away.</p> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n\n&gt;&gt;&gt; start = '2019-10-01 UTC'  # crypto is in UTC\n&gt;&gt;&gt; end = '2020-01-01 UTC'\n&gt;&gt;&gt; price = vbt.YFData.download('BTC-USD', start=start, end=end).get('Close')\n&gt;&gt;&gt; price = price.rename(None)\n\n&gt;&gt;&gt; drawdowns = vbt.Drawdowns.from_ts(price, wrapper_kwargs=dict(freq='d'))\n\n&gt;&gt;&gt; drawdowns.records_readable\n   Drawdown Id  Column            Peak Timestamp           Start Timestamp  \\\n0            0       0 2019-10-02 00:00:00+00:00 2019-10-03 00:00:00+00:00\n1            1       0 2019-10-09 00:00:00+00:00 2019-10-10 00:00:00+00:00\n2            2       0 2019-10-27 00:00:00+00:00 2019-10-28 00:00:00+00:00\n\n           Valley Timestamp             End Timestamp   Peak Value  \\\n0 2019-10-06 00:00:00+00:00 2019-10-09 00:00:00+00:00  8393.041992\n1 2019-10-24 00:00:00+00:00 2019-10-25 00:00:00+00:00  8595.740234\n2 2019-12-17 00:00:00+00:00 2020-01-01 00:00:00+00:00  9551.714844\n\n   Valley Value    End Value     Status\n0   7988.155762  8595.740234  Recovered\n1   7493.488770  8660.700195  Recovered\n2   6640.515137  7200.174316     Active\n\n&gt;&gt;&gt; drawdowns.duration.max(wrap_kwargs=dict(to_timedelta=True))\nTimedelta('66 days 00:00:00')\n</code></pre>","title":"drawdowns"},{"location":"api/generic/drawdowns/#from-accessors","text":"<p>Moreover, all generic accessors have a property <code>drawdowns</code> and a method <code>get_drawdowns</code>:</p> <pre><code>&gt;&gt;&gt; # vectorbt.generic.accessors.GenericAccessor.drawdowns.coverage\n&gt;&gt;&gt; price.vbt.drawdowns.coverage()\n0.9354838709677419\n</code></pre>","title":"From accessors"},{"location":"api/generic/drawdowns/#stats","text":"<p>Hint</p> <p>See StatsBuilderMixin.stats() and Drawdowns.metrics.</p>  <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\n...     'a': [1, 2, 1, 3, 2],\n...     'b': [2, 3, 1, 2, 1]\n... })\n\n&gt;&gt;&gt; drawdowns = df.vbt(freq='d').drawdowns\n\n&gt;&gt;&gt; drawdowns['a'].stats()\nStart                                        0\nEnd                                          4\nPeriod                         5 days 00:00:00\nCoverage [%]                              40.0\nTotal Records                                2\nTotal Recovered Drawdowns                    1\nTotal Active Drawdowns                       1\nActive Drawdown [%]                  33.333333\nActive Duration                1 days 00:00:00\nActive Recovery [%]                        0.0\nActive Recovery Return [%]                 0.0\nActive Recovery Duration       0 days 00:00:00\nMax Drawdown [%]                          50.0\nAvg Drawdown [%]                          50.0\nMax Drawdown Duration          1 days 00:00:00\nAvg Drawdown Duration          1 days 00:00:00\nMax Recovery Return [%]                  200.0\nAvg Recovery Return [%]                  200.0\nMax Recovery Duration          1 days 00:00:00\nAvg Recovery Duration          1 days 00:00:00\nAvg Recovery Duration Ratio                1.0\nName: a, dtype: object\n</code></pre> <p>By default, the metrics <code>max_dd</code>, <code>avg_dd</code>, <code>max_dd_duration</code>, and <code>avg_dd_duration</code> do not include active drawdowns. To change that, pass <code>incl_active=True</code>:</p> <pre><code>&gt;&gt;&gt; drawdowns['a'].stats(settings=dict(incl_active=True))\nStart                                        0\nEnd                                          4\nPeriod                         5 days 00:00:00\nCoverage [%]                              40.0\nTotal Records                                2\nTotal Recovered Drawdowns                    1\nTotal Active Drawdowns                       1\nActive Drawdown [%]                  33.333333\nActive Duration                1 days 00:00:00\nActive Recovery [%]                        0.0\nActive Recovery Return [%]                 0.0\nActive Recovery Duration       0 days 00:00:00\nMax Drawdown [%]                          50.0\nAvg Drawdown [%]                     41.666667\nMax Drawdown Duration          1 days 00:00:00\nAvg Drawdown Duration          1 days 00:00:00\nMax Recovery Return [%]                  200.0\nAvg Recovery Return [%]                  200.0\nMax Recovery Duration          1 days 00:00:00\nAvg Recovery Duration          1 days 00:00:00\nAvg Recovery Duration Ratio                1.0\nName: a, dtype: object\n</code></pre> <p>StatsBuilderMixin.stats() also supports (re-)grouping:</p> <pre><code>&gt;&gt;&gt; drawdowns['a'].stats(group_by=True)\nUserWarning: Metric 'active_dd' does not support grouped data\nUserWarning: Metric 'active_duration' does not support grouped data\nUserWarning: Metric 'active_recovery' does not support grouped data\nUserWarning: Metric 'active_recovery_return' does not support grouped data\nUserWarning: Metric 'active_recovery_duration' does not support grouped data\n\nStart                                        0\nEnd                                          4\nPeriod                         5 days 00:00:00\nCoverage [%]                              40.0\nTotal Records                                2\nTotal Recovered Drawdowns                    1\nTotal Active Drawdowns                       1\nMax Drawdown [%]                          50.0\nAvg Drawdown [%]                          50.0\nMax Drawdown Duration          1 days 00:00:00\nAvg Drawdown Duration          1 days 00:00:00\nMax Recovery Return [%]                  200.0\nAvg Recovery Return [%]                  200.0\nMax Recovery Duration          1 days 00:00:00\nAvg Recovery Duration          1 days 00:00:00\nAvg Recovery Duration Ratio                1.0\nName: group, dtype: object\n</code></pre>","title":"Stats"},{"location":"api/generic/drawdowns/#plots","text":"<p>Hint</p> <p>See PlotsBuilderMixin.plots() and Drawdowns.subplots.</p>  <p>Drawdowns class has a single subplot based on Drawdowns.plot():</p> <pre><code>&gt;&gt;&gt; drawdowns['a'].plots()\n</code></pre> <p></p>","title":"Plots"},{"location":"api/generic/drawdowns/#vectorbt.generic.drawdowns.dd_attach_field_config","text":"<p>Config of fields to be attached to Drawdowns.</p> <pre><code>Config({\n    \"status\": {\n        \"attach_filters\": true\n    }\n})\n</code></pre>","title":"dd_attach_field_config variable"},{"location":"api/generic/drawdowns/#vectorbt.generic.drawdowns.dd_field_config","text":"<p>Field config for Drawdowns.</p> <pre><code>Config({\n    \"dtype\": {\n        \"id\": \"int64\",\n        \"col\": \"int64\",\n        \"peak_idx\": \"int64\",\n        \"start_idx\": \"int64\",\n        \"valley_idx\": \"int64\",\n        \"end_idx\": \"int64\",\n        \"peak_val\": \"float64\",\n        \"valley_val\": \"float64\",\n        \"end_val\": \"float64\",\n        \"status\": \"int64\"\n    },\n    \"settings\": {\n        \"id\": {\n            \"title\": \"Drawdown Id\"\n        },\n        \"peak_idx\": {\n            \"title\": \"Peak Timestamp\",\n            \"mapping\": \"index\"\n        },\n        \"valley_idx\": {\n            \"title\": \"Valley Timestamp\",\n            \"mapping\": \"index\"\n        },\n        \"peak_val\": {\n            \"title\": \"Peak Value\"\n        },\n        \"valley_val\": {\n            \"title\": \"Valley Value\"\n        },\n        \"end_val\": {\n            \"title\": \"End Value\"\n        },\n        \"status\": {\n            \"mapping\": {\n                \"Active\": 0,\n                \"Recovered\": 1\n            }\n        }\n    }\n})\n</code></pre>","title":"dd_field_config variable"},{"location":"api/generic/drawdowns/#vectorbt.generic.drawdowns.Drawdowns","text":"<pre><code>Drawdowns(\n    wrapper,\n    records_arr,\n    ts=None,\n    **kwargs\n)\n</code></pre> <p>Extends Ranges for working with drawdown records.</p> <p>Requires <code>records_arr</code> to have all fields defined in drawdown_dt.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>Ranges</li> <li>Records</li> <li>RecordsWithFields</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>Ranges.avg_duration()</li> <li>Ranges.closed</li> <li>Ranges.col</li> <li>Ranges.col_arr</li> <li>Ranges.col_mapper</li> <li>Ranges.config</li> <li>Ranges.coverage()</li> <li>Ranges.duration</li> <li>Ranges.end_idx</li> <li>Ranges.id</li> <li>Ranges.id_arr</li> <li>Ranges.idx_arr</li> <li>Ranges.iloc</li> <li>Ranges.indexing_kwargs</li> <li>Ranges.loc</li> <li>Ranges.max_duration()</li> <li>Ranges.open</li> <li>Ranges.records</li> <li>Ranges.records_arr</li> <li>Ranges.records_readable</li> <li>Ranges.self_aliases</li> <li>Ranges.start_idx</li> <li>Ranges.status</li> <li>Ranges.to_mask()</li> <li>Ranges.ts</li> <li>Ranges.values</li> <li>Ranges.wrapper</li> <li>Ranges.writeable_attrs</li> <li>Records.apply()</li> <li>Records.apply_mask()</li> <li>Records.build_field_config_doc()</li> <li>Records.count()</li> <li>Records.get_apply_mapping_arr()</li> <li>Records.get_by_col_idxs()</li> <li>Records.get_field_arr()</li> <li>Records.get_field_mapping()</li> <li>Records.get_field_name()</li> <li>Records.get_field_setting()</li> <li>Records.get_field_title()</li> <li>Records.get_map_field()</li> <li>Records.get_map_field_to_index()</li> <li>Records.indexing_func_meta()</li> <li>Records.is_sorted()</li> <li>Records.map()</li> <li>Records.map_array()</li> <li>Records.map_field()</li> <li>Records.override_field_config_doc()</li> <li>Records.replace()</li> <li>Records.sort()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul>","title":"Drawdowns class"},{"location":"api/generic/drawdowns/#vectorbt.generic.drawdowns.Drawdowns.field_config","text":"<p>Field config of Drawdowns.</p> <pre><code>Config({\n    \"dtype\": {\n        \"id\": \"int64\",\n        \"col\": \"int64\",\n        \"peak_idx\": \"int64\",\n        \"start_idx\": \"int64\",\n        \"valley_idx\": \"int64\",\n        \"end_idx\": \"int64\",\n        \"peak_val\": \"float64\",\n        \"valley_val\": \"float64\",\n        \"end_val\": \"float64\",\n        \"status\": \"int64\"\n    },\n    \"settings\": {\n        \"id\": {\n            \"name\": \"id\",\n            \"title\": \"Drawdown Id\"\n        },\n        \"col\": {\n            \"name\": \"col\",\n            \"title\": \"Column\",\n            \"mapping\": \"columns\"\n        },\n        \"idx\": {\n            \"name\": \"end_idx\",\n            \"title\": \"Timestamp\",\n            \"mapping\": \"index\"\n        },\n        \"start_idx\": {\n            \"title\": \"Start Timestamp\",\n            \"mapping\": \"index\"\n        },\n        \"end_idx\": {\n            \"title\": \"End Timestamp\",\n            \"mapping\": \"index\"\n        },\n        \"status\": {\n            \"title\": \"Status\",\n            \"mapping\": {\n                \"Active\": 0,\n                \"Recovered\": 1\n            }\n        },\n        \"peak_idx\": {\n            \"title\": \"Peak Timestamp\",\n            \"mapping\": \"index\"\n        },\n        \"valley_idx\": {\n            \"title\": \"Valley Timestamp\",\n            \"mapping\": \"index\"\n        },\n        \"peak_val\": {\n            \"title\": \"Peak Value\"\n        },\n        \"valley_val\": {\n            \"title\": \"Valley Value\"\n        },\n        \"end_val\": {\n            \"title\": \"End Value\"\n        }\n    }\n})\n</code></pre>","title":"field_config class variable"},{"location":"api/generic/drawdowns/#vectorbt.generic.drawdowns.Drawdowns.metrics","text":"<p>Metrics supported by Drawdowns.</p> <pre><code>Config({\n    \"start\": {\n        \"title\": \"Start\",\n        \"calc_func\": \"&lt;function Drawdowns.&lt;lambda&gt; at 0x7ff533634c80&gt;\",\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"end\": {\n        \"title\": \"End\",\n        \"calc_func\": \"&lt;function Drawdowns.&lt;lambda&gt; at 0x7ff533634d08&gt;\",\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"period\": {\n        \"title\": \"Period\",\n        \"calc_func\": \"&lt;function Drawdowns.&lt;lambda&gt; at 0x7ff533634d90&gt;\",\n        \"apply_to_timedelta\": true,\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"coverage\": {\n        \"title\": \"Coverage [%]\",\n        \"calc_func\": \"coverage\",\n        \"post_calc_func\": \"&lt;function Drawdowns.&lt;lambda&gt; at 0x7ff533634e18&gt;\",\n        \"tags\": [\n            \"ranges\",\n            \"duration\"\n        ]\n    },\n    \"total_records\": {\n        \"title\": \"Total Records\",\n        \"calc_func\": \"count\",\n        \"tags\": \"records\"\n    },\n    \"total_recovered\": {\n        \"title\": \"Total Recovered Drawdowns\",\n        \"calc_func\": \"recovered.count\",\n        \"tags\": \"drawdowns\"\n    },\n    \"total_active\": {\n        \"title\": \"Total Active Drawdowns\",\n        \"calc_func\": \"active.count\",\n        \"tags\": \"drawdowns\"\n    },\n    \"active_dd\": {\n        \"title\": \"Active Drawdown [%]\",\n        \"calc_func\": \"active_drawdown\",\n        \"post_calc_func\": \"&lt;function Drawdowns.&lt;lambda&gt; at 0x7ff533634ea0&gt;\",\n        \"check_is_not_grouped\": true,\n        \"tags\": [\n            \"drawdowns\",\n            \"active\"\n        ]\n    },\n    \"active_duration\": {\n        \"title\": \"Active Duration\",\n        \"calc_func\": \"active_duration\",\n        \"fill_wrap_kwargs\": true,\n        \"check_is_not_grouped\": true,\n        \"tags\": [\n            \"drawdowns\",\n            \"active\",\n            \"duration\"\n        ]\n    },\n    \"active_recovery\": {\n        \"title\": \"Active Recovery [%]\",\n        \"calc_func\": \"active_recovery\",\n        \"post_calc_func\": \"&lt;function Drawdowns.&lt;lambda&gt; at 0x7ff533634f28&gt;\",\n        \"check_is_not_grouped\": true,\n        \"tags\": [\n            \"drawdowns\",\n            \"active\"\n        ]\n    },\n    \"active_recovery_return\": {\n        \"title\": \"Active Recovery Return [%]\",\n        \"calc_func\": \"active_recovery_return\",\n        \"post_calc_func\": \"&lt;function Drawdowns.&lt;lambda&gt; at 0x7ff533628048&gt;\",\n        \"check_is_not_grouped\": true,\n        \"tags\": [\n            \"drawdowns\",\n            \"active\"\n        ]\n    },\n    \"active_recovery_duration\": {\n        \"title\": \"Active Recovery Duration\",\n        \"calc_func\": \"active_recovery_duration\",\n        \"fill_wrap_kwargs\": true,\n        \"check_is_not_grouped\": true,\n        \"tags\": [\n            \"drawdowns\",\n            \"active\",\n            \"duration\"\n        ]\n    },\n    \"max_dd\": {\n        \"title\": \"Max Drawdown [%]\",\n        \"calc_func\": \"RepEval(expression=\\\"'max_drawdown' if incl_active else 'recovered.max_drawdown'\\\", mapping={})\",\n        \"post_calc_func\": \"&lt;function Drawdowns.&lt;lambda&gt; at 0x7ff5336280d0&gt;\",\n        \"tags\": \"RepEval(expression=\\\"['drawdowns'] if incl_active else ['drawdowns', 'recovered']\\\", mapping={})\"\n    },\n    \"avg_dd\": {\n        \"title\": \"Avg Drawdown [%]\",\n        \"calc_func\": \"RepEval(expression=\\\"'avg_drawdown' if incl_active else 'recovered.avg_drawdown'\\\", mapping={})\",\n        \"post_calc_func\": \"&lt;function Drawdowns.&lt;lambda&gt; at 0x7ff533628158&gt;\",\n        \"tags\": \"RepEval(expression=\\\"['drawdowns'] if incl_active else ['drawdowns', 'recovered']\\\", mapping={})\"\n    },\n    \"max_dd_duration\": {\n        \"title\": \"Max Drawdown Duration\",\n        \"calc_func\": \"RepEval(expression=\\\"'max_duration' if incl_active else 'recovered.max_duration'\\\", mapping={})\",\n        \"fill_wrap_kwargs\": true,\n        \"tags\": \"RepEval(expression=\\\"['drawdowns', 'duration'] if incl_active else ['drawdowns', 'recovered', 'duration']\\\", mapping={})\"\n    },\n    \"avg_dd_duration\": {\n        \"title\": \"Avg Drawdown Duration\",\n        \"calc_func\": \"RepEval(expression=\\\"'avg_duration' if incl_active else 'recovered.avg_duration'\\\", mapping={})\",\n        \"fill_wrap_kwargs\": true,\n        \"tags\": \"RepEval(expression=\\\"['drawdowns', 'duration'] if incl_active else ['drawdowns', 'recovered', 'duration']\\\", mapping={})\"\n    },\n    \"max_return\": {\n        \"title\": \"Max Recovery Return [%]\",\n        \"calc_func\": \"recovered.recovery_return.max\",\n        \"post_calc_func\": \"&lt;function Drawdowns.&lt;lambda&gt; at 0x7ff5336281e0&gt;\",\n        \"tags\": [\n            \"drawdowns\",\n            \"recovered\"\n        ]\n    },\n    \"avg_return\": {\n        \"title\": \"Avg Recovery Return [%]\",\n        \"calc_func\": \"recovered.recovery_return.mean\",\n        \"post_calc_func\": \"&lt;function Drawdowns.&lt;lambda&gt; at 0x7ff533628268&gt;\",\n        \"tags\": [\n            \"drawdowns\",\n            \"recovered\"\n        ]\n    },\n    \"max_recovery_duration\": {\n        \"title\": \"Max Recovery Duration\",\n        \"calc_func\": \"recovered.recovery_duration.max\",\n        \"apply_to_timedelta\": true,\n        \"tags\": [\n            \"drawdowns\",\n            \"recovered\",\n            \"duration\"\n        ]\n    },\n    \"avg_recovery_duration\": {\n        \"title\": \"Avg Recovery Duration\",\n        \"calc_func\": \"recovered.recovery_duration.mean\",\n        \"apply_to_timedelta\": true,\n        \"tags\": [\n            \"drawdowns\",\n            \"recovered\",\n            \"duration\"\n        ]\n    },\n    \"recovery_duration_ratio\": {\n        \"title\": \"Avg Recovery Duration Ratio\",\n        \"calc_func\": \"recovered.recovery_duration_ratio.mean\",\n        \"tags\": [\n            \"drawdowns\",\n            \"recovered\"\n        ]\n    }\n})\n</code></pre> <p>Returns <code>Drawdowns._metrics</code>, which gets (deep) copied upon creation of each instance. Thus, changing this config won't affect the class.</p> <p>To change metrics, you can either change the config in-place, override this property, or overwrite the instance variable <code>Drawdowns._metrics</code>.</p>","title":"metrics class variable"},{"location":"api/generic/drawdowns/#vectorbt.generic.drawdowns.Drawdowns.subplots","text":"<p>Subplots supported by Drawdowns.</p> <pre><code>Config({\n    \"plot\": {\n        \"title\": \"Drawdowns\",\n        \"check_is_not_grouped\": true,\n        \"plot_func\": \"plot\",\n        \"tags\": \"drawdowns\"\n    }\n})\n</code></pre> <p>Returns <code>Drawdowns._subplots</code>, which gets (deep) copied upon creation of each instance. Thus, changing this config won't affect the class.</p> <p>To change subplots, you can either change the config in-place, override this property, or overwrite the instance variable <code>Drawdowns._subplots</code>.</p>","title":"subplots class variable"},{"location":"api/generic/drawdowns/#vectorbt.generic.drawdowns.Drawdowns.from_ts","text":"<pre><code>Drawdowns.from_ts(\n    ts,\n    attach_ts=True,\n    wrapper_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Build Drawdowns from time series <code>ts</code>.</p> <p><code>**kwargs</code> will be passed to Drawdowns.</p>","title":"from_ts class method"},{"location":"api/generic/drawdowns/#vectorbt.generic.drawdowns.Drawdowns.active","text":"<p>Records filtered by <code>status == 0</code>.</p>","title":"active variable"},{"location":"api/generic/drawdowns/#vectorbt.generic.drawdowns.Drawdowns.decline_duration","text":"<p>See dd_decline_duration_nb().</p> <p>Takes into account both recovered and active drawdowns.</p>","title":"decline_duration variable"},{"location":"api/generic/drawdowns/#vectorbt.generic.drawdowns.Drawdowns.drawdown","text":"<p>See dd_drawdown_nb().</p> <p>Takes into account both recovered and active drawdowns.</p>","title":"drawdown variable"},{"location":"api/generic/drawdowns/#vectorbt.generic.drawdowns.Drawdowns.end_val","text":"<p>Mapped array of the field <code>end_val</code>.</p>","title":"end_val variable"},{"location":"api/generic/drawdowns/#vectorbt.generic.drawdowns.Drawdowns.peak_idx","text":"<p>Mapped array of the field <code>peak_idx</code>.</p>","title":"peak_idx variable"},{"location":"api/generic/drawdowns/#vectorbt.generic.drawdowns.Drawdowns.peak_val","text":"<p>Mapped array of the field <code>peak_val</code>.</p>","title":"peak_val variable"},{"location":"api/generic/drawdowns/#vectorbt.generic.drawdowns.Drawdowns.plots_defaults","text":"<p>Defaults for PlotsBuilderMixin.plots().</p> <p>Merges Ranges.plots_defaults and <code>drawdowns.plots</code> from settings.</p>","title":"plots_defaults property"},{"location":"api/generic/drawdowns/#vectorbt.generic.drawdowns.Drawdowns.recovered","text":"<p>Records filtered by <code>status == 1</code>.</p>","title":"recovered variable"},{"location":"api/generic/drawdowns/#vectorbt.generic.drawdowns.Drawdowns.recovery_duration","text":"<p>See dd_recovery_duration_nb().</p> <p>A value higher than 1 means the recovery was slower than the decline.</p> <p>Takes into account both recovered and active drawdowns.</p>","title":"recovery_duration variable"},{"location":"api/generic/drawdowns/#vectorbt.generic.drawdowns.Drawdowns.recovery_duration_ratio","text":"<p>See dd_recovery_duration_ratio_nb().</p> <p>Takes into account both recovered and active drawdowns.</p>","title":"recovery_duration_ratio variable"},{"location":"api/generic/drawdowns/#vectorbt.generic.drawdowns.Drawdowns.recovery_return","text":"<p>See dd_recovery_return_nb().</p> <p>Takes into account both recovered and active drawdowns.</p>","title":"recovery_return variable"},{"location":"api/generic/drawdowns/#vectorbt.generic.drawdowns.Drawdowns.stats_defaults","text":"<p>Defaults for StatsBuilderMixin.stats().</p> <p>Merges Ranges.stats_defaults and <code>drawdowns.stats</code> from settings.</p>","title":"stats_defaults property"},{"location":"api/generic/drawdowns/#vectorbt.generic.drawdowns.Drawdowns.valley_idx","text":"<p>Mapped array of the field <code>valley_idx</code>.</p>","title":"valley_idx variable"},{"location":"api/generic/drawdowns/#vectorbt.generic.drawdowns.Drawdowns.valley_val","text":"<p>Mapped array of the field <code>valley_val</code>.</p>","title":"valley_val variable"},{"location":"api/generic/drawdowns/#vectorbt.generic.drawdowns.Drawdowns.active_drawdown","text":"<pre><code>Drawdowns.active_drawdown(\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Drawdown of the last active drawdown only.</p> <p>Does not support grouping.</p>","title":"active_drawdown method"},{"location":"api/generic/drawdowns/#vectorbt.generic.drawdowns.Drawdowns.active_duration","text":"<pre><code>Drawdowns.active_duration(\n    group_by=None,\n    wrap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Duration of the last active drawdown only.</p> <p>Does not support grouping.</p>","title":"active_duration method"},{"location":"api/generic/drawdowns/#vectorbt.generic.drawdowns.Drawdowns.active_recovery","text":"<pre><code>Drawdowns.active_recovery(\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Recovery of the last active drawdown only.</p> <p>Does not support grouping.</p>","title":"active_recovery method"},{"location":"api/generic/drawdowns/#vectorbt.generic.drawdowns.Drawdowns.active_recovery_duration","text":"<pre><code>Drawdowns.active_recovery_duration(\n    group_by=None,\n    wrap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Recovery duration of the last active drawdown only.</p> <p>Does not support grouping.</p>","title":"active_recovery_duration method"},{"location":"api/generic/drawdowns/#vectorbt.generic.drawdowns.Drawdowns.active_recovery_return","text":"<pre><code>Drawdowns.active_recovery_return(\n    group_by=None,\n    wrap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Recovery return of the last active drawdown only.</p> <p>Does not support grouping.</p>","title":"active_recovery_return method"},{"location":"api/generic/drawdowns/#vectorbt.generic.drawdowns.Drawdowns.avg_drawdown","text":"<pre><code>Drawdowns.avg_drawdown(\n    group_by=None,\n    wrap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Average drawdown (ADD).</p> <p>Based on Drawdowns.drawdown.</p>","title":"avg_drawdown method"},{"location":"api/generic/drawdowns/#vectorbt.generic.drawdowns.Drawdowns.avg_recovery_return","text":"<pre><code>Drawdowns.avg_recovery_return(\n    group_by=None,\n    wrap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Average recovery return.</p> <p>Based on Drawdowns.recovery_return.</p>","title":"avg_recovery_return method"},{"location":"api/generic/drawdowns/#vectorbt.generic.drawdowns.Drawdowns.indexing_func","text":"<pre><code>Drawdowns.indexing_func(\n    pd_indexing_func,\n    **kwargs\n)\n</code></pre> <p>Perform indexing on Drawdowns.</p>","title":"indexing_func method"},{"location":"api/generic/drawdowns/#vectorbt.generic.drawdowns.Drawdowns.max_drawdown","text":"<pre><code>Drawdowns.max_drawdown(\n    group_by=None,\n    wrap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Maximum drawdown (MDD).</p> <p>Based on Drawdowns.drawdown.</p>","title":"max_drawdown method"},{"location":"api/generic/drawdowns/#vectorbt.generic.drawdowns.Drawdowns.max_recovery_return","text":"<pre><code>Drawdowns.max_recovery_return(\n    group_by=None,\n    wrap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Maximum recovery return.</p> <p>Based on Drawdowns.recovery_return.</p>","title":"max_recovery_return method"},{"location":"api/generic/drawdowns/#vectorbt.generic.drawdowns.Drawdowns.plot","text":"<pre><code>Drawdowns.plot(\n    column=None,\n    top_n=5,\n    plot_zones=True,\n    ts_trace_kwargs=None,\n    peak_trace_kwargs=None,\n    valley_trace_kwargs=None,\n    recovery_trace_kwargs=None,\n    active_trace_kwargs=None,\n    decline_shape_kwargs=None,\n    recovery_shape_kwargs=None,\n    active_shape_kwargs=None,\n    add_trace_kwargs=None,\n    xref='x',\n    yref='y',\n    fig=None,\n    **layout_kwargs\n)\n</code></pre> <p>Plot drawdowns.</p> <p>Args</p>  <code>column</code> :\u2002<code>str</code> Name of the column to plot. <code>top_n</code> :\u2002<code>int</code> Filter top N drawdown records by maximum drawdown. <code>plot_zones</code> :\u2002<code>bool</code> Whether to plot zones. <code>ts_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for Drawdowns.ts. <code>peak_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for peak values. <code>valley_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for valley values. <code>recovery_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for recovery values. <code>active_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for active recovery values. <code>decline_shape_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for decline zones. <code>recovery_shape_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for recovery zones. <code>active_shape_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for active recovery zones. <code>add_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>add_trace</code>. <code>xref</code> :\u2002<code>str</code> X coordinate axis. <code>yref</code> :\u2002<code>str</code> Y coordinate axis. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**layout_kwargs</code> Keyword arguments for layout.  <p>Usage</p> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n&gt;&gt;&gt; from datetime import datetime, timedelta\n&gt;&gt;&gt; import pandas as pd\n\n&gt;&gt;&gt; price = pd.Series([1, 2, 1, 2, 3, 2, 1, 2], name='Price')\n&gt;&gt;&gt; price.index = [datetime(2020, 1, 1) + timedelta(days=i) for i in range(len(price))]\n&gt;&gt;&gt; vbt.Drawdowns.from_ts(price, wrapper_kwargs=dict(freq='1 day')).plot()\n</code></pre> <p></p>","title":"plot method"},{"location":"api/generic/enums/","text":"<p>Named tuples and enumerated types.</p> <p>Defines enums and other schemas for vectorbt.generic.</p>","title":"enums"},{"location":"api/generic/enums/#vectorbt.generic.enums.DrawdownStatus","text":"<p>Drawdown status.</p> <pre><code>{\n    \"Active\": 0,\n    \"Recovered\": 1\n}\n</code></pre>","title":"DrawdownStatus variable"},{"location":"api/generic/enums/#vectorbt.generic.enums.RangeStatus","text":"<p>Range status.</p> <pre><code>{\n    \"Open\": 0,\n    \"Closed\": 1\n}\n</code></pre>","title":"RangeStatus variable"},{"location":"api/generic/enums/#vectorbt.generic.enums.drawdown_dt","text":"<p><code>np.dtype</code> of drawdown records.</p> <pre><code>{\n    \"id\": \"int64\",\n    \"col\": \"int64\",\n    \"peak_idx\": \"int64\",\n    \"start_idx\": \"int64\",\n    \"valley_idx\": \"int64\",\n    \"end_idx\": \"int64\",\n    \"peak_val\": \"float64\",\n    \"valley_val\": \"float64\",\n    \"end_val\": \"float64\",\n    \"status\": \"int64\"\n}\n</code></pre>","title":"drawdown_dt variable"},{"location":"api/generic/enums/#vectorbt.generic.enums.range_dt","text":"<p><code>np.dtype</code> of range records.</p> <pre><code>{\n    \"id\": \"int64\",\n    \"col\": \"int64\",\n    \"start_idx\": \"int64\",\n    \"end_idx\": \"int64\",\n    \"status\": \"int64\"\n}\n</code></pre>","title":"range_dt variable"},{"location":"api/generic/nb/","text":"<p>Numba-compiled functions.</p> <p>Provides an arsenal of Numba-compiled functions that are used by accessors and in many other parts of the backtesting pipeline, such as technical indicators. These only accept NumPy arrays and other Numba-compatible types.</p> <p>The module can be accessed directly via <code>vbt.nb</code>.</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; # vectorbt.generic.nb.rolling_mean_1d_nb\n&gt;&gt;&gt; vbt.nb.rolling_mean_1d_nb(np.array([1, 2, 3, 4]), 2)\narray([nan, 1.5, 2.5, 3.5])\n</code></pre>  <p>Note</p> <p>vectorbt treats matrices as first-class citizens and expects input arrays to be 2-dim, unless function has suffix <code>_1d</code> or is meant to be input to another function.  Data is processed along index (axis 0).</p> <p>Rolling functions with <code>minp=None</code> have <code>min_periods</code> set to the window size.</p> <p>All functions passed as argument should be Numba-compiled.</p>","title":"nb"},{"location":"api/generic/nb/#vectorbt.generic.nb.any_squeeze_nb","text":"<pre><code>any_squeeze_nb(\n    col,\n    group,\n    a\n)\n</code></pre> <p>Return any (ignores NaNs) of a group.</p>","title":"any_squeeze_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.apply_and_reduce_nb","text":"<pre><code>apply_and_reduce_nb(\n    a,\n    apply_func_nb,\n    apply_args,\n    reduce_func_nb,\n    reduce_args\n)\n</code></pre> <p>Apply <code>apply_func_nb</code> on each column and reduce into a single value using <code>reduce_func_nb</code>.</p> <p><code>apply_func_nb</code> should accept index of the column, the column itself, and <code>*apply_args</code>. Should return an array.</p> <p><code>reduce_func_nb</code> should accept index of the column, the array of results from <code>apply_func_nb</code> for that column, and <code>*reduce_args</code>. Should return a single value.</p>","title":"apply_and_reduce_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.apply_nb","text":"<pre><code>apply_nb(\n    a,\n    apply_func_nb,\n    *args\n)\n</code></pre> <p>Apply function on each column.</p> <p><code>apply_func_nb</code> should accept index of the column, the array, and <code>*args</code>. Should return a single value or an array of shape <code>a.shape[1]</code>.</p>","title":"apply_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.applymap_nb","text":"<pre><code>applymap_nb(\n    a,\n    map_func_nb,\n    *args\n)\n</code></pre> <p>Map non-NA elements element-wise using <code>map_func_nb</code>.</p> <p><code>map_func_nb</code> should accept index of the row, index of the column, the element itself, and <code>*args</code>. Should return a single value.</p>","title":"applymap_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.argmax_reduce_nb","text":"<pre><code>argmax_reduce_nb(\n    col,\n    a\n)\n</code></pre> <p>Return position of max.</p>","title":"argmax_reduce_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.argmin_reduce_nb","text":"<pre><code>argmin_reduce_nb(\n    col,\n    a\n)\n</code></pre> <p>Return position of min.</p>","title":"argmin_reduce_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.bfill_1d_nb","text":"<pre><code>bfill_1d_nb(\n    a\n)\n</code></pre> <p>Fill NaNs by propagating first valid observation backward.</p> <p>Numba equivalent to <code>pd.Series(a).fillna(method='bfill')</code>.</p>  <p>Warning</p> <p>This operation looks ahead.</p>","title":"bfill_1d_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.bfill_nb","text":"<pre><code>bfill_nb(\n    a\n)\n</code></pre> <p>2-dim version of bfill_1d_nb().</p>","title":"bfill_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.bshift_1d_nb","text":"<pre><code>bshift_1d_nb(\n    a,\n    n=1,\n    fill_value=nan\n)\n</code></pre> <p>Shift backward by <code>n</code> positions.</p> <p>Numba equivalent to <code>pd.Series(a).shift(n)</code>.</p>  <p>Warning</p> <p>This operation looks ahead.</p>","title":"bshift_1d_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.bshift_nb","text":"<pre><code>bshift_nb(\n    a,\n    n=1,\n    fill_value=nan\n)\n</code></pre> <p>2-dim version of bshift_1d_nb().</p>","title":"bshift_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.count_reduce_nb","text":"<pre><code>count_reduce_nb(\n    col,\n    a\n)\n</code></pre> <p>Return count (ignores NaNs).</p>","title":"count_reduce_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.crossed_above_1d_nb","text":"<pre><code>crossed_above_1d_nb(\n    arr1,\n    arr2,\n    wait=0\n)\n</code></pre> <p>Get the crossover of the first array going above the second array.</p>","title":"crossed_above_1d_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.crossed_above_nb","text":"<pre><code>crossed_above_nb(\n    arr1,\n    arr2,\n    wait=0\n)\n</code></pre> <p>2-dim version of crossed_above_1d_nb().</p>","title":"crossed_above_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.dd_decline_duration_nb","text":"<pre><code>dd_decline_duration_nb(\n    start_idx_arr,\n    valley_idx_arr\n)\n</code></pre> <p>Return the duration of the peak-to-valley phase of each drawdown record.</p>","title":"dd_decline_duration_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.dd_drawdown_nb","text":"<pre><code>dd_drawdown_nb(\n    peak_val_arr,\n    valley_val_arr\n)\n</code></pre> <p>Return the drawdown of each drawdown record.</p>","title":"dd_drawdown_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.dd_recovery_duration_nb","text":"<pre><code>dd_recovery_duration_nb(\n    valley_idx_arr,\n    end_idx_arr\n)\n</code></pre> <p>Return the duration of the valley-to-recovery phase of each drawdown record.</p>","title":"dd_recovery_duration_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.dd_recovery_duration_ratio_nb","text":"<pre><code>dd_recovery_duration_ratio_nb(\n    start_idx_arr,\n    valley_idx_arr,\n    end_idx_arr\n)\n</code></pre> <p>Return the ratio of the recovery duration to the decline duration of each drawdown record.</p>","title":"dd_recovery_duration_ratio_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.dd_recovery_return_nb","text":"<pre><code>dd_recovery_return_nb(\n    valley_val_arr,\n    end_val_arr\n)\n</code></pre> <p>Return the recovery return of each drawdown record.</p>","title":"dd_recovery_return_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.describe_reduce_nb","text":"<pre><code>describe_reduce_nb(\n    col,\n    a,\n    perc,\n    ddof\n)\n</code></pre> <p>Return descriptive statistics (ignores NaNs).</p> <p>Numba equivalent to <code>pd.Series(a).describe(perc)</code>.</p>","title":"describe_reduce_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.diff_1d_nb","text":"<pre><code>diff_1d_nb(\n    a,\n    n=1\n)\n</code></pre> <p>Return the 1-th discrete difference.</p> <p>Numba equivalent to <code>pd.Series(a).diff()</code>.</p>","title":"diff_1d_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.diff_nb","text":"<pre><code>diff_nb(\n    a,\n    n=1\n)\n</code></pre> <p>2-dim version of diff_1d_nb().</p>","title":"diff_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.ewm_mean_1d_nb","text":"<pre><code>ewm_mean_1d_nb(\n    a,\n    span,\n    minp=0,\n    adjust=False\n)\n</code></pre> <p>Return exponential weighted average.</p> <p>Numba equivalent to <code>pd.Series(a).ewm(span=span, min_periods=minp, adjust=adjust).mean()</code>.</p> <p>Adaptation of <code>pd._libs.window.aggregations.window_aggregations.ewma</code> with default arguments.</p>","title":"ewm_mean_1d_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.ewm_mean_nb","text":"<pre><code>ewm_mean_nb(\n    a,\n    span,\n    minp=0,\n    adjust=False\n)\n</code></pre> <p>2-dim version of ewm_mean_1d_nb().</p>","title":"ewm_mean_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.ewm_std_1d_nb","text":"<pre><code>ewm_std_1d_nb(\n    a,\n    span,\n    minp=0,\n    adjust=False,\n    ddof=0\n)\n</code></pre> <p>Return exponential weighted standard deviation.</p> <p>Numba equivalent to <code>pd.Series(a).ewm(span=span, min_periods=minp).std(ddof=ddof)</code>.</p> <p>Adaptation of <code>pd._libs.window.aggregations.window_aggregations.ewmcov</code> with default arguments.</p>","title":"ewm_std_1d_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.ewm_std_nb","text":"<pre><code>ewm_std_nb(\n    a,\n    span,\n    minp=0,\n    adjust=False,\n    ddof=0\n)\n</code></pre> <p>2-dim version of ewm_std_1d_nb().</p>","title":"ewm_std_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.expanding_apply_nb","text":"<pre><code>expanding_apply_nb(\n    a,\n    minp,\n    apply_func_nb,\n    *args\n)\n</code></pre> <p>Expanding version of rolling_apply_nb().</p>","title":"expanding_apply_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.expanding_matrix_apply_nb","text":"<pre><code>expanding_matrix_apply_nb(\n    a,\n    minp,\n    apply_func_nb,\n    *args\n)\n</code></pre> <p>Expanding version of rolling_matrix_apply_nb().</p>","title":"expanding_matrix_apply_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.expanding_max_1d_nb","text":"<pre><code>expanding_max_1d_nb(\n    a,\n    minp=1\n)\n</code></pre> <p>Return expanding max.</p> <p>Numba equivalent to <code>pd.Series(a).expanding(min_periods=minp).max()</code>.</p>","title":"expanding_max_1d_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.expanding_max_nb","text":"<pre><code>expanding_max_nb(\n    a,\n    minp=1\n)\n</code></pre> <p>2-dim version of expanding_max_1d_nb().</p>","title":"expanding_max_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.expanding_mean_1d_nb","text":"<pre><code>expanding_mean_1d_nb(\n    a,\n    minp=1\n)\n</code></pre> <p>Return expanding mean.</p> <p>Numba equivalent to <code>pd.Series(a).expanding(min_periods=minp).mean()</code>.</p>","title":"expanding_mean_1d_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.expanding_mean_nb","text":"<pre><code>expanding_mean_nb(\n    a,\n    minp=1\n)\n</code></pre> <p>2-dim version of expanding_mean_1d_nb().</p>","title":"expanding_mean_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.expanding_min_1d_nb","text":"<pre><code>expanding_min_1d_nb(\n    a,\n    minp=1\n)\n</code></pre> <p>Return expanding min.</p> <p>Numba equivalent to <code>pd.Series(a).expanding(min_periods=minp).min()</code>.</p>","title":"expanding_min_1d_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.expanding_min_nb","text":"<pre><code>expanding_min_nb(\n    a,\n    minp=1\n)\n</code></pre> <p>2-dim version of expanding_min_1d_nb().</p>","title":"expanding_min_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.expanding_std_1d_nb","text":"<pre><code>expanding_std_1d_nb(\n    a,\n    minp=1,\n    ddof=0\n)\n</code></pre> <p>Return expanding standard deviation.</p> <p>Numba equivalent to <code>pd.Series(a).expanding(min_periods=minp).std(ddof=ddof)</code>.</p>","title":"expanding_std_1d_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.expanding_std_nb","text":"<pre><code>expanding_std_nb(\n    a,\n    minp=1,\n    ddof=0\n)\n</code></pre> <p>2-dim version of expanding_std_1d_nb().</p>","title":"expanding_std_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.ffill_1d_nb","text":"<pre><code>ffill_1d_nb(\n    a\n)\n</code></pre> <p>Fill NaNs by propagating last valid observation forward.</p> <p>Numba equivalent to <code>pd.Series(a).fillna(method='ffill')</code>.</p>","title":"ffill_1d_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.ffill_nb","text":"<pre><code>ffill_nb(\n    a\n)\n</code></pre> <p>2-dim version of ffill_1d_nb().</p>","title":"ffill_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.fillna_1d_nb","text":"<pre><code>fillna_1d_nb(\n    a,\n    value\n)\n</code></pre> <p>Replace NaNs with value.</p> <p>Numba equivalent to <code>pd.Series(a).fillna(value)</code>.</p>","title":"fillna_1d_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.fillna_nb","text":"<pre><code>fillna_nb(\n    a,\n    value\n)\n</code></pre> <p>2-dim version of fillna_1d_nb().</p>","title":"fillna_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.filter_nb","text":"<pre><code>filter_nb(\n    a,\n    filter_func_nb,\n    *args\n)\n</code></pre> <p>Filter non-NA elements elementwise using <code>filter_func_nb</code>.  The filtered out elements will become NA.</p> <p><code>filter_func_nb</code> should accept index of the row, index of the column, the element itself, and <code>*args</code>. Should return a bool.</p>","title":"filter_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.find_ranges_nb","text":"<pre><code>find_ranges_nb(\n    ts,\n    gap_value\n)\n</code></pre> <p>Find ranges and store their information as records to an array.</p> <p>Usage</p> <ul> <li>Find ranges in time series:</li> </ul> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from vectorbt.generic.nb import find_ranges_nb\n\n&gt;&gt;&gt; ts = np.asarray([\n...     [np.nan, np.nan, np.nan, np.nan],\n...     [     2, np.nan, np.nan, np.nan],\n...     [     3,      3, np.nan, np.nan],\n...     [np.nan,      4,      4, np.nan],\n...     [     5, np.nan,      5,      5],\n...     [     6,      6, np.nan,      6]\n... ])\n&gt;&gt;&gt; records = find_ranges_nb(ts, np.nan)\n\n&gt;&gt;&gt; pd.DataFrame.from_records(records)\n   id  col  start_idx  end_idx\n0   0    0          1        3\n1   1    0          4        6\n2   2    1          2        4\n3   3    1          5        6\n4   4    2          3        5\n5   5    3          4        6\n</code></pre>","title":"find_ranges_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.flat_reduce_grouped_nb","text":"<pre><code>flat_reduce_grouped_nb(\n    a,\n    group_lens,\n    in_c_order,\n    reduce_func_nb,\n    *args\n)\n</code></pre> <p>Same as reduce_grouped_nb() but passes flattened array.</p>","title":"flat_reduce_grouped_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.flat_reduce_grouped_to_array_nb","text":"<pre><code>flat_reduce_grouped_to_array_nb(\n    a,\n    group_lens,\n    in_c_order,\n    reduce_func_nb,\n    *args\n)\n</code></pre> <p>Same as reduce_grouped_to_array_nb() but passes flattened 1D array.</p>","title":"flat_reduce_grouped_to_array_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.flatten_forder_nb","text":"<pre><code>flatten_forder_nb(\n    a\n)\n</code></pre> <p>Flatten <code>a</code> in F order.</p>","title":"flatten_forder_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.flatten_grouped_nb","text":"<pre><code>flatten_grouped_nb(\n    a,\n    group_lens,\n    in_c_order\n)\n</code></pre> <p>Flatten each group of columns.</p>","title":"flatten_grouped_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.flatten_uniform_grouped_nb","text":"<pre><code>flatten_uniform_grouped_nb(\n    a,\n    group_lens,\n    in_c_order\n)\n</code></pre> <p>Flatten each group of columns of the same length.</p>","title":"flatten_uniform_grouped_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.fshift_1d_nb","text":"<pre><code>fshift_1d_nb(\n    a,\n    n=1,\n    fill_value=nan\n)\n</code></pre> <p>Shift forward by <code>n</code> positions.</p> <p>Numba equivalent to <code>pd.Series(a).shift(n)</code>.</p>","title":"fshift_1d_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.fshift_nb","text":"<pre><code>fshift_nb(\n    a,\n    n=1,\n    fill_value=nan\n)\n</code></pre> <p>2-dim version of fshift_1d_nb().</p>","title":"fshift_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.get_drawdowns_nb","text":"<pre><code>get_drawdowns_nb(\n    ts\n)\n</code></pre> <p>Fill drawdown records by analyzing a time series.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from vectorbt.generic.nb import get_drawdowns_nb\n\n&gt;&gt;&gt; ts = np.asarray([\n...     [1, 5, 1, 3],\n...     [2, 4, 2, 2],\n...     [3, 3, 3, 1],\n...     [4, 2, 2, 2],\n...     [5, 1, 1, 3]\n... ])\n&gt;&gt;&gt; records = get_drawdowns_nb(ts)\n\n&gt;&gt;&gt; pd.DataFrame.from_records(records)\n   id  col  peak_idx  start_idx  valley_idx  end_idx  peak_val  valley_val  \\\n0   0    1         0          1           4        4       5.0         1.0\n1   1    2         2          3           4        4       3.0         1.0\n2   2    3         0          1           2        4       3.0         1.0\n\n   end_val  status\n0      1.0       0\n1      1.0       0\n2      3.0       1\n</code></pre>","title":"get_drawdowns_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.groupby_apply_nb","text":"<pre><code>groupby_apply_nb(\n    a,\n    groups,\n    apply_func_nb,\n    *args\n)\n</code></pre> <p>Provide group-by calculations.</p> <p><code>groups</code> should be a dictionary, where each key is an index that points to an element in the new array where a group-by result will be stored, while the value should be an array of indices in <code>a</code> to apply <code>apply_func_nb</code> on.</p> <p><code>apply_func_nb</code> should accept indices of the group, index of the column, the array, and <code>*args</code>. Should return a single value.</p>","title":"groupby_apply_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.groupby_matrix_apply_nb","text":"<pre><code>groupby_matrix_apply_nb(\n    a,\n    groups,\n    apply_func_nb,\n    *args\n)\n</code></pre> <p>groupby_apply_nb() with <code>apply_func_nb</code> being applied on all columns at once.</p> <p><code>apply_func_nb</code> should accept indices of the group, the 2-dim array, and <code>*args</code>. Should return a single value or an array of shape <code>a.shape[1]</code>.</p>","title":"groupby_matrix_apply_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.max_reduce_nb","text":"<pre><code>max_reduce_nb(\n    col,\n    a\n)\n</code></pre> <p>Return max (ignores NaNs).</p>","title":"max_reduce_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.max_squeeze_nb","text":"<pre><code>max_squeeze_nb(\n    col,\n    group,\n    a\n)\n</code></pre> <p>Return max (ignores NaNs) of a group.</p>","title":"max_squeeze_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.mean_reduce_nb","text":"<pre><code>mean_reduce_nb(\n    col,\n    a\n)\n</code></pre> <p>Return mean (ignores NaNs).</p>","title":"mean_reduce_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.median_reduce_nb","text":"<pre><code>median_reduce_nb(\n    col,\n    a\n)\n</code></pre> <p>Return median (ignores NaNs).</p>","title":"median_reduce_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.min_reduce_nb","text":"<pre><code>min_reduce_nb(\n    col,\n    a\n)\n</code></pre> <p>Return min (ignores NaNs).</p>","title":"min_reduce_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.min_squeeze_nb","text":"<pre><code>min_squeeze_nb(\n    col,\n    group,\n    a\n)\n</code></pre> <p>Return min (ignores NaNs) of a group.</p>","title":"min_squeeze_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.nancnt_nb","text":"<pre><code>nancnt_nb(\n    a\n)\n</code></pre> <p>Compute count while ignoring NaNs.</p>","title":"nancnt_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.nancumprod_nb","text":"<pre><code>nancumprod_nb(\n    a\n)\n</code></pre> <p>Numba-equivalent of <code>np.nancumprod</code> along axis 0.</p>","title":"nancumprod_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.nancumsum_nb","text":"<pre><code>nancumsum_nb(\n    a\n)\n</code></pre> <p>Numba-equivalent of <code>np.nancumsum</code> along axis 0.</p>","title":"nancumsum_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.nanmax_nb","text":"<pre><code>nanmax_nb(\n    a\n)\n</code></pre> <p>Numba-equivalent of <code>np.nanmax</code> along axis 0.</p>","title":"nanmax_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.nanmean_nb","text":"<pre><code>nanmean_nb(\n    a\n)\n</code></pre> <p>Numba-equivalent of <code>np.nanmean</code> along axis 0.</p>","title":"nanmean_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.nanmedian_nb","text":"<pre><code>nanmedian_nb(\n    a\n)\n</code></pre> <p>Numba-equivalent of <code>np.nanmedian</code> along axis 0.</p>","title":"nanmedian_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.nanmin_nb","text":"<pre><code>nanmin_nb(\n    a\n)\n</code></pre> <p>Numba-equivalent of <code>np.nanmin</code> along axis 0.</p>","title":"nanmin_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.nanprod_nb","text":"<pre><code>nanprod_nb(\n    a\n)\n</code></pre> <p>Numba-equivalent of <code>np.nanprod</code> along axis 0.</p>","title":"nanprod_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.nanstd_1d_nb","text":"<pre><code>nanstd_1d_nb(\n    a,\n    ddof=0\n)\n</code></pre> <p>Numba-equivalent of <code>np.nanstd</code>.</p>","title":"nanstd_1d_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.nanstd_nb","text":"<pre><code>nanstd_nb(\n    a,\n    ddof=0\n)\n</code></pre> <p>2-dim version of nanstd_1d_nb().</p>","title":"nanstd_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.nansum_nb","text":"<pre><code>nansum_nb(\n    a\n)\n</code></pre> <p>Numba-equivalent of <code>np.nansum</code> along axis 0.</p>","title":"nansum_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.nth_index_reduce_nb","text":"<pre><code>nth_index_reduce_nb(\n    col,\n    a,\n    n\n)\n</code></pre> <p>Return index of n-th element.</p>","title":"nth_index_reduce_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.nth_reduce_nb","text":"<pre><code>nth_reduce_nb(\n    col,\n    a,\n    n\n)\n</code></pre> <p>Return n-th element.</p>","title":"nth_reduce_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.pct_change_1d_nb","text":"<pre><code>pct_change_1d_nb(\n    a,\n    n=1\n)\n</code></pre> <p>Return the percentage change.</p> <p>Numba equivalent to <code>pd.Series(a).pct_change()</code>.</p>","title":"pct_change_1d_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.pct_change_nb","text":"<pre><code>pct_change_nb(\n    a,\n    n=1\n)\n</code></pre> <p>2-dim version of pct_change_1d_nb().</p>","title":"pct_change_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.range_coverage_nb","text":"<pre><code>range_coverage_nb(\n    start_idx_arr,\n    end_idx_arr,\n    status_arr,\n    col_map,\n    index_lens,\n    overlapping=False,\n    normalize=False\n)\n</code></pre> <p>Get coverage of range records.</p> <p>Set <code>overlapping</code> to True to get the number of overlapping steps. Set <code>normalize</code> to True to get the number of steps in relation either to the total number of steps (when <code>overlapping=False</code>) or to the number of covered steps (when <code>overlapping=True</code>).</p>","title":"range_coverage_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.range_duration_nb","text":"<pre><code>range_duration_nb(\n    start_idx_arr,\n    end_idx_arr,\n    status_arr\n)\n</code></pre> <p>Get duration of each duration record.</p>","title":"range_duration_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.ranges_to_mask_nb","text":"<pre><code>ranges_to_mask_nb(\n    start_idx_arr,\n    end_idx_arr,\n    status_arr,\n    col_map,\n    index_len\n)\n</code></pre> <p>Convert ranges to 2-dim mask.</p>","title":"ranges_to_mask_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.reduce_grouped_nb","text":"<pre><code>reduce_grouped_nb(\n    a,\n    group_lens,\n    reduce_func_nb,\n    *args\n)\n</code></pre> <p>Reduce each group of columns into a single value using <code>reduce_func_nb</code>.</p> <p><code>reduce_func_nb</code> should accept index of the group, the array of row values, and <code>*args</code>. Should return a single value.</p>","title":"reduce_grouped_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.reduce_grouped_to_array_nb","text":"<pre><code>reduce_grouped_to_array_nb(\n    a,\n    group_lens,\n    reduce_func_nb,\n    *args\n)\n</code></pre> <p>Reduce each group of columns into an array of values using <code>reduce_func_nb</code>.</p> <p><code>reduce_func_nb</code> same as for reduce_grouped_nb() but should return an array.</p>  <p>Note</p> <p>Output of <code>reduce_func_nb</code> should be strictly homogeneous.</p>","title":"reduce_grouped_to_array_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.reduce_nb","text":"<pre><code>reduce_nb(\n    a,\n    reduce_func_nb,\n    *args\n)\n</code></pre> <p>Reduce each column into a single value using <code>reduce_func_nb</code>.</p> <p><code>reduce_func_nb</code> should accept index of the column, the array, and <code>*args</code>. Should return a single value.</p>","title":"reduce_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.reduce_to_array_nb","text":"<pre><code>reduce_to_array_nb(\n    a,\n    reduce_func_nb,\n    *args\n)\n</code></pre> <p>Reduce each column into an array of values using <code>reduce_func_nb</code>.</p> <p><code>reduce_func_nb</code> same as for reduce_nb() but should return an array.</p>  <p>Note</p> <p>Output of <code>reduce_func_nb</code> should be strictly homogeneous.</p>","title":"reduce_to_array_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.rolling_apply_nb","text":"<pre><code>rolling_apply_nb(\n    a,\n    window,\n    minp,\n    apply_func_nb,\n    *args\n)\n</code></pre> <p>Provide rolling window calculations.</p> <p><code>apply_func_nb</code> should accept index of the row, index of the column, the array, and <code>*args</code>. Should return a single value.</p>","title":"rolling_apply_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.rolling_matrix_apply_nb","text":"<pre><code>rolling_matrix_apply_nb(\n    a,\n    window,\n    minp,\n    apply_func_nb,\n    *args\n)\n</code></pre> <p>rolling_apply_nb() with <code>apply_func_nb</code> being applied on all columns at once.</p> <p><code>apply_func_nb</code> should accept index of the row, the 2-dim array, and <code>*args</code>. Should return a single value or an array of shape <code>a.shape[1]</code>.</p>","title":"rolling_matrix_apply_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.rolling_max_1d_nb","text":"<pre><code>rolling_max_1d_nb(\n    a,\n    window,\n    minp=None\n)\n</code></pre> <p>Return rolling max.</p> <p>Numba equivalent to <code>pd.Series(a).rolling(window, min_periods=minp).max()</code>.</p>","title":"rolling_max_1d_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.rolling_max_nb","text":"<pre><code>rolling_max_nb(\n    a,\n    window,\n    minp=None\n)\n</code></pre> <p>2-dim version of rolling_max_1d_nb().</p>","title":"rolling_max_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.rolling_mean_1d_nb","text":"<pre><code>rolling_mean_1d_nb(\n    a,\n    window,\n    minp=None\n)\n</code></pre> <p>Return rolling mean.</p> <p>Numba equivalent to <code>pd.Series(a).rolling(window, min_periods=minp).mean()</code>.</p>","title":"rolling_mean_1d_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.rolling_mean_nb","text":"<pre><code>rolling_mean_nb(\n    a,\n    window,\n    minp=None\n)\n</code></pre> <p>2-dim version of rolling_mean_1d_nb().</p>","title":"rolling_mean_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.rolling_min_1d_nb","text":"<pre><code>rolling_min_1d_nb(\n    a,\n    window,\n    minp=None\n)\n</code></pre> <p>Return rolling min.</p> <p>Numba equivalent to <code>pd.Series(a).rolling(window, min_periods=minp).min()</code>.</p>","title":"rolling_min_1d_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.rolling_min_nb","text":"<pre><code>rolling_min_nb(\n    a,\n    window,\n    minp=None\n)\n</code></pre> <p>2-dim version of rolling_min_1d_nb().</p>","title":"rolling_min_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.rolling_std_1d_nb","text":"<pre><code>rolling_std_1d_nb(\n    a,\n    window,\n    minp=None,\n    ddof=0\n)\n</code></pre> <p>Return rolling standard deviation.</p> <p>Numba equivalent to <code>pd.Series(a).rolling(window, min_periods=minp).std(ddof=ddof)</code>.</p>","title":"rolling_std_1d_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.rolling_std_nb","text":"<pre><code>rolling_std_nb(\n    a,\n    window,\n    minp=None,\n    ddof=0\n)\n</code></pre> <p>2-dim version of rolling_std_1d_nb().</p>","title":"rolling_std_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.row_apply_nb","text":"<pre><code>row_apply_nb(\n    a,\n    apply_func_nb,\n    *args\n)\n</code></pre> <p>Apply function on each row.</p> <p><code>apply_func_nb</code> should accept index of the row, the array, and <code>*args</code>. Should return a single value or an array of shape <code>a.shape[1]</code>.</p>","title":"row_apply_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.set_by_mask_1d_nb","text":"<pre><code>set_by_mask_1d_nb(\n    a,\n    mask,\n    value\n)\n</code></pre> <p>Set each element to a value by boolean mask.</p>","title":"set_by_mask_1d_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.set_by_mask_mult_1d_nb","text":"<pre><code>set_by_mask_mult_1d_nb(\n    a,\n    mask,\n    values\n)\n</code></pre> <p>Set each element in one array to the corresponding element in another by boolean mask.</p> <p><code>values</code> should be of the same shape as in <code>a</code>.</p>","title":"set_by_mask_mult_1d_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.set_by_mask_mult_nb","text":"<pre><code>set_by_mask_mult_nb(\n    a,\n    mask,\n    values\n)\n</code></pre> <p>2-dim version of set_by_mask_mult_1d_nb().</p>","title":"set_by_mask_mult_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.set_by_mask_nb","text":"<pre><code>set_by_mask_nb(\n    a,\n    mask,\n    value\n)\n</code></pre> <p>2-dim version of set_by_mask_1d_nb().</p>","title":"set_by_mask_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.shuffle_1d_nb","text":"<pre><code>shuffle_1d_nb(\n    a,\n    seed=None\n)\n</code></pre> <p>Shuffle each column in <code>a</code>.</p> <p>Specify <code>seed</code> to make output deterministic.</p>","title":"shuffle_1d_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.shuffle_nb","text":"<pre><code>shuffle_nb(\n    a,\n    seed=None\n)\n</code></pre> <p>2-dim version of shuffle_1d_nb().</p>","title":"shuffle_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.squeeze_grouped_nb","text":"<pre><code>squeeze_grouped_nb(\n    a,\n    group_lens,\n    squeeze_func_nb,\n    *args\n)\n</code></pre> <p>Squeeze each group of columns into a single column using <code>squeeze_func_nb</code>.</p> <p><code>squeeze_func_nb</code> should accept index of the row, index of the group, the array, and <code>*args</code>. Should return a single value.</p>","title":"squeeze_grouped_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.std_reduce_nb","text":"<pre><code>std_reduce_nb(\n    col,\n    a,\n    ddof\n)\n</code></pre> <p>Return std (ignores NaNs).</p>","title":"std_reduce_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.sum_reduce_nb","text":"<pre><code>sum_reduce_nb(\n    col,\n    a\n)\n</code></pre> <p>Return sum (ignores NaNs).</p>","title":"sum_reduce_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.sum_squeeze_nb","text":"<pre><code>sum_squeeze_nb(\n    col,\n    group,\n    a\n)\n</code></pre> <p>Return sum (ignores NaNs) of a group.</p>","title":"sum_squeeze_nb function"},{"location":"api/generic/nb/#vectorbt.generic.nb.value_counts_nb","text":"<pre><code>value_counts_nb(\n    codes,\n    n_uniques,\n    group_lens\n)\n</code></pre> <p>Return value counts per column/group.</p>","title":"value_counts_nb function"},{"location":"api/generic/plots_builder/","text":"<p>Mixin for building plots out of subplots.</p>","title":"plots_builder"},{"location":"api/generic/plots_builder/#vectorbt.generic.plots_builder.MetaPlotsBuilderMixin","text":"<pre><code>MetaPlotsBuilderMixin(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Meta class that exposes a read-only class property PlotsBuilderMixin.subplots.</p> <p>Superclasses</p> <ul> <li><code>builtins.type</code></li> </ul> <p>Subclasses</p> <ul> <li>MetaData</li> <li>MetaGenericAccessor</li> <li>MetaIndicatorBase</li> <li>MetaMappedArray</li> <li>MetaPortfolio</li> <li>MetaRecords</li> </ul>","title":"MetaPlotsBuilderMixin class"},{"location":"api/generic/plots_builder/#vectorbt.generic.plots_builder.MetaPlotsBuilderMixin.subplots","text":"<p>Subplots supported by PlotsBuilderMixin.plots().</p>","title":"subplots property"},{"location":"api/generic/plots_builder/#vectorbt.generic.plots_builder.PlotsBuilderMixin","text":"<pre><code>PlotsBuilderMixin()\n</code></pre> <p>Mixin that implements PlotsBuilderMixin.plots().</p> <p>Required to be a subclass of Wrapping.</p> <p>Subclasses</p> <ul> <li>Data</li> <li>GenericAccessor</li> <li>IndicatorBase</li> <li>MappedArray</li> <li>Portfolio</li> <li>Records</li> </ul>","title":"PlotsBuilderMixin class"},{"location":"api/generic/plots_builder/#vectorbt.generic.plots_builder.PlotsBuilderMixin.subplots","text":"<p>Subplots supported by PlotsBuilderMixin.</p> <pre><code>Config({})\n</code></pre> <p>Returns <code>PlotsBuilderMixin._subplots</code>, which gets (deep) copied upon creation of each instance. Thus, changing this config won't affect the class.</p> <p>To change subplots, you can either change the config in-place, override this property, or overwrite the instance variable <code>PlotsBuilderMixin._subplots</code>.</p>","title":"subplots class variable"},{"location":"api/generic/plots_builder/#vectorbt.generic.plots_builder.PlotsBuilderMixin.build_subplots_doc","text":"<pre><code>PlotsBuilderMixin.build_subplots_doc(\n    source_cls=None\n)\n</code></pre> <p>Build subplots documentation.</p>","title":"build_subplots_doc class method"},{"location":"api/generic/plots_builder/#vectorbt.generic.plots_builder.PlotsBuilderMixin.override_subplots_doc","text":"<pre><code>PlotsBuilderMixin.override_subplots_doc(\n    __pdoc__,\n    source_cls=None\n)\n</code></pre> <p>Call this method on each subclass that overrides <code>subplots</code>.</p>","title":"override_subplots_doc class method"},{"location":"api/generic/plots_builder/#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots_defaults","text":"<p>Defaults for PlotsBuilderMixin.plots().</p> <p>See <code>plots_builder</code> in settings.</p>","title":"plots_defaults property"},{"location":"api/generic/plots_builder/#vectorbt.generic.plots_builder.PlotsBuilderMixin.writeable_attrs","text":"<p>Set of writeable attributes that will be saved/copied along with the config.</p>","title":"writeable_attrs property"},{"location":"api/generic/plots_builder/#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots","text":"<pre><code>PlotsBuilderMixin.plots(\n    subplots=None,\n    tags=None,\n    column=None,\n    group_by=None,\n    silence_warnings=None,\n    template_mapping=None,\n    settings=None,\n    filters=None,\n    subplot_settings=None,\n    show_titles=None,\n    hide_id_labels=None,\n    group_id_labels=None,\n    make_subplots_kwargs=None,\n    **layout_kwargs\n)\n</code></pre> <p>Plot various parts of this object.</p> <p>Args</p>  <code>subplots</code> :\u2002<code>str</code>, <code>tuple</code>, <code>iterable</code>, <code>or dict</code>  <p>Subplots to plot.</p> <p>Each element can be either:</p> <ul> <li>a subplot name (see keys in PlotsBuilderMixin.subplots)</li> <li>a tuple of a subplot name and a settings dict as in PlotsBuilderMixin.subplots.</li> </ul> <p>The settings dict can contain the following keys:</p> <ul> <li><code>title</code>: Title of the subplot. Defaults to the name.</li> <li><code>plot_func</code> (required): Plotting function for custom subplots.     Should write the supplied figure <code>fig</code> in-place and can return anything (it won't be used).</li> <li><code>xaxis_kwargs</code>: Layout keyword arguments for the x-axis. Defaults to <code>dict(title='Index')</code>.</li> <li><code>yaxis_kwargs</code>: Layout keyword arguments for the y-axis. Defaults to empty dict.</li> <li><code>tags</code>, <code>check_{filter}</code>, <code>inv_check_{filter}</code>, <code>resolve_plot_func</code>, <code>pass_{arg}</code>,     <code>resolve_path_{arg}</code>, <code>resolve_{arg}</code> and <code>template_mapping</code>:     The same as in StatsBuilderMixin for <code>calc_func</code>.</li> <li>Any other keyword argument that overrides the settings or is passed directly to <code>plot_func</code>.</li> </ul> <p>If <code>resolve_plot_func</code> is True, the plotting function may \"request\" any of the following arguments by accepting them or if <code>pass_{arg}</code> was found in the settings dict:</p> <ul> <li>Each of AttrResolver.self_aliases: original object     (ungrouped, with no column selected)</li> <li><code>group_by</code>: won't be passed if it was used in resolving the first attribute of <code>plot_func</code>     specified as a path, use <code>pass_group_by=True</code> to pass anyway</li> <li><code>column</code></li> <li><code>subplot_name</code></li> <li><code>trace_names</code>: list with the subplot name, can't be used in templates</li> <li><code>add_trace_kwargs</code>: dict with subplot row and column index</li> <li><code>xref</code></li> <li><code>yref</code></li> <li><code>xaxis</code></li> <li><code>yaxis</code></li> <li><code>x_domain</code></li> <li><code>y_domain</code></li> <li><code>fig</code></li> <li><code>silence_warnings</code></li> <li>Any argument from <code>settings</code></li> <li>Any attribute of this object if it meant to be resolved     (see AttrResolver.resolve_attr())</li> </ul>  <p>Note</p> <p>Layout-related resolution arguments such as <code>add_trace_kwargs</code> are unavailable before filtering and thus cannot be used in any templates but can still be overridden.</p>  <p>Pass <code>subplots='all'</code> to plot all supported subplots.</p>  <code>tags</code> :\u2002<code>str</code> or <code>iterable</code> See <code>tags</code> in StatsBuilderMixin. <code>column</code> :\u2002<code>str</code> See <code>column</code> in StatsBuilderMixin. <code>group_by</code> :\u2002<code>any</code> See <code>group_by</code> in StatsBuilderMixin. <code>silence_warnings</code> :\u2002<code>bool</code> See <code>silence_warnings</code> in StatsBuilderMixin. <code>template_mapping</code> :\u2002<code>mapping</code>  <p>See <code>template_mapping</code> in StatsBuilderMixin.</p> <p>Applied on <code>settings</code>, <code>make_subplots_kwargs</code>, and <code>layout_kwargs</code>, and then on each subplot settings.</p>  <code>filters</code> :\u2002<code>dict</code> See <code>filters</code> in StatsBuilderMixin. <code>settings</code> :\u2002<code>dict</code> See <code>settings</code> in StatsBuilderMixin. <code>subplot_settings</code> :\u2002<code>dict</code> See <code>metric_settings</code> in StatsBuilderMixin. <code>show_titles</code> :\u2002<code>bool</code> Whether to show the title of each subplot. <code>hide_id_labels</code> :\u2002<code>bool</code>  <p>Whether to hide identical legend labels.</p> <p>Two labels are identical if their name, marker style and line style match.</p>  <code>group_id_labels</code> :\u2002<code>bool</code> Whether to group identical legend labels. <code>make_subplots_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.subplots.make_subplots</code>. <code>**layout_kwargs</code> Keyword arguments used to update the layout of the figure.   <p>Note</p> <p>PlotsBuilderMixin and StatsBuilderMixin are very similar. Some artifacts follow the same concept, just named differently:</p> <ul> <li><code>plots_defaults</code> vs <code>stats_defaults</code></li> <li><code>subplots</code> vs <code>metrics</code></li> <li><code>subplot_settings</code> vs <code>metric_settings</code></li> </ul> <p>See further notes under StatsBuilderMixin.</p>  <p>Usage</p> <p>See vectorbt.portfolio.base for examples.</p>","title":"plots method"},{"location":"api/generic/plotting/","text":"<p>Base plotting functions.</p> <p>Provides functions for visualizing data in an efficient and convenient way. Each creates a figure widget that is compatible with ipywidgets and enables interactive data visualization in Jupyter Notebook and JupyterLab environments. For more details on using Plotly, see Getting Started with Plotly in Python.</p> <p>The module can be accessed directly via <code>vbt.plotting</code>.</p>  <p>Warning</p> <p>In case of errors, it won't be visible in the notebook cell, but in the logs.</p>","title":"plotting"},{"location":"api/generic/plotting/#vectorbt.generic.plotting.clean_labels","text":"<pre><code>clean_labels(\n    labels\n)\n</code></pre> <p>Clean labels.</p> <p>Plotly doesn't support multi-indexes.</p>","title":"clean_labels function"},{"location":"api/generic/plotting/#vectorbt.generic.plotting.Bar","text":"<pre><code>Bar(\n    data=None,\n    trace_names=None,\n    x_labels=None,\n    trace_kwargs=None,\n    add_trace_kwargs=None,\n    fig=None,\n    **layout_kwargs\n)\n</code></pre> <p>Class with an initialization config.</p> <p>All subclasses of <code>Configured</code> are initialized using <code>Config</code>, which makes it easier to pickle.</p> <p>Settings are defined under <code>configured</code> in settings.</p>  <p>Warning</p> <p>If any attribute has been overwritten that isn't listed in <code>Configured.writeable_attrs</code>, or if any <code>Configured.__init__</code> argument depends upon global defaults, their values won't be copied over. Make sure to pass them explicitly to make the saved &amp; loaded / copied instance resilient to changes in globals.</p>  <p>Create a bar plot.</p> <p>Args</p>  <code>data</code> :\u2002<code>array_like</code>  <p>Data in any format that can be converted to NumPy.</p> <p>Must be of shape (<code>x_labels</code>, <code>trace_names</code>).</p>  <code>trace_names</code> :\u2002<code>str</code> or <code>list</code> of <code>str</code> Trace names, corresponding to columns in pandas. <code>x_labels</code> :\u2002<code>array_like</code> X-axis labels, corresponding to index in pandas. <code>trace_kwargs</code> :\u2002<code>dict</code> or <code>list</code> of <code>dict</code>  <p>Keyword arguments passed to <code>plotly.graph_objects.Bar</code>.</p> <p>Can be specified per trace as a sequence of dicts.</p>  <code>add_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>add_trace</code>. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**layout_kwargs</code> Keyword arguments for layout.  <p>Usage</p> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; bar = vbt.plotting.Bar(\n...     data=[[1, 2], [3, 4]],\n...     trace_names=['a', 'b'],\n...     x_labels=['x', 'y']\n... )\n&gt;&gt;&gt; bar.fig\n</code></pre> <p></p> <p>Superclasses</p> <ul> <li>Configured</li> <li>Documented</li> <li>Pickleable</li> <li>TraceUpdater</li> </ul> <p>Inherited members</p> <ul> <li>Configured.config</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>Configured.writeable_attrs</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>TraceUpdater.fig</li> <li>TraceUpdater.traces</li> </ul>","title":"Bar class"},{"location":"api/generic/plotting/#vectorbt.generic.plotting.Bar.update","text":"<pre><code>Bar.update(\n    data\n)\n</code></pre> <p>Update the trace data.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; bar.update([[2, 1], [4, 3]])\n&gt;&gt;&gt; bar.fig\n</code></pre> <p></p>","title":"update method"},{"location":"api/generic/plotting/#vectorbt.generic.plotting.Box","text":"<pre><code>Box(\n    data=None,\n    trace_names=None,\n    horizontal=False,\n    remove_nan=True,\n    from_quantile=None,\n    to_quantile=None,\n    trace_kwargs=None,\n    add_trace_kwargs=None,\n    fig=None,\n    **layout_kwargs\n)\n</code></pre> <p>Class with an initialization config.</p> <p>All subclasses of <code>Configured</code> are initialized using <code>Config</code>, which makes it easier to pickle.</p> <p>Settings are defined under <code>configured</code> in settings.</p>  <p>Warning</p> <p>If any attribute has been overwritten that isn't listed in <code>Configured.writeable_attrs</code>, or if any <code>Configured.__init__</code> argument depends upon global defaults, their values won't be copied over. Make sure to pass them explicitly to make the saved &amp; loaded / copied instance resilient to changes in globals.</p>  <p>Create a box plot.</p> <p>For keyword arguments, see Histogram.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; box = vbt.plotting.Box(\n...     data=[[1, 2], [3, 4], [2, 1]],\n...     trace_names=['a', 'b']\n... )\n&gt;&gt;&gt; box.fig\n</code></pre> <p></p> <p>Superclasses</p> <ul> <li>Configured</li> <li>Documented</li> <li>Pickleable</li> <li>TraceUpdater</li> </ul> <p>Inherited members</p> <ul> <li>Configured.config</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>Configured.writeable_attrs</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>TraceUpdater.fig</li> <li>TraceUpdater.traces</li> <li>TraceUpdater.update()</li> </ul>","title":"Box class"},{"location":"api/generic/plotting/#vectorbt.generic.plotting.Box.from_quantile","text":"<p>Filter out data points before this quantile.</p>","title":"from_quantile property"},{"location":"api/generic/plotting/#vectorbt.generic.plotting.Box.horizontal","text":"<p>Whether to plot horizontally.</p>","title":"horizontal property"},{"location":"api/generic/plotting/#vectorbt.generic.plotting.Box.remove_nan","text":"<p>Whether to remove NaN values.</p>","title":"remove_nan property"},{"location":"api/generic/plotting/#vectorbt.generic.plotting.Box.to_quantile","text":"<p>Filter out data points after this quantile.</p>","title":"to_quantile property"},{"location":"api/generic/plotting/#vectorbt.generic.plotting.Gauge","text":"<pre><code>Gauge(\n    value=None,\n    label=None,\n    value_range=None,\n    cmap_name='Spectral',\n    trace_kwargs=None,\n    add_trace_kwargs=None,\n    fig=None,\n    **layout_kwargs\n)\n</code></pre> <p>Class with an initialization config.</p> <p>All subclasses of <code>Configured</code> are initialized using <code>Config</code>, which makes it easier to pickle.</p> <p>Settings are defined under <code>configured</code> in settings.</p>  <p>Warning</p> <p>If any attribute has been overwritten that isn't listed in <code>Configured.writeable_attrs</code>, or if any <code>Configured.__init__</code> argument depends upon global defaults, their values won't be copied over. Make sure to pass them explicitly to make the saved &amp; loaded / copied instance resilient to changes in globals.</p>  <p>Create a gauge plot.</p> <p>Args</p>  <code>value</code> :\u2002<code>float</code> The value to be displayed. <code>label</code> :\u2002<code>str</code> The label to be displayed. <code>value_range</code> :\u2002<code>tuple</code> of <code>float</code> The value range of the gauge. <code>cmap_name</code> :\u2002<code>str</code>  <p>A matplotlib-compatible colormap name.</p> <p>See the list of available colormaps.</p>  <code>trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to the <code>plotly.graph_objects.Indicator</code>. <code>add_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>add_trace</code>. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**layout_kwargs</code> Keyword arguments for layout.  <p>Usage</p> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; gauge = vbt.plotting.Gauge(\n...     value=2,\n...     value_range=(1, 3),\n...     label='My Gauge'\n... )\n&gt;&gt;&gt; gauge.fig\n</code></pre> <p></p> <p>Superclasses</p> <ul> <li>Configured</li> <li>Documented</li> <li>Pickleable</li> <li>TraceUpdater</li> </ul> <p>Inherited members</p> <ul> <li>Configured.config</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>Configured.writeable_attrs</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>TraceUpdater.fig</li> <li>TraceUpdater.traces</li> <li>TraceUpdater.update()</li> </ul>","title":"Gauge class"},{"location":"api/generic/plotting/#vectorbt.generic.plotting.Gauge.cmap_name","text":"<p>A matplotlib-compatible colormap name.</p>","title":"cmap_name property"},{"location":"api/generic/plotting/#vectorbt.generic.plotting.Gauge.value_range","text":"<p>The value range of the gauge.</p>","title":"value_range property"},{"location":"api/generic/plotting/#vectorbt.generic.plotting.Heatmap","text":"<pre><code>Heatmap(\n    data=None,\n    x_labels=None,\n    y_labels=None,\n    is_x_category=False,\n    is_y_category=False,\n    trace_kwargs=None,\n    add_trace_kwargs=None,\n    fig=None,\n    **layout_kwargs\n)\n</code></pre> <p>Class with an initialization config.</p> <p>All subclasses of <code>Configured</code> are initialized using <code>Config</code>, which makes it easier to pickle.</p> <p>Settings are defined under <code>configured</code> in settings.</p>  <p>Warning</p> <p>If any attribute has been overwritten that isn't listed in <code>Configured.writeable_attrs</code>, or if any <code>Configured.__init__</code> argument depends upon global defaults, their values won't be copied over. Make sure to pass them explicitly to make the saved &amp; loaded / copied instance resilient to changes in globals.</p>  <p>Create a heatmap plot.</p> <p>Args</p>  <code>data</code> :\u2002<code>array_like</code>  <p>Data in any format that can be converted to NumPy.</p> <p>Must be of shape (<code>y_labels</code>, <code>x_labels</code>).</p>  <code>x_labels</code> :\u2002<code>array_like</code> X-axis labels, corresponding to columns in pandas. <code>y_labels</code> :\u2002<code>array_like</code> Y-axis labels, corresponding to index in pandas. <code>is_x_category</code> :\u2002<code>bool</code> Whether X-axis is a categorical axis. <code>is_y_category</code> :\u2002<code>bool</code> Whether Y-axis is a categorical axis. <code>trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Heatmap</code>. <code>add_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>add_trace</code>. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**layout_kwargs</code> Keyword arguments for layout.  <p>Usage</p> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; heatmap = vbt.plotting.Heatmap(\n...     data=[[1, 2], [3, 4]],\n...     x_labels=['a', 'b'],\n...     y_labels=['x', 'y']\n... )\n&gt;&gt;&gt; heatmap.fig\n</code></pre> <p></p> <p>Superclasses</p> <ul> <li>Configured</li> <li>Documented</li> <li>Pickleable</li> <li>TraceUpdater</li> </ul> <p>Inherited members</p> <ul> <li>Configured.config</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>Configured.writeable_attrs</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>TraceUpdater.fig</li> <li>TraceUpdater.traces</li> <li>TraceUpdater.update()</li> </ul>","title":"Heatmap class"},{"location":"api/generic/plotting/#vectorbt.generic.plotting.Histogram","text":"<pre><code>Histogram(\n    data=None,\n    trace_names=None,\n    horizontal=False,\n    remove_nan=True,\n    from_quantile=None,\n    to_quantile=None,\n    trace_kwargs=None,\n    add_trace_kwargs=None,\n    fig=None,\n    **layout_kwargs\n)\n</code></pre> <p>Class with an initialization config.</p> <p>All subclasses of <code>Configured</code> are initialized using <code>Config</code>, which makes it easier to pickle.</p> <p>Settings are defined under <code>configured</code> in settings.</p>  <p>Warning</p> <p>If any attribute has been overwritten that isn't listed in <code>Configured.writeable_attrs</code>, or if any <code>Configured.__init__</code> argument depends upon global defaults, their values won't be copied over. Make sure to pass them explicitly to make the saved &amp; loaded / copied instance resilient to changes in globals.</p>  <p>Create a histogram plot.</p> <p>Args</p>  <code>data</code> :\u2002<code>array_like</code>  <p>Data in any format that can be converted to NumPy.</p> <p>Must be of shape (any, <code>trace_names</code>).</p>  <code>trace_names</code> :\u2002<code>str</code> or <code>list</code> of <code>str</code> Trace names, corresponding to columns in pandas. <code>horizontal</code> :\u2002<code>bool</code> Whether to plot horizontally. <code>remove_nan</code> :\u2002<code>bool</code> Whether to remove NaN values. <code>from_quantile</code> :\u2002<code>float</code>  <p>Filter out data points before this quantile.</p> <p>Should be in range <code>[0, 1]</code>.</p>  <code>to_quantile</code> :\u2002<code>float</code>  <p>Filter out data points after this quantile.</p> <p>Should be in range <code>[0, 1]</code>.</p>  <code>trace_kwargs</code> :\u2002<code>dict</code> or <code>list</code> of <code>dict</code>  <p>Keyword arguments passed to <code>plotly.graph_objects.Histogram</code>.</p> <p>Can be specified per trace as a sequence of dicts.</p>  <code>add_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>add_trace</code>. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**layout_kwargs</code> Keyword arguments for layout.  <p>Usage</p> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; hist = vbt.plotting.Histogram(\n...     data=[[1, 2], [3, 4], [2, 1]],\n...     trace_names=['a', 'b']\n... )\n&gt;&gt;&gt; hist.fig\n</code></pre> <p></p> <p>Superclasses</p> <ul> <li>Configured</li> <li>Documented</li> <li>Pickleable</li> <li>TraceUpdater</li> </ul> <p>Inherited members</p> <ul> <li>Configured.config</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>Configured.writeable_attrs</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>TraceUpdater.fig</li> <li>TraceUpdater.traces</li> <li>TraceUpdater.update()</li> </ul>","title":"Histogram class"},{"location":"api/generic/plotting/#vectorbt.generic.plotting.Histogram.from_quantile","text":"<p>Filter out data points before this quantile.</p>","title":"from_quantile property"},{"location":"api/generic/plotting/#vectorbt.generic.plotting.Histogram.horizontal","text":"<p>Whether to plot horizontally.</p>","title":"horizontal property"},{"location":"api/generic/plotting/#vectorbt.generic.plotting.Histogram.remove_nan","text":"<p>Whether to remove NaN values.</p>","title":"remove_nan property"},{"location":"api/generic/plotting/#vectorbt.generic.plotting.Histogram.to_quantile","text":"<p>Filter out data points after this quantile.</p>","title":"to_quantile property"},{"location":"api/generic/plotting/#vectorbt.generic.plotting.Scatter","text":"<pre><code>Scatter(\n    data=None,\n    trace_names=None,\n    x_labels=None,\n    trace_kwargs=None,\n    add_trace_kwargs=None,\n    fig=None,\n    **layout_kwargs\n)\n</code></pre> <p>Class with an initialization config.</p> <p>All subclasses of <code>Configured</code> are initialized using <code>Config</code>, which makes it easier to pickle.</p> <p>Settings are defined under <code>configured</code> in settings.</p>  <p>Warning</p> <p>If any attribute has been overwritten that isn't listed in <code>Configured.writeable_attrs</code>, or if any <code>Configured.__init__</code> argument depends upon global defaults, their values won't be copied over. Make sure to pass them explicitly to make the saved &amp; loaded / copied instance resilient to changes in globals.</p>  <p>Create a scatter plot.</p> <p>Args</p>  <code>data</code> :\u2002<code>array_like</code>  <p>Data in any format that can be converted to NumPy.</p> <p>Must be of shape (<code>x_labels</code>, <code>trace_names</code>).</p>  <code>trace_names</code> :\u2002<code>str</code> or <code>list</code> of <code>str</code> Trace names, corresponding to columns in pandas. <code>x_labels</code> :\u2002<code>array_like</code> X-axis labels, corresponding to index in pandas. <code>trace_kwargs</code> :\u2002<code>dict</code> or <code>list</code> of <code>dict</code>  <p>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code>.</p> <p>Can be specified per trace as a sequence of dicts.</p>  <code>add_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>add_trace</code>. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**layout_kwargs</code> Keyword arguments for layout.  <p>Usage</p> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; scatter = vbt.plotting.Scatter(\n...     data=[[1, 2], [3, 4]],\n...     trace_names=['a', 'b'],\n...     x_labels=['x', 'y']\n... )\n&gt;&gt;&gt; scatter.fig\n</code></pre> <p></p> <p>Superclasses</p> <ul> <li>Configured</li> <li>Documented</li> <li>Pickleable</li> <li>TraceUpdater</li> </ul> <p>Inherited members</p> <ul> <li>Configured.config</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>Configured.writeable_attrs</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>TraceUpdater.fig</li> <li>TraceUpdater.traces</li> <li>TraceUpdater.update()</li> </ul>","title":"Scatter class"},{"location":"api/generic/plotting/#vectorbt.generic.plotting.TraceUpdater","text":"<pre><code>TraceUpdater(\n    fig,\n    traces\n)\n</code></pre> <p>Base trace updating class.</p> <p>Subclasses</p> <ul> <li>Bar</li> <li>Box</li> <li>Gauge</li> <li>Heatmap</li> <li>Histogram</li> <li>Scatter</li> <li>Volume</li> </ul>","title":"TraceUpdater class"},{"location":"api/generic/plotting/#vectorbt.generic.plotting.TraceUpdater.fig","text":"<p>Figure.</p>","title":"fig property"},{"location":"api/generic/plotting/#vectorbt.generic.plotting.TraceUpdater.traces","text":"<p>Traces to update.</p>","title":"traces property"},{"location":"api/generic/plotting/#vectorbt.generic.plotting.TraceUpdater.update","text":"<pre><code>TraceUpdater.update(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Update the trace data.</p>","title":"update method"},{"location":"api/generic/plotting/#vectorbt.generic.plotting.Volume","text":"<pre><code>Volume(\n    data=None,\n    x_labels=None,\n    y_labels=None,\n    z_labels=None,\n    trace_kwargs=None,\n    add_trace_kwargs=None,\n    scene_name='scene',\n    fig=None,\n    **layout_kwargs\n)\n</code></pre> <p>Class with an initialization config.</p> <p>All subclasses of <code>Configured</code> are initialized using <code>Config</code>, which makes it easier to pickle.</p> <p>Settings are defined under <code>configured</code> in settings.</p>  <p>Warning</p> <p>If any attribute has been overwritten that isn't listed in <code>Configured.writeable_attrs</code>, or if any <code>Configured.__init__</code> argument depends upon global defaults, their values won't be copied over. Make sure to pass them explicitly to make the saved &amp; loaded / copied instance resilient to changes in globals.</p>  <p>Create a volume plot.</p> <p>Args</p>  <code>data</code> :\u2002<code>array_like</code>  <p>Data in any format that can be converted to NumPy.</p> <p>Must be a 3-dim array.</p>  <code>x_labels</code> :\u2002<code>array_like</code> X-axis labels. <code>y_labels</code> :\u2002<code>array_like</code> Y-axis labels. <code>z_labels</code> :\u2002<code>array_like</code> Z-axis labels. <code>trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Volume</code>. <code>add_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>add_trace</code>. <code>scene_name</code> :\u2002<code>str</code> Reference to the 3D scene. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**layout_kwargs</code> Keyword arguments for layout.   <p>Note</p> <p>Figure widgets have currently problems displaying NaNs. Use <code>.show()</code> method for rendering.</p>  <p>Usage</p> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n&gt;&gt;&gt; import numpy as np\n\n&gt;&gt;&gt; volume = vbt.plotting.Volume(\n...     data=np.random.randint(1, 10, size=(3, 3, 3)),\n...     x_labels=['a', 'b', 'c'],\n...     y_labels=['d', 'e', 'f'],\n...     z_labels=['g', 'h', 'i']\n... )\n&gt;&gt;&gt; volume.fig\n</code></pre> <p></p> <p>Superclasses</p> <ul> <li>Configured</li> <li>Documented</li> <li>Pickleable</li> <li>TraceUpdater</li> </ul> <p>Inherited members</p> <ul> <li>Configured.config</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>Configured.writeable_attrs</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>TraceUpdater.fig</li> <li>TraceUpdater.traces</li> <li>TraceUpdater.update()</li> </ul>","title":"Volume class"},{"location":"api/generic/ranges/","text":"<p>Base class for working with range records.</p> <p>Range records capture information on ranges. They are useful for analyzing duration of processes, such as drawdowns, trades, and positions. They also come in handy when analyzing distance between events, such as entry and exit signals.</p> <p>Each range has a starting point and an ending point. For example, the points for <code>range(20)</code> are 0 and 20 (not 19!) respectively.</p>  <p>Note</p> <p>Be aware that if a range hasn't ended in a column, its <code>end_idx</code> will point at the latest index. Make sure to account for this when computing custom metrics involving duration.</p>  <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n\n&gt;&gt;&gt; start = '2019-01-01 UTC'  # crypto is in UTC\n&gt;&gt;&gt; end = '2020-01-01 UTC'\n&gt;&gt;&gt; price = vbt.YFData.download('BTC-USD', start=start, end=end).get('Close')\n&gt;&gt;&gt; fast_ma = vbt.MA.run(price, 10)\n&gt;&gt;&gt; slow_ma = vbt.MA.run(price, 50)\n&gt;&gt;&gt; fast_below_slow = fast_ma.ma_above(slow_ma)\n\n&gt;&gt;&gt; ranges = vbt.Ranges.from_ts(fast_below_slow, wrapper_kwargs=dict(freq='d'))\n\n&gt;&gt;&gt; ranges.records_readable\n   Range Id  Column           Start Timestamp             End Timestamp  \\\n0         0       0 2019-02-19 00:00:00+00:00 2019-07-25 00:00:00+00:00\n1         1       0 2019-08-08 00:00:00+00:00 2019-08-19 00:00:00+00:00\n2         2       0 2019-11-01 00:00:00+00:00 2019-11-20 00:00:00+00:00\n\n   Status\n0  Closed\n1  Closed\n2  Closed\n\n&gt;&gt;&gt; ranges.duration.max(wrap_kwargs=dict(to_timedelta=True))\nTimedelta('74 days 00:00:00')\n</code></pre>","title":"ranges"},{"location":"api/generic/ranges/#from-accessors","text":"<p>Moreover, all generic accessors have a property <code>ranges</code> and a method <code>get_ranges</code>:</p> <pre><code>&gt;&gt;&gt; # vectorbt.generic.accessors.GenericAccessor.ranges.coverage\n&gt;&gt;&gt; fast_below_slow.vbt.ranges.coverage()\n0.35792349726775957\n</code></pre>","title":"From accessors"},{"location":"api/generic/ranges/#stats","text":"<p>Hint</p> <p>See StatsBuilderMixin.stats() and Ranges.metrics.</p>  <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\n...     'a': [1, 2, np.nan, np.nan, 5, 6],\n...     'b': [np.nan, 2, np.nan, 4, np.nan, 6]\n... })\n&gt;&gt;&gt; ranges = df.vbt(freq='d').ranges\n\n&gt;&gt;&gt; ranges['a'].stats()\nStart                             0\nEnd                               5\nPeriod              6 days 00:00:00\nTotal Records                     2\nCoverage            4 days 00:00:00\nOverlap Coverage    0 days 00:00:00\nDuration: Min       2 days 00:00:00\nDuration: Median    2 days 00:00:00\nDuration: Max       2 days 00:00:00\nDuration: Mean      2 days 00:00:00\nDuration: Std       0 days 00:00:00\nName: a, dtype: object\n</code></pre> <p>StatsBuilderMixin.stats() also supports (re-)grouping:</p> <pre><code>&gt;&gt;&gt; ranges.stats(group_by=True)\nStart                                       0\nEnd                                         5\nPeriod                        6 days 00:00:00\nTotal Records                               5\nCoverage                      5 days 00:00:00\nOverlap Coverage              2 days 00:00:00\nDuration: Min                 1 days 00:00:00\nDuration: Median              1 days 00:00:00\nDuration: Max                 2 days 00:00:00\nDuration: Mean                1 days 09:36:00\nDuration: Std       0 days 13:08:43.228968446\nName: group, dtype: object\n</code></pre>","title":"Stats"},{"location":"api/generic/ranges/#plots","text":"<p>Hint</p> <p>See PlotsBuilderMixin.plots() and Ranges.subplots.</p>  <p>Ranges class has a single subplot based on Ranges.plot():</p> <pre><code>&gt;&gt;&gt; ranges['a'].plots()\n</code></pre> <p></p>","title":"Plots"},{"location":"api/generic/ranges/#vectorbt.generic.ranges.ranges_attach_field_config","text":"<p>Config of fields to be attached to Ranges.</p> <pre><code>Config({\n    \"status\": {\n        \"attach_filters\": true\n    }\n})\n</code></pre>","title":"ranges_attach_field_config variable"},{"location":"api/generic/ranges/#vectorbt.generic.ranges.ranges_field_config","text":"<p>Field config for Ranges.</p> <pre><code>Config({\n    \"dtype\": {\n        \"id\": \"int64\",\n        \"col\": \"int64\",\n        \"start_idx\": \"int64\",\n        \"end_idx\": \"int64\",\n        \"status\": \"int64\"\n    },\n    \"settings\": {\n        \"id\": {\n            \"title\": \"Range Id\"\n        },\n        \"idx\": {\n            \"name\": \"end_idx\"\n        },\n        \"start_idx\": {\n            \"title\": \"Start Timestamp\",\n            \"mapping\": \"index\"\n        },\n        \"end_idx\": {\n            \"title\": \"End Timestamp\",\n            \"mapping\": \"index\"\n        },\n        \"status\": {\n            \"title\": \"Status\",\n            \"mapping\": {\n                \"Open\": 0,\n                \"Closed\": 1\n            }\n        }\n    }\n})\n</code></pre>","title":"ranges_field_config variable"},{"location":"api/generic/ranges/#vectorbt.generic.ranges.Ranges","text":"<pre><code>Ranges(\n    wrapper,\n    records_arr,\n    ts=None,\n    **kwargs\n)\n</code></pre> <p>Extends <code>Records</code> for working with range records.</p> <p>Requires <code>records_arr</code> to have all fields defined in range_dt.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>Records</li> <li>RecordsWithFields</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>Records.apply()</li> <li>Records.apply_mask()</li> <li>Records.build_field_config_doc()</li> <li>Records.col_arr</li> <li>Records.col_mapper</li> <li>Records.config</li> <li>Records.count()</li> <li>Records.get_apply_mapping_arr()</li> <li>Records.get_by_col_idxs()</li> <li>Records.get_field_arr()</li> <li>Records.get_field_mapping()</li> <li>Records.get_field_name()</li> <li>Records.get_field_setting()</li> <li>Records.get_field_title()</li> <li>Records.get_map_field()</li> <li>Records.get_map_field_to_index()</li> <li>Records.id_arr</li> <li>Records.idx_arr</li> <li>Records.iloc</li> <li>Records.indexing_func_meta()</li> <li>Records.indexing_kwargs</li> <li>Records.is_sorted()</li> <li>Records.loc</li> <li>Records.map()</li> <li>Records.map_array()</li> <li>Records.map_field()</li> <li>Records.override_field_config_doc()</li> <li>Records.records</li> <li>Records.records_arr</li> <li>Records.records_readable</li> <li>Records.replace()</li> <li>Records.self_aliases</li> <li>Records.sort()</li> <li>Records.values</li> <li>Records.wrapper</li> <li>Records.writeable_attrs</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li>Drawdowns</li> <li>Trades</li> </ul>","title":"Ranges class"},{"location":"api/generic/ranges/#vectorbt.generic.ranges.Ranges.field_config","text":"<p>Field config of Ranges.</p> <pre><code>Config({\n    \"dtype\": {\n        \"id\": \"int64\",\n        \"col\": \"int64\",\n        \"start_idx\": \"int64\",\n        \"end_idx\": \"int64\",\n        \"status\": \"int64\"\n    },\n    \"settings\": {\n        \"id\": {\n            \"name\": \"id\",\n            \"title\": \"Range Id\"\n        },\n        \"col\": {\n            \"name\": \"col\",\n            \"title\": \"Column\",\n            \"mapping\": \"columns\"\n        },\n        \"idx\": {\n            \"name\": \"end_idx\",\n            \"title\": \"Timestamp\",\n            \"mapping\": \"index\"\n        },\n        \"start_idx\": {\n            \"title\": \"Start Timestamp\",\n            \"mapping\": \"index\"\n        },\n        \"end_idx\": {\n            \"title\": \"End Timestamp\",\n            \"mapping\": \"index\"\n        },\n        \"status\": {\n            \"title\": \"Status\",\n            \"mapping\": {\n                \"Open\": 0,\n                \"Closed\": 1\n            }\n        }\n    }\n})\n</code></pre>","title":"field_config class variable"},{"location":"api/generic/ranges/#vectorbt.generic.ranges.Ranges.metrics","text":"<p>Metrics supported by Ranges.</p> <pre><code>Config({\n    \"start\": {\n        \"title\": \"Start\",\n        \"calc_func\": \"&lt;function Ranges.&lt;lambda&gt; at 0x7ff533644ae8&gt;\",\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"end\": {\n        \"title\": \"End\",\n        \"calc_func\": \"&lt;function Ranges.&lt;lambda&gt; at 0x7ff533644b70&gt;\",\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"period\": {\n        \"title\": \"Period\",\n        \"calc_func\": \"&lt;function Ranges.&lt;lambda&gt; at 0x7ff533644bf8&gt;\",\n        \"apply_to_timedelta\": true,\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"coverage\": {\n        \"title\": \"Coverage\",\n        \"calc_func\": \"coverage\",\n        \"overlapping\": false,\n        \"normalize\": false,\n        \"apply_to_timedelta\": true,\n        \"tags\": [\n            \"ranges\",\n            \"coverage\"\n        ]\n    },\n    \"overlap_coverage\": {\n        \"title\": \"Overlap Coverage\",\n        \"calc_func\": \"coverage\",\n        \"overlapping\": true,\n        \"normalize\": false,\n        \"apply_to_timedelta\": true,\n        \"tags\": [\n            \"ranges\",\n            \"coverage\"\n        ]\n    },\n    \"total_records\": {\n        \"title\": \"Total Records\",\n        \"calc_func\": \"count\",\n        \"tags\": \"records\"\n    },\n    \"duration\": {\n        \"title\": \"Duration\",\n        \"calc_func\": \"duration.describe\",\n        \"post_calc_func\": \"&lt;function Ranges.&lt;lambda&gt; at 0x7ff533644c80&gt;\",\n        \"apply_to_timedelta\": true,\n        \"tags\": [\n            \"ranges\",\n            \"duration\"\n        ]\n    }\n})\n</code></pre> <p>Returns <code>Ranges._metrics</code>, which gets (deep) copied upon creation of each instance. Thus, changing this config won't affect the class.</p> <p>To change metrics, you can either change the config in-place, override this property, or overwrite the instance variable <code>Ranges._metrics</code>.</p>","title":"metrics class variable"},{"location":"api/generic/ranges/#vectorbt.generic.ranges.Ranges.subplots","text":"<p>Subplots supported by Ranges.</p> <pre><code>Config({\n    \"plot\": {\n        \"title\": \"Ranges\",\n        \"check_is_not_grouped\": true,\n        \"plot_func\": \"plot\",\n        \"tags\": \"ranges\"\n    }\n})\n</code></pre> <p>Returns <code>Ranges._subplots</code>, which gets (deep) copied upon creation of each instance. Thus, changing this config won't affect the class.</p> <p>To change subplots, you can either change the config in-place, override this property, or overwrite the instance variable <code>Ranges._subplots</code>.</p>","title":"subplots class variable"},{"location":"api/generic/ranges/#vectorbt.generic.ranges.Ranges.from_ts","text":"<pre><code>Ranges.from_ts(\n    ts,\n    gap_value=None,\n    attach_ts=True,\n    wrapper_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Build Ranges from time series <code>ts</code>.</p> <p>Searches for sequences of</p> <ul> <li>True values in boolean data (False acts as a gap),</li> <li>positive values in integer data (-1 acts as a gap), and</li> <li>non-NaN values in any other data (NaN acts as a gap).</li> </ul> <p><code>**kwargs</code> will be passed to Ranges.</p>","title":"from_ts class method"},{"location":"api/generic/ranges/#vectorbt.generic.ranges.Ranges.closed","text":"<p>Records filtered by <code>status == 1</code>.</p>","title":"closed variable"},{"location":"api/generic/ranges/#vectorbt.generic.ranges.Ranges.col","text":"<p>Mapped array of the field <code>col</code>.</p>","title":"col variable"},{"location":"api/generic/ranges/#vectorbt.generic.ranges.Ranges.duration","text":"<p>Duration of each range (in raw format).</p>","title":"duration variable"},{"location":"api/generic/ranges/#vectorbt.generic.ranges.Ranges.end_idx","text":"<p>Mapped array of the field <code>end_idx</code>.</p>","title":"end_idx variable"},{"location":"api/generic/ranges/#vectorbt.generic.ranges.Ranges.id","text":"<p>Mapped array of the field <code>id</code>.</p>","title":"id variable"},{"location":"api/generic/ranges/#vectorbt.generic.ranges.Ranges.open","text":"<p>Records filtered by <code>status == 0</code>.</p>","title":"open variable"},{"location":"api/generic/ranges/#vectorbt.generic.ranges.Ranges.plots_defaults","text":"<p>Defaults for PlotsBuilderMixin.plots().</p> <p>Merges Records.plots_defaults and <code>ranges.plots</code> from settings.</p>","title":"plots_defaults property"},{"location":"api/generic/ranges/#vectorbt.generic.ranges.Ranges.start_idx","text":"<p>Mapped array of the field <code>start_idx</code>.</p>","title":"start_idx variable"},{"location":"api/generic/ranges/#vectorbt.generic.ranges.Ranges.stats_defaults","text":"<p>Defaults for StatsBuilderMixin.stats().</p> <p>Merges Records.stats_defaults and <code>ranges.stats</code> from settings.</p>","title":"stats_defaults property"},{"location":"api/generic/ranges/#vectorbt.generic.ranges.Ranges.status","text":"<p>Mapped array of the field <code>status</code>.</p>","title":"status variable"},{"location":"api/generic/ranges/#vectorbt.generic.ranges.Ranges.ts","text":"<p>Original time series that records are built from (optional).</p>","title":"ts property"},{"location":"api/generic/ranges/#vectorbt.generic.ranges.Ranges.avg_duration","text":"<pre><code>Ranges.avg_duration(\n    group_by=None,\n    wrap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Average range duration (as timedelta).</p>","title":"avg_duration method"},{"location":"api/generic/ranges/#vectorbt.generic.ranges.Ranges.coverage","text":"<pre><code>Ranges.coverage(\n    overlapping=False,\n    normalize=True,\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Coverage, that is, the number of steps that are covered by all ranges.</p> <p>See range_coverage_nb().</p>","title":"coverage method"},{"location":"api/generic/ranges/#vectorbt.generic.ranges.Ranges.indexing_func","text":"<pre><code>Ranges.indexing_func(\n    pd_indexing_func,\n    **kwargs\n)\n</code></pre> <p>Perform indexing on Ranges.</p>","title":"indexing_func method"},{"location":"api/generic/ranges/#vectorbt.generic.ranges.Ranges.max_duration","text":"<pre><code>Ranges.max_duration(\n    group_by=None,\n    wrap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Maximum range duration (as timedelta).</p>","title":"max_duration method"},{"location":"api/generic/ranges/#vectorbt.generic.ranges.Ranges.plot","text":"<pre><code>Ranges.plot(\n    column=None,\n    top_n=5,\n    plot_zones=True,\n    ts_trace_kwargs=None,\n    start_trace_kwargs=None,\n    end_trace_kwargs=None,\n    open_shape_kwargs=None,\n    closed_shape_kwargs=None,\n    add_trace_kwargs=None,\n    xref='x',\n    yref='y',\n    fig=None,\n    **layout_kwargs\n)\n</code></pre> <p>Plot ranges.</p> <p>Args</p>  <code>column</code> :\u2002<code>str</code> Name of the column to plot. <code>top_n</code> :\u2002<code>int</code> Filter top N range records by maximum duration. <code>plot_zones</code> :\u2002<code>bool</code> Whether to plot zones. <code>ts_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for Ranges.ts. <code>start_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for start values. <code>end_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for end values. <code>open_shape_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for open zones. <code>closed_shape_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for closed zones. <code>add_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>add_trace</code>. <code>xref</code> :\u2002<code>str</code> X coordinate axis. <code>yref</code> :\u2002<code>str</code> Y coordinate axis. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**layout_kwargs</code> Keyword arguments for layout.  <p>Usage</p> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n&gt;&gt;&gt; from datetime import datetime, timedelta\n&gt;&gt;&gt; import pandas as pd\n\n&gt;&gt;&gt; price = pd.Series([1, 2, 1, 2, 3, 2, 1, 2], name='Price')\n&gt;&gt;&gt; price.index = [datetime(2020, 1, 1) + timedelta(days=i) for i in range(len(price))]\n&gt;&gt;&gt; vbt.Ranges.from_ts(price &gt;= 2, wrapper_kwargs=dict(freq='1 day')).plot()\n</code></pre> <p></p>","title":"plot method"},{"location":"api/generic/ranges/#vectorbt.generic.ranges.Ranges.to_mask","text":"<pre><code>Ranges.to_mask(\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Convert ranges to a mask.</p> <p>See ranges_to_mask_nb().</p>","title":"to_mask method"},{"location":"api/generic/splitters/","text":"<p>Splitters for cross-validation.</p> <p>Defines splitter classes similar (but may not compatible) to <code>sklearn.model_selection.BaseCrossValidator</code>.</p>","title":"splitters"},{"location":"api/generic/splitters/#vectorbt.generic.splitters.split_ranges_into_sets","text":"<pre><code>split_ranges_into_sets(\n    start_idxs,\n    end_idxs,\n    set_lens=(),\n    left_to_right=True\n)\n</code></pre> <p>Generate ranges between each in <code>start_idxs</code> and <code>end_idxs</code> and optionally split into one or more sets.</p> <p>Args</p>  <code>start_idxs</code> :\u2002<code>array_like</code> Start indices. <code>end_idxs</code> :\u2002<code>array_like</code> End indices. <code>set_lens</code> :\u2002<code>list</code> of <code>float</code>  <p>Lengths of sets in each range.</p> <p>The number of returned sets is the length of <code>set_lens</code> plus one, which stores the remaining elements.</p> <p>Can be passed per range.</p>  <code>left_to_right</code> :\u2002<code>bool</code> or <code>list</code> of <code>bool</code>  <p>Whether to resolve <code>set_lens</code> from left to right.</p> <p>Makes the last set variable, otherwise makes the first set variable.</p> <p>Can be passed per range.</p>   <p>Usage</p> <ul> <li><code>set_lens=(0.5)</code>: 50% in training set, the rest in test set</li> <li><code>set_lens=(0.5, 0.25)</code>: 50% in training set, 25% in validation set, the rest in test set</li> <li><code>set_lens=(50, 30)</code>: 50 in training set, 30 in validation set, the rest in test set</li> <li><code>set_lens=(50, 30)</code> and <code>left_to_right=False</code>: 30 in test set, 50 in validation set,     the rest in training set</li> </ul>","title":"split_ranges_into_sets function"},{"location":"api/generic/splitters/#vectorbt.generic.splitters.BaseSplitter","text":"<pre><code>BaseSplitter()\n</code></pre> <p>Abstract splitter class.</p> <p>Subclasses</p> <ul> <li>ExpandingSplitter</li> <li>RangeSplitter</li> <li>RollingSplitter</li> </ul>","title":"BaseSplitter class"},{"location":"api/generic/splitters/#vectorbt.generic.splitters.BaseSplitter.split","text":"<pre><code>BaseSplitter.split(\n    X,\n    **kwargs\n)\n</code></pre>","title":"split method"},{"location":"api/generic/splitters/#vectorbt.generic.splitters.ExpandingSplitter","text":"<pre><code>ExpandingSplitter()\n</code></pre> <p>Expanding walk-forward splitter.</p> <p>Superclasses</p> <ul> <li>BaseSplitter</li> </ul>","title":"ExpandingSplitter class"},{"location":"api/generic/splitters/#vectorbt.generic.splitters.ExpandingSplitter.split","text":"<pre><code>ExpandingSplitter.split(\n    X,\n    n=None,\n    min_len=1,\n    **kwargs\n)\n</code></pre> <p>Similar to RollingSplitter.split(), but expanding.</p> <p><code>**kwargs</code> are passed to split_ranges_into_sets().</p>","title":"split method"},{"location":"api/generic/splitters/#vectorbt.generic.splitters.RangeSplitter","text":"<pre><code>RangeSplitter()\n</code></pre> <p>Range splitter.</p> <p>Superclasses</p> <ul> <li>BaseSplitter</li> </ul>","title":"RangeSplitter class"},{"location":"api/generic/splitters/#vectorbt.generic.splitters.RangeSplitter.split","text":"<pre><code>RangeSplitter.split(\n    X,\n    n=None,\n    range_len=None,\n    min_len=1,\n    start_idxs=None,\n    end_idxs=None,\n    **kwargs\n)\n</code></pre> <p>Either split into <code>n</code> ranges each <code>range_len</code> long, or split into ranges between <code>start_idxs</code> and <code>end_idxs</code>, and concatenate along the column axis.</p> <p>At least one of <code>range_len</code>, <code>n</code>, or <code>start_idxs</code> and <code>end_idxs</code> must be set:</p> <ul> <li>If <code>range_len</code> is None, are split evenly into <code>n</code> ranges.</li> <li>If <code>n</code> is None, returns the maximum number of ranges of length <code>range_len</code> (can be a percentage).</li> <li>If <code>start_idxs</code> and <code>end_idxs</code>, splits into ranges between both arrays. Both index arrays should be either NumPy arrays with absolute positions or pandas indexes with labels. The last index should be inclusive. The distance between each start and end index can be different, and smaller ranges are filled with NaNs.</li> </ul> <p><code>range_len</code> can be a floating number between 0 and 1 to indicate a fraction of the total range.</p> <p><code>**kwargs</code> are passed to split_ranges_into_sets().</p>","title":"split method"},{"location":"api/generic/splitters/#vectorbt.generic.splitters.RollingSplitter","text":"<pre><code>RollingSplitter()\n</code></pre> <p>Rolling walk-forward splitter.</p> <p>Superclasses</p> <ul> <li>BaseSplitter</li> </ul>","title":"RollingSplitter class"},{"location":"api/generic/splitters/#vectorbt.generic.splitters.RollingSplitter.split","text":"<pre><code>RollingSplitter.split(\n    X,\n    n=None,\n    window_len=None,\n    min_len=1,\n    **kwargs\n)\n</code></pre> <p>Split by rolling a window.</p> <p><code>**kwargs</code> are passed to split_ranges_into_sets().</p>","title":"split method"},{"location":"api/generic/splitters/#vectorbt.generic.splitters.SplitterT","text":"<pre><code>SplitterT(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Base class for protocol classes. Protocol classes are defined as::</p> <pre><code>class Proto(Protocol):\n    def meth(self) -&gt; int:\n        ...\n</code></pre> <p>Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example::</p> <p>    class C</p> <pre><code>def meth(self) -&gt; int:\n    return 0\n</code></pre> <p>def func(x: Proto) -&gt; int:     return x.meth()</p> <p>func(C())  # Passes static type check</p> <p>See PEP 544 for details. Protocol classes decorated with @typing_extensions.runtime act as simple-minded runtime protocol that checks only the presence of given attributes, ignoring their type signatures.</p> <p>Protocol classes can be generic, they are defined as::</p> <pre><code>class GenProto(Protocol[T]):\n    def meth(self) -&gt; T:\n        ...\n</code></pre> <p>Superclasses</p> <ul> <li><code>typing_extensions.Protocol</code></li> </ul>","title":"SplitterT class"},{"location":"api/generic/splitters/#vectorbt.generic.splitters.SplitterT.split","text":"<pre><code>SplitterT.split(\n    X,\n    **kwargs\n)\n</code></pre>","title":"split method"},{"location":"api/generic/stats_builder/","text":"<p>Mixin for building statistics out of performance metrics.</p>","title":"stats_builder"},{"location":"api/generic/stats_builder/#vectorbt.generic.stats_builder.MetaStatsBuilderMixin","text":"<pre><code>MetaStatsBuilderMixin(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Meta class that exposes a read-only class property StatsBuilderMixin.metrics.</p> <p>Superclasses</p> <ul> <li><code>builtins.type</code></li> </ul> <p>Subclasses</p> <ul> <li>MetaData</li> <li>MetaGenericAccessor</li> <li>MetaIndicatorBase</li> <li>MetaMappedArray</li> <li>MetaPortfolio</li> <li>MetaRecords</li> </ul>","title":"MetaStatsBuilderMixin class"},{"location":"api/generic/stats_builder/#vectorbt.generic.stats_builder.MetaStatsBuilderMixin.metrics","text":"<p>Metrics supported by StatsBuilderMixin.stats().</p>","title":"metrics property"},{"location":"api/generic/stats_builder/#vectorbt.generic.stats_builder.StatsBuilderMixin","text":"<pre><code>StatsBuilderMixin()\n</code></pre> <p>Mixin that implements StatsBuilderMixin.stats().</p> <p>Required to be a subclass of Wrapping.</p> <p>Subclasses</p> <ul> <li>Data</li> <li>GenericAccessor</li> <li>IndicatorBase</li> <li>MappedArray</li> <li>Portfolio</li> <li>Records</li> </ul>","title":"StatsBuilderMixin class"},{"location":"api/generic/stats_builder/#vectorbt.generic.stats_builder.StatsBuilderMixin.metrics","text":"<p>Metrics supported by StatsBuilderMixin.</p> <pre><code>Config({\n    \"start\": {\n        \"title\": \"Start\",\n        \"calc_func\": \"&lt;function StatsBuilderMixin.&lt;lambda&gt; at 0x7ff5336d3620&gt;\",\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"end\": {\n        \"title\": \"End\",\n        \"calc_func\": \"&lt;function StatsBuilderMixin.&lt;lambda&gt; at 0x7ff5336d36a8&gt;\",\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"period\": {\n        \"title\": \"Period\",\n        \"calc_func\": \"&lt;function StatsBuilderMixin.&lt;lambda&gt; at 0x7ff5336d3730&gt;\",\n        \"apply_to_timedelta\": true,\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    }\n})\n</code></pre> <p>Returns <code>StatsBuilderMixin._metrics</code>, which gets (deep) copied upon creation of each instance. Thus, changing this config won't affect the class.</p> <p>To change metrics, you can either change the config in-place, override this property, or overwrite the instance variable <code>StatsBuilderMixin._metrics</code>.</p>","title":"metrics class variable"},{"location":"api/generic/stats_builder/#vectorbt.generic.stats_builder.StatsBuilderMixin.build_metrics_doc","text":"<pre><code>StatsBuilderMixin.build_metrics_doc(\n    source_cls=None\n)\n</code></pre> <p>Build metrics documentation.</p>","title":"build_metrics_doc class method"},{"location":"api/generic/stats_builder/#vectorbt.generic.stats_builder.StatsBuilderMixin.override_metrics_doc","text":"<pre><code>StatsBuilderMixin.override_metrics_doc(\n    __pdoc__,\n    source_cls=None\n)\n</code></pre> <p>Call this method on each subclass that overrides <code>metrics</code>.</p>","title":"override_metrics_doc class method"},{"location":"api/generic/stats_builder/#vectorbt.generic.stats_builder.StatsBuilderMixin.stats_defaults","text":"<p>Defaults for StatsBuilderMixin.stats().</p> <p>See <code>stats_builder</code> in settings.</p>","title":"stats_defaults property"},{"location":"api/generic/stats_builder/#vectorbt.generic.stats_builder.StatsBuilderMixin.writeable_attrs","text":"<p>Set of writeable attributes that will be saved/copied along with the config.</p>","title":"writeable_attrs property"},{"location":"api/generic/stats_builder/#vectorbt.generic.stats_builder.StatsBuilderMixin.stats","text":"<pre><code>StatsBuilderMixin.stats(\n    metrics=None,\n    tags=None,\n    column=None,\n    group_by=None,\n    agg_func=&lt;function mean&gt;,\n    silence_warnings=None,\n    template_mapping=None,\n    settings=None,\n    filters=None,\n    metric_settings=None\n)\n</code></pre> <p>Compute various metrics on this object.</p> <p>Args</p>  <code>metrics</code> :\u2002<code>str</code>, <code>tuple</code>, <code>iterable</code>, <code>or dict</code>  <p>Metrics to calculate.</p> <p>Each element can be either:</p> <ul> <li>a metric name (see keys in StatsBuilderMixin.metrics)</li> <li>a tuple of a metric name and a settings dict as in StatsBuilderMixin.metrics.</li> </ul> <p>The settings dict can contain the following keys:</p> <ul> <li><code>title</code>: Title of the metric. Defaults to the name.</li> <li><code>tags</code>: Single or multiple tags to associate this metric with.     If any of these tags is in <code>tags</code>, keeps this metric.</li> <li><code>check_{filter}</code> and <code>inv_check_{filter}</code>: Whether to check this metric against a     filter defined in <code>filters</code>. True (or False for inverse) means to keep this metric.</li> <li><code>calc_func</code> (required): Calculation function for custom metrics.     Should return either a scalar for one column/group, pd.Series for multiple columns/groups,     or a dict of such for multiple sub-metrics.</li> <li><code>resolve_calc_func</code>: whether to resolve <code>calc_func</code>. If the function can be accessed     by traversing attributes of this object, you can specify the path to this function     as a string (see deep_getattr() for the path format).     If <code>calc_func</code> is a function, arguments from merged metric settings are matched with     arguments in the signature (see below). If <code>resolve_calc_func</code> is False, <code>calc_func</code>     should accept (resolved) self and dictionary of merged metric settings.     Defaults to True.</li> <li><code>post_calc_func</code>: Function to post-process the result of <code>calc_func</code>.     Should accept (resolved) self, output of <code>calc_func</code>, and dictionary of merged metric settings,     and return whatever is acceptable to be returned by <code>calc_func</code>. Defaults to None.</li> <li><code>fill_wrap_kwargs</code>: Whether to fill <code>wrap_kwargs</code> with <code>to_timedelta</code> and <code>silence_warnings</code>.     Defaults to False.</li> <li><code>apply_to_timedelta</code>: Whether to apply ArrayWrapper.to_timedelta()     on the result. To disable this globally, pass <code>to_timedelta=False</code> in <code>settings</code>.     Defaults to False.</li> <li><code>pass_{arg}</code>: Whether to pass any argument from the settings (see below). Defaults to True if     this argument was found in the function's signature. Set to False to not pass.     If argument to be passed was not found, <code>pass_{arg}</code> is removed.</li> <li><code>resolve_path_{arg}</code>: Whether to resolve an argument that is meant to be an attribute of     this object and is the first part of the path of <code>calc_func</code>. Passes only optional arguments.     Defaults to True. See AttrResolver.resolve_attr().</li> <li><code>resolve_{arg}</code>: Whether to resolve an argument that is meant to be an attribute of     this object and is present in the function's signature. Defaults to False.     See AttrResolver.resolve_attr().</li> <li><code>template_mapping</code>: Mapping to replace templates in metric settings. Used across all settings.</li> <li>Any other keyword argument that overrides the settings or is passed directly to <code>calc_func</code>.</li> </ul> <p>If <code>resolve_calc_func</code> is True, the calculation function may \"request\" any of the following arguments by accepting them or if <code>pass_{arg}</code> was found in the settings dict:</p> <ul> <li>Each of AttrResolver.self_aliases: original object     (ungrouped, with no column selected)</li> <li><code>group_by</code>: won't be passed if it was used in resolving the first attribute of <code>calc_func</code>     specified as a path, use <code>pass_group_by=True</code> to pass anyway</li> <li><code>column</code></li> <li><code>metric_name</code></li> <li><code>agg_func</code></li> <li><code>silence_warnings</code></li> <li><code>to_timedelta</code>: replaced by True if None and frequency is set</li> <li>Any argument from <code>settings</code></li> <li>Any attribute of this object if it meant to be resolved     (see AttrResolver.resolve_attr())</li> </ul> <p>Pass <code>metrics='all'</code> to calculate all supported metrics.</p>  <code>tags</code> :\u2002<code>str</code> or <code>iterable</code>  <p>Tags to select.</p> <p>See match_tags().</p>  <code>column</code> :\u2002<code>str</code>  <p>Name of the column/group.</p>  <p>Hint</p> <p>There are two ways to select a column: <code>obj['a'].stats()</code> and <code>obj.stats(column='a')</code>. They both accomplish the same thing but in different ways: <code>obj['a'].stats()</code> computes statistics of the column 'a' only, while <code>obj.stats(column='a')</code> computes statistics of all columns first and only then selects the column 'a'. The first method is preferred when you have a lot of data or caching is disabled. The second method is preferred when most attributes have already been cached.</p>   <code>group_by</code> :\u2002<code>any</code> Group or ungroup columns. See ColumnGrouper. <code>agg_func</code> :\u2002<code>callable</code>  <p>Aggregation function to aggregate statistics across all columns. Defaults to mean.</p> <p>Should take <code>pd.Series</code> and return a const.</p> <p>Has only effect if <code>column</code> was specified or this object contains only one column of data.</p> <p>If <code>agg_func</code> has been overridden by a metric:</p> <ul> <li>it only takes effect if global <code>agg_func</code> is not None</li> <li>will raise a warning if it's None but the result of calculation has multiple values</li> </ul>  <code>silence_warnings</code> :\u2002<code>bool</code> Whether to silence all warnings. <code>template_mapping</code> :\u2002<code>mapping</code>  <p>Global mapping to replace templates.</p> <p>Gets merged over <code>template_mapping</code> from StatsBuilderMixin.stats_defaults.</p> <p>Applied on <code>settings</code> and then on each metric settings.</p>  <code>filters</code> :\u2002<code>dict</code>  <p>Filters to apply.</p> <p>Each item consists of the filter name and settings dict.</p> <p>The settings dict can contain the following keys:</p> <ul> <li><code>filter_func</code>: Filter function that should accept resolved self and     merged settings for a metric, and return either True or False.</li> <li><code>warning_message</code>: Warning message to be shown when skipping a metric.     Can be a template that will be substituted using merged metric settings as mapping.     Defaults to None.</li> <li><code>inv_warning_message</code>: Same as <code>warning_message</code> but for inverse checks.</li> </ul> <p>Gets merged over <code>filters</code> from StatsBuilderMixin.stats_defaults.</p>  <code>settings</code> :\u2002<code>dict</code>  <p>Global settings and resolution arguments.</p> <p>Extends/overrides <code>settings</code> from StatsBuilderMixin.stats_defaults. Gets extended/overridden by metric settings.</p>  <code>metric_settings</code> :\u2002<code>dict</code>  <p>Keyword arguments for each metric.</p> <p>Extends/overrides all global and metric settings.</p>   <p>For template logic, see vectorbt.utils.template.</p> <p>For defaults, see StatsBuilderMixin.stats_defaults.</p>  <p>Hint</p> <p>There are two types of arguments: optional (or resolution) and mandatory arguments. Optional arguments are only passed if they are found in the function's signature. Mandatory arguments are passed regardless of this. Optional arguments can only be defined using <code>settings</code> (that is, globally), while mandatory arguments can be defined both using default metric settings and <code>{metric_name}_kwargs</code>. Overriding optional arguments using default metric settings or <code>{metric_name}_kwargs</code> won't turn them into mandatory. For this, pass <code>pass_{arg}=True</code>.</p>   <p>Hint</p> <p>Make sure to resolve and then to re-use as many object attributes as possible to utilize built-in caching (even if global caching is disabled).</p>  <p>Usage</p> <p>See vectorbt.portfolio.base for examples.</p>","title":"stats method"},{"location":"api/indicators/","text":"<p>Modules for building and running indicators.</p> <p>Technical indicators are used to see past trends and anticipate future moves. See Using Technical Indicators to Develop Trading Strategies.</p>","title":"indicators"},{"location":"api/indicators/#vectorbt.indicators.pandas_ta","text":"<pre><code>pandas_ta(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Shortcut for IndicatorFactory.from_pandas_ta().</p>","title":"pandas_ta function"},{"location":"api/indicators/#vectorbt.indicators.ta","text":"<pre><code>ta(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Shortcut for IndicatorFactory.from_ta().</p>","title":"ta function"},{"location":"api/indicators/#vectorbt.indicators.talib","text":"<pre><code>talib(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Shortcut for IndicatorFactory.from_talib().</p>","title":"talib function"},{"location":"api/indicators/#sub-modules","text":"<ul> <li>vectorbt.indicators.basic</li> <li>vectorbt.indicators.configs</li> <li>vectorbt.indicators.factory</li> <li>vectorbt.indicators.nb</li> </ul>","title":"Sub-modules"},{"location":"api/indicators/basic/","text":"<p>Indicators built with IndicatorFactory.</p> <p>You can access all the indicators either by <code>vbt.*</code> or <code>vbt.indicators.*</code>.</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; # vectorbt.indicators.basic.MA\n&gt;&gt;&gt; vbt.MA.run(pd.Series([1, 2, 3]), [2, 3]).ma\nma_window     2     3\nma_ewm    False False\n0           NaN   NaN\n1           1.5   NaN\n2           2.5   2.0\n</code></pre> <p>The advantage of these indicators over TA-Lib's is that they work primarily on 2-dimensional arrays and utilize caching, which makes them faster for matrices with huge number of columns. They also have plotting methods.</p> <p>Run for the examples below:</p> <p><pre><code>&gt;&gt;&gt; import vectorbt as vbt\n&gt;&gt;&gt; from datetime import datetime\n\n&gt;&gt;&gt; start = '2019-03-01 UTC'  # crypto is in UTC\n&gt;&gt;&gt; end = '2019-09-01 UTC'\n&gt;&gt;&gt; cols = ['Open', 'High', 'Low', 'Close', 'Volume']\n&gt;&gt;&gt; ohlcv = vbt.YFData.download(\"BTC-USD\", start=start, end=end).get(cols)\n&gt;&gt;&gt; ohlcv\n                                   Open          High          Low  \\\nDate\n2019-03-01 00:00:00+00:00   3853.757080   3907.795410  3851.692383\n2019-03-02 00:00:00+00:00   3855.318115   3874.607422  3832.127930\n2019-03-03 00:00:00+00:00   3862.266113   3875.483643  3836.905762\n...                                 ...           ...          ...\n2019-08-30 00:00:00+00:00   9514.844727   9656.124023  9428.302734\n2019-08-31 00:00:00+00:00   9597.539062   9673.220703  9531.799805\n2019-09-01 00:00:00+00:00   9630.592773   9796.755859  9582.944336\n\n                                 Close       Volume\nDate\n2019-03-01 00:00:00+00:00  3859.583740   7661247975\n2019-03-02 00:00:00+00:00  3864.415039   7578786076\n2019-03-03 00:00:00+00:00  3847.175781   7253558152\n...                                ...          ...\n2019-08-30 00:00:00+00:00  9598.173828  13595263986\n2019-08-31 00:00:00+00:00  9630.664062  11454806419\n2019-09-01 00:00:00+00:00  9757.970703  11445355859\n\n[185 rows x 5 columns]\n\n&gt;&gt;&gt; ohlcv.vbt.ohlcv.plot()\n</code></pre> </p>","title":"basic"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR","text":"<pre><code>ATR(\n    wrapper,\n    input_list,\n    input_mapper,\n    in_output_list,\n    output_list,\n    param_list,\n    mapper_list,\n    short_name,\n    level_names\n)\n</code></pre> <p>Average True Range (ATR).</p> <p>The indicator provide an indication of the degree of price volatility. Strong moves, in either direction, are often accompanied by large ranges, or large True Ranges.</p> <p>See Average True Range - ATR.</p>  <p>Note</p> <p>Uses Simple MA and Exponential MA as compared to Wilder.</p>  <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>IndicatorBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> <li><code>vectorbt.indicators.basic.ParamIndexer</code></li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>IndicatorBase.config</li> <li>IndicatorBase.iloc</li> <li>IndicatorBase.in_output_names</li> <li>IndicatorBase.indexing_func()</li> <li>IndicatorBase.indexing_kwargs</li> <li>IndicatorBase.input_names</li> <li>IndicatorBase.level_names</li> <li>IndicatorBase.loc</li> <li>IndicatorBase.output_flags</li> <li>IndicatorBase.output_names</li> <li>IndicatorBase.param_names</li> <li>IndicatorBase.plots_defaults</li> <li>IndicatorBase.self_aliases</li> <li>IndicatorBase.short_name</li> <li>IndicatorBase.stats_defaults</li> <li>IndicatorBase.wrapper</li> <li>IndicatorBase.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li><code>vectorbt.indicators.basic._ATR</code></li> </ul>","title":"ATR class"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.run","text":"<pre><code>ATR.run(\n    high,\n    low,\n    close,\n    window=Default(14),\n    ewm=Default(True),\n    short_name='atr',\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Run ATR indicator.</p> <ul> <li>Inputs: <code>high</code>, <code>low</code>, <code>close</code></li> <li>Parameters: <code>window</code>, <code>ewm</code></li> <li>Outputs: <code>tr</code>, <code>atr</code></li> </ul> <p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels. Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p> <p>Other keyword arguments are passed to run_pipeline().</p>","title":"run class method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.run_combs","text":"<pre><code>ATR.run_combs(\n    high,\n    low,\n    close,\n    window=Default(14),\n    ewm=Default(True),\n    r=2,\n    param_product=False,\n    comb_func=itertools.combinations,\n    run_unique=True,\n    short_names=None,\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Create a combination of multiple ATR indicators using function <code>comb_func</code>.</p> <ul> <li>Inputs: <code>high</code>, <code>low</code>, <code>close</code></li> <li>Parameters: <code>window</code>, <code>ewm</code></li> <li>Outputs: <code>tr</code>, <code>atr</code></li> </ul> <p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.  Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>. Pass <code>r</code> to specify how many indicators to run.  Pass <code>short_names</code> to specify the short name for each indicator.  Set <code>run_unique</code> to True to first compute raw outputs for all parameters,  and then use them to build each indicator (faster).</p> <p>Other keyword arguments are passed to ATR.run().</p>","title":"run_combs class method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.atr","text":"<p>Output array.</p>","title":"atr property"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.close","text":"<p>Input array.</p>","title":"close variable"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.ewm_list","text":"<p>List of <code>ewm</code> values.</p>","title":"ewm_list property"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.high","text":"<p>Input array.</p>","title":"high variable"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.low","text":"<p>Input array.</p>","title":"low variable"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.tr","text":"<p>Output array.</p>","title":"tr property"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.window_list","text":"<p>List of <code>window</code> values.</p>","title":"window_list property"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.apply_func","text":"<pre><code>ATR.apply_func(\n    high,\n    low,\n    close,\n    window,\n    ewm,\n    adjust,\n    tr,\n    cache_dict\n)\n</code></pre> <p>Apply function for ATR.</p>","title":"apply_func method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.atr_above","text":"<pre><code>ATR.atr_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>atr</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"atr_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.atr_below","text":"<pre><code>ATR.atr_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>atr</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"atr_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.atr_crossed_above","text":"<pre><code>ATR.atr_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>atr</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"atr_crossed_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.atr_crossed_below","text":"<pre><code>ATR.atr_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>atr</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"atr_crossed_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.atr_equal","text":"<pre><code>ATR.atr_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>atr</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"atr_equal method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.atr_stats","text":"<pre><code>ATR.atr_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>atr</code> as generic.</p>","title":"atr_stats method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.close_above","text":"<pre><code>ATR.close_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.close_below","text":"<pre><code>ATR.close_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.close_crossed_above","text":"<pre><code>ATR.close_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.close_crossed_below","text":"<pre><code>ATR.close_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.close_equal","text":"<pre><code>ATR.close_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_equal method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.close_stats","text":"<pre><code>ATR.close_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>close</code> as generic.</p>","title":"close_stats method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.high_above","text":"<pre><code>ATR.high_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>high</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"high_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.high_below","text":"<pre><code>ATR.high_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>high</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"high_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.high_crossed_above","text":"<pre><code>ATR.high_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>high</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"high_crossed_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.high_crossed_below","text":"<pre><code>ATR.high_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>high</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"high_crossed_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.high_equal","text":"<pre><code>ATR.high_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>high</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"high_equal method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.high_stats","text":"<pre><code>ATR.high_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>high</code> as generic.</p>","title":"high_stats method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.low_above","text":"<pre><code>ATR.low_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>low</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"low_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.low_below","text":"<pre><code>ATR.low_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>low</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"low_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.low_crossed_above","text":"<pre><code>ATR.low_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>low</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"low_crossed_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.low_crossed_below","text":"<pre><code>ATR.low_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>low</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"low_crossed_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.low_equal","text":"<pre><code>ATR.low_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>low</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"low_equal method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.low_stats","text":"<pre><code>ATR.low_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>low</code> as generic.</p>","title":"low_stats method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.tr_above","text":"<pre><code>ATR.tr_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>tr</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"tr_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.tr_below","text":"<pre><code>ATR.tr_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>tr</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"tr_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.tr_crossed_above","text":"<pre><code>ATR.tr_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>tr</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"tr_crossed_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.tr_crossed_below","text":"<pre><code>ATR.tr_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>tr</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"tr_crossed_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.tr_equal","text":"<pre><code>ATR.tr_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>tr</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"tr_equal method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.tr_stats","text":"<pre><code>ATR.tr_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>tr</code> as generic.</p>","title":"tr_stats method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.custom_func","text":"<pre><code>IndicatorFactory.from_apply_func.&lt;locals&gt;.custom_func(\n    input_list,\n    in_output_list,\n    param_list,\n    *args,\n    input_shape=None,\n    col=None,\n    flex_2d=None,\n    return_cache=False,\n    use_cache=None,\n    use_ray=False,\n    **_kwargs\n)\n</code></pre> <p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p>","title":"custom_func method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.ATR.plot","text":"<pre><code>_ATR.plot(\n    column=None,\n    tr_trace_kwargs=None,\n    atr_trace_kwargs=None,\n    add_trace_kwargs=None,\n    fig=None,\n    **layout_kwargs\n)\n</code></pre> <p>Plot ATR.tr and ATR.atr.</p> <p>Args</p>  <code>column</code> :\u2002<code>str</code> Name of the column to plot. <code>tr_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for ATR.tr. <code>atr_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for ATR.atr. <code>add_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>add_trace</code>. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**layout_kwargs</code> Keyword arguments for layout.  <p>Usage</p> <pre><code>&gt;&gt;&gt; vbt.ATR.run(ohlcv['High'], ohlcv['Low'], ohlcv['Close'], 10).plot()\n</code></pre> <p></p>","title":"plot method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS","text":"<pre><code>BBANDS(\n    wrapper,\n    input_list,\n    input_mapper,\n    in_output_list,\n    output_list,\n    param_list,\n    mapper_list,\n    short_name,\n    level_names\n)\n</code></pre> <p>Bollinger Bands (BBANDS).</p> <p>A Bollinger Band\u00ae is a technical analysis tool defined by a set of lines plotted two standard deviations (positively and negatively) away from a simple moving average (SMA) of the security's price, but can be adjusted to user preferences.</p> <p>See Bollinger Band\u00ae.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>IndicatorBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> <li><code>vectorbt.indicators.basic.ParamIndexer</code></li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>IndicatorBase.config</li> <li>IndicatorBase.iloc</li> <li>IndicatorBase.in_output_names</li> <li>IndicatorBase.indexing_func()</li> <li>IndicatorBase.indexing_kwargs</li> <li>IndicatorBase.input_names</li> <li>IndicatorBase.level_names</li> <li>IndicatorBase.loc</li> <li>IndicatorBase.output_flags</li> <li>IndicatorBase.output_names</li> <li>IndicatorBase.param_names</li> <li>IndicatorBase.plots_defaults</li> <li>IndicatorBase.self_aliases</li> <li>IndicatorBase.short_name</li> <li>IndicatorBase.stats_defaults</li> <li>IndicatorBase.wrapper</li> <li>IndicatorBase.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li><code>vectorbt.indicators.basic._BBANDS</code></li> </ul>","title":"BBANDS class"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.run","text":"<pre><code>BBANDS.run(\n    close,\n    window=Default(20),\n    ewm=Default(False),\n    alpha=Default(2),\n    short_name='bb',\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Run BBANDS indicator.</p> <ul> <li>Inputs: <code>close</code></li> <li>Parameters: <code>window</code>, <code>ewm</code>, <code>alpha</code></li> <li>Outputs: <code>middle</code>, <code>upper</code>, <code>lower</code></li> </ul> <p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels. Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p> <p>Other keyword arguments are passed to run_pipeline().</p>","title":"run class method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.run_combs","text":"<pre><code>BBANDS.run_combs(\n    close,\n    window=Default(20),\n    ewm=Default(False),\n    alpha=Default(2),\n    r=2,\n    param_product=False,\n    comb_func=itertools.combinations,\n    run_unique=True,\n    short_names=None,\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Create a combination of multiple BBANDS indicators using function <code>comb_func</code>.</p> <ul> <li>Inputs: <code>close</code></li> <li>Parameters: <code>window</code>, <code>ewm</code>, <code>alpha</code></li> <li>Outputs: <code>middle</code>, <code>upper</code>, <code>lower</code></li> </ul> <p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.  Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>. Pass <code>r</code> to specify how many indicators to run.  Pass <code>short_names</code> to specify the short name for each indicator.  Set <code>run_unique</code> to True to first compute raw outputs for all parameters,  and then use them to build each indicator (faster).</p> <p>Other keyword arguments are passed to BBANDS.run().</p>","title":"run_combs class method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.alpha_list","text":"<p>List of <code>alpha</code> values.</p>","title":"alpha_list property"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.bandwidth","text":"<p>Custom property.</p>","title":"bandwidth variable"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.close","text":"<p>Input array.</p>","title":"close variable"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.ewm_list","text":"<p>List of <code>ewm</code> values.</p>","title":"ewm_list property"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.lower","text":"<p>Output array.</p>","title":"lower property"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.middle","text":"<p>Output array.</p>","title":"middle property"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.percent_b","text":"<p>Custom property.</p>","title":"percent_b variable"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.upper","text":"<p>Output array.</p>","title":"upper property"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.window_list","text":"<p>List of <code>window</code> values.</p>","title":"window_list property"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.apply_func","text":"<pre><code>BBANDS.apply_func(\n    close,\n    window,\n    ewm,\n    alpha,\n    adjust,\n    ddof,\n    ma_cache_dict,\n    mstd_cache_dict\n)\n</code></pre> <p>Apply function for BBANDS.</p>","title":"apply_func method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.bandwidth_above","text":"<pre><code>BBANDS.bandwidth_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>bandwidth</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"bandwidth_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.bandwidth_below","text":"<pre><code>BBANDS.bandwidth_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>bandwidth</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"bandwidth_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.bandwidth_crossed_above","text":"<pre><code>BBANDS.bandwidth_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>bandwidth</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"bandwidth_crossed_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.bandwidth_crossed_below","text":"<pre><code>BBANDS.bandwidth_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>bandwidth</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"bandwidth_crossed_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.bandwidth_equal","text":"<pre><code>BBANDS.bandwidth_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>bandwidth</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"bandwidth_equal method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.bandwidth_stats","text":"<pre><code>BBANDS.bandwidth_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>bandwidth</code> as generic.</p>","title":"bandwidth_stats method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.close_above","text":"<pre><code>BBANDS.close_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.close_below","text":"<pre><code>BBANDS.close_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.close_crossed_above","text":"<pre><code>BBANDS.close_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.close_crossed_below","text":"<pre><code>BBANDS.close_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.close_equal","text":"<pre><code>BBANDS.close_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_equal method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.close_stats","text":"<pre><code>BBANDS.close_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>close</code> as generic.</p>","title":"close_stats method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.lower_above","text":"<pre><code>BBANDS.lower_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>lower</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"lower_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.lower_below","text":"<pre><code>BBANDS.lower_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>lower</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"lower_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.lower_crossed_above","text":"<pre><code>BBANDS.lower_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>lower</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"lower_crossed_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.lower_crossed_below","text":"<pre><code>BBANDS.lower_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>lower</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"lower_crossed_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.lower_equal","text":"<pre><code>BBANDS.lower_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>lower</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"lower_equal method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.lower_stats","text":"<pre><code>BBANDS.lower_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>lower</code> as generic.</p>","title":"lower_stats method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.middle_above","text":"<pre><code>BBANDS.middle_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>middle</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"middle_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.middle_below","text":"<pre><code>BBANDS.middle_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>middle</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"middle_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.middle_crossed_above","text":"<pre><code>BBANDS.middle_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>middle</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"middle_crossed_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.middle_crossed_below","text":"<pre><code>BBANDS.middle_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>middle</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"middle_crossed_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.middle_equal","text":"<pre><code>BBANDS.middle_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>middle</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"middle_equal method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.middle_stats","text":"<pre><code>BBANDS.middle_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>middle</code> as generic.</p>","title":"middle_stats method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.percent_b_above","text":"<pre><code>BBANDS.percent_b_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>percent_b</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"percent_b_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.percent_b_below","text":"<pre><code>BBANDS.percent_b_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>percent_b</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"percent_b_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.percent_b_crossed_above","text":"<pre><code>BBANDS.percent_b_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>percent_b</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"percent_b_crossed_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.percent_b_crossed_below","text":"<pre><code>BBANDS.percent_b_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>percent_b</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"percent_b_crossed_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.percent_b_equal","text":"<pre><code>BBANDS.percent_b_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>percent_b</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"percent_b_equal method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.percent_b_stats","text":"<pre><code>BBANDS.percent_b_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>percent_b</code> as generic.</p>","title":"percent_b_stats method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.upper_above","text":"<pre><code>BBANDS.upper_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>upper</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"upper_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.upper_below","text":"<pre><code>BBANDS.upper_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>upper</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"upper_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.upper_crossed_above","text":"<pre><code>BBANDS.upper_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>upper</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"upper_crossed_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.upper_crossed_below","text":"<pre><code>BBANDS.upper_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>upper</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"upper_crossed_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.upper_equal","text":"<pre><code>BBANDS.upper_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>upper</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"upper_equal method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.upper_stats","text":"<pre><code>BBANDS.upper_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>upper</code> as generic.</p>","title":"upper_stats method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.custom_func","text":"<pre><code>IndicatorFactory.from_apply_func.&lt;locals&gt;.custom_func(\n    input_list,\n    in_output_list,\n    param_list,\n    *args,\n    input_shape=None,\n    col=None,\n    flex_2d=None,\n    return_cache=False,\n    use_cache=None,\n    use_ray=False,\n    **_kwargs\n)\n</code></pre> <p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p>","title":"custom_func method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.BBANDS.plot","text":"<pre><code>_BBANDS.plot(\n    column=None,\n    plot_close=True,\n    close_trace_kwargs=None,\n    middle_trace_kwargs=None,\n    upper_trace_kwargs=None,\n    lower_trace_kwargs=None,\n    add_trace_kwargs=None,\n    fig=None,\n    **layout_kwargs\n)\n</code></pre> <p>Plot BBANDS.middle, BBANDS.upper and BBANDS.lower against BBANDS.close.</p> <p>Args</p>  <code>column</code> :\u2002<code>str</code> Name of the column to plot. <code>plot_close</code> :\u2002<code>bool</code> Whether to plot MA.close. <code>close_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for BBANDS.close. <code>middle_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for BBANDS.middle. <code>upper_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for BBANDS.upper. <code>lower_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for BBANDS.lower. <code>add_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>add_trace</code>. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**layout_kwargs</code> Keyword arguments for layout.  <p>Usage</p> <pre><code>&gt;&gt;&gt; vbt.BBANDS.run(ohlcv['Close']).plot()\n</code></pre> <p></p>","title":"plot method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MA","text":"<pre><code>MA(\n    wrapper,\n    input_list,\n    input_mapper,\n    in_output_list,\n    output_list,\n    param_list,\n    mapper_list,\n    short_name,\n    level_names\n)\n</code></pre> <p>Moving Average (MA).</p> <p>A moving average is a widely used indicator in technical analysis that helps smooth out price action by filtering out the \u201cnoise\u201d from random short-term price fluctuations. </p> <p>See Moving Average (MA).</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>IndicatorBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> <li><code>vectorbt.indicators.basic.ParamIndexer</code></li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>IndicatorBase.config</li> <li>IndicatorBase.iloc</li> <li>IndicatorBase.in_output_names</li> <li>IndicatorBase.indexing_func()</li> <li>IndicatorBase.indexing_kwargs</li> <li>IndicatorBase.input_names</li> <li>IndicatorBase.level_names</li> <li>IndicatorBase.loc</li> <li>IndicatorBase.output_flags</li> <li>IndicatorBase.output_names</li> <li>IndicatorBase.param_names</li> <li>IndicatorBase.plots_defaults</li> <li>IndicatorBase.self_aliases</li> <li>IndicatorBase.short_name</li> <li>IndicatorBase.stats_defaults</li> <li>IndicatorBase.wrapper</li> <li>IndicatorBase.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li><code>vectorbt.indicators.basic._MA</code></li> </ul>","title":"MA class"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MA.run","text":"<pre><code>MA.run(\n    close,\n    window,\n    ewm=Default(False),\n    short_name='ma',\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Run MA indicator.</p> <ul> <li>Inputs: <code>close</code></li> <li>Parameters: <code>window</code>, <code>ewm</code></li> <li>Outputs: <code>ma</code></li> </ul> <p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels. Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p> <p>Other keyword arguments are passed to run_pipeline().</p>","title":"run class method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MA.run_combs","text":"<pre><code>MA.run_combs(\n    close,\n    window,\n    ewm=Default(False),\n    r=2,\n    param_product=False,\n    comb_func=itertools.combinations,\n    run_unique=True,\n    short_names=None,\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Create a combination of multiple MA indicators using function <code>comb_func</code>.</p> <ul> <li>Inputs: <code>close</code></li> <li>Parameters: <code>window</code>, <code>ewm</code></li> <li>Outputs: <code>ma</code></li> </ul> <p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.  Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>. Pass <code>r</code> to specify how many indicators to run.  Pass <code>short_names</code> to specify the short name for each indicator.  Set <code>run_unique</code> to True to first compute raw outputs for all parameters,  and then use them to build each indicator (faster).</p> <p>Other keyword arguments are passed to MA.run().</p>","title":"run_combs class method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MA.close","text":"<p>Input array.</p>","title":"close variable"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MA.ewm_list","text":"<p>List of <code>ewm</code> values.</p>","title":"ewm_list property"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MA.ma","text":"<p>Output array.</p>","title":"ma property"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MA.window_list","text":"<p>List of <code>window</code> values.</p>","title":"window_list property"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MA.custom_func","text":"<pre><code>IndicatorFactory.from_apply_func.&lt;locals&gt;.custom_func(\n    input_list,\n    in_output_list,\n    param_list,\n    *args,\n    input_shape=None,\n    col=None,\n    flex_2d=None,\n    return_cache=False,\n    use_cache=None,\n    use_ray=False,\n    **_kwargs\n)\n</code></pre> <p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p>","title":"custom_func method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MA.apply_func","text":"<pre><code>MA.apply_func(\n    close,\n    window,\n    ewm,\n    adjust,\n    cache_dict\n)\n</code></pre> <p>Apply function for MA.</p>","title":"apply_func method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MA.close_above","text":"<pre><code>MA.close_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MA.close_below","text":"<pre><code>MA.close_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MA.close_crossed_above","text":"<pre><code>MA.close_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MA.close_crossed_below","text":"<pre><code>MA.close_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MA.close_equal","text":"<pre><code>MA.close_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_equal method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MA.close_stats","text":"<pre><code>MA.close_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>close</code> as generic.</p>","title":"close_stats method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MA.ma_above","text":"<pre><code>MA.ma_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>ma</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"ma_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MA.ma_below","text":"<pre><code>MA.ma_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>ma</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"ma_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MA.ma_crossed_above","text":"<pre><code>MA.ma_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>ma</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"ma_crossed_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MA.ma_crossed_below","text":"<pre><code>MA.ma_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>ma</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"ma_crossed_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MA.ma_equal","text":"<pre><code>MA.ma_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>ma</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"ma_equal method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MA.ma_stats","text":"<pre><code>MA.ma_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>ma</code> as generic.</p>","title":"ma_stats method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MA.plot","text":"<pre><code>_MA.plot(\n    column=None,\n    plot_close=True,\n    close_trace_kwargs=None,\n    ma_trace_kwargs=None,\n    add_trace_kwargs=None,\n    fig=None,\n    **layout_kwargs\n)\n</code></pre> <p>Plot MA.ma against MA.close.</p> <p>Args</p>  <code>column</code> :\u2002<code>str</code> Name of the column to plot. <code>plot_close</code> :\u2002<code>bool</code> Whether to plot MA.close. <code>close_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for MA.close. <code>ma_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for MA.ma. <code>add_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>add_trace</code>. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**layout_kwargs</code> Keyword arguments for layout.  <p>Usage</p> <pre><code>&gt;&gt;&gt; vbt.MA.run(ohlcv['Close'], 10).plot()\n</code></pre> <p></p>","title":"plot method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD","text":"<pre><code>MACD(\n    wrapper,\n    input_list,\n    input_mapper,\n    in_output_list,\n    output_list,\n    param_list,\n    mapper_list,\n    short_name,\n    level_names\n)\n</code></pre> <p>Moving Average Convergence Divergence (MACD).</p> <p>Is a trend-following momentum indicator that shows the relationship between two moving averages of prices.</p> <p>See Moving Average Convergence Divergence \u2013 MACD.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>IndicatorBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> <li><code>vectorbt.indicators.basic.ParamIndexer</code></li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>IndicatorBase.config</li> <li>IndicatorBase.iloc</li> <li>IndicatorBase.in_output_names</li> <li>IndicatorBase.indexing_func()</li> <li>IndicatorBase.indexing_kwargs</li> <li>IndicatorBase.input_names</li> <li>IndicatorBase.level_names</li> <li>IndicatorBase.loc</li> <li>IndicatorBase.output_flags</li> <li>IndicatorBase.output_names</li> <li>IndicatorBase.param_names</li> <li>IndicatorBase.plots_defaults</li> <li>IndicatorBase.self_aliases</li> <li>IndicatorBase.short_name</li> <li>IndicatorBase.stats_defaults</li> <li>IndicatorBase.wrapper</li> <li>IndicatorBase.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li><code>vectorbt.indicators.basic._MACD</code></li> </ul>","title":"MACD class"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.run","text":"<pre><code>MACD.run(\n    close,\n    fast_window=Default(12),\n    slow_window=Default(26),\n    signal_window=Default(9),\n    macd_ewm=Default(False),\n    signal_ewm=Default(False),\n    short_name='macd',\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Run MACD indicator.</p> <ul> <li>Inputs: <code>close</code></li> <li>Parameters: <code>fast_window</code>, <code>slow_window</code>, <code>signal_window</code>, <code>macd_ewm</code>, <code>signal_ewm</code></li> <li>Outputs: <code>macd</code>, <code>signal</code></li> </ul> <p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels. Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p> <p>Other keyword arguments are passed to run_pipeline().</p>","title":"run class method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.run_combs","text":"<pre><code>MACD.run_combs(\n    close,\n    fast_window=Default(12),\n    slow_window=Default(26),\n    signal_window=Default(9),\n    macd_ewm=Default(False),\n    signal_ewm=Default(False),\n    r=2,\n    param_product=False,\n    comb_func=itertools.combinations,\n    run_unique=True,\n    short_names=None,\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Create a combination of multiple MACD indicators using function <code>comb_func</code>.</p> <ul> <li>Inputs: <code>close</code></li> <li>Parameters: <code>fast_window</code>, <code>slow_window</code>, <code>signal_window</code>, <code>macd_ewm</code>, <code>signal_ewm</code></li> <li>Outputs: <code>macd</code>, <code>signal</code></li> </ul> <p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.  Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>. Pass <code>r</code> to specify how many indicators to run.  Pass <code>short_names</code> to specify the short name for each indicator.  Set <code>run_unique</code> to True to first compute raw outputs for all parameters,  and then use them to build each indicator (faster).</p> <p>Other keyword arguments are passed to MACD.run().</p>","title":"run_combs class method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.close","text":"<p>Input array.</p>","title":"close variable"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.fast_window_list","text":"<p>List of <code>fast_window</code> values.</p>","title":"fast_window_list property"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.hist","text":"<p>Custom property.</p>","title":"hist variable"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.macd","text":"<p>Output array.</p>","title":"macd property"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.macd_ewm_list","text":"<p>List of <code>macd_ewm</code> values.</p>","title":"macd_ewm_list property"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.signal","text":"<p>Output array.</p>","title":"signal property"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.signal_ewm_list","text":"<p>List of <code>signal_ewm</code> values.</p>","title":"signal_ewm_list property"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.signal_window_list","text":"<p>List of <code>signal_window</code> values.</p>","title":"signal_window_list property"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.slow_window_list","text":"<p>List of <code>slow_window</code> values.</p>","title":"slow_window_list property"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.custom_func","text":"<pre><code>IndicatorFactory.from_apply_func.&lt;locals&gt;.custom_func(\n    input_list,\n    in_output_list,\n    param_list,\n    *args,\n    input_shape=None,\n    col=None,\n    flex_2d=None,\n    return_cache=False,\n    use_cache=None,\n    use_ray=False,\n    **_kwargs\n)\n</code></pre> <p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p>","title":"custom_func method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.apply_func","text":"<pre><code>MACD.apply_func(\n    close,\n    fast_window,\n    slow_window,\n    signal_window,\n    macd_ewm,\n    signal_ewm,\n    adjust,\n    cache_dict\n)\n</code></pre> <p>Apply function for MACD.</p>","title":"apply_func method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.close_above","text":"<pre><code>MACD.close_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.close_below","text":"<pre><code>MACD.close_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.close_crossed_above","text":"<pre><code>MACD.close_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.close_crossed_below","text":"<pre><code>MACD.close_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.close_equal","text":"<pre><code>MACD.close_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_equal method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.close_stats","text":"<pre><code>MACD.close_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>close</code> as generic.</p>","title":"close_stats method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.hist_above","text":"<pre><code>MACD.hist_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>hist</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"hist_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.hist_below","text":"<pre><code>MACD.hist_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>hist</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"hist_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.hist_crossed_above","text":"<pre><code>MACD.hist_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>hist</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"hist_crossed_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.hist_crossed_below","text":"<pre><code>MACD.hist_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>hist</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"hist_crossed_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.hist_equal","text":"<pre><code>MACD.hist_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>hist</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"hist_equal method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.hist_stats","text":"<pre><code>MACD.hist_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>hist</code> as generic.</p>","title":"hist_stats method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.macd_above","text":"<pre><code>MACD.macd_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>macd</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"macd_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.macd_below","text":"<pre><code>MACD.macd_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>macd</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"macd_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.macd_crossed_above","text":"<pre><code>MACD.macd_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>macd</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"macd_crossed_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.macd_crossed_below","text":"<pre><code>MACD.macd_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>macd</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"macd_crossed_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.macd_equal","text":"<pre><code>MACD.macd_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>macd</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"macd_equal method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.macd_stats","text":"<pre><code>MACD.macd_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>macd</code> as generic.</p>","title":"macd_stats method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.signal_above","text":"<pre><code>MACD.signal_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>signal</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"signal_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.signal_below","text":"<pre><code>MACD.signal_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>signal</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"signal_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.signal_crossed_above","text":"<pre><code>MACD.signal_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>signal</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"signal_crossed_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.signal_crossed_below","text":"<pre><code>MACD.signal_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>signal</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"signal_crossed_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.signal_equal","text":"<pre><code>MACD.signal_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>signal</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"signal_equal method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.signal_stats","text":"<pre><code>MACD.signal_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>signal</code> as generic.</p>","title":"signal_stats method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MACD.plot","text":"<pre><code>_MACD.plot(\n    column=None,\n    macd_trace_kwargs=None,\n    signal_trace_kwargs=None,\n    hist_trace_kwargs=None,\n    add_trace_kwargs=None,\n    fig=None,\n    **layout_kwargs\n)\n</code></pre> <p>Plot MACD.macd, MACD.signal and MACD.hist.</p> <p>Args</p>  <code>column</code> :\u2002<code>str</code> Name of the column to plot. <code>macd_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for MACD.macd. <code>signal_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for MACD.signal. <code>hist_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Bar</code> for MACD.hist. <code>add_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>add_trace</code>. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**layout_kwargs</code> Keyword arguments for layout.  <p>Usage</p> <pre><code>&gt;&gt;&gt; vbt.MACD.run(ohlcv['Close']).plot()\n</code></pre> <p></p>","title":"plot method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MSTD","text":"<pre><code>MSTD(\n    wrapper,\n    input_list,\n    input_mapper,\n    in_output_list,\n    output_list,\n    param_list,\n    mapper_list,\n    short_name,\n    level_names\n)\n</code></pre> <p>Moving Standard Deviation (MSTD).</p> <p>Standard deviation is an indicator that measures the size of an assets recent price moves in order to predict how volatile the price may be in the future.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>IndicatorBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> <li><code>vectorbt.indicators.basic.ParamIndexer</code></li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>IndicatorBase.config</li> <li>IndicatorBase.iloc</li> <li>IndicatorBase.in_output_names</li> <li>IndicatorBase.indexing_func()</li> <li>IndicatorBase.indexing_kwargs</li> <li>IndicatorBase.input_names</li> <li>IndicatorBase.level_names</li> <li>IndicatorBase.loc</li> <li>IndicatorBase.output_flags</li> <li>IndicatorBase.output_names</li> <li>IndicatorBase.param_names</li> <li>IndicatorBase.plots_defaults</li> <li>IndicatorBase.self_aliases</li> <li>IndicatorBase.short_name</li> <li>IndicatorBase.stats_defaults</li> <li>IndicatorBase.wrapper</li> <li>IndicatorBase.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li><code>vectorbt.indicators.basic._MSTD</code></li> </ul>","title":"MSTD class"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MSTD.run","text":"<pre><code>MSTD.run(\n    close,\n    window,\n    ewm=Default(False),\n    short_name='mstd',\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Run MSTD indicator.</p> <ul> <li>Inputs: <code>close</code></li> <li>Parameters: <code>window</code>, <code>ewm</code></li> <li>Outputs: <code>mstd</code></li> </ul> <p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels. Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p> <p>Other keyword arguments are passed to run_pipeline().</p>","title":"run class method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MSTD.run_combs","text":"<pre><code>MSTD.run_combs(\n    close,\n    window,\n    ewm=Default(False),\n    r=2,\n    param_product=False,\n    comb_func=itertools.combinations,\n    run_unique=True,\n    short_names=None,\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Create a combination of multiple MSTD indicators using function <code>comb_func</code>.</p> <ul> <li>Inputs: <code>close</code></li> <li>Parameters: <code>window</code>, <code>ewm</code></li> <li>Outputs: <code>mstd</code></li> </ul> <p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.  Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>. Pass <code>r</code> to specify how many indicators to run.  Pass <code>short_names</code> to specify the short name for each indicator.  Set <code>run_unique</code> to True to first compute raw outputs for all parameters,  and then use them to build each indicator (faster).</p> <p>Other keyword arguments are passed to MSTD.run().</p>","title":"run_combs class method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MSTD.close","text":"<p>Input array.</p>","title":"close variable"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MSTD.ewm_list","text":"<p>List of <code>ewm</code> values.</p>","title":"ewm_list property"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MSTD.mstd","text":"<p>Output array.</p>","title":"mstd property"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MSTD.window_list","text":"<p>List of <code>window</code> values.</p>","title":"window_list property"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MSTD.custom_func","text":"<pre><code>IndicatorFactory.from_apply_func.&lt;locals&gt;.custom_func(\n    input_list,\n    in_output_list,\n    param_list,\n    *args,\n    input_shape=None,\n    col=None,\n    flex_2d=None,\n    return_cache=False,\n    use_cache=None,\n    use_ray=False,\n    **_kwargs\n)\n</code></pre> <p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p>","title":"custom_func method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MSTD.apply_func","text":"<pre><code>MSTD.apply_func(\n    close,\n    window,\n    ewm,\n    adjust,\n    ddof,\n    cache_dict\n)\n</code></pre> <p>Apply function for MSTD.</p>","title":"apply_func method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MSTD.close_above","text":"<pre><code>MSTD.close_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MSTD.close_below","text":"<pre><code>MSTD.close_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MSTD.close_crossed_above","text":"<pre><code>MSTD.close_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MSTD.close_crossed_below","text":"<pre><code>MSTD.close_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MSTD.close_equal","text":"<pre><code>MSTD.close_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_equal method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MSTD.close_stats","text":"<pre><code>MSTD.close_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>close</code> as generic.</p>","title":"close_stats method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MSTD.mstd_above","text":"<pre><code>MSTD.mstd_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>mstd</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"mstd_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MSTD.mstd_below","text":"<pre><code>MSTD.mstd_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>mstd</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"mstd_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MSTD.mstd_crossed_above","text":"<pre><code>MSTD.mstd_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>mstd</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"mstd_crossed_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MSTD.mstd_crossed_below","text":"<pre><code>MSTD.mstd_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>mstd</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"mstd_crossed_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MSTD.mstd_equal","text":"<pre><code>MSTD.mstd_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>mstd</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"mstd_equal method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MSTD.mstd_stats","text":"<pre><code>MSTD.mstd_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>mstd</code> as generic.</p>","title":"mstd_stats method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.MSTD.plot","text":"<pre><code>_MSTD.plot(\n    column=None,\n    mstd_trace_kwargs=None,\n    add_trace_kwargs=None,\n    fig=None,\n    **layout_kwargs\n)\n</code></pre> <p>Plot MSTD.mstd.</p> <p>Args</p>  <code>column</code> :\u2002<code>str</code> Name of the column to plot. <code>mstd_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for MSTD.mstd. <code>add_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>add_trace</code>. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**layout_kwargs</code> Keyword arguments for layout.  <p>Usage</p> <pre><code>&gt;&gt;&gt; vbt.MSTD.run(ohlcv['Close'], 10).plot()\n</code></pre> <p></p>","title":"plot method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.OBV","text":"<pre><code>OBV(\n    wrapper,\n    input_list,\n    input_mapper,\n    in_output_list,\n    output_list,\n    param_list,\n    mapper_list,\n    short_name,\n    level_names\n)\n</code></pre> <p>On-balance volume (OBV).</p> <p>It relates price and volume in the stock market. OBV is based on a cumulative total volume.</p> <p>See On-Balance Volume (OBV).</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>IndicatorBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> <li><code>vectorbt.indicators.basic.ParamIndexer</code></li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>IndicatorBase.config</li> <li>IndicatorBase.iloc</li> <li>IndicatorBase.in_output_names</li> <li>IndicatorBase.indexing_func()</li> <li>IndicatorBase.indexing_kwargs</li> <li>IndicatorBase.input_names</li> <li>IndicatorBase.level_names</li> <li>IndicatorBase.loc</li> <li>IndicatorBase.output_flags</li> <li>IndicatorBase.output_names</li> <li>IndicatorBase.param_names</li> <li>IndicatorBase.plots_defaults</li> <li>IndicatorBase.run_combs()</li> <li>IndicatorBase.self_aliases</li> <li>IndicatorBase.short_name</li> <li>IndicatorBase.stats_defaults</li> <li>IndicatorBase.wrapper</li> <li>IndicatorBase.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li><code>vectorbt.indicators.basic._OBV</code></li> </ul>","title":"OBV class"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.OBV.run","text":"<pre><code>OBV.run(\n    close,\n    volume,\n    short_name='obv',\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Run OBV indicator.</p> <ul> <li>Inputs: <code>close</code>, <code>volume</code></li> <li>Outputs: <code>obv</code></li> </ul> <p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels. Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p> <p>Other keyword arguments are passed to run_pipeline().</p>","title":"run class method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.OBV.close","text":"<p>Input array.</p>","title":"close variable"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.OBV.obv","text":"<p>Output array.</p>","title":"obv property"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.OBV.volume","text":"<p>Input array.</p>","title":"volume variable"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.OBV.close_above","text":"<pre><code>OBV.close_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.OBV.close_below","text":"<pre><code>OBV.close_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.OBV.close_crossed_above","text":"<pre><code>OBV.close_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.OBV.close_crossed_below","text":"<pre><code>OBV.close_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.OBV.close_equal","text":"<pre><code>OBV.close_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_equal method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.OBV.close_stats","text":"<pre><code>OBV.close_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>close</code> as generic.</p>","title":"close_stats method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.OBV.custom_func","text":"<pre><code>OBV.custom_func(\n    close,\n    volume_ts\n)\n</code></pre> <p>Custom calculation function for OBV.</p>","title":"custom_func method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.OBV.obv_above","text":"<pre><code>OBV.obv_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>obv</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"obv_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.OBV.obv_below","text":"<pre><code>OBV.obv_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>obv</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"obv_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.OBV.obv_crossed_above","text":"<pre><code>OBV.obv_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>obv</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"obv_crossed_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.OBV.obv_crossed_below","text":"<pre><code>OBV.obv_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>obv</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"obv_crossed_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.OBV.obv_equal","text":"<pre><code>OBV.obv_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>obv</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"obv_equal method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.OBV.obv_stats","text":"<pre><code>OBV.obv_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>obv</code> as generic.</p>","title":"obv_stats method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.OBV.volume_above","text":"<pre><code>OBV.volume_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>volume</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"volume_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.OBV.volume_below","text":"<pre><code>OBV.volume_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>volume</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"volume_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.OBV.volume_crossed_above","text":"<pre><code>OBV.volume_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>volume</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"volume_crossed_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.OBV.volume_crossed_below","text":"<pre><code>OBV.volume_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>volume</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"volume_crossed_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.OBV.volume_equal","text":"<pre><code>OBV.volume_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>volume</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"volume_equal method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.OBV.volume_stats","text":"<pre><code>OBV.volume_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>volume</code> as generic.</p>","title":"volume_stats method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.OBV.plot","text":"<pre><code>_OBV.plot(\n    column=None,\n    obv_trace_kwargs=None,\n    add_trace_kwargs=None,\n    fig=None,\n    **layout_kwargs\n)\n</code></pre> <p>Plot OBV.obv.</p> <p>Args</p>  <code>column</code> :\u2002<code>str</code> Name of the column to plot. <code>obv_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for OBV.obv. <code>add_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>add_trace</code>. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**layout_kwargs</code> Keyword arguments for layout.  <p>Usage</p> <pre><code>&gt;&gt;&gt; vbt.OBV.run(ohlcv['Close'], ohlcv['Volume']).plot()\n</code></pre> <p></p>","title":"plot method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.RSI","text":"<pre><code>RSI(\n    wrapper,\n    input_list,\n    input_mapper,\n    in_output_list,\n    output_list,\n    param_list,\n    mapper_list,\n    short_name,\n    level_names\n)\n</code></pre> <p>Relative Strength Index (RSI).</p> <p>Compares the magnitude of recent gains and losses over a specified time period to measure speed and change of price movements of a security. It is primarily used to attempt to identify overbought or oversold conditions in the trading of an asset.</p> <p>See Relative Strength Index (RSI).</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>IndicatorBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> <li><code>vectorbt.indicators.basic.ParamIndexer</code></li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>IndicatorBase.config</li> <li>IndicatorBase.iloc</li> <li>IndicatorBase.in_output_names</li> <li>IndicatorBase.indexing_func()</li> <li>IndicatorBase.indexing_kwargs</li> <li>IndicatorBase.input_names</li> <li>IndicatorBase.level_names</li> <li>IndicatorBase.loc</li> <li>IndicatorBase.output_flags</li> <li>IndicatorBase.output_names</li> <li>IndicatorBase.param_names</li> <li>IndicatorBase.plots_defaults</li> <li>IndicatorBase.self_aliases</li> <li>IndicatorBase.short_name</li> <li>IndicatorBase.stats_defaults</li> <li>IndicatorBase.wrapper</li> <li>IndicatorBase.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li><code>vectorbt.indicators.basic._RSI</code></li> </ul>","title":"RSI class"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.RSI.run","text":"<pre><code>RSI.run(\n    close,\n    window=Default(14),\n    ewm=Default(False),\n    short_name='rsi',\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Run RSI indicator.</p> <ul> <li>Inputs: <code>close</code></li> <li>Parameters: <code>window</code>, <code>ewm</code></li> <li>Outputs: <code>rsi</code></li> </ul> <p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels. Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p> <p>Other keyword arguments are passed to run_pipeline().</p>","title":"run class method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.RSI.run_combs","text":"<pre><code>RSI.run_combs(\n    close,\n    window=Default(14),\n    ewm=Default(False),\n    r=2,\n    param_product=False,\n    comb_func=itertools.combinations,\n    run_unique=True,\n    short_names=None,\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Create a combination of multiple RSI indicators using function <code>comb_func</code>.</p> <ul> <li>Inputs: <code>close</code></li> <li>Parameters: <code>window</code>, <code>ewm</code></li> <li>Outputs: <code>rsi</code></li> </ul> <p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.  Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>. Pass <code>r</code> to specify how many indicators to run.  Pass <code>short_names</code> to specify the short name for each indicator.  Set <code>run_unique</code> to True to first compute raw outputs for all parameters,  and then use them to build each indicator (faster).</p> <p>Other keyword arguments are passed to RSI.run().</p>","title":"run_combs class method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.RSI.close","text":"<p>Input array.</p>","title":"close variable"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.RSI.ewm_list","text":"<p>List of <code>ewm</code> values.</p>","title":"ewm_list property"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.RSI.rsi","text":"<p>Output array.</p>","title":"rsi property"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.RSI.window_list","text":"<p>List of <code>window</code> values.</p>","title":"window_list property"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.RSI.custom_func","text":"<pre><code>IndicatorFactory.from_apply_func.&lt;locals&gt;.custom_func(\n    input_list,\n    in_output_list,\n    param_list,\n    *args,\n    input_shape=None,\n    col=None,\n    flex_2d=None,\n    return_cache=False,\n    use_cache=None,\n    use_ray=False,\n    **_kwargs\n)\n</code></pre> <p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p>","title":"custom_func method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.RSI.apply_func","text":"<pre><code>RSI.apply_func(\n    close,\n    window,\n    ewm,\n    adjust,\n    cache_dict\n)\n</code></pre> <p>Apply function for RSI.</p>","title":"apply_func method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.RSI.close_above","text":"<pre><code>RSI.close_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.RSI.close_below","text":"<pre><code>RSI.close_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.RSI.close_crossed_above","text":"<pre><code>RSI.close_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.RSI.close_crossed_below","text":"<pre><code>RSI.close_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.RSI.close_equal","text":"<pre><code>RSI.close_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_equal method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.RSI.close_stats","text":"<pre><code>RSI.close_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>close</code> as generic.</p>","title":"close_stats method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.RSI.rsi_above","text":"<pre><code>RSI.rsi_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>rsi</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"rsi_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.RSI.rsi_below","text":"<pre><code>RSI.rsi_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>rsi</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"rsi_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.RSI.rsi_crossed_above","text":"<pre><code>RSI.rsi_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>rsi</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"rsi_crossed_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.RSI.rsi_crossed_below","text":"<pre><code>RSI.rsi_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>rsi</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"rsi_crossed_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.RSI.rsi_equal","text":"<pre><code>RSI.rsi_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>rsi</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"rsi_equal method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.RSI.rsi_stats","text":"<pre><code>RSI.rsi_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>rsi</code> as generic.</p>","title":"rsi_stats method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.RSI.plot","text":"<pre><code>_RSI.plot(\n    column=None,\n    levels=(30, 70),\n    rsi_trace_kwargs=None,\n    add_trace_kwargs=None,\n    xref='x',\n    yref='y',\n    fig=None,\n    **layout_kwargs\n)\n</code></pre> <p>Plot RSI.rsi.</p> <p>Args</p>  <code>column</code> :\u2002<code>str</code> Name of the column to plot. <code>levels</code> :\u2002<code>tuple</code> Two extremes: bottom and top. <code>rsi_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for RSI.rsi. <code>add_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>add_trace</code>. <code>xref</code> :\u2002<code>str</code> X coordinate axis. <code>yref</code> :\u2002<code>str</code> Y coordinate axis. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**layout_kwargs</code> Keyword arguments for layout.  <p>Usage</p> <pre><code>&gt;&gt;&gt; vbt.RSI.run(ohlcv['Close']).plot()\n</code></pre> <p></p>","title":"plot method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH","text":"<pre><code>STOCH(\n    wrapper,\n    input_list,\n    input_mapper,\n    in_output_list,\n    output_list,\n    param_list,\n    mapper_list,\n    short_name,\n    level_names\n)\n</code></pre> <p>Stochastic Oscillator (STOCH).</p> <p>A stochastic oscillator is a momentum indicator comparing a particular closing price of a security to a range of its prices over a certain period of time. It is used to generate overbought and oversold trading signals, utilizing a 0-100 bounded range of values.</p> <p>See Stochastic Oscillator.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>IndicatorBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> <li><code>vectorbt.indicators.basic.ParamIndexer</code></li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>IndicatorBase.config</li> <li>IndicatorBase.iloc</li> <li>IndicatorBase.in_output_names</li> <li>IndicatorBase.indexing_func()</li> <li>IndicatorBase.indexing_kwargs</li> <li>IndicatorBase.input_names</li> <li>IndicatorBase.level_names</li> <li>IndicatorBase.loc</li> <li>IndicatorBase.output_flags</li> <li>IndicatorBase.output_names</li> <li>IndicatorBase.param_names</li> <li>IndicatorBase.plots_defaults</li> <li>IndicatorBase.self_aliases</li> <li>IndicatorBase.short_name</li> <li>IndicatorBase.stats_defaults</li> <li>IndicatorBase.wrapper</li> <li>IndicatorBase.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li><code>vectorbt.indicators.basic._STOCH</code></li> </ul>","title":"STOCH class"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.run","text":"<pre><code>STOCH.run(\n    high,\n    low,\n    close,\n    k_window=Default(14),\n    d_window=Default(3),\n    d_ewm=Default(False),\n    short_name='stoch',\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Run STOCH indicator.</p> <ul> <li>Inputs: <code>high</code>, <code>low</code>, <code>close</code></li> <li>Parameters: <code>k_window</code>, <code>d_window</code>, <code>d_ewm</code></li> <li>Outputs: <code>percent_k</code>, <code>percent_d</code></li> </ul> <p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels. Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p> <p>Other keyword arguments are passed to run_pipeline().</p>","title":"run class method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.run_combs","text":"<pre><code>STOCH.run_combs(\n    high,\n    low,\n    close,\n    k_window=Default(14),\n    d_window=Default(3),\n    d_ewm=Default(False),\n    r=2,\n    param_product=False,\n    comb_func=itertools.combinations,\n    run_unique=True,\n    short_names=None,\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Create a combination of multiple STOCH indicators using function <code>comb_func</code>.</p> <ul> <li>Inputs: <code>high</code>, <code>low</code>, <code>close</code></li> <li>Parameters: <code>k_window</code>, <code>d_window</code>, <code>d_ewm</code></li> <li>Outputs: <code>percent_k</code>, <code>percent_d</code></li> </ul> <p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.  Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>. Pass <code>r</code> to specify how many indicators to run.  Pass <code>short_names</code> to specify the short name for each indicator.  Set <code>run_unique</code> to True to first compute raw outputs for all parameters,  and then use them to build each indicator (faster).</p> <p>Other keyword arguments are passed to STOCH.run().</p>","title":"run_combs class method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.close","text":"<p>Input array.</p>","title":"close variable"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.d_ewm_list","text":"<p>List of <code>d_ewm</code> values.</p>","title":"d_ewm_list property"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.d_window_list","text":"<p>List of <code>d_window</code> values.</p>","title":"d_window_list property"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.high","text":"<p>Input array.</p>","title":"high variable"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.k_window_list","text":"<p>List of <code>k_window</code> values.</p>","title":"k_window_list property"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.low","text":"<p>Input array.</p>","title":"low variable"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.percent_d","text":"<p>Output array.</p>","title":"percent_d property"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.percent_k","text":"<p>Output array.</p>","title":"percent_k property"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.custom_func","text":"<pre><code>IndicatorFactory.from_apply_func.&lt;locals&gt;.custom_func(\n    input_list,\n    in_output_list,\n    param_list,\n    *args,\n    input_shape=None,\n    col=None,\n    flex_2d=None,\n    return_cache=False,\n    use_cache=None,\n    use_ray=False,\n    **_kwargs\n)\n</code></pre> <p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p>","title":"custom_func method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.apply_func","text":"<pre><code>STOCH.apply_func(\n    high,\n    low,\n    close,\n    k_window,\n    d_window,\n    d_ewm,\n    adjust,\n    cache_dict\n)\n</code></pre> <p>Apply function for STOCH.</p>","title":"apply_func method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.close_above","text":"<pre><code>STOCH.close_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.close_below","text":"<pre><code>STOCH.close_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.close_crossed_above","text":"<pre><code>STOCH.close_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.close_crossed_below","text":"<pre><code>STOCH.close_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.close_equal","text":"<pre><code>STOCH.close_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_equal method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.close_stats","text":"<pre><code>STOCH.close_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>close</code> as generic.</p>","title":"close_stats method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.high_above","text":"<pre><code>STOCH.high_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>high</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"high_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.high_below","text":"<pre><code>STOCH.high_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>high</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"high_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.high_crossed_above","text":"<pre><code>STOCH.high_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>high</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"high_crossed_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.high_crossed_below","text":"<pre><code>STOCH.high_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>high</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"high_crossed_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.high_equal","text":"<pre><code>STOCH.high_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>high</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"high_equal method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.high_stats","text":"<pre><code>STOCH.high_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>high</code> as generic.</p>","title":"high_stats method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.low_above","text":"<pre><code>STOCH.low_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>low</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"low_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.low_below","text":"<pre><code>STOCH.low_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>low</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"low_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.low_crossed_above","text":"<pre><code>STOCH.low_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>low</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"low_crossed_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.low_crossed_below","text":"<pre><code>STOCH.low_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>low</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"low_crossed_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.low_equal","text":"<pre><code>STOCH.low_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>low</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"low_equal method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.low_stats","text":"<pre><code>STOCH.low_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>low</code> as generic.</p>","title":"low_stats method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.percent_d_above","text":"<pre><code>STOCH.percent_d_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>percent_d</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"percent_d_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.percent_d_below","text":"<pre><code>STOCH.percent_d_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>percent_d</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"percent_d_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.percent_d_crossed_above","text":"<pre><code>STOCH.percent_d_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>percent_d</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"percent_d_crossed_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.percent_d_crossed_below","text":"<pre><code>STOCH.percent_d_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>percent_d</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"percent_d_crossed_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.percent_d_equal","text":"<pre><code>STOCH.percent_d_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>percent_d</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"percent_d_equal method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.percent_d_stats","text":"<pre><code>STOCH.percent_d_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>percent_d</code> as generic.</p>","title":"percent_d_stats method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.percent_k_above","text":"<pre><code>STOCH.percent_k_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>percent_k</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"percent_k_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.percent_k_below","text":"<pre><code>STOCH.percent_k_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>percent_k</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"percent_k_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.percent_k_crossed_above","text":"<pre><code>STOCH.percent_k_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>percent_k</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"percent_k_crossed_above method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.percent_k_crossed_below","text":"<pre><code>STOCH.percent_k_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>percent_k</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"percent_k_crossed_below method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.percent_k_equal","text":"<pre><code>STOCH.percent_k_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>percent_k</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"percent_k_equal method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.percent_k_stats","text":"<pre><code>STOCH.percent_k_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>percent_k</code> as generic.</p>","title":"percent_k_stats method"},{"location":"api/indicators/basic/#vectorbt.indicators.basic.STOCH.plot","text":"<pre><code>_STOCH.plot(\n    column=None,\n    levels=(30, 70),\n    percent_k_trace_kwargs=None,\n    percent_d_trace_kwargs=None,\n    shape_kwargs=None,\n    add_trace_kwargs=None,\n    xref='x',\n    yref='y',\n    fig=None,\n    **layout_kwargs\n)\n</code></pre> <p>Plot STOCH.percent_k and STOCH.percent_d.</p> <p>Args</p>  <code>column</code> :\u2002<code>str</code> Name of the column to plot. <code>levels</code> :\u2002<code>tuple</code> Two extremes: bottom and top. <code>percent_k_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for STOCH.percent_k. <code>percent_d_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for STOCH.percent_d. <code>shape_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>Figure or FigureWidget.add_shape</code> for zone between levels. <code>add_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>add_trace</code>. <code>xref</code> :\u2002<code>str</code> X coordinate axis. <code>yref</code> :\u2002<code>str</code> Y coordinate axis. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**layout_kwargs</code> Keyword arguments for layout.  <p>Usage</p> <pre><code>&gt;&gt;&gt; vbt.STOCH.run(ohlcv['High'], ohlcv['Low'], ohlcv['Close']).plot()\n</code></pre> <p></p>","title":"plot method"},{"location":"api/indicators/configs/","text":"<p>Common configurations for indicators.</p>","title":"configs"},{"location":"api/indicators/configs/#vectorbt.indicators.configs.flex_col_param_config","text":"<p>Config for flexible column-wise parameters.</p>","title":"flex_col_param_config variable"},{"location":"api/indicators/configs/#vectorbt.indicators.configs.flex_elem_param_config","text":"<p>Config for flexible element-wise parameters.</p>","title":"flex_elem_param_config variable"},{"location":"api/indicators/factory/","text":"<p>A factory for building new indicators with ease.</p> <p>The indicator factory class IndicatorFactory offers a convenient way to create technical indicators of any complexity. By providing it with information such as calculation functions and the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class capable of running the indicator for an arbitrary combination of your inputs and parameters. It also creates methods for signal generation and supports common pandas and parameter indexing operations.</p> <p>Each indicator is basically a pipeline that:</p> <ul> <li>Accepts a list of input arrays (for example, OHLCV data)</li> <li>Accepts a list of parameter arrays (for example, window size)</li> <li>Accepts other relevant arguments and keyword arguments</li> <li>For each parameter combination, performs calculation on the input arrays</li> <li>Concatenates results into new output arrays (for example, rolling average)</li> </ul> <p>This pipeline can be well standardized, which is done by run_pipeline().</p> <p>IndicatorFactory simplifies the usage of run_pipeline() by generating and pre-configuring a new Python class with various class methods for running the indicator.</p> <p>Each generated class includes the following features:</p> <ul> <li>Accepts input arrays of any compatible shape thanks to broadcasting</li> <li>Accepts output arrays written in-place instead of returning</li> <li>Accepts arbitrary parameter grids</li> <li>Supports caching and other optimizations out of the box</li> <li>Supports pandas and parameter indexing</li> <li>Offers helper methods for all inputs, outputs, and properties</li> </ul> <p>Consider the following price DataFrame composed of two columns, one per asset:</p> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from numba import njit\n&gt;&gt;&gt; from datetime import datetime\n\n&gt;&gt;&gt; price = pd.DataFrame({\n...     'a': [1, 2, 3, 4, 5],\n...     'b': [5, 4, 3, 2, 1]\n... }, index=pd.Index([\n...     datetime(2020, 1, 1),\n...     datetime(2020, 1, 2),\n...     datetime(2020, 1, 3),\n...     datetime(2020, 1, 4),\n...     datetime(2020, 1, 5),\n... ])).astype(float)\n&gt;&gt;&gt; price\n            a    b\n2020-01-01  1.0  5.0\n2020-01-02  2.0  4.0\n2020-01-03  3.0  3.0\n2020-01-04  4.0  2.0\n2020-01-05  5.0  1.0\n</code></pre> <p>For each column in the DataFrame, let's calculate a simple moving average and get its crossover with price. In particular, we want to test two different window sizes: 2 and 3.</p>","title":"factory"},{"location":"api/indicators/factory/#naive-approach","text":"<p>A naive way of doing this:</p> <pre><code>&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(\n...     price.rolling(window=2).mean(),\n...     price.rolling(window=3).mean(),\n...     keys=pd.Index([2, 3], name='ma_window'))\n&gt;&gt;&gt; ma_df\nma_window          2         3\n              a    b    a    b\n2020-01-01  NaN  NaN  NaN  NaN\n2020-01-02  1.5  4.5  NaN  NaN\n2020-01-03  2.5  3.5  2.0  4.0\n2020-01-04  3.5  2.5  3.0  3.0\n2020-01-05  4.5  1.5  4.0  2.0\n\n&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)\n&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)\n&gt;&gt;&gt; above_signals\nma_window              2             3\n                a      b      a      b\n2020-01-01  False  False  False  False\n2020-01-02   True  False  False  False\n2020-01-03  False  False   True  False\n2020-01-04  False  False  False  False\n2020-01-05  False  False  False  False\n\n&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)\n&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)\n&gt;&gt;&gt; below_signals\nma_window              2             3\n                a      b      a      b\n2020-01-01  False  False  False  False\n2020-01-02  False   True  False  False\n2020-01-03  False  False  False   True\n2020-01-04  False  False  False  False\n2020-01-05  False  False  False  False\n</code></pre> <p>Now the same using IndicatorFactory:</p> <pre><code>&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(\n...     input_names=['price'],\n...     param_names=['window'],\n...     output_names=['ma'],\n... ).from_apply_func(vbt.nb.rolling_mean_nb)\n\n&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])\n&gt;&gt;&gt; above_signals = myind.price_crossed_above(myind.ma)\n&gt;&gt;&gt; below_signals = myind.price_crossed_below(myind.ma)\n</code></pre> <p>The IndicatorFactory class is used to construct indicator classes from UDFs. First, we provide all the necessary information (indicator conig) to build the facade of the indicator, such as the names of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a self-contained indicator class capable of running arbitrary configurations of inputs and parameters. To run any configuration, we can either use the <code>run</code> method (as we did above) or the <code>run_combs</code> method.</p>","title":"Naive approach"},{"location":"api/indicators/factory/#run-and-run_combs-methods","text":"<p>The main method to run an indicator is <code>run</code>, which accepts arguments based on the config provided to the IndicatorFactory (see the example above). These arguments include input arrays, in-place output arrays, parameters, and arguments for run_pipeline().</p> <p>The <code>run_combs</code> method takes the same inputs as the method above, but computes all combinations of passed parameters based on a combinatorial function and returns multiple instances that can be compared with each other. For example, this is useful to generate crossover signals of multiple moving averages:</p> <pre><code>&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])\n\n&gt;&gt;&gt; myind1.ma\nmyind_1_window                  2         3\n                 a    b    a    b    a    b\n2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN\n2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN\n2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0\n2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0\n2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0\n\n&gt;&gt;&gt; myind2.ma\nmyind_2_window        3                   4\n                 a    b    a    b    a    b\n2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN\n2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN\n2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN\n2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5\n2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5\n\n&gt;&gt;&gt; myind1.ma_crossed_above(myind2.ma)\nmyind_1_window                          2             3\nmyind_2_window            3             4             4\n                   a      b      a      b      a      b\n2020-01-01     False  False  False  False  False  False\n2020-01-02     False  False  False  False  False  False\n2020-01-03      True  False  False  False  False  False\n2020-01-04     False  False   True  False   True  False\n2020-01-05     False  False  False  False  False  False\n</code></pre> <p>Its main advantage is that it doesn't need to re-compute each combination thanks to smart caching.</p> <p>To get details on what arguments are accepted by any of the class methods, use <code>help</code>:</p> <pre><code>&gt;&gt;&gt; help(MyInd.run)\nHelp on method run:\n\nrun(price, window, short_name='custom', hide_params=None, hide_default=True, **kwargs) method of builtins.type instance\n    Run `Indicator` indicator.\n\n    * Inputs: `price`\n    * Parameters: `window`\n    * Outputs: `ma`\n\n    Pass a list of parameter names as `hide_params` to hide their column levels.\n    Set `hide_default` to False to show the column levels of the parameters with a default value.\n\n    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.\n</code></pre>","title":"run and run_combs methods"},{"location":"api/indicators/factory/#parameters","text":"<p>IndicatorFactory allows definition of arbitrary parameter grids.</p> <p>Parameters are variables that can hold one or more values. A single value can be passed as a scalar, an array, or any other object. Multiple values are passed as a list or an array (if the flag <code>is_array_like</code> is set to False for that parameter). If there are multiple parameters and each is having multiple values, their values will broadcast to a single shape:</p> <pre><code>       p1         p2            result\n0       0          1          [(0, 1)]\n1  [0, 1]        [2]  [(0, 2), (1, 2)]\n2  [0, 1]     [2, 3]  [(0, 2), (1, 3)]\n3  [0, 1]  [2, 3, 4]             error\n</code></pre> <p>To illustrate the usage of parameters in indicators, let's build a basic indicator that returns 1 if the rolling mean is within upper and lower bounds, and -1 if it's outside:</p> <pre><code>&gt;&gt;&gt; @njit\n... def apply_func_nb(price, window, lower, upper):\n...     output = np.full(price.shape, np.nan, dtype=np.float_)\n...     for col in range(price.shape[1]):\n...         for i in range(window, price.shape[0]):\n...             mean = np.mean(price[i - window:i, col])\n...             output[i, col] = lower &lt; mean &lt; upper\n...     return output\n\n&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(\n...     input_names=['price'],\n...     param_names=['window', 'lower', 'upper'],\n...     output_names=['output']\n... ).from_apply_func(apply_func_nb)\n</code></pre> <p>By default, when <code>per_column</code> is set to False, each parameter is applied to the entire input.</p> <p>One parameter combination:</p> <pre><code>&gt;&gt;&gt; MyInd.run(\n...     price,\n...     window=2,\n...     lower=3,\n...     upper=5\n... ).output\ncustom_window         2\ncustom_lower          3\ncustom_upper          5\n                 a    b\n2020-01-01     NaN  NaN\n2020-01-02     NaN  NaN\n2020-01-03     0.0  1.0\n2020-01-04     0.0  1.0\n2020-01-05     1.0  0.0\n</code></pre> <p>Multiple parameter combinations:</p> <pre><code>&gt;&gt;&gt; MyInd.run(\n...     price,\n...     window=[2, 3],\n...     lower=3,\n...     upper=5\n... ).output\ncustom_window         2         3\ncustom_lower          3         3\ncustom_upper          5         5\n                 a    b    a    b\n2020-01-01     NaN  NaN  NaN  NaN\n2020-01-02     NaN  NaN  NaN  NaN\n2020-01-03     0.0  1.0  NaN  NaN\n2020-01-04     0.0  1.0  0.0  1.0\n2020-01-05     1.0  0.0  0.0  0.0\n</code></pre> <p>Product of parameter combinations:</p> <pre><code>&gt;&gt;&gt; MyInd.run(\n...     price,\n...     window=[2, 3],\n...     lower=[3, 4],\n...     upper=5,\n...     param_product=True\n... ).output\ncustom_window                   2                   3\ncustom_lower          3         4         3         4\ncustom_upper          5         5         5         5\n                 a    b    a    b    a    b    a    b\n2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN\n2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN\n2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN\n2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0\n2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n</code></pre> <p>Multiple parameter combinations, one per column:</p> <pre><code>&gt;&gt;&gt; MyInd.run(\n...     price,\n...     window=[2, 3],\n...     lower=[3, 4],\n...     upper=5,\n...     per_column=True\n... ).output\ncustom_window    2    3\ncustom_lower     3    4\ncustom_upper     5    5\n                 a    b\n2020-01-01     NaN  NaN\n2020-01-02     NaN  NaN\n2020-01-03     0.0  NaN\n2020-01-04     0.0  0.0\n2020-01-05     1.0  0.0\n</code></pre> <p>Parameter defaults can be passed directly to the IndicatorFactory.from_custom_func() and IndicatorFactory.from_apply_func(), and overriden in the run method:</p> <pre><code>&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(\n...     input_names=['price'],\n...     param_names=['window', 'lower', 'upper'],\n...     output_names=['output']\n... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)\n\n&gt;&gt;&gt; MyInd.run(price, upper=5).output\ncustom_window         2\ncustom_lower          3\ncustom_upper          5\n                 a    b\n2020-01-01     NaN  NaN\n2020-01-02     NaN  NaN\n2020-01-03     0.0  1.0\n2020-01-04     0.0  1.0\n2020-01-05     1.0  0.0\n</code></pre> <p>Some parameters are meant to be defined per row, column, or element of the input. By default, if we pass the parameter value as an array, the indicator will treat this array as a list of multiple values - one per input. To make the indicator view this array as a single value, set the flag <code>is_array_like</code> to True in <code>param_settings</code>. Also, to automatically broadcast the passed scalar/array to the input shape, set <code>bc_to_input</code> to True, 0 (index axis), or 1 (column axis).</p> <p>In our example, the parameter <code>window</code> can broadcast per column, and both parameters <code>lower</code> and <code>upper</code> can broadcast per element:</p> <pre><code>&gt;&gt;&gt; @njit\n... def apply_func_nb(price, window, lower, upper):\n...     output = np.full(price.shape, np.nan, dtype=np.float_)\n...     for col in range(price.shape[1]):\n...         for i in range(window[col], price.shape[0]):\n...             mean = np.mean(price[i - window[col]:i, col])\n...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]\n...     return output\n\n&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(\n...     input_names=['price'],\n...     param_names=['window', 'lower', 'upper'],\n...     output_names=['output']\n... ).from_apply_func(\n...     apply_func_nb,\n...     param_settings=dict(\n...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),\n...         lower=dict(is_array_like=True, bc_to_input=True),\n...         upper=dict(is_array_like=True, bc_to_input=True)\n...     )\n... )\n\n&gt;&gt;&gt; MyInd.run(\n...     price,\n...     window=[np.array([2, 3]), np.array([3, 4])],\n...     lower=np.array([1, 2]),\n...     upper=np.array([3, 4]),\n... ).output\ncustom_window       2       3               4\ncustom_lower  array_0 array_0 array_1 array_1\ncustom_upper  array_0 array_0 array_1 array_1\n                    a       b       a       b\n2020-01-01        NaN     NaN     NaN     NaN\n2020-01-02        NaN     NaN     NaN     NaN\n2020-01-03        1.0     NaN     NaN     NaN\n2020-01-04        1.0     0.0     1.0     NaN\n2020-01-05        0.0     1.0     0.0     1.0\n</code></pre> <p>Broadcasting a huge number of parameters to the input shape can consume lots of memory, especially when the array materializes. Luckily, vectorbt implements flexible broadcasting, which preserves the original dimensions of the parameter. This requires two changes: setting <code>keep_raw</code> to True in <code>broadcast_kwargs</code> and passing <code>flex_2d</code> to the apply function.</p> <p>There are two configs in vectorbt.indicators.configs exactly for this purpose: one for column-wise broadcasting and one for element-wise broadcasting:</p> <pre><code>&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb\n&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config\n\n&gt;&gt;&gt; @njit\n... def apply_func_nb(price, window, lower, upper, flex_2d):\n...     output = np.full(price.shape, np.nan, dtype=np.float_)\n...     for col in range(price.shape[1]):\n...         _window = flex_select_auto_nb(window, 0, col, flex_2d)\n...         for i in range(_window, price.shape[0]):\n...             _lower = flex_select_auto_nb(lower, i, col, flex_2d)\n...             _upper = flex_select_auto_nb(upper, i, col, flex_2d)\n...             mean = np.mean(price[i - _window:i, col])\n...             output[i, col] = _lower &lt; mean &lt; _upper\n...     return output\n\n&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(\n...     input_names=['price'],\n...     param_names=['window', 'lower', 'upper'],\n...     output_names=['output']\n... ).from_apply_func(\n...     apply_func_nb,\n...     param_settings=dict(\n...         window=flex_col_param_config,\n...         lower=flex_elem_param_config,\n...         upper=flex_elem_param_config\n...     ),\n...     pass_flex_2d=True\n... )\n</code></pre> <p>Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional array (value per row or column, depending upon whether input is a Series or a DataFrame), a 2-dimensional array (value per element), or a list of any of those. This allows for the highest parameter flexibility at the lowest memory cost.</p> <p>For example, let's build a grid of two parameter combinations, each being one window size per column and both bounds per element:</p> <pre><code>&gt;&gt;&gt; MyInd.run(\n...     price,\n...     window=[np.array([2, 3]), np.array([3, 4])],\n...     lower=price.values - 3,\n...     upper=price.values + 3,\n... ).output\ncustom_window       2       3               4\ncustom_lower  array_0 array_0 array_1 array_1\ncustom_upper  array_0 array_0 array_1 array_1\n                    a       b       a       b\n2020-01-01        NaN     NaN     NaN     NaN\n2020-01-02        NaN     NaN     NaN     NaN\n2020-01-03        1.0     NaN     NaN     NaN\n2020-01-04        1.0     1.0     1.0     NaN\n2020-01-05        1.0     1.0     1.0     1.0\n</code></pre> <p>Indicators can also be parameterless. See OBV.</p>","title":"Parameters"},{"location":"api/indicators/factory/#inputs","text":"<p>IndicatorFactory supports passing none, one, or multiple inputs. If multiple inputs are passed, it tries to broadcast them into a single shape.</p> <p>Remember that in vectorbt each column means a separate backtest instance. That's why in order to use multiple pieces of information, such as open, high, low, close, and volume, we need to provide them as separate pandas objects rather than a single DataFrame.</p> <p>Let's create a parameterless indicator that measures the position of the close price within each bar:</p> <pre><code>&gt;&gt;&gt; @njit\n... def apply_func_nb(high, low, close):\n...     return (close - low) / (high - low)\n\n&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(\n...     input_names=['high', 'low', 'close'],\n...     output_names=['output']\n... ).from_apply_func(apply_func_nb)\n\n&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output\n              a    b\n2020-01-01  0.5  0.5\n2020-01-02  0.5  0.5\n2020-01-03  0.5  0.5\n2020-01-04  0.5  0.5\n2020-01-05  0.5  0.5\n</code></pre> <p>To demonstrate broadcasting, let's pass high as a DataFrame, low as a Series, and close as a scalar:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))\n&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))\n&gt;&gt;&gt; MyInd.run(df, sr, 1).output\n          0         1\n0  0.960680  0.666820\n1  0.400646  0.528456\n2  0.093467  0.134777\n3  0.037210  0.102411\n4  0.529012  0.652602\n</code></pre> <p>By default, if a Series was passed, it's automatically expanded into a 2-dimensional array. To keep it as 1-dimensional, set <code>to_2d</code> to False.</p> <p>Similar to parameters, we can also define defaults for inputs. In addition to using scalars and arrays as default values, we can reference other inputs:</p> <pre><code>&gt;&gt;&gt; @njit\n... def apply_func_nb(ts1, ts2, ts3):\n...     return ts1 + ts2 + ts3\n\n&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(\n...     input_names=['ts1', 'ts2', 'ts3'],\n...     output_names=['output']\n... ).from_apply_func(apply_func_nb, ts2='ts1', ts3='ts1')\n\n&gt;&gt;&gt; MyInd.run(price).output\n               a     b\n2020-01-01   3.0  15.0\n2020-01-02   6.0  12.0\n2020-01-03   9.0   9.0\n2020-01-04  12.0   6.0\n2020-01-05  15.0   3.0\n\n&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output\n               a     b\n2020-01-01   4.0  20.0\n2020-01-02   8.0  16.0\n2020-01-03  12.0  12.0\n2020-01-04  16.0   8.0\n2020-01-05  20.0   4.0\n</code></pre> <p>What if an indicator doesn't take any input arrays? In that case, we can force the user to at least provide the input shape. Let's define a generator that emulates random returns and generates synthetic price:</p> <pre><code>&gt;&gt;&gt; @njit\n... def apply_func_nb(input_shape, start, mu, sigma):\n...     rand_returns = np.random.normal(mu, sigma, input_shape)\n...     return start * vbt.nb.nancumprod_nb(rand_returns + 1)\n\n&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(\n...     param_names=['start', 'mu', 'sigma'],\n...     output_names=['output']\n... ).from_apply_func(\n...     apply_func_nb,\n...     require_input_shape=True,\n...     seed=42\n... )\n\n&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output\ncustom_start                     100\ncustom_mu                          0\ncustom_sigma        0.01        0.01\n0             100.496714   99.861736\n1             101.147620  101.382660\n2             100.910779  101.145285\n3             102.504375  101.921510\n4             102.023143  102.474495\n</code></pre> <p>We can also supply pandas meta such as <code>input_index</code> and <code>input_columns</code> to the run method:</p> <pre><code>&gt;&gt;&gt; MyInd.run(\n...     price.shape, 100, 0, 0.01,\n...     input_index=price.index, input_columns=price.columns\n... ).output\ncustom_start                     100\ncustom_mu                          0\ncustom_sigma        0.01        0.01\n                       a           b\n2020-01-01    100.496714   99.861736\n2020-01-02    101.147620  101.382660\n2020-01-03    100.910779  101.145285\n2020-01-04    102.504375  101.921510\n2020-01-05    102.023143  102.474495\n</code></pre> <p>One can even build input-less indicator that decides on the output shape dynamically:</p> <pre><code>&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one\n\n&gt;&gt;&gt; def apply_func(i, ps, input_shape):\n...      out = np.full(input_shape, 0)\n...      out[:ps[i]] = 1\n...      return out\n\n&gt;&gt;&gt; def custom_func(ps):\n...     input_shape = (np.max(ps),)\n...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)\n\n&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(\n...     param_names=['p'],\n...     output_names=['output']\n... ).from_custom_func(custom_func)\n\n&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output\ncustom_p  1  2  3  4  5\n0         1  1  1  1  1\n1         0  1  1  1  1\n2         0  0  1  1  1\n3         0  0  0  1  1\n4         0  0  0  0  1\n</code></pre>","title":"Inputs"},{"location":"api/indicators/factory/#outputs","text":"<p>There are two types of outputs: regular and in-place outputs:</p> <ul> <li>Regular outputs are one or more arrays returned by the function. Each should have an exact same shape and match the number of columns in the input multiplied by the number of parameter values.</li> <li>In-place outputs are not returned but modified in-place. They broadcast together with inputs and are passed to the calculation function as a list, one per parameter.</li> </ul> <p>Two regular outputs:</p> <pre><code>&gt;&gt;&gt; @njit\n... def apply_func_nb(price):\n...     return price - 1, price + 1\n\n&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(\n...     input_names=['price'],\n...     output_names=['out1', 'out2']\n... ).from_apply_func(apply_func_nb)\n\n&gt;&gt;&gt; myind = MyInd.run(price)\n&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)\n&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)\n</code></pre> <p>One regular output and one in-place output:</p> <pre><code>&gt;&gt;&gt; @njit\n... def apply_func_nb(price, in_out2):\n...     in_out2[:] = price + 1\n...     return price - 1\n\n&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(\n...     input_names=['price'],\n...     output_names=['out1'],\n...     in_output_names=['in_out2']\n... ).from_apply_func(apply_func_nb)\n\n&gt;&gt;&gt; myind = MyInd.run(price)\n&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)\n&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)\n</code></pre> <p>Two in-place outputs:</p> <pre><code>&gt;&gt;&gt; @njit\n... def apply_func_nb(price, in_out1, in_out2):\n...     in_out1[:] = price - 1\n...     in_out2[:] = price + 1\n\n&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(\n...     input_names=['price'],\n...     in_output_names=['in_out1', 'in_out2']\n... ).from_apply_func(apply_func_nb)\n\n&gt;&gt;&gt; myind = MyInd.run(price)\n&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)\n&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)\n</code></pre> <p>By default, in-place outputs are created as empty arrays with uninitialized values. This allows creation of optional outputs that, if not written, do not occupy much memory. Since not all outputs are meant to be of data type <code>float</code>, we can pass <code>dtype</code> in the <code>in_output_settings</code>.</p> <pre><code>&gt;&gt;&gt; @njit\n... def apply_func_nb(price, in_out):\n...     in_out[:] = price &gt; np.mean(price)\n\n&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(\n...     input_names=['price'],\n...     in_output_names=['in_out']\n... ).from_apply_func(\n...     apply_func_nb,\n...     in_output_settings=dict(in_out=dict(dtype=bool))\n... )\n\n&gt;&gt;&gt; MyInd.run(price).in_out\n                a      b\n2020-01-01  False   True\n2020-01-02  False   True\n2020-01-03  False  False\n2020-01-04   True  False\n2020-01-05   True  False\n</code></pre> <p>Another advantage of in-place outputs is that we can provide their initial state:</p> <pre><code>&gt;&gt;&gt; @njit\n... def apply_func_nb(price, in_out1, in_out2):\n...     in_out1[:] = in_out1 + price\n...     in_out2[:] = in_out2 + price\n\n&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(\n...     input_names=['price'],\n...     in_output_names=['in_out1', 'in_out2']\n... ).from_apply_func(\n...     apply_func_nb,\n...     in_out1=100,\n...     in_out2='price'\n... )\n\n&gt;&gt;&gt; myind = MyInd.run(price)\n&gt;&gt;&gt; myind.in_out1\n              a    b\n2020-01-01  101  105\n2020-01-02  102  104\n2020-01-03  103  103\n2020-01-04  104  102\n2020-01-05  105  101\n&gt;&gt;&gt; myind.in_out2\n               a     b\n2020-01-01   2.0  10.0\n2020-01-02   4.0   8.0\n2020-01-03   6.0   6.0\n2020-01-04   8.0   4.0\n2020-01-05  10.0   2.0\n</code></pre>","title":"Outputs"},{"location":"api/indicators/factory/#without-numba","text":"<p>It's also possible to supply a function that is not Numba-compiled. This is handy when working with third-party libraries (see the implementation of IndicatorFactory.from_talib()). Additionally, we can set <code>keep_pd</code> to True to pass all inputs as pandas objects instead of raw NumPy arrays.</p>  <p>Note</p> <p>Already broadcasted pandas meta will be provided; that is, each input array will have the same index and columns.</p>  <p>Let's demonstrate this by wrapping a basic composed pandas_ta strategy:</p> <pre><code>&gt;&gt;&gt; import pandas_ta\n\n&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):\n...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))\n...     df.ta.strategy(pandas_ta.Strategy(\"MyStrategy\", [\n...         dict(kind='ema', length=ema_len),\n...         dict(kind='linreg', close='EMA_' + str(ema_len), length=linreg_len)\n...     ]))\n...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])\n\n&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(\n...     input_names=['open', 'high', 'low', 'close', 'volume'],\n...     param_names=['ema_len', 'linreg_len'],\n...     output_names=['ema', 'ema_linreg']\n... ).from_apply_func(\n...     apply_func,\n...     keep_pd=True,\n...     to_2d=False\n... )\n\n&gt;&gt;&gt; my_ind = MyInd.run(\n...     ohlcv['Open'],\n...     ohlcv['High'],\n...     ohlcv['Low'],\n...     ohlcv['Close'],\n...     ohlcv['Volume'],\n...     ema_len=5,\n...     linreg_len=[8, 9, 10]\n... )\n\n&gt;&gt;&gt; my_ind.ema_linreg\ncustom_ema_len                                            5\ncustom_linreg_len            8             9             10\ndate\n2021-02-02                  NaN           NaN           NaN\n2021-02-03                  NaN           NaN           NaN\n2021-02-04                  NaN           NaN           NaN\n2021-02-05                  NaN           NaN           NaN\n2021-02-06                  NaN           NaN           NaN\n...                         ...           ...           ...\n2021-02-25         52309.302811  52602.005326  52899.576568\n2021-02-26         50797.264793  51224.188381  51590.825690\n2021-02-28         49217.904905  49589.546052  50066.206828\n2021-03-01         48316.305403  48553.540713  48911.701664\n2021-03-02         47984.395969  47956.885953  48150.929668\n</code></pre> <p>In the example above, only one Series per open, high, low, close, and volume can be passed. To enable the indicator to process two-dimensional data, set <code>to_2d</code> to True and create a loop over each column in the <code>apply_func</code>.</p>  <p>Hint</p> <p>Writing a native Numba-compiled code may provide a performance that is magnitudes higher than that offered by libraries that work on pandas.</p>","title":"Without Numba"},{"location":"api/indicators/factory/#raw-outputs-and-caching","text":"<p>IndicatorFactory re-uses calculation artifacts whenever possible. Since it was originally designed for hyperparameter optimization and there are times when parameter values gets repeated, prevention of processing the same parameter over and over again is inevitable for good performance. For instance, when the <code>run_combs</code> method is being used and <code>run_unique</code> is set to True, it first calculates the raw outputs of all unique parameter combinations and then uses them to build outputs for the whole parameter grid.</p> <p>Let's first take a look at a typical raw output by setting <code>return_raw</code> to True:</p> <pre><code>&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)\n&gt;&gt;&gt; raw\n([array([[       nan,        nan,        nan,        nan],\n         [1.5       , 4.5       , 1.66666667, 4.33333333],\n         [2.5       , 3.5       , 2.55555556, 3.44444444],\n         [3.5       , 2.5       , 3.51851852, 2.48148148],\n         [4.5       , 1.5       , 4.50617284, 1.49382716]])],\n [(2, False), (2, True)],\n 2,\n [])\n</code></pre> <p>It consists of a list of the returned output arrays, a list of the zipped parameter combinations, the number of input columns, and other objects returned along with output arrays but not listed in <code>output_names</code>. The next time we decide to run the indicator on a subset of the parameters above, we can simply pass this tuple as the <code>use_raw</code> argument. This won't call the calculation function and will throw an error if some of the requested parameter combinations cannot be found in <code>raw</code>.</p> <pre><code>&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma\nma_window                    2\nma_ewm                    True\n                   a         b\n2020-01-01       NaN       NaN\n2020-01-02  1.666667  4.333333\n2020-01-03  2.555556  3.444444\n2020-01-04  3.518519  2.481481\n2020-01-05  4.506173  1.493827\n</code></pre> <p>Here is how the performance compares when repeatedly running the same parameter combination with and without <code>run_unique</code>:</p> <pre><code>&gt;&gt;&gt; a = np.random.uniform(size=(1000,))\n\n&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)\n73.4 ms \u00b1 4.76 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n\n&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)\n8.99 ms \u00b1 114 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n</code></pre>  <p>Note</p> <p><code>run_unique</code> is disabled by default.</p>  <p>Enable <code>run_unique</code> if input arrays have few columns and there are tons of repeated parameter combinations. Disable <code>run_unique</code> if input arrays are very wide, if two identical parameter combinations can lead to different results, or when requesting raw output, cache, or additional outputs outside of <code>output_names</code>.</p> <p>Another performance enhancement can be introduced by caching, which has to be implemented by the user. The class method IndicatorFactory.from_apply_func() has an argument <code>cache_func</code>, which is called prior to the main calculation.</p> <p>Consider the following scenario: we want to compute the relative distance between two expensive rolling windows. We have already decided on the value for the first window, and want to test thousands of values for the second window. Without caching, and even with <code>run_unique</code> enabled, the first rolling window will be re-calculated over and over again and waste our resources:</p> <pre><code>&gt;&gt;&gt; @njit\n... def roll_mean_expensive_nb(price, w):\n...     for i in range(100):\n...         out = vbt.nb.rolling_mean_nb(price, w)\n...     return out\n\n&gt;&gt;&gt; @njit\n... def apply_func_nb(price, w1, w2):\n...     roll_mean1 = roll_mean_expensive_nb(price, w1)\n...     roll_mean2 = roll_mean_expensive_nb(price, w2)\n...     return (roll_mean2 - roll_mean1) / roll_mean1\n\n&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(\n...     input_names=['price'],\n...     param_names=['w1', 'w2'],\n...     output_names=['output'],\n... ).from_apply_func(apply_func_nb)\n\n&gt;&gt;&gt; MyInd.run(price, 2, 3).output\ncustom_w1                    2\ncustom_w2                    3\n                   a         b\n2020-01-01       NaN       NaN\n2020-01-02       NaN       NaN\n2020-01-03 -0.200000  0.142857\n2020-01-04 -0.142857  0.200000\n2020-01-05 -0.111111  0.333333\n\n&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))\n264 ms \u00b1 3.22 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</code></pre> <p>To avoid this, let's cache all unique rolling windows:</p> <pre><code>&gt;&gt;&gt; @njit\n... def cache_func_nb(price, ws1, ws2):\n...     cache_dict = dict()\n...     ws = ws1.copy()\n...     ws.extend(ws2)\n...     for i in range(len(ws)):\n...         h = hash((ws[i]))\n...         if h not in cache_dict:\n...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])\n...     return cache_dict\n\n&gt;&gt;&gt; @njit\n... def apply_func_nb(price, w1, w2, cache_dict):\n...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]\n\n&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(\n...     input_names=['price'],\n...     param_names=['w1', 'w2'],\n...     output_names=['output'],\n... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)\n\n&gt;&gt;&gt; MyInd.run(price, 2, 3).output\ncustom_w1                    2\ncustom_w2                    3\n                   a         b\n2020-01-01       NaN       NaN\n2020-01-02       NaN       NaN\n2020-01-03 -0.200000  0.142857\n2020-01-04 -0.142857  0.200000\n2020-01-05 -0.111111  0.333333\n\n&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))\n145 ms \u00b1 4.55 ms per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n</code></pre> <p>We have cut down the processing time almost in half.</p> <p>Similar to raw outputs, we can force IndicatorFactory to return the cache, so it can be used in other calculations or even indicators. The clear advantage of this approach is that we don't rely on some fixed set of parameter combinations any more, but on the values of each parameter, which gives us more granularity in managing performance.</p> <pre><code>&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)\n\n&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)\n30.1 ms \u00b1 2 ms per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n</code></pre>","title":"Raw outputs and caching"},{"location":"api/indicators/factory/#custom-properties-and-methods","text":"<p>Use <code>custom_output_props</code> argument when constructing an indicator to define lazy outputs - outputs that are processed only when explicitly called. They will become cached properties and, in contrast to regular outputs, they can have an arbitrary shape. For example, let's attach a property that will calculate the distance between the moving average and the price.</p> <pre><code>&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(\n...     input_names=['price'],\n...     param_names=['window'],\n...     output_names=['ma'],\n...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)\n... ).from_apply_func(vbt.nb.rolling_mean_nb)\n\n&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance\ncustom_window                   2                   3\n                      a         b         a         b\n2020-01-01          NaN       NaN       NaN       NaN\n2020-01-02     0.333333 -0.111111       NaN       NaN\n2020-01-03     0.200000 -0.142857  0.500000 -0.250000\n2020-01-04     0.142857 -0.200000  0.333333 -0.333333\n2020-01-05     0.111111 -0.333333  0.250000 -0.500000\n</code></pre> <p>Another way of defining own properties and methods is subclassing:</p> <pre><code>&gt;&gt;&gt; class MyIndExtended(MyInd):\n...     def plot(self, column=None, **kwargs):\n...         self_col = self.select_one(column=column, group_by=False)\n...         return self.ma.vbt.plot(**kwargs)\n\n&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, 'a')].plot()\n</code></pre> <p></p>","title":"Custom properties and methods"},{"location":"api/indicators/factory/#helper-properties-and-methods","text":"<p>For all in <code>input_names</code>, <code>in_output_names</code>, <code>output_names</code>, and <code>custom_output_props</code>, IndicatorFactory will create a bunch of comparison and combination methods, such as for generating signals. What kind of methods are created can be regulated using <code>dtype</code> in the <code>attr_settings</code> dictionary.</p> <pre><code>&gt;&gt;&gt; from collections import namedtuple\n\n&gt;&gt;&gt; MyEnum = namedtuple('MyEnum', ['one', 'two'])(0, 1)\n\n&gt;&gt;&gt; def apply_func_nb(price):\n...     out_float = np.empty(price.shape, dtype=np.float_)\n...     out_bool = np.empty(price.shape, dtype=np.bool_)\n...     out_enum = np.empty(price.shape, dtype=np.int_)\n...     return out_float, out_bool, out_enum\n\n&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(\n...     input_names=['price'],\n...     output_names=['out_float', 'out_bool', 'out_enum'],\n...     attr_settings=dict(\n...         out_float=dict(dtype=np.float_),\n...         out_bool=dict(dtype=np.bool_),\n...         out_enum=dict(dtype=MyEnum)\n... )).from_apply_func(apply_func_nb)\n\n&gt;&gt;&gt; myind = MyInd.run(price)\n&gt;&gt;&gt; dir(myind)\n[\n    ...\n    'out_bool',\n    'out_bool_and',\n    'out_bool_or',\n    'out_bool_stats',\n    'out_bool_xor',\n    'out_enum',\n    'out_enum_readable',\n    'out_enum_stats',\n    'out_float',\n    'out_float_above',\n    'out_float_below',\n    'out_float_equal',\n    'out_float_stats',\n    ...\n    'price',\n    'price_above',\n    'price_below',\n    'price_equal',\n    'price_stats',\n    ...\n]\n</code></pre> <p>Each of these methods and properties are created for sheer convenience: to easily combine boolean arrays using logical rules and to compare numeric arrays. All operations are done strictly using NumPy. Another advantage is utilization of vectorbt's own broadcasting, such that one can combine inputs and outputs with an arbitrary array-like object, given their shapes can broadcast together.</p> <p>We can also do comparison with multiple objects at once by passing them as a tuple/list:</p> <pre><code>&gt;&gt;&gt; myind.price_above([1.5, 2.5])\ncustom_price_above           1.5           2.5\n                        a      b      a      b\n2020-01-01          False   True  False   True\n2020-01-02           True   True  False   True\n2020-01-03           True   True   True   True\n2020-01-04           True   True   True  False\n2020-01-05           True  False   True  False\n</code></pre>","title":"Helper properties and methods"},{"location":"api/indicators/factory/#indexing","text":"<p>IndicatorFactory attaches pandas indexing to the indicator class thanks to ArrayWrapper. Supported are <code>iloc</code>, <code>loc</code>, <code>*param_name*_loc</code>, <code>xs</code>, and <code>__getitem__</code>.</p> <p>This makes possible accessing rows and columns by labels, integer positions, and parameters.</p> <pre><code>&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])\n\n&gt;&gt;&gt; ma[(2, 'b')]\n&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;\n\n&gt;&gt;&gt; ma[(2, 'b')].ma\n2020-01-01    NaN\n2020-01-02    4.5\n2020-01-03    3.5\n2020-01-04    2.5\n2020-01-05    1.5\nName: (2, b), dtype: float64\n\n&gt;&gt;&gt; ma.window_loc[2].ma\n              a    b\n2020-01-01  NaN  NaN\n2020-01-02  1.5  4.5\n2020-01-03  2.5  3.5\n2020-01-04  3.5  2.5\n2020-01-05  4.5  1.5\n</code></pre>","title":"Indexing"},{"location":"api/indicators/factory/#ta-lib","text":"<p>Indicator factory also provides a class method IndicatorFactory.from_talib() that can be used to wrap any function from TA-Lib. It automatically fills all the neccessary information, such as input, parameter and output names.</p>","title":"TA-Lib"},{"location":"api/indicators/factory/#stats","text":"<p>Hint</p> <p>See StatsBuilderMixin.stats().</p>  <p>We can attach metrics to any new indicator class:</p> <pre><code>&gt;&gt;&gt; @njit\n... def apply_func_nb(price):\n...     return price ** 2, price ** 3\n\n&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(\n...     input_names=['price'],\n...     output_names=['out1', 'out2'],\n...     metrics=dict(\n...         sum_diff=dict(\n...             calc_func=lambda self: self.out2.sum() - self.out1.sum()\n...         )\n...     )\n... ).from_apply_func(\n...     apply_func_nb\n... )\n\n&gt;&gt;&gt; myind = MyInd.run(price)\n&gt;&gt;&gt; myind.stats(column='a')\nsum_diff    170.0\nName: a, dtype: float64\n</code></pre>","title":"Stats"},{"location":"api/indicators/factory/#plots","text":"<p>Hint</p> <p>See PlotsBuilderMixin.plots().</p>  <p>Similarly to stats, we can attach subplots to any new indicator class:</p> <pre><code>&gt;&gt;&gt; @njit\n... def apply_func_nb(price):\n...     return price ** 2, price ** 3\n\n&gt;&gt;&gt; def plot_outputs(out1, out2, column=None, fig=None):\n...     fig = out1[column].rename('out1').vbt.plot(fig=fig)\n...     fig = out2[column].rename('out2').vbt.plot(fig=fig)\n\n&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(\n...     input_names=['price'],\n...     output_names=['out1', 'out2'],\n...     subplots=dict(\n...         plot_outputs=dict(\n...             plot_func=plot_outputs,\n...             resolve_out1=True,\n...             resolve_out2=True\n...         )\n...     )\n... ).from_apply_func(\n...     apply_func_nb\n... )\n\n&gt;&gt;&gt; myind = MyInd.run(price)\n&gt;&gt;&gt; myind.plots(column='a')\n</code></pre> <p></p>","title":"Plots"},{"location":"api/indicators/factory/#vectorbt.indicators.factory.build_columns","text":"<pre><code>build_columns(\n    param_list,\n    input_columns,\n    level_names=None,\n    hide_levels=None,\n    param_settings=None,\n    per_column=False,\n    ignore_default=False,\n    **kwargs\n)\n</code></pre> <p>For each parameter in <code>param_list</code>, create a new column level with parameter values and stack it on top of <code>input_columns</code>.</p> <p>Returns a list of parameter indexes and new columns.</p>","title":"build_columns function"},{"location":"api/indicators/factory/#vectorbt.indicators.factory.combine_objs","text":"<pre><code>combine_objs(\n    obj,\n    other,\n    *args,\n    level_name=None,\n    keys=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Combines/compares <code>obj</code> to <code>other</code>, for example, to generate signals.</p> <p>Both will broadcast together. Pass <code>other</code> as a tuple or a list to compare with multiple arguments. In this case, a new column level will be created with the name <code>level_name</code>.</p> <p>See BaseAccessor.combine().</p>","title":"combine_objs function"},{"location":"api/indicators/factory/#vectorbt.indicators.factory.params_to_list","text":"<pre><code>params_to_list(\n    params,\n    is_tuple,\n    is_array_like\n)\n</code></pre> <p>Cast parameters to a list.</p>","title":"params_to_list function"},{"location":"api/indicators/factory/#vectorbt.indicators.factory.prepare_params","text":"<pre><code>prepare_params(\n    param_list,\n    param_settings=None,\n    input_shape=None,\n    to_2d=False\n)\n</code></pre> <p>Prepare parameters.</p>","title":"prepare_params function"},{"location":"api/indicators/factory/#vectorbt.indicators.factory.run_pipeline","text":"<pre><code>run_pipeline(\n    num_ret_outputs,\n    custom_func,\n    *args,\n    require_input_shape=False,\n    input_shape=None,\n    input_index=None,\n    input_columns=None,\n    input_list=None,\n    in_output_list=None,\n    in_output_settings=None,\n    broadcast_kwargs=None,\n    param_list=None,\n    param_product=False,\n    param_settings=None,\n    run_unique=False,\n    silence_warnings=False,\n    per_column=False,\n    pass_col=False,\n    keep_pd=False,\n    to_2d=True,\n    as_lists=False,\n    pass_input_shape=False,\n    pass_flex_2d=False,\n    level_names=None,\n    hide_levels=None,\n    stacking_kwargs=None,\n    return_raw=False,\n    use_raw=None,\n    wrapper_kwargs=None,\n    seed=None,\n    **kwargs\n)\n</code></pre> <p>A pipeline for running an indicator, used by IndicatorFactory.</p> <p>Args</p>  <code>num_ret_outputs</code> :\u2002<code>int</code> The number of output arrays returned by <code>custom_func</code>. <code>custom_func</code> :\u2002<code>callable</code>  <p>A custom calculation function.</p> <p>See IndicatorFactory.from_custom_func().</p>  <code>*args</code> Arguments passed to the <code>custom_func</code>. <code>require_input_shape</code> :\u2002<code>bool</code>  <p>Whether to input shape is required.</p> <p>Will set <code>pass_input_shape</code> to True and raise an error if <code>input_shape</code> is None.</p>  <code>input_shape</code> :\u2002<code>tuple</code>  <p>Shape to broadcast each input to.</p> <p>Can be passed to <code>custom_func</code>. See <code>pass_input_shape</code>.</p>  <code>input_index</code> :\u2002<code>index_like</code>  <p>Sets index of each input.</p> <p>Can be used to label index if no inputs passed.</p>  <code>input_columns</code> :\u2002<code>index_like</code>  <p>Sets columns of each input.</p> <p>Can be used to label columns if no inputs passed.</p>  <code>input_list</code> :\u2002<code>list</code> of <code>array_like</code> A list of input arrays. <code>in_output_list</code> :\u2002<code>list</code> of <code>array_like</code>  <p>A list of in-place output arrays.</p> <p>If an array should be generated, pass None.</p>  <code>in_output_settings</code> :\u2002<code>dict</code> or <code>list</code> of <code>dict</code>  <p>Settings corresponding to each in-place output.</p> <p>Following keys are accepted:</p> <ul> <li><code>dtype</code>: Create this array using this data type and <code>np.empty</code>. Default is None.</li> </ul>  <code>broadcast_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to broadcast() to broadcast inputs. <code>param_list</code> :\u2002<code>list</code> of <code>any</code>  <p>A list of parameters.</p> <p>Each element is either an array-like object or a single value of any type.</p>  <code>param_product</code> :\u2002<code>bool</code> Whether to build a Cartesian product out of all parameters. <code>param_settings</code> :\u2002<code>dict</code> or <code>list</code> of <code>dict</code>  <p>Settings corresponding to each parameter.</p> <p>Following keys are accepted:</p> <ul> <li><code>dtype</code>: If data type is an enumerated type or other mapping, and a string as parameter     value was passed, will convert it first.</li> <li><code>is_tuple</code>: If tuple was passed, it will be considered as a single value.     To treat it as multiple values, pack it into a list.</li> <li><code>is_array_like</code>: If array-like object was passed, it will be considered as a single value.     To treat it as multiple values, pack it into a list.</li> <li><code>bc_to_input</code>: Whether to broadcast parameter to input size. You can also broadcast     parameter to an axis by passing an integer.</li> <li><code>broadcast_kwargs</code>: Keyword arguments passed to broadcast().</li> <li><code>per_column</code>: Whether each parameter value can be split per column such that it can     be better reflected in a multi-index. Does not affect broadcasting.</li> </ul>  <code>run_unique</code> :\u2002<code>bool</code>  <p>Whether to run only on unique parameter combinations.</p> <p>Disable if two identical parameter combinations can lead to different results (e.g., due to randomness) or if inputs are large and <code>custom_func</code> is fast.</p>  <p>Note</p> <p>Cache, raw output, and output objects outside of <code>num_ret_outputs</code> will be returned for unique parameter combinations only.</p>   <code>silence_warnings</code> :\u2002<code>bool</code> Whether to hide warnings such as coming from <code>run_unique</code>. <code>per_column</code> :\u2002<code>bool</code>  <p>Whether to split the DataFrame into Series, one per column, and run <code>custom_func</code> on each Series.</p> <p>Each list of parameter values will broadcast to the number of columns and each parameter value will be applied per Series rather than per DataFrame. Input shape must be known beforehand.</p>  <code>pass_col</code> :\u2002<code>bool</code> Whether to pass column index as keyword argument if <code>per_column</code> is set to True. <code>keep_pd</code> :\u2002<code>bool</code> Whether to keep inputs as pandas objects, otherwise convert to NumPy arrays. <code>to_2d</code> :\u2002<code>bool</code> Whether to reshape inputs to 2-dim arrays, otherwise keep as-is. <code>as_lists</code> :\u2002<code>bool</code>  <p>Whether to pass inputs and parameters to <code>custom_func</code> as lists.</p> <p>If <code>custom_func</code> is Numba-compiled, passes tuples.</p>  <code>pass_input_shape</code> :\u2002<code>bool</code> Whether to pass <code>input_shape</code> to <code>custom_func</code> as keyword argument. <code>pass_flex_2d</code> :\u2002<code>bool</code> Whether to pass <code>flex_2d</code> to <code>custom_func</code> as keyword argument. <code>level_names</code> :\u2002<code>list</code> of <code>str</code>  <p>A list of column level names corresponding to each parameter.</p> <p>Should have the same length as <code>param_list</code>.</p>  <code>hide_levels</code> :\u2002<code>list</code> of <code>int</code> A list of indices of parameter levels to hide. <code>stacking_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to repeat_index(), tile_index(), and stack_indexes() when stacking parameter and input column levels. <code>return_raw</code> :\u2002<code>bool</code> Whether to return raw output without post-processing and hashed parameter tuples. <code>use_raw</code> :\u2002<code>bool</code> Takes the raw results and uses them instead of running <code>custom_func</code>. <code>wrapper_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to ArrayWrapper. <code>seed</code> :\u2002<code>int</code> Set seed to make output deterministic. <code>**kwargs</code>  <p>Keyword arguments passed to the <code>custom_func</code>.</p> <p>Some common arguments include <code>return_cache</code> to return cache and <code>use_cache</code> to use cache. Those are only applicable to <code>custom_func</code> that supports it (<code>custom_func</code> created using IndicatorFactory.from_apply_func() are supported by default).</p>   <p>Returns</p> <p>Array wrapper, list of inputs (<code>np.ndarray</code>), input mapper (<code>np.ndarray</code>), list of outputs (<code>np.ndarray</code>), list of parameter arrays (<code>np.ndarray</code>), list of parameter mappers (<code>np.ndarray</code>), list of outputs that are outside of <code>num_ret_outputs</code>. Explanation</p> <p>Here is a subset of tasks that the function run_pipeline() does:</p> <ul> <li>Takes one or multiple array objects in <code>input_list</code> and broadcasts them.</li> </ul> <pre><code>&gt;&gt;&gt; sr = pd.Series([1, 2], index=['x', 'y'])\n&gt;&gt;&gt; df = pd.DataFrame([[3, 4], [5, 6]], index=['x', 'y'], columns=['a', 'b'])\n&gt;&gt;&gt; input_list = vbt.base.reshape_fns.broadcast(sr, df)\n&gt;&gt;&gt; input_list[0]\n   a  b\nx  1  1\ny  2  2\n&gt;&gt;&gt; input_list[1]\n   a  b\nx  3  4\ny  5  6\n</code></pre> <ul> <li>Takes one or multiple parameters in <code>param_list</code>, converts them to NumPy arrays and     broadcasts them.</li> </ul> <pre><code>&gt;&gt;&gt; p1, p2, p3 = 1, [2, 3, 4], [False]\n&gt;&gt;&gt; param_list = vbt.base.reshape_fns.broadcast(p1, p2, p3)\n&gt;&gt;&gt; param_list[0]\narray([1, 1, 1])\n&gt;&gt;&gt; param_list[1]\narray([2, 3, 4])\n&gt;&gt;&gt; param_list[2]\narray([False, False, False])\n</code></pre> <ul> <li>Performs calculation using <code>custom_func</code> to build output arrays (<code>output_list</code>) and     other objects (<code>other_list</code>, optionally).</li> </ul> <pre><code>&gt;&gt;&gt; def custom_func(ts1, ts2, p1, p2, p3, *args, **kwargs):\n...     return np.hstack((\n...         ts1 + ts2 + p1[0] * p2[0],\n...         ts1 + ts2 + p1[1] * p2[1],\n...         ts1 + ts2 + p1[2] * p2[2],\n...     ))\n\n&gt;&gt;&gt; output = custom_func(*input_list, *param_list)\n&gt;&gt;&gt; output\narray([[ 6,  7,  7,  8,  8,  9],\n       [ 9, 10, 10, 11, 11, 12]])\n</code></pre> <ul> <li>Creates new column hierarchy based on parameters and level names.</li> </ul> <pre><code>&gt;&gt;&gt; p1_columns = pd.Index(param_list[0], name='p1')\n&gt;&gt;&gt; p2_columns = pd.Index(param_list[1], name='p2')\n&gt;&gt;&gt; p3_columns = pd.Index(param_list[2], name='p3')\n&gt;&gt;&gt; p_columns = vbt.base.index_fns.stack_indexes([p1_columns, p2_columns, p3_columns])\n&gt;&gt;&gt; new_columns = vbt.base.index_fns.combine_indexes([p_columns, input_list[0].columns])\n\n&gt;&gt;&gt; output_df = pd.DataFrame(output, columns=new_columns)\n&gt;&gt;&gt; output_df\np1                                         1\np2             2             3             4\np3  False  False  False  False  False  False\n        a      b      a      b      a      b\n0       6      7      7      8      8      9\n1       9     10     10     11     11     12\n</code></pre> <ul> <li>Broadcasts objects in <code>input_list</code> to match the shape of objects in <code>output_list</code> through tiling.     This is done to be able to compare them and generate signals, since we cannot compare NumPy     arrays that have totally different shapes, such as (2, 2) and (2, 6).</li> </ul> <pre><code>&gt;&gt;&gt; new_input_list = [\n...     input_list[0].vbt.tile(len(param_list[0]), keys=p_columns),\n...     input_list[1].vbt.tile(len(param_list[0]), keys=p_columns)\n... ]\n&gt;&gt;&gt; new_input_list[0]\np1                                         1\np2             2             3             4\np3  False  False  False  False  False  False\n        a      b      a      b      a      b\n0       1      1      1      1      1      1\n1       2      2      2      2      2      2\n</code></pre> <ul> <li>Builds parameter mappers that will link parameters from <code>param_list</code> to columns in     <code>input_list</code> and <code>output_list</code>. This is done to enable column indexing using parameter values.</li> </ul>","title":"run_pipeline function"},{"location":"api/indicators/factory/#vectorbt.indicators.factory.IndicatorBase","text":"<pre><code>IndicatorBase(\n    wrapper,\n    input_list,\n    input_mapper,\n    in_output_list,\n    output_list,\n    param_list,\n    mapper_list,\n    short_name,\n    level_names\n)\n</code></pre> <p>Indicator base class.</p> <p>Properties should be set before instantiation.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>PlotsBuilderMixin.plots_defaults</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>StatsBuilderMixin.stats_defaults</li> <li>Wrapping.config</li> <li>Wrapping.iloc</li> <li>Wrapping.indexing_kwargs</li> <li>Wrapping.loc</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> <li>Wrapping.self_aliases</li> <li>Wrapping.wrapper</li> <li>Wrapping.writeable_attrs</li> </ul> <p>Subclasses</p> <ul> <li>ATR</li> <li>BBANDS</li> <li>BOLB</li> <li>FIXLB</li> <li>FMAX</li> <li>FMEAN</li> <li>FMIN</li> <li>FSTD</li> <li>LEXLB</li> <li>MA</li> <li>MACD</li> <li>MEANLB</li> <li>MSTD</li> <li>OBV</li> <li>OHLCSTCX</li> <li>OHLCSTX</li> <li>RAND</li> <li>RANDNX</li> <li>RANDX</li> <li>RPROB</li> <li>RPROBCX</li> <li>RPROBNX</li> <li>RPROBX</li> <li>RSI</li> <li>STCX</li> <li>STOCH</li> <li>STX</li> <li>TRENDLB</li> </ul>","title":"IndicatorBase class"},{"location":"api/indicators/factory/#vectorbt.indicators.factory.IndicatorBase.run","text":"<pre><code>IndicatorBase.run(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Public run method.</p>","title":"run class method"},{"location":"api/indicators/factory/#vectorbt.indicators.factory.IndicatorBase.run_combs","text":"<pre><code>IndicatorBase.run_combs(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Public run combinations method.</p>","title":"run_combs class method"},{"location":"api/indicators/factory/#vectorbt.indicators.factory.IndicatorBase.in_output_names","text":"<p>Names of the in-place output arrays.</p>","title":"in_output_names variable"},{"location":"api/indicators/factory/#vectorbt.indicators.factory.IndicatorBase.input_names","text":"<p>Names of the input arrays.</p>","title":"input_names variable"},{"location":"api/indicators/factory/#vectorbt.indicators.factory.IndicatorBase.level_names","text":"<p>Column level names corresponding to each parameter.</p>","title":"level_names property"},{"location":"api/indicators/factory/#vectorbt.indicators.factory.IndicatorBase.output_flags","text":"<p>Dictionary of output flags.</p>","title":"output_flags variable"},{"location":"api/indicators/factory/#vectorbt.indicators.factory.IndicatorBase.output_names","text":"<p>Names of the regular output arrays.</p>","title":"output_names variable"},{"location":"api/indicators/factory/#vectorbt.indicators.factory.IndicatorBase.param_names","text":"<p>Names of the parameters.</p>","title":"param_names variable"},{"location":"api/indicators/factory/#vectorbt.indicators.factory.IndicatorBase.short_name","text":"<p>Name of the indicator.</p>","title":"short_name property"},{"location":"api/indicators/factory/#vectorbt.indicators.factory.IndicatorBase.indexing_func","text":"<pre><code>IndicatorBase.indexing_func(\n    pd_indexing_func,\n    **kwargs\n)\n</code></pre> <p>Perform indexing on IndicatorBase.</p>","title":"indexing_func method"},{"location":"api/indicators/factory/#vectorbt.indicators.factory.IndicatorFactory","text":"<pre><code>IndicatorFactory(\n    class_name='Indicator',\n    class_docstring='',\n    module_name='vectorbt.indicators.factory',\n    short_name=None,\n    prepend_name=True,\n    input_names=None,\n    param_names=None,\n    in_output_names=None,\n    output_names=None,\n    output_flags=None,\n    custom_output_props=None,\n    attr_settings=None,\n    metrics=None,\n    stats_defaults=None,\n    subplots=None,\n    plots_defaults=None\n)\n</code></pre> <p>A factory for creating new indicators.</p> <p>Initialize IndicatorFactory to create a skeleton and then use a class method such as IndicatorFactory.from_custom_func() to bind a calculation function to the skeleton.</p> <p>Args</p>  <code>class_name</code> :\u2002<code>str</code> Name for the created indicator class. <code>class_docstring</code> :\u2002<code>str</code> Docstring for the created indicator class. <code>module_name</code> :\u2002<code>str</code> Specify the module the class originates from. <code>short_name</code> :\u2002<code>str</code>  <p>A short name of the indicator.</p> <p>Defaults to lower-case <code>class_name</code>.</p>  <code>prepend_name</code> :\u2002<code>bool</code> Whether to prepend <code>short_name</code> to each parameter level. <code>input_names</code> :\u2002<code>list</code> of <code>str</code> A list of names of input arrays. <code>param_names</code> :\u2002<code>list</code> of <code>str</code> A list of names of parameters. <code>in_output_names</code> :\u2002<code>list</code> of <code>str</code>  <p>A list of names of in-place output arrays.</p> <p>An in-place output is an output that is not returned but modified in-place. Some advantages of such outputs include:</p> <p>1) they don't need to be returned, 2) they can be passed between functions as easily as inputs, 3) they can be provided with already allocated data to safe memory, 4) if data or default value are not provided, they are created empty to not occupy memory.</p>  <code>output_names</code> :\u2002<code>list</code> of <code>str</code> A list of names of output arrays. <code>output_flags</code> :\u2002<code>dict</code> A dictionary of in-place and regular output flags. <code>custom_output_props</code> :\u2002<code>dict</code> A dictionary with user-defined functions that will be bound to the indicator class and wrapped with <code>@cached_property</code>. <code>attr_settings</code> :\u2002<code>dict</code>  <p>A dictionary of settings by attribute name.</p> <p>Attributes can be <code>input_names</code>, <code>in_output_names</code>, <code>output_names</code> and <code>custom_output_props</code>.</p> <p>Following keys are accepted:</p> <ul> <li><code>dtype</code>: Data type used to determine which methods to generate around this attribute.     Set to None to disable. Default is <code>np.float_</code>. Can be set to instance of     <code>collections.namedtuple</code> acting as enumerated type, or any other mapping;     It will then create a property with suffix <code>readable</code> that contains data in a string format.</li> </ul>  <code>metrics</code> :\u2002<code>dict</code>  <p>Metrics supported by StatsBuilderMixin.stats().</p> <p>If dict, will be converted to Config.</p>  <code>stats_defaults</code> :\u2002<code>callable</code> or <code>dict</code>  <p>Defaults for StatsBuilderMixin.stats().</p> <p>If dict, will be converted into a property.</p>  <code>subplots</code> :\u2002<code>dict</code>  <p>Subplots supported by PlotsBuilderMixin.plots().</p> <p>If dict, will be converted to Config.</p>  <code>plots_defaults</code> :\u2002<code>callable</code> or <code>dict</code>  <p>Defaults for PlotsBuilderMixin.plots().</p> <p>If dict, will be converted into a property.</p>    <p>Note</p> <p>The <code>__init__</code> method is not used for running the indicator, for this use <code>run</code>. The reason for this is indexing, which requires a clean <code>__init__</code> method for creating  a new indicator object with newly indexed attributes.</p>  <p>Subclasses</p> <ul> <li>SignalFactory</li> </ul>","title":"IndicatorFactory class"},{"location":"api/indicators/factory/#vectorbt.indicators.factory.IndicatorFactory.find_ta_indicator","text":"<pre><code>IndicatorFactory.find_ta_indicator(\n    cls_name\n)\n</code></pre> <p>Get ta indicator class by its name.</p>","title":"find_ta_indicator class method"},{"location":"api/indicators/factory/#vectorbt.indicators.factory.IndicatorFactory.from_pandas_ta","text":"<pre><code>IndicatorFactory.from_pandas_ta(\n    func_name,\n    parse_kwargs=None,\n    init_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Build an indicator class around a pandas-ta function.</p> <p>Requires pandas-ta installed.</p> <p>Args</p>  <code>func_name</code> :\u2002<code>str</code> Function name. <code>parse_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to IndicatorFactory.parse_pandas_ta_config(). <code>init_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to IndicatorFactory. <code>**kwargs</code> Keyword arguments passed to IndicatorFactory.from_custom_func().  <p>Returns</p> <p>Indicator Usage</p> <pre><code>&gt;&gt;&gt; SMA = vbt.IndicatorFactory.from_pandas_ta('SMA')\n\n&gt;&gt;&gt; sma = SMA.run(price, length=[2, 3])\n&gt;&gt;&gt; sma.sma\nsma_length         2         3\n              a    b    a    b\n2020-01-01  NaN  NaN  NaN  NaN\n2020-01-02  1.5  4.5  NaN  NaN\n2020-01-03  2.5  3.5  2.0  4.0\n2020-01-04  3.5  2.5  3.0  3.0\n2020-01-05  4.5  1.5  4.0  2.0\n</code></pre> <ul> <li>To get help on running the indicator, use the <code>help</code> command:</li> </ul> <pre><code>&gt;&gt;&gt; help(SMA.run)\nHelp on method run:\n\nrun(close, length=None, offset=None, short_name='sma', hide_params=None, hide_default=True, **kwargs) method of builtins.type instance\n    Run `SMA` indicator.\n\n    * Inputs: `close`\n    * Parameters: `length`, `offset`\n    * Outputs: `sma`\n\n    Pass a list of parameter names as `hide_params` to hide their column levels.\n    Set `hide_default` to False to show the column levels of the parameters with a default value.\n\n    Other keyword arguments are passed to [run_pipeline()](/api/indicators/factory/#vectorbt.indicators.factory.run_pipeline \"vectorbt.indicators.factory.run_pipeline\").\n</code></pre> <ul> <li>To get the indicator docstring, use the <code>help</code> command or print the <code>__doc__</code> attribute:</li> </ul> <pre><code>&gt;&gt;&gt; print(SMA.__doc__)\nSimple Moving Average (SMA)\n\nThe Simple Moving Average is the classic moving average that is the equally\nweighted average over n periods.\n\nSources:\n    &lt;https://www.tradingtechnologies.com/help/x-study/technical-indicator-definitions/simple-moving-average-sma/&gt;\n\nCalculation:\n    Default Inputs:\n        length=10\n    SMA = SUM(close, length) / length\n\nArgs:\n    close (pd.Series): Series of 'close's\n    length (int): It's period. Default: 10\n    offset (int): How many periods to offset the result. Default: 0\n\nKwargs:\n    adjust (bool): Default: True\n    presma (bool, optional): If True, uses SMA for initial value.\n    fillna (value, optional): pd.DataFrame.fillna(value)\n    fill_method (value, optional): Type of fill method\n\nReturns:\n    pd.Series: New feature generated.\n</code></pre>","title":"from_pandas_ta class method"},{"location":"api/indicators/factory/#vectorbt.indicators.factory.IndicatorFactory.from_ta","text":"<pre><code>IndicatorFactory.from_ta(\n    cls_name,\n    init_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Build an indicator class around a ta class.</p> <p>Requires ta installed.</p> <p>Args</p>  <code>cls_name</code> :\u2002<code>str</code> Class name. <code>init_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to IndicatorFactory. <code>**kwargs</code> Keyword arguments passed to IndicatorFactory.from_custom_func().  <p>Returns</p> <p>Indicator Usage</p> <pre><code>&gt;&gt;&gt; SMAIndicator = vbt.IndicatorFactory.from_ta('SMAIndicator')\n\n&gt;&gt;&gt; sma = SMAIndicator.run(price, window=[2, 3])\n&gt;&gt;&gt; sma.sma_indicator\nsmaindicator_window    2         3\n                       a    b    a    b\n2020-01-01           NaN  NaN  NaN  NaN\n2020-01-02           1.5  4.5  NaN  NaN\n2020-01-03           2.5  3.5  2.0  4.0\n2020-01-04           3.5  2.5  3.0  3.0\n2020-01-05           4.5  1.5  4.0  2.0\n</code></pre> <ul> <li>To get help on running the indicator, use the <code>help</code> command:</li> </ul> <pre><code>&gt;&gt;&gt; help(SMAIndicator.run)\nHelp on method run:\n\nrun(close, window, fillna=False, short_name='smaindicator', hide_params=None, hide_default=True, **kwargs) method of builtins.type instance\n    Run `SMAIndicator` indicator.\n\n    * Inputs: `close`\n    * Parameters: `window`, `fillna`\n    * Outputs: `sma_indicator`\n\n    Pass a list of parameter names as `hide_params` to hide their column levels.\n    Set `hide_default` to False to show the column levels of the parameters with a default value.\n\n    Other keyword arguments are passed to [run_pipeline()](/api/indicators/factory/#vectorbt.indicators.factory.run_pipeline \"vectorbt.indicators.factory.run_pipeline\").\n</code></pre> <ul> <li>To get the indicator docstring, use the <code>help</code> command or print the <code>__doc__</code> attribute:</li> </ul> <pre><code>&gt;&gt;&gt; print(SMAIndicator.__doc__)\nSMA - Simple Moving Average\n\n    Args:\n        close(pandas.Series): dataset 'Close' column.\n        window(int): n period.\n        fillna(bool): if True, fill nan values.\n</code></pre>","title":"from_ta class method"},{"location":"api/indicators/factory/#vectorbt.indicators.factory.IndicatorFactory.from_talib","text":"<pre><code>IndicatorFactory.from_talib(\n    func_name,\n    init_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Build an indicator class around a TA-Lib function.</p> <p>Requires TA-Lib installed.</p> <p>For input, parameter and output names, see docs.</p> <p>Args</p>  <code>func_name</code> :\u2002<code>str</code> Function name. <code>init_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to IndicatorFactory. <code>**kwargs</code> Keyword arguments passed to IndicatorFactory.from_custom_func().  <p>Returns</p> <p>Indicator Usage</p> <pre><code>&gt;&gt;&gt; SMA = vbt.IndicatorFactory.from_talib('SMA')\n\n&gt;&gt;&gt; sma = SMA.run(price, timeperiod=[2, 3])\n&gt;&gt;&gt; sma.real\nsma_timeperiod         2         3\n                  a    b    a    b\n2020-01-01      NaN  NaN  NaN  NaN\n2020-01-02      1.5  4.5  NaN  NaN\n2020-01-03      2.5  3.5  2.0  4.0\n2020-01-04      3.5  2.5  3.0  3.0\n2020-01-05      4.5  1.5  4.0  2.0\n</code></pre> <ul> <li>To get help on running the indicator, use the <code>help</code> command:</li> </ul> <pre><code>&gt;&gt;&gt; help(SMA.run)\nHelp on method run:\n\nrun(close, timeperiod=30, short_name='sma', hide_params=None, hide_default=True, **kwargs) method of builtins.type instance\n    Run `SMA` indicator.\n\n    * Inputs: `close`\n    * Parameters: `timeperiod`\n    * Outputs: `real`\n\n    Pass a list of parameter names as `hide_params` to hide their column levels.\n    Set `hide_default` to False to show the column levels of the parameters with a default value.\n\n    Other keyword arguments are passed to [run_pipeline()](/api/indicators/factory/#vectorbt.indicators.factory.run_pipeline \"vectorbt.indicators.factory.run_pipeline\").\n</code></pre>","title":"from_talib class method"},{"location":"api/indicators/factory/#vectorbt.indicators.factory.IndicatorFactory.get_pandas_ta_indicators","text":"<pre><code>IndicatorFactory.get_pandas_ta_indicators(\n    silence_warnings=True\n)\n</code></pre> <p>Get all pandas-ta indicators.</p>  <p>Note</p> <p>Returns only the indicators that have been successfully parsed.</p>","title":"get_pandas_ta_indicators class method"},{"location":"api/indicators/factory/#vectorbt.indicators.factory.IndicatorFactory.get_ta_indicators","text":"<pre><code>IndicatorFactory.get_ta_indicators()\n</code></pre> <p>Get all ta indicators.</p>","title":"get_ta_indicators class method"},{"location":"api/indicators/factory/#vectorbt.indicators.factory.IndicatorFactory.get_talib_indicators","text":"<pre><code>IndicatorFactory.get_talib_indicators()\n</code></pre> <p>Get all TA-Lib indicators.</p>","title":"get_talib_indicators class method"},{"location":"api/indicators/factory/#vectorbt.indicators.factory.IndicatorFactory.parse_pandas_ta_config","text":"<pre><code>IndicatorFactory.parse_pandas_ta_config(\n    func,\n    test_input_names=None,\n    test_index_len=100\n)\n</code></pre> <p>Get the config of a pandas-ta indicator.</p>","title":"parse_pandas_ta_config class method"},{"location":"api/indicators/factory/#vectorbt.indicators.factory.IndicatorFactory.parse_ta_config","text":"<pre><code>IndicatorFactory.parse_ta_config(\n    ind_cls\n)\n</code></pre> <p>Get the config of a ta indicator.</p>","title":"parse_ta_config class method"},{"location":"api/indicators/factory/#vectorbt.indicators.factory.IndicatorFactory.from_apply_func","text":"<pre><code>IndicatorFactory.from_apply_func(\n    apply_func,\n    cache_func=None,\n    pass_packed=False,\n    kwargs_to_args=None,\n    numba_loop=False,\n    **kwargs\n)\n</code></pre> <p>Build indicator class around a custom apply function.</p> <p>In contrast to IndicatorFactory.from_custom_func(), this method handles a lot of things for you, such as caching, parameter selection, and concatenation. Your part is writing a function <code>apply_func</code> that accepts a selection of parameters (single values as opposed to multiple values in IndicatorFactory.from_custom_func()) and does the calculation. It then automatically concatenates the resulting arrays into a single array per output.</p> <p>While this approach is simpler, it's also less flexible, since we can only work with one parameter selection at a time and can't view all parameters. The UDF <code>apply_func</code> also can't take keyword arguments, nor it can return anything other than outputs listed in <code>output_names</code>.</p>  <p>Note</p> <p>If <code>apply_func</code> is a Numba-compiled function:</p> <ul> <li>All inputs are automatically converted to NumPy arrays</li> <li>Each argument in <code>*args</code> must be of a Numba-compatible type</li> <li>You cannot pass keyword arguments</li> <li>Your outputs must be arrays of the same shape, data type and data order</li> </ul>  <p>Args</p>  <code>apply_func</code> :\u2002<code>callable</code>  <p>A function that takes inputs, selection of parameters, and other arguments, and does calculations to produce outputs.</p> <p>Arguments are passed to <code>apply_func</code> in the following order:</p> <ul> <li><code>input_shape</code> if <code>pass_input_shape</code> is set to True and <code>input_shape</code> not in <code>kwargs_to_args</code></li> <li><code>col</code> if <code>per_column</code> and <code>pass_col</code> are set to True and <code>col</code> not in <code>kwargs_to_args</code></li> <li>broadcast time-series arrays corresponding to <code>input_names</code></li> <li>broadcast in-place output arrays corresponding to <code>in_output_names</code></li> <li>single parameter selection corresponding to <code>param_names</code></li> <li>variable arguments if <code>var_args</code> is set to True</li> <li>arguments listed in <code>kwargs_to_args</code></li> <li><code>flex_2d</code> if <code>pass_flex_2d</code> is set to True and <code>flex_2d</code> not in <code>kwargs_to_args</code></li> <li>keyword arguments if <code>apply_func</code> is not Numba-compiled</li> </ul> <p>Can be Numba-compiled.</p>  <p>Note</p> <p>Shape of each output should be the same and match the shape of each input.</p>   <code>cache_func</code> :\u2002<code>callable</code>  <p>A caching function to preprocess data beforehand.</p> <p>Takes the same arguments as <code>apply_func</code>. Should return a single object or a tuple of objects. All returned objects will be passed unpacked as last arguments to <code>apply_func</code>.</p> <p>Can be Numba-compiled.</p>  <code>pass_packed</code> :\u2002<code>bool</code> Whether to pass packed tuples for inputs, in-place outputs, and parameters. <code>kwargs_to_args</code> :\u2002<code>list</code> of <code>str</code>  <p>Keyword arguments from <code>kwargs</code> dict to pass as positional arguments to the apply function.</p> <p>Should be used together with <code>numba_loop</code> set to True since Numba doesn't support variable keyword arguments.</p> <p>Defaults to []. Order matters.</p>  <code>numba_loop</code> :\u2002<code>bool</code>  <p>Whether to loop using Numba.</p> <p>Set to True when iterating large number of times over small input, but note that Numba doesn't support variable keyword arguments.</p>  <code>**kwargs</code> Keyword arguments passed to IndicatorFactory.from_custom_func().  <p>Returns</p> <p>Indicator Additionally, each run method now supports <code>use_ray</code> argument, which indicates whether to use Ray to execute <code>apply_func</code> in parallel. Only works with <code>numba_loop</code> set to False. See ray_apply() for related keyword arguments.</p> <p>Usage</p> <ul> <li>The following example produces the same indicator as the IndicatorFactory.from_custom_func() example.</li> </ul> <pre><code>&gt;&gt;&gt; @njit\n... def apply_func_nb(ts1, ts2, p1, p2, arg1, arg2):\n...     return ts1 * p1 + arg1, ts2 * p2 + arg2\n\n&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(\n...     input_names=['ts1', 'ts2'],\n...     param_names=['p1', 'p2'],\n...     output_names=['o1', 'o2']\n... ).from_apply_func(\n...     apply_func_nb, var_args=True,\n...     kwargs_to_args=['arg2'], arg2=200)\n\n&gt;&gt;&gt; myInd = MyInd.run(price, price * 2, [1, 2], [3, 4], 100)\n&gt;&gt;&gt; myInd.o1\ncustom_p1              1             2\ncustom_p2              3             4\n                a      b      a      b\n2020-01-01  101.0  105.0  102.0  110.0\n2020-01-02  102.0  104.0  104.0  108.0\n2020-01-03  103.0  103.0  106.0  106.0\n2020-01-04  104.0  102.0  108.0  104.0\n2020-01-05  105.0  101.0  110.0  102.0\n&gt;&gt;&gt; myInd.o2\ncustom_p1              1             2\ncustom_p2              3             4\n                a      b      a      b\n2020-01-01  206.0  230.0  208.0  240.0\n2020-01-02  212.0  224.0  216.0  232.0\n2020-01-03  218.0  218.0  224.0  224.0\n2020-01-04  224.0  212.0  232.0  216.0\n2020-01-05  230.0  206.0  240.0  208.0\n</code></pre>","title":"from_apply_func method"},{"location":"api/indicators/factory/#vectorbt.indicators.factory.IndicatorFactory.from_custom_func","text":"<pre><code>IndicatorFactory.from_custom_func(\n    custom_func,\n    require_input_shape=False,\n    param_settings=None,\n    in_output_settings=None,\n    hide_params=None,\n    hide_default=True,\n    var_args=False,\n    keyword_only_args=False,\n    **pipeline_kwargs\n)\n</code></pre> <p>Build indicator class around a custom calculation function.</p> <p>In contrast to IndicatorFactory.from_apply_func(), this method offers full flexbility. It's up to we to handle caching and concatenate columns for each parameter (for example, by using apply_and_concat_one()). Also, you should ensure that each output array has an appropriate number of columns, which is the number of columns in input arrays multiplied by the number of parameter combinations.</p> <p>Args</p>  <code>custom_func</code> :\u2002<code>callable</code>  <p>A function that takes broadcast arrays corresponding to <code>input_names</code>, broadcast in-place output arrays corresponding to <code>in_output_names</code>, broadcast parameter arrays corresponding to <code>param_names</code>, and other arguments and keyword arguments, and returns outputs corresponding to <code>output_names</code> and other objects that are then returned with the indicator instance.</p> <p>Can be Numba-compiled.</p>  <p>Note</p> <p>Shape of each output should be the same and match the shape of each input stacked n times (= the number of parameter values) along the column axis.</p>   <code>require_input_shape</code> :\u2002<code>bool</code> Whether to input shape is required. <code>param_settings</code> :\u2002<code>dict</code>  <p>A dictionary of parameter settings keyed by name. See run_pipeline() for keys.</p> <p>Can be overwritten by any run method.</p>  <code>in_output_settings</code> :\u2002<code>dict</code>  <p>A dictionary of in-place output settings keyed by name. See run_pipeline() for keys.</p> <p>Can be overwritten by any run method.</p>  <code>hide_params</code> :\u2002<code>list</code> of <code>str</code>  <p>Parameter names to hide column levels for.</p> <p>Can be overwritten by any run method.</p>  <code>hide_default</code> :\u2002<code>bool</code>  <p>Whether to hide column levels of parameters with default value.</p> <p>Can be overwritten by any run method.</p>  <code>var_args</code> :\u2002<code>bool</code>  <p>Whether run methods should accept variable arguments (<code>*args</code>).</p> <p>Set to True if <code>custom_func</code> accepts positional agruments that are not listed in the config.</p>  <code>keyword_only_args</code> :\u2002<code>bool</code>  <p>Whether run methods should accept keyword-only arguments (<code>*</code>).</p> <p>Set to True to force the user to use keyword arguments (e.g., to avoid misplacing arguments).</p>  <code>**pipeline_kwargs</code>  <p>Keyword arguments passed to run_pipeline().</p> <p>Can be overwritten by any run method.</p> <p>Can contain default values for <code>param_names</code> and <code>in_output_names</code>, but also custom positional and keyword arguments passed to the <code>custom_func</code>.</p>   <p>Returns</p> <p><code>Indicator</code>, and optionally other objects that are returned by <code>custom_func</code> and exceed <code>output_names</code>. Usage</p> <ul> <li>The following example produces the same indicator as the IndicatorFactory.from_apply_func() example.</li> </ul> <pre><code>&gt;&gt;&gt; @njit\n&gt;&gt;&gt; def apply_func_nb(i, ts1, ts2, p1, p2, arg1, arg2):\n...     return ts1 * p1[i] + arg1, ts2 * p2[i] + arg2\n\n&gt;&gt;&gt; @njit\n... def custom_func(ts1, ts2, p1, p2, arg1, arg2):\n...     return vbt.base.combine_fns.apply_and_concat_multiple_nb(\n...         len(p1), apply_func_nb, ts1, ts2, p1, p2, arg1, arg2)\n\n&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(\n...     input_names=['ts1', 'ts2'],\n...     param_names=['p1', 'p2'],\n...     output_names=['o1', 'o2']\n... ).from_custom_func(custom_func, var_args=True, arg2=200)\n\n&gt;&gt;&gt; myInd = MyInd.run(price, price * 2, [1, 2], [3, 4], 100)\n&gt;&gt;&gt; myInd.o1\ncustom_p1              1             2\ncustom_p2              3             4\n                a      b      a      b\n2020-01-01  101.0  105.0  102.0  110.0\n2020-01-02  102.0  104.0  104.0  108.0\n2020-01-03  103.0  103.0  106.0  106.0\n2020-01-04  104.0  102.0  108.0  104.0\n2020-01-05  105.0  101.0  110.0  102.0\n&gt;&gt;&gt; myInd.o2\ncustom_p1              1             2\ncustom_p2              3             4\n                a      b      a      b\n2020-01-01  206.0  230.0  208.0  240.0\n2020-01-02  212.0  224.0  216.0  232.0\n2020-01-03  218.0  218.0  224.0  224.0\n2020-01-04  224.0  212.0  232.0  216.0\n2020-01-05  230.0  206.0  240.0  208.0\n</code></pre> <p>The difference between <code>apply_func_nb</code> here and in IndicatorFactory.from_apply_func() is that here it takes the index of the current parameter combination that can be used for parameter selection. You can also remove the entire <code>apply_func_nb</code> and define your logic in <code>custom_func</code> (which shouldn't necessarily be Numba-compiled):</p> <pre><code>&gt;&gt;&gt; @njit\n... def custom_func(ts1, ts2, p1, p2, arg1, arg2):\n...     input_shape = ts1.shape\n...     n_params = len(p1)\n...     out1 = np.empty((input_shape[0], input_shape[1] * n_params), dtype=np.float_)\n...     out2 = np.empty((input_shape[0], input_shape[1] * n_params), dtype=np.float_)\n...     for k in range(n_params):\n...         for col in range(input_shape[1]):\n...             for i in range(input_shape[0]):\n...                 out1[i, input_shape[1] * k + col] = ts1[i, col] * p1[k] + arg1\n...                 out2[i, input_shape[1] * k + col] = ts2[i, col] * p2[k] + arg2\n...     return out1, out2\n</code></pre>","title":"from_custom_func method"},{"location":"api/indicators/factory/#vectorbt.indicators.factory.MetaIndicatorBase","text":"<pre><code>MetaIndicatorBase(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Meta class that exposes a read-only class property <code>StatsBuilderMixin.metrics</code>.</p> <p>Superclasses</p> <ul> <li>MetaPlotsBuilderMixin</li> <li>MetaStatsBuilderMixin</li> <li><code>builtins.type</code></li> </ul> <p>Inherited members</p> <ul> <li>MetaPlotsBuilderMixin.subplots</li> <li>MetaStatsBuilderMixin.metrics</li> </ul>","title":"MetaIndicatorBase class"},{"location":"api/indicators/nb/","text":"<p>Numba-compiled functions.</p> <p>Provides an arsenal of Numba-compiled functions that are used by indicator classes. These only accept NumPy arrays and other Numba-compatible types.</p>  <p>Note</p> <p>vectorbt treats matrices as first-class citizens and expects input arrays to be 2-dim, unless function has suffix <code>_1d</code> or is meant to be input to another function. Data is processed along index (axis 0).</p> <p>All functions passed as argument should be Numba-compiled.</p>","title":"nb"},{"location":"api/indicators/nb/#vectorbt.indicators.nb.atr_apply_nb","text":"<pre><code>atr_apply_nb(\n    high,\n    low,\n    close,\n    window,\n    ewm,\n    adjust,\n    tr,\n    cache_dict\n)\n</code></pre> <p>Apply function for ATR.</p>","title":"atr_apply_nb function"},{"location":"api/indicators/nb/#vectorbt.indicators.nb.atr_cache_nb","text":"<pre><code>atr_cache_nb(\n    high,\n    low,\n    close,\n    windows,\n    ewms,\n    adjust\n)\n</code></pre> <p>Caching function for ATR.</p>","title":"atr_cache_nb function"},{"location":"api/indicators/nb/#vectorbt.indicators.nb.bb_apply_nb","text":"<pre><code>bb_apply_nb(\n    close,\n    window,\n    ewm,\n    alpha,\n    adjust,\n    ddof,\n    ma_cache_dict,\n    mstd_cache_dict\n)\n</code></pre> <p>Apply function for BBANDS.</p>","title":"bb_apply_nb function"},{"location":"api/indicators/nb/#vectorbt.indicators.nb.bb_cache_nb","text":"<pre><code>bb_cache_nb(\n    close,\n    windows,\n    ewms,\n    alphas,\n    adjust,\n    ddof\n)\n</code></pre> <p>Caching function for BBANDS.</p>","title":"bb_cache_nb function"},{"location":"api/indicators/nb/#vectorbt.indicators.nb.ma_apply_nb","text":"<pre><code>ma_apply_nb(\n    close,\n    window,\n    ewm,\n    adjust,\n    cache_dict\n)\n</code></pre> <p>Apply function for MA.</p>","title":"ma_apply_nb function"},{"location":"api/indicators/nb/#vectorbt.indicators.nb.ma_cache_nb","text":"<pre><code>ma_cache_nb(\n    close,\n    windows,\n    ewms,\n    adjust\n)\n</code></pre> <p>Caching function for MA.</p>","title":"ma_cache_nb function"},{"location":"api/indicators/nb/#vectorbt.indicators.nb.ma_nb","text":"<pre><code>ma_nb(\n    a,\n    window,\n    ewm,\n    adjust=False\n)\n</code></pre> <p>Compute simple or exponential moving average (<code>ewm=True</code>).</p>","title":"ma_nb function"},{"location":"api/indicators/nb/#vectorbt.indicators.nb.macd_apply_nb","text":"<pre><code>macd_apply_nb(\n    close,\n    fast_window,\n    slow_window,\n    signal_window,\n    macd_ewm,\n    signal_ewm,\n    adjust,\n    cache_dict\n)\n</code></pre> <p>Apply function for MACD.</p>","title":"macd_apply_nb function"},{"location":"api/indicators/nb/#vectorbt.indicators.nb.macd_cache_nb","text":"<pre><code>macd_cache_nb(\n    close,\n    fast_windows,\n    slow_windows,\n    signal_windows,\n    macd_ewms,\n    signal_ewms,\n    adjust\n)\n</code></pre> <p>Caching function for MACD.</p>","title":"macd_cache_nb function"},{"location":"api/indicators/nb/#vectorbt.indicators.nb.mstd_apply_nb","text":"<pre><code>mstd_apply_nb(\n    close,\n    window,\n    ewm,\n    adjust,\n    ddof,\n    cache_dict\n)\n</code></pre> <p>Apply function for MSTD.</p>","title":"mstd_apply_nb function"},{"location":"api/indicators/nb/#vectorbt.indicators.nb.mstd_cache_nb","text":"<pre><code>mstd_cache_nb(\n    close,\n    windows,\n    ewms,\n    adjust,\n    ddof\n)\n</code></pre> <p>Caching function for MSTD.</p>","title":"mstd_cache_nb function"},{"location":"api/indicators/nb/#vectorbt.indicators.nb.mstd_nb","text":"<pre><code>mstd_nb(\n    a,\n    window,\n    ewm,\n    adjust=False,\n    ddof=0\n)\n</code></pre> <p>Compute simple or exponential moving STD (<code>ewm=True</code>).</p>","title":"mstd_nb function"},{"location":"api/indicators/nb/#vectorbt.indicators.nb.obv_custom_nb","text":"<pre><code>obv_custom_nb(\n    close,\n    volume_ts\n)\n</code></pre> <p>Custom calculation function for OBV.</p>","title":"obv_custom_nb function"},{"location":"api/indicators/nb/#vectorbt.indicators.nb.rsi_apply_nb","text":"<pre><code>rsi_apply_nb(\n    close,\n    window,\n    ewm,\n    adjust,\n    cache_dict\n)\n</code></pre> <p>Apply function for RSI.</p>","title":"rsi_apply_nb function"},{"location":"api/indicators/nb/#vectorbt.indicators.nb.rsi_cache_nb","text":"<pre><code>rsi_cache_nb(\n    close,\n    windows,\n    ewms,\n    adjust\n)\n</code></pre> <p>Caching function for RSI.</p>","title":"rsi_cache_nb function"},{"location":"api/indicators/nb/#vectorbt.indicators.nb.stoch_apply_nb","text":"<pre><code>stoch_apply_nb(\n    high,\n    low,\n    close,\n    k_window,\n    d_window,\n    d_ewm,\n    adjust,\n    cache_dict\n)\n</code></pre> <p>Apply function for STOCH.</p>","title":"stoch_apply_nb function"},{"location":"api/indicators/nb/#vectorbt.indicators.nb.stoch_cache_nb","text":"<pre><code>stoch_cache_nb(\n    high,\n    low,\n    close,\n    k_windows,\n    d_windows,\n    d_ewms,\n    adjust\n)\n</code></pre> <p>Caching function for STOCH.</p>","title":"stoch_cache_nb function"},{"location":"api/indicators/nb/#vectorbt.indicators.nb.true_range_nb","text":"<pre><code>true_range_nb(\n    high,\n    low,\n    close\n)\n</code></pre> <p>Calculate true range.</p>","title":"true_range_nb function"},{"location":"api/labels/","text":"<p>Modules for building and running look-ahead indicators and label generators.</p>","title":"labels"},{"location":"api/labels/#sub-modules","text":"<ul> <li>vectorbt.labels.enums</li> <li>vectorbt.labels.generators</li> <li>vectorbt.labels.nb</li> </ul>","title":"Sub-modules"},{"location":"api/labels/enums/","text":"<p>Named tuples and enumerated types.</p> <p>Defines enums and other schemas for vectorbt.labels.</p>","title":"enums"},{"location":"api/labels/enums/#vectorbt.labels.enums.TrendMode","text":"<p>Trend mode.</p> <pre><code>{\n    \"Binary\": 0,\n    \"BinaryCont\": 1,\n    \"BinaryContSat\": 2,\n    \"PctChange\": 3,\n    \"PctChangeNorm\": 4\n}\n</code></pre> <p>Attributes</p>  <code>Binary</code> See bn_trend_labels_nb(). <code>BinaryCont</code> See bn_cont_trend_labels_nb(). <code>BinaryContSat</code> See bn_cont_sat_trend_labels_nb(). <code>PctChange</code> See pct_trend_labels_nb(). <code>PctChangeNorm</code> See pct_trend_labels_nb() with <code>normalize</code> set to True.","title":"TrendMode variable"},{"location":"api/labels/generators/","text":"<p>Basic look-ahead indicators and label generators.</p> <p>You can access all the indicators either by <code>vbt.*</code> or <code>vbt.labels.*</code>.</p>","title":"generators"},{"location":"api/labels/generators/#vectorbt.labels.generators.BOLB","text":"<pre><code>BOLB(\n    wrapper,\n    input_list,\n    input_mapper,\n    in_output_list,\n    output_list,\n    param_list,\n    mapper_list,\n    short_name,\n    level_names\n)\n</code></pre> <p>Label generator based on breakout_labels_nb().</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>IndicatorBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> <li><code>vectorbt.labels.generators.ParamIndexer</code></li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>IndicatorBase.config</li> <li>IndicatorBase.iloc</li> <li>IndicatorBase.in_output_names</li> <li>IndicatorBase.indexing_func()</li> <li>IndicatorBase.indexing_kwargs</li> <li>IndicatorBase.input_names</li> <li>IndicatorBase.level_names</li> <li>IndicatorBase.loc</li> <li>IndicatorBase.output_flags</li> <li>IndicatorBase.output_names</li> <li>IndicatorBase.param_names</li> <li>IndicatorBase.plots_defaults</li> <li>IndicatorBase.self_aliases</li> <li>IndicatorBase.short_name</li> <li>IndicatorBase.stats_defaults</li> <li>IndicatorBase.wrapper</li> <li>IndicatorBase.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li><code>vectorbt.labels.generators._BOLB</code></li> </ul>","title":"BOLB class"},{"location":"api/labels/generators/#vectorbt.labels.generators.BOLB.run","text":"<pre><code>BOLB.run(\n    close,\n    window,\n    pos_th=Default(0.0),\n    neg_th=Default(0.0),\n    short_name='bolb',\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Run BOLB indicator.</p> <ul> <li>Inputs: <code>close</code></li> <li>Parameters: <code>window</code>, <code>pos_th</code>, <code>neg_th</code></li> <li>Outputs: <code>labels</code></li> </ul> <p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels. Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p> <p>Other keyword arguments are passed to run_pipeline().</p>","title":"run class method"},{"location":"api/labels/generators/#vectorbt.labels.generators.BOLB.run_combs","text":"<pre><code>BOLB.run_combs(\n    close,\n    window,\n    pos_th=Default(0.0),\n    neg_th=Default(0.0),\n    r=2,\n    param_product=False,\n    comb_func=itertools.combinations,\n    run_unique=True,\n    short_names=None,\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Create a combination of multiple BOLB indicators using function <code>comb_func</code>.</p> <ul> <li>Inputs: <code>close</code></li> <li>Parameters: <code>window</code>, <code>pos_th</code>, <code>neg_th</code></li> <li>Outputs: <code>labels</code></li> </ul> <p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.  Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>. Pass <code>r</code> to specify how many indicators to run.  Pass <code>short_names</code> to specify the short name for each indicator.  Set <code>run_unique</code> to True to first compute raw outputs for all parameters,  and then use them to build each indicator (faster).</p> <p>Other keyword arguments are passed to BOLB.run().</p>","title":"run_combs class method"},{"location":"api/labels/generators/#vectorbt.labels.generators.BOLB.close","text":"<p>Input array.</p>","title":"close variable"},{"location":"api/labels/generators/#vectorbt.labels.generators.BOLB.labels","text":"<p>Output array.</p>","title":"labels property"},{"location":"api/labels/generators/#vectorbt.labels.generators.BOLB.neg_th_list","text":"<p>List of <code>neg_th</code> values.</p>","title":"neg_th_list property"},{"location":"api/labels/generators/#vectorbt.labels.generators.BOLB.pos_th_list","text":"<p>List of <code>pos_th</code> values.</p>","title":"pos_th_list property"},{"location":"api/labels/generators/#vectorbt.labels.generators.BOLB.window_list","text":"<p>List of <code>window</code> values.</p>","title":"window_list property"},{"location":"api/labels/generators/#vectorbt.labels.generators.BOLB.apply_func","text":"<pre><code>BOLB.apply_func(\n    close,\n    window,\n    pos_th,\n    neg_th,\n    wait=1,\n    flex_2d=True\n)\n</code></pre> <p>For each value, return 1 if any value in the next period is greater than the positive threshold (in %), -1 if less than the negative threshold, and 0 otherwise.</p> <p>First hit wins.</p>","title":"apply_func method"},{"location":"api/labels/generators/#vectorbt.labels.generators.BOLB.close_above","text":"<pre><code>BOLB.close_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.BOLB.close_below","text":"<pre><code>BOLB.close_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.BOLB.close_crossed_above","text":"<pre><code>BOLB.close_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.BOLB.close_crossed_below","text":"<pre><code>BOLB.close_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.BOLB.close_equal","text":"<pre><code>BOLB.close_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_equal method"},{"location":"api/labels/generators/#vectorbt.labels.generators.BOLB.close_stats","text":"<pre><code>BOLB.close_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>close</code> as generic.</p>","title":"close_stats method"},{"location":"api/labels/generators/#vectorbt.labels.generators.BOLB.labels_above","text":"<pre><code>BOLB.labels_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>labels</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"labels_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.BOLB.labels_below","text":"<pre><code>BOLB.labels_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>labels</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"labels_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.BOLB.labels_crossed_above","text":"<pre><code>BOLB.labels_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>labels</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"labels_crossed_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.BOLB.labels_crossed_below","text":"<pre><code>BOLB.labels_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>labels</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"labels_crossed_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.BOLB.labels_equal","text":"<pre><code>BOLB.labels_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>labels</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"labels_equal method"},{"location":"api/labels/generators/#vectorbt.labels.generators.BOLB.labels_stats","text":"<pre><code>BOLB.labels_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>labels</code> as generic.</p>","title":"labels_stats method"},{"location":"api/labels/generators/#vectorbt.labels.generators.BOLB.plot","text":"<pre><code>BOLB.plot(\n    column=None,\n    **kwargs\n)\n</code></pre> <p>Plot <code>close</code> and overlay it with the heatmap of <code>labels</code>.</p> <p><code>**kwargs</code> are passed to GenericSRAccessor.overlay_with_heatmap().</p>","title":"plot method"},{"location":"api/labels/generators/#vectorbt.labels.generators.BOLB.custom_func","text":"<pre><code>IndicatorFactory.from_apply_func.&lt;locals&gt;.custom_func(\n    input_list,\n    in_output_list,\n    param_list,\n    *args,\n    input_shape=None,\n    col=None,\n    flex_2d=None,\n    return_cache=False,\n    use_cache=None,\n    use_ray=False,\n    **_kwargs\n)\n</code></pre> <p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p>","title":"custom_func method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FIXLB","text":"<pre><code>FIXLB(\n    wrapper,\n    input_list,\n    input_mapper,\n    in_output_list,\n    output_list,\n    param_list,\n    mapper_list,\n    short_name,\n    level_names\n)\n</code></pre> <p>Label generator based on fixed_labels_apply_nb().</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>IndicatorBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> <li><code>vectorbt.labels.generators.ParamIndexer</code></li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>IndicatorBase.config</li> <li>IndicatorBase.iloc</li> <li>IndicatorBase.in_output_names</li> <li>IndicatorBase.indexing_func()</li> <li>IndicatorBase.indexing_kwargs</li> <li>IndicatorBase.input_names</li> <li>IndicatorBase.level_names</li> <li>IndicatorBase.loc</li> <li>IndicatorBase.output_flags</li> <li>IndicatorBase.output_names</li> <li>IndicatorBase.param_names</li> <li>IndicatorBase.plots_defaults</li> <li>IndicatorBase.self_aliases</li> <li>IndicatorBase.short_name</li> <li>IndicatorBase.stats_defaults</li> <li>IndicatorBase.wrapper</li> <li>IndicatorBase.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li><code>vectorbt.labels.generators._FIXLB</code></li> </ul>","title":"FIXLB class"},{"location":"api/labels/generators/#vectorbt.labels.generators.FIXLB.run","text":"<pre><code>FIXLB.run(\n    close,\n    n,\n    short_name='fixlb',\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Run FIXLB indicator.</p> <ul> <li>Inputs: <code>close</code></li> <li>Parameters: <code>n</code></li> <li>Outputs: <code>labels</code></li> </ul> <p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels. Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p> <p>Other keyword arguments are passed to run_pipeline().</p>","title":"run class method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FIXLB.run_combs","text":"<pre><code>FIXLB.run_combs(\n    close,\n    n,\n    r=2,\n    param_product=False,\n    comb_func=itertools.combinations,\n    run_unique=True,\n    short_names=None,\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Create a combination of multiple FIXLB indicators using function <code>comb_func</code>.</p> <ul> <li>Inputs: <code>close</code></li> <li>Parameters: <code>n</code></li> <li>Outputs: <code>labels</code></li> </ul> <p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.  Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>. Pass <code>r</code> to specify how many indicators to run.  Pass <code>short_names</code> to specify the short name for each indicator.  Set <code>run_unique</code> to True to first compute raw outputs for all parameters,  and then use them to build each indicator (faster).</p> <p>Other keyword arguments are passed to FIXLB.run().</p>","title":"run_combs class method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FIXLB.close","text":"<p>Input array.</p>","title":"close variable"},{"location":"api/labels/generators/#vectorbt.labels.generators.FIXLB.labels","text":"<p>Output array.</p>","title":"labels property"},{"location":"api/labels/generators/#vectorbt.labels.generators.FIXLB.n_list","text":"<p>List of <code>n</code> values.</p>","title":"n_list property"},{"location":"api/labels/generators/#vectorbt.labels.generators.FIXLB.apply_func","text":"<pre><code>FIXLB.apply_func(\n    close,\n    n\n)\n</code></pre> <p>Get percentage change from the current value to a future value.</p>","title":"apply_func method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FIXLB.close_above","text":"<pre><code>FIXLB.close_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FIXLB.close_below","text":"<pre><code>FIXLB.close_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FIXLB.close_crossed_above","text":"<pre><code>FIXLB.close_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FIXLB.close_crossed_below","text":"<pre><code>FIXLB.close_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FIXLB.close_equal","text":"<pre><code>FIXLB.close_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_equal method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FIXLB.close_stats","text":"<pre><code>FIXLB.close_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>close</code> as generic.</p>","title":"close_stats method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FIXLB.labels_above","text":"<pre><code>FIXLB.labels_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>labels</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"labels_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FIXLB.labels_below","text":"<pre><code>FIXLB.labels_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>labels</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"labels_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FIXLB.labels_crossed_above","text":"<pre><code>FIXLB.labels_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>labels</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"labels_crossed_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FIXLB.labels_crossed_below","text":"<pre><code>FIXLB.labels_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>labels</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"labels_crossed_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FIXLB.labels_equal","text":"<pre><code>FIXLB.labels_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>labels</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"labels_equal method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FIXLB.labels_stats","text":"<pre><code>FIXLB.labels_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>labels</code> as generic.</p>","title":"labels_stats method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FIXLB.plot","text":"<pre><code>FIXLB.plot(\n    column=None,\n    **kwargs\n)\n</code></pre> <p>Plot <code>close</code> and overlay it with the heatmap of <code>labels</code>.</p> <p><code>**kwargs</code> are passed to GenericSRAccessor.overlay_with_heatmap().</p>","title":"plot method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FIXLB.custom_func","text":"<pre><code>IndicatorFactory.from_apply_func.&lt;locals&gt;.custom_func(\n    input_list,\n    in_output_list,\n    param_list,\n    *args,\n    input_shape=None,\n    col=None,\n    flex_2d=None,\n    return_cache=False,\n    use_cache=None,\n    use_ray=False,\n    **_kwargs\n)\n</code></pre> <p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p>","title":"custom_func method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMAX","text":"<pre><code>FMAX(\n    wrapper,\n    input_list,\n    input_mapper,\n    in_output_list,\n    output_list,\n    param_list,\n    mapper_list,\n    short_name,\n    level_names\n)\n</code></pre> <p>Look-ahead indicator based on future_max_apply_nb().</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>IndicatorBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> <li><code>vectorbt.labels.generators.ParamIndexer</code></li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>IndicatorBase.config</li> <li>IndicatorBase.iloc</li> <li>IndicatorBase.in_output_names</li> <li>IndicatorBase.indexing_func()</li> <li>IndicatorBase.indexing_kwargs</li> <li>IndicatorBase.input_names</li> <li>IndicatorBase.level_names</li> <li>IndicatorBase.loc</li> <li>IndicatorBase.output_flags</li> <li>IndicatorBase.output_names</li> <li>IndicatorBase.param_names</li> <li>IndicatorBase.plots_defaults</li> <li>IndicatorBase.self_aliases</li> <li>IndicatorBase.short_name</li> <li>IndicatorBase.stats_defaults</li> <li>IndicatorBase.wrapper</li> <li>IndicatorBase.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul>","title":"FMAX class"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMAX.run","text":"<pre><code>FMAX.run(\n    close,\n    window,\n    short_name='fmax',\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Run FMAX indicator.</p> <ul> <li>Inputs: <code>close</code></li> <li>Parameters: <code>window</code></li> <li>Outputs: <code>fmax</code></li> </ul> <p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels. Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p> <p>Other keyword arguments are passed to run_pipeline().</p>","title":"run class method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMAX.run_combs","text":"<pre><code>FMAX.run_combs(\n    close,\n    window,\n    r=2,\n    param_product=False,\n    comb_func=itertools.combinations,\n    run_unique=True,\n    short_names=None,\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Create a combination of multiple FMAX indicators using function <code>comb_func</code>.</p> <ul> <li>Inputs: <code>close</code></li> <li>Parameters: <code>window</code></li> <li>Outputs: <code>fmax</code></li> </ul> <p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.  Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>. Pass <code>r</code> to specify how many indicators to run.  Pass <code>short_names</code> to specify the short name for each indicator.  Set <code>run_unique</code> to True to first compute raw outputs for all parameters,  and then use them to build each indicator (faster).</p> <p>Other keyword arguments are passed to FMAX.run().</p>","title":"run_combs class method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMAX.close","text":"<p>Input array.</p>","title":"close variable"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMAX.fmax","text":"<p>Output array.</p>","title":"fmax property"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMAX.window_list","text":"<p>List of <code>window</code> values.</p>","title":"window_list property"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMAX.apply_func","text":"<pre><code>FMAX.apply_func(\n    close,\n    window,\n    wait=1\n)\n</code></pre> <p>Get the maximum of the next period.</p>","title":"apply_func method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMAX.close_above","text":"<pre><code>FMAX.close_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMAX.close_below","text":"<pre><code>FMAX.close_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMAX.close_crossed_above","text":"<pre><code>FMAX.close_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMAX.close_crossed_below","text":"<pre><code>FMAX.close_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMAX.close_equal","text":"<pre><code>FMAX.close_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_equal method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMAX.close_stats","text":"<pre><code>FMAX.close_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>close</code> as generic.</p>","title":"close_stats method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMAX.fmax_above","text":"<pre><code>FMAX.fmax_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>fmax</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"fmax_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMAX.fmax_below","text":"<pre><code>FMAX.fmax_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>fmax</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"fmax_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMAX.fmax_crossed_above","text":"<pre><code>FMAX.fmax_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>fmax</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"fmax_crossed_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMAX.fmax_crossed_below","text":"<pre><code>FMAX.fmax_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>fmax</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"fmax_crossed_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMAX.fmax_equal","text":"<pre><code>FMAX.fmax_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>fmax</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"fmax_equal method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMAX.fmax_stats","text":"<pre><code>FMAX.fmax_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>fmax</code> as generic.</p>","title":"fmax_stats method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMAX.custom_func","text":"<pre><code>IndicatorFactory.from_apply_func.&lt;locals&gt;.custom_func(\n    input_list,\n    in_output_list,\n    param_list,\n    *args,\n    input_shape=None,\n    col=None,\n    flex_2d=None,\n    return_cache=False,\n    use_cache=None,\n    use_ray=False,\n    **_kwargs\n)\n</code></pre> <p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p>","title":"custom_func method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMEAN","text":"<pre><code>FMEAN(\n    wrapper,\n    input_list,\n    input_mapper,\n    in_output_list,\n    output_list,\n    param_list,\n    mapper_list,\n    short_name,\n    level_names\n)\n</code></pre> <p>Look-ahead indicator based on future_mean_apply_nb().</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>IndicatorBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> <li><code>vectorbt.labels.generators.ParamIndexer</code></li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>IndicatorBase.config</li> <li>IndicatorBase.iloc</li> <li>IndicatorBase.in_output_names</li> <li>IndicatorBase.indexing_func()</li> <li>IndicatorBase.indexing_kwargs</li> <li>IndicatorBase.input_names</li> <li>IndicatorBase.level_names</li> <li>IndicatorBase.loc</li> <li>IndicatorBase.output_flags</li> <li>IndicatorBase.output_names</li> <li>IndicatorBase.param_names</li> <li>IndicatorBase.plots_defaults</li> <li>IndicatorBase.self_aliases</li> <li>IndicatorBase.short_name</li> <li>IndicatorBase.stats_defaults</li> <li>IndicatorBase.wrapper</li> <li>IndicatorBase.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul>","title":"FMEAN class"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMEAN.run","text":"<pre><code>FMEAN.run(\n    close,\n    window,\n    ewm=Default(False),\n    short_name='fmean',\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Run FMEAN indicator.</p> <ul> <li>Inputs: <code>close</code></li> <li>Parameters: <code>window</code>, <code>ewm</code></li> <li>Outputs: <code>fmean</code></li> </ul> <p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels. Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p> <p>Other keyword arguments are passed to run_pipeline().</p>","title":"run class method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMEAN.run_combs","text":"<pre><code>FMEAN.run_combs(\n    close,\n    window,\n    ewm=Default(False),\n    r=2,\n    param_product=False,\n    comb_func=itertools.combinations,\n    run_unique=True,\n    short_names=None,\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Create a combination of multiple FMEAN indicators using function <code>comb_func</code>.</p> <ul> <li>Inputs: <code>close</code></li> <li>Parameters: <code>window</code>, <code>ewm</code></li> <li>Outputs: <code>fmean</code></li> </ul> <p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.  Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>. Pass <code>r</code> to specify how many indicators to run.  Pass <code>short_names</code> to specify the short name for each indicator.  Set <code>run_unique</code> to True to first compute raw outputs for all parameters,  and then use them to build each indicator (faster).</p> <p>Other keyword arguments are passed to FMEAN.run().</p>","title":"run_combs class method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMEAN.close","text":"<p>Input array.</p>","title":"close variable"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMEAN.ewm_list","text":"<p>List of <code>ewm</code> values.</p>","title":"ewm_list property"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMEAN.fmean","text":"<p>Output array.</p>","title":"fmean property"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMEAN.window_list","text":"<p>List of <code>window</code> values.</p>","title":"window_list property"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMEAN.apply_func","text":"<pre><code>FMEAN.apply_func(\n    close,\n    window,\n    ewm,\n    wait=1,\n    adjust=False\n)\n</code></pre> <p>Get the mean of the next period.</p>","title":"apply_func method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMEAN.close_above","text":"<pre><code>FMEAN.close_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMEAN.close_below","text":"<pre><code>FMEAN.close_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMEAN.close_crossed_above","text":"<pre><code>FMEAN.close_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMEAN.close_crossed_below","text":"<pre><code>FMEAN.close_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMEAN.close_equal","text":"<pre><code>FMEAN.close_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_equal method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMEAN.close_stats","text":"<pre><code>FMEAN.close_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>close</code> as generic.</p>","title":"close_stats method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMEAN.fmean_above","text":"<pre><code>FMEAN.fmean_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>fmean</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"fmean_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMEAN.fmean_below","text":"<pre><code>FMEAN.fmean_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>fmean</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"fmean_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMEAN.fmean_crossed_above","text":"<pre><code>FMEAN.fmean_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>fmean</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"fmean_crossed_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMEAN.fmean_crossed_below","text":"<pre><code>FMEAN.fmean_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>fmean</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"fmean_crossed_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMEAN.fmean_equal","text":"<pre><code>FMEAN.fmean_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>fmean</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"fmean_equal method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMEAN.fmean_stats","text":"<pre><code>FMEAN.fmean_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>fmean</code> as generic.</p>","title":"fmean_stats method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMEAN.custom_func","text":"<pre><code>IndicatorFactory.from_apply_func.&lt;locals&gt;.custom_func(\n    input_list,\n    in_output_list,\n    param_list,\n    *args,\n    input_shape=None,\n    col=None,\n    flex_2d=None,\n    return_cache=False,\n    use_cache=None,\n    use_ray=False,\n    **_kwargs\n)\n</code></pre> <p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p>","title":"custom_func method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMIN","text":"<pre><code>FMIN(\n    wrapper,\n    input_list,\n    input_mapper,\n    in_output_list,\n    output_list,\n    param_list,\n    mapper_list,\n    short_name,\n    level_names\n)\n</code></pre> <p>Look-ahead indicator based on future_min_apply_nb().</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>IndicatorBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> <li><code>vectorbt.labels.generators.ParamIndexer</code></li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>IndicatorBase.config</li> <li>IndicatorBase.iloc</li> <li>IndicatorBase.in_output_names</li> <li>IndicatorBase.indexing_func()</li> <li>IndicatorBase.indexing_kwargs</li> <li>IndicatorBase.input_names</li> <li>IndicatorBase.level_names</li> <li>IndicatorBase.loc</li> <li>IndicatorBase.output_flags</li> <li>IndicatorBase.output_names</li> <li>IndicatorBase.param_names</li> <li>IndicatorBase.plots_defaults</li> <li>IndicatorBase.self_aliases</li> <li>IndicatorBase.short_name</li> <li>IndicatorBase.stats_defaults</li> <li>IndicatorBase.wrapper</li> <li>IndicatorBase.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul>","title":"FMIN class"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMIN.run","text":"<pre><code>FMIN.run(\n    close,\n    window,\n    short_name='fmin',\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Run FMIN indicator.</p> <ul> <li>Inputs: <code>close</code></li> <li>Parameters: <code>window</code></li> <li>Outputs: <code>fmin</code></li> </ul> <p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels. Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p> <p>Other keyword arguments are passed to run_pipeline().</p>","title":"run class method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMIN.run_combs","text":"<pre><code>FMIN.run_combs(\n    close,\n    window,\n    r=2,\n    param_product=False,\n    comb_func=itertools.combinations,\n    run_unique=True,\n    short_names=None,\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Create a combination of multiple FMIN indicators using function <code>comb_func</code>.</p> <ul> <li>Inputs: <code>close</code></li> <li>Parameters: <code>window</code></li> <li>Outputs: <code>fmin</code></li> </ul> <p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.  Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>. Pass <code>r</code> to specify how many indicators to run.  Pass <code>short_names</code> to specify the short name for each indicator.  Set <code>run_unique</code> to True to first compute raw outputs for all parameters,  and then use them to build each indicator (faster).</p> <p>Other keyword arguments are passed to FMIN.run().</p>","title":"run_combs class method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMIN.close","text":"<p>Input array.</p>","title":"close variable"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMIN.fmin","text":"<p>Output array.</p>","title":"fmin property"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMIN.window_list","text":"<p>List of <code>window</code> values.</p>","title":"window_list property"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMIN.apply_func","text":"<pre><code>FMIN.apply_func(\n    close,\n    window,\n    wait=1\n)\n</code></pre> <p>Get the minimum of the next period.</p>","title":"apply_func method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMIN.close_above","text":"<pre><code>FMIN.close_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMIN.close_below","text":"<pre><code>FMIN.close_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMIN.close_crossed_above","text":"<pre><code>FMIN.close_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMIN.close_crossed_below","text":"<pre><code>FMIN.close_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMIN.close_equal","text":"<pre><code>FMIN.close_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_equal method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMIN.close_stats","text":"<pre><code>FMIN.close_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>close</code> as generic.</p>","title":"close_stats method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMIN.fmin_above","text":"<pre><code>FMIN.fmin_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>fmin</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"fmin_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMIN.fmin_below","text":"<pre><code>FMIN.fmin_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>fmin</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"fmin_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMIN.fmin_crossed_above","text":"<pre><code>FMIN.fmin_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>fmin</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"fmin_crossed_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMIN.fmin_crossed_below","text":"<pre><code>FMIN.fmin_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>fmin</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"fmin_crossed_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMIN.fmin_equal","text":"<pre><code>FMIN.fmin_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>fmin</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"fmin_equal method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMIN.fmin_stats","text":"<pre><code>FMIN.fmin_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>fmin</code> as generic.</p>","title":"fmin_stats method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FMIN.custom_func","text":"<pre><code>IndicatorFactory.from_apply_func.&lt;locals&gt;.custom_func(\n    input_list,\n    in_output_list,\n    param_list,\n    *args,\n    input_shape=None,\n    col=None,\n    flex_2d=None,\n    return_cache=False,\n    use_cache=None,\n    use_ray=False,\n    **_kwargs\n)\n</code></pre> <p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p>","title":"custom_func method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FSTD","text":"<pre><code>FSTD(\n    wrapper,\n    input_list,\n    input_mapper,\n    in_output_list,\n    output_list,\n    param_list,\n    mapper_list,\n    short_name,\n    level_names\n)\n</code></pre> <p>Look-ahead indicator based on future_std_apply_nb().</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>IndicatorBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> <li><code>vectorbt.labels.generators.ParamIndexer</code></li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>IndicatorBase.config</li> <li>IndicatorBase.iloc</li> <li>IndicatorBase.in_output_names</li> <li>IndicatorBase.indexing_func()</li> <li>IndicatorBase.indexing_kwargs</li> <li>IndicatorBase.input_names</li> <li>IndicatorBase.level_names</li> <li>IndicatorBase.loc</li> <li>IndicatorBase.output_flags</li> <li>IndicatorBase.output_names</li> <li>IndicatorBase.param_names</li> <li>IndicatorBase.plots_defaults</li> <li>IndicatorBase.self_aliases</li> <li>IndicatorBase.short_name</li> <li>IndicatorBase.stats_defaults</li> <li>IndicatorBase.wrapper</li> <li>IndicatorBase.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul>","title":"FSTD class"},{"location":"api/labels/generators/#vectorbt.labels.generators.FSTD.run","text":"<pre><code>FSTD.run(\n    close,\n    window,\n    ewm=Default(False),\n    short_name='fstd',\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Run FSTD indicator.</p> <ul> <li>Inputs: <code>close</code></li> <li>Parameters: <code>window</code>, <code>ewm</code></li> <li>Outputs: <code>fstd</code></li> </ul> <p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels. Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p> <p>Other keyword arguments are passed to run_pipeline().</p>","title":"run class method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FSTD.run_combs","text":"<pre><code>FSTD.run_combs(\n    close,\n    window,\n    ewm=Default(False),\n    r=2,\n    param_product=False,\n    comb_func=itertools.combinations,\n    run_unique=True,\n    short_names=None,\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Create a combination of multiple FSTD indicators using function <code>comb_func</code>.</p> <ul> <li>Inputs: <code>close</code></li> <li>Parameters: <code>window</code>, <code>ewm</code></li> <li>Outputs: <code>fstd</code></li> </ul> <p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.  Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>. Pass <code>r</code> to specify how many indicators to run.  Pass <code>short_names</code> to specify the short name for each indicator.  Set <code>run_unique</code> to True to first compute raw outputs for all parameters,  and then use them to build each indicator (faster).</p> <p>Other keyword arguments are passed to FSTD.run().</p>","title":"run_combs class method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FSTD.close","text":"<p>Input array.</p>","title":"close variable"},{"location":"api/labels/generators/#vectorbt.labels.generators.FSTD.ewm_list","text":"<p>List of <code>ewm</code> values.</p>","title":"ewm_list property"},{"location":"api/labels/generators/#vectorbt.labels.generators.FSTD.fstd","text":"<p>Output array.</p>","title":"fstd property"},{"location":"api/labels/generators/#vectorbt.labels.generators.FSTD.window_list","text":"<p>List of <code>window</code> values.</p>","title":"window_list property"},{"location":"api/labels/generators/#vectorbt.labels.generators.FSTD.apply_func","text":"<pre><code>FSTD.apply_func(\n    close,\n    window,\n    ewm,\n    wait=1,\n    adjust=False,\n    ddof=0\n)\n</code></pre> <p>Get the standard deviation of the next period.</p>","title":"apply_func method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FSTD.close_above","text":"<pre><code>FSTD.close_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FSTD.close_below","text":"<pre><code>FSTD.close_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FSTD.close_crossed_above","text":"<pre><code>FSTD.close_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FSTD.close_crossed_below","text":"<pre><code>FSTD.close_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FSTD.close_equal","text":"<pre><code>FSTD.close_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_equal method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FSTD.close_stats","text":"<pre><code>FSTD.close_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>close</code> as generic.</p>","title":"close_stats method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FSTD.fstd_above","text":"<pre><code>FSTD.fstd_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>fstd</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"fstd_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FSTD.fstd_below","text":"<pre><code>FSTD.fstd_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>fstd</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"fstd_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FSTD.fstd_crossed_above","text":"<pre><code>FSTD.fstd_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>fstd</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"fstd_crossed_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FSTD.fstd_crossed_below","text":"<pre><code>FSTD.fstd_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>fstd</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"fstd_crossed_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FSTD.fstd_equal","text":"<pre><code>FSTD.fstd_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>fstd</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"fstd_equal method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FSTD.fstd_stats","text":"<pre><code>FSTD.fstd_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>fstd</code> as generic.</p>","title":"fstd_stats method"},{"location":"api/labels/generators/#vectorbt.labels.generators.FSTD.custom_func","text":"<pre><code>IndicatorFactory.from_apply_func.&lt;locals&gt;.custom_func(\n    input_list,\n    in_output_list,\n    param_list,\n    *args,\n    input_shape=None,\n    col=None,\n    flex_2d=None,\n    return_cache=False,\n    use_cache=None,\n    use_ray=False,\n    **_kwargs\n)\n</code></pre> <p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p>","title":"custom_func method"},{"location":"api/labels/generators/#vectorbt.labels.generators.LEXLB","text":"<pre><code>LEXLB(\n    wrapper,\n    input_list,\n    input_mapper,\n    in_output_list,\n    output_list,\n    param_list,\n    mapper_list,\n    short_name,\n    level_names\n)\n</code></pre> <p>Label generator based on local_extrema_apply_nb().</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>IndicatorBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> <li><code>vectorbt.labels.generators.ParamIndexer</code></li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>IndicatorBase.config</li> <li>IndicatorBase.iloc</li> <li>IndicatorBase.in_output_names</li> <li>IndicatorBase.indexing_func()</li> <li>IndicatorBase.indexing_kwargs</li> <li>IndicatorBase.input_names</li> <li>IndicatorBase.level_names</li> <li>IndicatorBase.loc</li> <li>IndicatorBase.output_flags</li> <li>IndicatorBase.output_names</li> <li>IndicatorBase.param_names</li> <li>IndicatorBase.plots_defaults</li> <li>IndicatorBase.self_aliases</li> <li>IndicatorBase.short_name</li> <li>IndicatorBase.stats_defaults</li> <li>IndicatorBase.wrapper</li> <li>IndicatorBase.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li><code>vectorbt.labels.generators._LEXLB</code></li> </ul>","title":"LEXLB class"},{"location":"api/labels/generators/#vectorbt.labels.generators.LEXLB.run","text":"<pre><code>LEXLB.run(\n    close,\n    pos_th,\n    neg_th,\n    short_name='lexlb',\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Run LEXLB indicator.</p> <ul> <li>Inputs: <code>close</code></li> <li>Parameters: <code>pos_th</code>, <code>neg_th</code></li> <li>Outputs: <code>labels</code></li> </ul> <p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels. Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p> <p>Other keyword arguments are passed to run_pipeline().</p>","title":"run class method"},{"location":"api/labels/generators/#vectorbt.labels.generators.LEXLB.run_combs","text":"<pre><code>LEXLB.run_combs(\n    close,\n    pos_th,\n    neg_th,\n    r=2,\n    param_product=False,\n    comb_func=itertools.combinations,\n    run_unique=True,\n    short_names=None,\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Create a combination of multiple LEXLB indicators using function <code>comb_func</code>.</p> <ul> <li>Inputs: <code>close</code></li> <li>Parameters: <code>pos_th</code>, <code>neg_th</code></li> <li>Outputs: <code>labels</code></li> </ul> <p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.  Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>. Pass <code>r</code> to specify how many indicators to run.  Pass <code>short_names</code> to specify the short name for each indicator.  Set <code>run_unique</code> to True to first compute raw outputs for all parameters,  and then use them to build each indicator (faster).</p> <p>Other keyword arguments are passed to LEXLB.run().</p>","title":"run_combs class method"},{"location":"api/labels/generators/#vectorbt.labels.generators.LEXLB.close","text":"<p>Input array.</p>","title":"close variable"},{"location":"api/labels/generators/#vectorbt.labels.generators.LEXLB.labels","text":"<p>Output array.</p>","title":"labels property"},{"location":"api/labels/generators/#vectorbt.labels.generators.LEXLB.neg_th_list","text":"<p>List of <code>neg_th</code> values.</p>","title":"neg_th_list property"},{"location":"api/labels/generators/#vectorbt.labels.generators.LEXLB.pos_th_list","text":"<p>List of <code>pos_th</code> values.</p>","title":"pos_th_list property"},{"location":"api/labels/generators/#vectorbt.labels.generators.LEXLB.custom_func","text":"<pre><code>IndicatorFactory.from_apply_func.&lt;locals&gt;.custom_func(\n    input_list,\n    in_output_list,\n    param_list,\n    *args,\n    input_shape=None,\n    col=None,\n    flex_2d=None,\n    return_cache=False,\n    use_cache=None,\n    use_ray=False,\n    **_kwargs\n)\n</code></pre> <p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p>","title":"custom_func method"},{"location":"api/labels/generators/#vectorbt.labels.generators.LEXLB.apply_func","text":"<pre><code>LEXLB.apply_func(\n    close,\n    pos_th,\n    neg_th,\n    flex_2d=True\n)\n</code></pre> <p>Get array of local extrema denoted by 1 (peak) or -1 (trough), otherwise 0.</p> <p>Two adjacent peak and trough points should exceed the given threshold parameters.</p> <p>If any threshold is given element-wise, it will be applied per new/updated extremum.</p> <p>Inspired by https://www.mdpi.com/1099-4300/22/10/1162/pdf</p>","title":"apply_func method"},{"location":"api/labels/generators/#vectorbt.labels.generators.LEXLB.close_above","text":"<pre><code>LEXLB.close_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.LEXLB.close_below","text":"<pre><code>LEXLB.close_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.LEXLB.close_crossed_above","text":"<pre><code>LEXLB.close_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.LEXLB.close_crossed_below","text":"<pre><code>LEXLB.close_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.LEXLB.close_equal","text":"<pre><code>LEXLB.close_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_equal method"},{"location":"api/labels/generators/#vectorbt.labels.generators.LEXLB.close_stats","text":"<pre><code>LEXLB.close_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>close</code> as generic.</p>","title":"close_stats method"},{"location":"api/labels/generators/#vectorbt.labels.generators.LEXLB.labels_above","text":"<pre><code>LEXLB.labels_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>labels</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"labels_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.LEXLB.labels_below","text":"<pre><code>LEXLB.labels_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>labels</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"labels_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.LEXLB.labels_crossed_above","text":"<pre><code>LEXLB.labels_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>labels</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"labels_crossed_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.LEXLB.labels_crossed_below","text":"<pre><code>LEXLB.labels_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>labels</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"labels_crossed_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.LEXLB.labels_equal","text":"<pre><code>LEXLB.labels_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>labels</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"labels_equal method"},{"location":"api/labels/generators/#vectorbt.labels.generators.LEXLB.labels_stats","text":"<pre><code>LEXLB.labels_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>labels</code> as generic.</p>","title":"labels_stats method"},{"location":"api/labels/generators/#vectorbt.labels.generators.LEXLB.plot","text":"<pre><code>LEXLB.plot(\n    column=None,\n    **kwargs\n)\n</code></pre> <p>Plot <code>close</code> and overlay it with the heatmap of <code>labels</code>.</p> <p><code>**kwargs</code> are passed to GenericSRAccessor.overlay_with_heatmap().</p>","title":"plot method"},{"location":"api/labels/generators/#vectorbt.labels.generators.MEANLB","text":"<pre><code>MEANLB(\n    wrapper,\n    input_list,\n    input_mapper,\n    in_output_list,\n    output_list,\n    param_list,\n    mapper_list,\n    short_name,\n    level_names\n)\n</code></pre> <p>Label generator based on mean_labels_apply_nb().</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>IndicatorBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> <li><code>vectorbt.labels.generators.ParamIndexer</code></li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>IndicatorBase.config</li> <li>IndicatorBase.iloc</li> <li>IndicatorBase.in_output_names</li> <li>IndicatorBase.indexing_func()</li> <li>IndicatorBase.indexing_kwargs</li> <li>IndicatorBase.input_names</li> <li>IndicatorBase.level_names</li> <li>IndicatorBase.loc</li> <li>IndicatorBase.output_flags</li> <li>IndicatorBase.output_names</li> <li>IndicatorBase.param_names</li> <li>IndicatorBase.plots_defaults</li> <li>IndicatorBase.self_aliases</li> <li>IndicatorBase.short_name</li> <li>IndicatorBase.stats_defaults</li> <li>IndicatorBase.wrapper</li> <li>IndicatorBase.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li><code>vectorbt.labels.generators._MEANLB</code></li> </ul>","title":"MEANLB class"},{"location":"api/labels/generators/#vectorbt.labels.generators.MEANLB.run","text":"<pre><code>MEANLB.run(\n    close,\n    window,\n    ewm=Default(False),\n    short_name='meanlb',\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Run MEANLB indicator.</p> <ul> <li>Inputs: <code>close</code></li> <li>Parameters: <code>window</code>, <code>ewm</code></li> <li>Outputs: <code>labels</code></li> </ul> <p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels. Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p> <p>Other keyword arguments are passed to run_pipeline().</p>","title":"run class method"},{"location":"api/labels/generators/#vectorbt.labels.generators.MEANLB.run_combs","text":"<pre><code>MEANLB.run_combs(\n    close,\n    window,\n    ewm=Default(False),\n    r=2,\n    param_product=False,\n    comb_func=itertools.combinations,\n    run_unique=True,\n    short_names=None,\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Create a combination of multiple MEANLB indicators using function <code>comb_func</code>.</p> <ul> <li>Inputs: <code>close</code></li> <li>Parameters: <code>window</code>, <code>ewm</code></li> <li>Outputs: <code>labels</code></li> </ul> <p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.  Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>. Pass <code>r</code> to specify how many indicators to run.  Pass <code>short_names</code> to specify the short name for each indicator.  Set <code>run_unique</code> to True to first compute raw outputs for all parameters,  and then use them to build each indicator (faster).</p> <p>Other keyword arguments are passed to MEANLB.run().</p>","title":"run_combs class method"},{"location":"api/labels/generators/#vectorbt.labels.generators.MEANLB.close","text":"<p>Input array.</p>","title":"close variable"},{"location":"api/labels/generators/#vectorbt.labels.generators.MEANLB.ewm_list","text":"<p>List of <code>ewm</code> values.</p>","title":"ewm_list property"},{"location":"api/labels/generators/#vectorbt.labels.generators.MEANLB.labels","text":"<p>Output array.</p>","title":"labels property"},{"location":"api/labels/generators/#vectorbt.labels.generators.MEANLB.window_list","text":"<p>List of <code>window</code> values.</p>","title":"window_list property"},{"location":"api/labels/generators/#vectorbt.labels.generators.MEANLB.custom_func","text":"<pre><code>IndicatorFactory.from_apply_func.&lt;locals&gt;.custom_func(\n    input_list,\n    in_output_list,\n    param_list,\n    *args,\n    input_shape=None,\n    col=None,\n    flex_2d=None,\n    return_cache=False,\n    use_cache=None,\n    use_ray=False,\n    **_kwargs\n)\n</code></pre> <p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p>","title":"custom_func method"},{"location":"api/labels/generators/#vectorbt.labels.generators.MEANLB.apply_func","text":"<pre><code>MEANLB.apply_func(\n    close,\n    window,\n    ewm,\n    wait=1,\n    adjust=False\n)\n</code></pre> <p>Get the percentage change from the current value to the average of the next period.</p>","title":"apply_func method"},{"location":"api/labels/generators/#vectorbt.labels.generators.MEANLB.close_above","text":"<pre><code>MEANLB.close_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.MEANLB.close_below","text":"<pre><code>MEANLB.close_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.MEANLB.close_crossed_above","text":"<pre><code>MEANLB.close_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.MEANLB.close_crossed_below","text":"<pre><code>MEANLB.close_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.MEANLB.close_equal","text":"<pre><code>MEANLB.close_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_equal method"},{"location":"api/labels/generators/#vectorbt.labels.generators.MEANLB.close_stats","text":"<pre><code>MEANLB.close_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>close</code> as generic.</p>","title":"close_stats method"},{"location":"api/labels/generators/#vectorbt.labels.generators.MEANLB.labels_above","text":"<pre><code>MEANLB.labels_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>labels</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"labels_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.MEANLB.labels_below","text":"<pre><code>MEANLB.labels_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>labels</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"labels_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.MEANLB.labels_crossed_above","text":"<pre><code>MEANLB.labels_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>labels</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"labels_crossed_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.MEANLB.labels_crossed_below","text":"<pre><code>MEANLB.labels_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>labels</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"labels_crossed_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.MEANLB.labels_equal","text":"<pre><code>MEANLB.labels_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>labels</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"labels_equal method"},{"location":"api/labels/generators/#vectorbt.labels.generators.MEANLB.labels_stats","text":"<pre><code>MEANLB.labels_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>labels</code> as generic.</p>","title":"labels_stats method"},{"location":"api/labels/generators/#vectorbt.labels.generators.MEANLB.plot","text":"<pre><code>MEANLB.plot(\n    column=None,\n    **kwargs\n)\n</code></pre> <p>Plot <code>close</code> and overlay it with the heatmap of <code>labels</code>.</p> <p><code>**kwargs</code> are passed to GenericSRAccessor.overlay_with_heatmap().</p>","title":"plot method"},{"location":"api/labels/generators/#vectorbt.labels.generators.TRENDLB","text":"<pre><code>TRENDLB(\n    wrapper,\n    input_list,\n    input_mapper,\n    in_output_list,\n    output_list,\n    param_list,\n    mapper_list,\n    short_name,\n    level_names\n)\n</code></pre> <p>Label generator based on trend_labels_apply_nb().</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>IndicatorBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> <li><code>vectorbt.labels.generators.ParamIndexer</code></li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>IndicatorBase.config</li> <li>IndicatorBase.iloc</li> <li>IndicatorBase.in_output_names</li> <li>IndicatorBase.indexing_func()</li> <li>IndicatorBase.indexing_kwargs</li> <li>IndicatorBase.input_names</li> <li>IndicatorBase.level_names</li> <li>IndicatorBase.loc</li> <li>IndicatorBase.output_flags</li> <li>IndicatorBase.output_names</li> <li>IndicatorBase.param_names</li> <li>IndicatorBase.plots_defaults</li> <li>IndicatorBase.self_aliases</li> <li>IndicatorBase.short_name</li> <li>IndicatorBase.stats_defaults</li> <li>IndicatorBase.wrapper</li> <li>IndicatorBase.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li><code>vectorbt.labels.generators._TRENDLB</code></li> </ul>","title":"TRENDLB class"},{"location":"api/labels/generators/#vectorbt.labels.generators.TRENDLB.run","text":"<pre><code>TRENDLB.run(\n    close,\n    pos_th,\n    neg_th,\n    mode=Default(0),\n    short_name='trendlb',\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Run TRENDLB indicator.</p> <ul> <li>Inputs: <code>close</code></li> <li>Parameters: <code>pos_th</code>, <code>neg_th</code>, <code>mode</code></li> <li>Outputs: <code>labels</code></li> </ul> <p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels. Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p> <p>Other keyword arguments are passed to run_pipeline().</p>","title":"run class method"},{"location":"api/labels/generators/#vectorbt.labels.generators.TRENDLB.run_combs","text":"<pre><code>TRENDLB.run_combs(\n    close,\n    pos_th,\n    neg_th,\n    mode=Default(0),\n    r=2,\n    param_product=False,\n    comb_func=itertools.combinations,\n    run_unique=True,\n    short_names=None,\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Create a combination of multiple TRENDLB indicators using function <code>comb_func</code>.</p> <ul> <li>Inputs: <code>close</code></li> <li>Parameters: <code>pos_th</code>, <code>neg_th</code>, <code>mode</code></li> <li>Outputs: <code>labels</code></li> </ul> <p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.  Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>. Pass <code>r</code> to specify how many indicators to run.  Pass <code>short_names</code> to specify the short name for each indicator.  Set <code>run_unique</code> to True to first compute raw outputs for all parameters,  and then use them to build each indicator (faster).</p> <p>Other keyword arguments are passed to TRENDLB.run().</p>","title":"run_combs class method"},{"location":"api/labels/generators/#vectorbt.labels.generators.TRENDLB.close","text":"<p>Input array.</p>","title":"close variable"},{"location":"api/labels/generators/#vectorbt.labels.generators.TRENDLB.labels","text":"<p>Output array.</p>","title":"labels property"},{"location":"api/labels/generators/#vectorbt.labels.generators.TRENDLB.mode_list","text":"<p>List of <code>mode</code> values.</p>","title":"mode_list property"},{"location":"api/labels/generators/#vectorbt.labels.generators.TRENDLB.neg_th_list","text":"<p>List of <code>neg_th</code> values.</p>","title":"neg_th_list property"},{"location":"api/labels/generators/#vectorbt.labels.generators.TRENDLB.pos_th_list","text":"<p>List of <code>pos_th</code> values.</p>","title":"pos_th_list property"},{"location":"api/labels/generators/#vectorbt.labels.generators.TRENDLB.custom_func","text":"<pre><code>IndicatorFactory.from_apply_func.&lt;locals&gt;.custom_func(\n    input_list,\n    in_output_list,\n    param_list,\n    *args,\n    input_shape=None,\n    col=None,\n    flex_2d=None,\n    return_cache=False,\n    use_cache=None,\n    use_ray=False,\n    **_kwargs\n)\n</code></pre> <p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p>","title":"custom_func method"},{"location":"api/labels/generators/#vectorbt.labels.generators.TRENDLB.apply_func","text":"<pre><code>TRENDLB.apply_func(\n    close,\n    pos_th,\n    neg_th,\n    mode,\n    flex_2d=True\n)\n</code></pre> <p>Apply a trend labeling function based on <code>TrendMode</code>.</p>","title":"apply_func method"},{"location":"api/labels/generators/#vectorbt.labels.generators.TRENDLB.close_above","text":"<pre><code>TRENDLB.close_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.TRENDLB.close_below","text":"<pre><code>TRENDLB.close_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.TRENDLB.close_crossed_above","text":"<pre><code>TRENDLB.close_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.TRENDLB.close_crossed_below","text":"<pre><code>TRENDLB.close_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.TRENDLB.close_equal","text":"<pre><code>TRENDLB.close_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_equal method"},{"location":"api/labels/generators/#vectorbt.labels.generators.TRENDLB.close_stats","text":"<pre><code>TRENDLB.close_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>close</code> as generic.</p>","title":"close_stats method"},{"location":"api/labels/generators/#vectorbt.labels.generators.TRENDLB.labels_above","text":"<pre><code>TRENDLB.labels_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>labels</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"labels_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.TRENDLB.labels_below","text":"<pre><code>TRENDLB.labels_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>labels</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"labels_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.TRENDLB.labels_crossed_above","text":"<pre><code>TRENDLB.labels_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>labels</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"labels_crossed_above method"},{"location":"api/labels/generators/#vectorbt.labels.generators.TRENDLB.labels_crossed_below","text":"<pre><code>TRENDLB.labels_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>labels</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"labels_crossed_below method"},{"location":"api/labels/generators/#vectorbt.labels.generators.TRENDLB.labels_equal","text":"<pre><code>TRENDLB.labels_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>labels</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"labels_equal method"},{"location":"api/labels/generators/#vectorbt.labels.generators.TRENDLB.labels_stats","text":"<pre><code>TRENDLB.labels_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>labels</code> as generic.</p>","title":"labels_stats method"},{"location":"api/labels/generators/#vectorbt.labels.generators.TRENDLB.plot","text":"<pre><code>TRENDLB.plot(\n    column=None,\n    **kwargs\n)\n</code></pre> <p>Plot <code>close</code> and overlay it with the heatmap of <code>labels</code>.</p> <p><code>**kwargs</code> are passed to GenericSRAccessor.overlay_with_heatmap().</p>","title":"plot method"},{"location":"api/labels/nb/","text":"<p>Numba-compiled functions.</p> <p>Provides an arsenal of Numba-compiled functions that are used by indicator classes. These only accept NumPy arrays and other Numba-compatible types.</p>  <p>Note</p> <p>Set <code>wait</code> to 1 to exclude the current value from calculation of future values.</p>   <p>Warning</p> <p>Do not attempt to use these functions for building features as they may introduce look-ahead bias to your model.</p>","title":"nb"},{"location":"api/labels/nb/#vectorbt.labels.nb.bn_cont_sat_trend_labels_nb","text":"<pre><code>bn_cont_sat_trend_labels_nb(\n    close,\n    local_extrema,\n    pos_th,\n    neg_th,\n    flex_2d=True\n)\n</code></pre> <p>Similar to bn_cont_trend_labels_nb() but sets each close value to 0 or 1 if the percentage change to the next extremum exceeds the threshold set for this range.</p>","title":"bn_cont_sat_trend_labels_nb function"},{"location":"api/labels/nb/#vectorbt.labels.nb.bn_cont_trend_labels_nb","text":"<pre><code>bn_cont_trend_labels_nb(\n    close,\n    local_extrema\n)\n</code></pre> <p>Normalize each range between two extrema between 0 (will go up) and 1 (will go down).</p>","title":"bn_cont_trend_labels_nb function"},{"location":"api/labels/nb/#vectorbt.labels.nb.bn_trend_labels_nb","text":"<pre><code>bn_trend_labels_nb(\n    close,\n    local_extrema\n)\n</code></pre> <p>Return 0 for H-L and 1 for L-H.</p>","title":"bn_trend_labels_nb function"},{"location":"api/labels/nb/#vectorbt.labels.nb.breakout_labels_nb","text":"<pre><code>breakout_labels_nb(\n    close,\n    window,\n    pos_th,\n    neg_th,\n    wait=1,\n    flex_2d=True\n)\n</code></pre> <p>For each value, return 1 if any value in the next period is greater than the positive threshold (in %), -1 if less than the negative threshold, and 0 otherwise.</p> <p>First hit wins.</p>","title":"breakout_labels_nb function"},{"location":"api/labels/nb/#vectorbt.labels.nb.fixed_labels_apply_nb","text":"<pre><code>fixed_labels_apply_nb(\n    close,\n    n\n)\n</code></pre> <p>Get percentage change from the current value to a future value.</p>","title":"fixed_labels_apply_nb function"},{"location":"api/labels/nb/#vectorbt.labels.nb.future_max_apply_nb","text":"<pre><code>future_max_apply_nb(\n    close,\n    window,\n    wait=1\n)\n</code></pre> <p>Get the maximum of the next period.</p>","title":"future_max_apply_nb function"},{"location":"api/labels/nb/#vectorbt.labels.nb.future_mean_apply_nb","text":"<pre><code>future_mean_apply_nb(\n    close,\n    window,\n    ewm,\n    wait=1,\n    adjust=False\n)\n</code></pre> <p>Get the mean of the next period.</p>","title":"future_mean_apply_nb function"},{"location":"api/labels/nb/#vectorbt.labels.nb.future_min_apply_nb","text":"<pre><code>future_min_apply_nb(\n    close,\n    window,\n    wait=1\n)\n</code></pre> <p>Get the minimum of the next period.</p>","title":"future_min_apply_nb function"},{"location":"api/labels/nb/#vectorbt.labels.nb.future_std_apply_nb","text":"<pre><code>future_std_apply_nb(\n    close,\n    window,\n    ewm,\n    wait=1,\n    adjust=False,\n    ddof=0\n)\n</code></pre> <p>Get the standard deviation of the next period.</p>","title":"future_std_apply_nb function"},{"location":"api/labels/nb/#vectorbt.labels.nb.get_symmetric_neg_th_nb","text":"<pre><code>get_symmetric_neg_th_nb(\n    pos_th\n)\n</code></pre> <p>Compute the negative return that is symmetric to a positive one.</p>","title":"get_symmetric_neg_th_nb function"},{"location":"api/labels/nb/#vectorbt.labels.nb.get_symmetric_pos_th_nb","text":"<pre><code>get_symmetric_pos_th_nb(\n    neg_th\n)\n</code></pre> <p>Compute the positive return that is symmetric to a negative one.</p> <p>For example, 50% down requires 100% to go up to the initial level.</p>","title":"get_symmetric_pos_th_nb function"},{"location":"api/labels/nb/#vectorbt.labels.nb.local_extrema_apply_nb","text":"<pre><code>local_extrema_apply_nb(\n    close,\n    pos_th,\n    neg_th,\n    flex_2d=True\n)\n</code></pre> <p>Get array of local extrema denoted by 1 (peak) or -1 (trough), otherwise 0.</p> <p>Two adjacent peak and trough points should exceed the given threshold parameters.</p> <p>If any threshold is given element-wise, it will be applied per new/updated extremum.</p> <p>Inspired by https://www.mdpi.com/1099-4300/22/10/1162/pdf</p>","title":"local_extrema_apply_nb function"},{"location":"api/labels/nb/#vectorbt.labels.nb.mean_labels_apply_nb","text":"<pre><code>mean_labels_apply_nb(\n    close,\n    window,\n    ewm,\n    wait=1,\n    adjust=False\n)\n</code></pre> <p>Get the percentage change from the current value to the average of the next period.</p>","title":"mean_labels_apply_nb function"},{"location":"api/labels/nb/#vectorbt.labels.nb.pct_trend_labels_nb","text":"<pre><code>pct_trend_labels_nb(\n    close,\n    local_extrema,\n    normalize\n)\n</code></pre> <p>Compute the percentage change of the current value to the next extremum.</p>","title":"pct_trend_labels_nb function"},{"location":"api/labels/nb/#vectorbt.labels.nb.trend_labels_apply_nb","text":"<pre><code>trend_labels_apply_nb(\n    close,\n    pos_th,\n    neg_th,\n    mode,\n    flex_2d=True\n)\n</code></pre> <p>Apply a trend labeling function based on <code>TrendMode</code>.</p>","title":"trend_labels_apply_nb function"},{"location":"api/messaging/","text":"<p>Modules for messaging.</p>","title":"messaging"},{"location":"api/messaging/#sub-modules","text":"<ul> <li>vectorbt.messaging.telegram</li> </ul>","title":"Sub-modules"},{"location":"api/messaging/telegram/","text":"<p>Messaging using <code>python-telegram-bot</code>.</p>","title":"telegram"},{"location":"api/messaging/telegram/#vectorbt.messaging.telegram.self_decorator","text":"<pre><code>self_decorator(\n    func\n)\n</code></pre> <p>Pass bot object to func command.</p>","title":"self_decorator function"},{"location":"api/messaging/telegram/#vectorbt.messaging.telegram.send_action","text":"<pre><code>send_action(\n    action\n)\n</code></pre> <p>Sends <code>action</code> while processing func command.</p> <p>Suitable only for bound callbacks taking arguments <code>self</code>, <code>update</code>, <code>context</code> and optionally other.</p>","title":"send_action function"},{"location":"api/messaging/telegram/#vectorbt.messaging.telegram.LogHandler","text":"<pre><code>LogHandler(\n    callback,\n    pass_update_queue=False,\n    pass_job_queue=False,\n    pass_user_data=False,\n    pass_chat_data=False,\n    run_async=False\n)\n</code></pre> <p>Handler to log user updates.</p> <p>Superclasses</p> <ul> <li><code>abc.ABC</code></li> <li><code>telegram.ext.handler.Handler</code></li> <li><code>typing.Generic</code></li> </ul>","title":"LogHandler class"},{"location":"api/messaging/telegram/#vectorbt.messaging.telegram.LogHandler.check_update","text":"<pre><code>LogHandler.check_update(\n    update\n)\n</code></pre> <p>This method is called to determine if an update should be handled by this handler instance. It should always be overridden.</p> <p>Note</p> <p>Custom updates types can be handled by the dispatcher. Therefore, an implementation of this method should always check the type of :attr:<code>update</code>.</p> <p>Args</p> <p>update (:obj:<code>str</code> | :class:<code>telegram.Update</code>): The update to be tested. Returns</p> <p>Either :obj:<code>None</code> or :obj:<code>False</code> if the update should not be handled. Otherwise an object that will be passed to :meth:<code>handle_update</code> and :meth:<code>collect_additional_context</code> when the update gets handled.</p>","title":"check_update method"},{"location":"api/messaging/telegram/#vectorbt.messaging.telegram.TelegramBot","text":"<pre><code>TelegramBot(\n    giphy_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Telegram bot.</p> <p>See Extensions \u2013 Your first Bot.</p> <p><code>**kwargs</code> are passed to <code>telegram.ext.updater.Updater</code> and override settings under <code>messaging.telegram</code> in settings.</p> <p>Usage</p> <ul> <li>Let's extend TelegramBot to track cryptocurrency prices:</li> </ul> <pre><code>&gt;&gt;&gt; from telegram.ext import CommandHandler\n&gt;&gt;&gt; import ccxt\n&gt;&gt;&gt; import logging\n&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; logging.basicConfig(level=logging.INFO)  # enable logging\n\n&gt;&gt;&gt; class MyTelegramBot(vbt.TelegramBot):\n...     @property\n...     def custom_handlers(self):\n...         return (CommandHandler('get', self.get),)\n...\n...     @property\n...     def help_message(self):\n...         return \"Type /get [symbol] [exchange id (optional)] to get the latest price.\"\n...\n...     def get(self, update, context):\n...         chat_id = update.effective_chat.id\n...\n...         if len(context.args) == 1:\n...             symbol = context.args[0]\n...             exchange = 'binance'\n...         elif len(context.args) == 2:\n...             symbol = context.args[0]\n...             exchange = context.args[1]\n...         else:\n...             self.send_message(chat_id, \"This command requires symbol and optionally exchange id.\")\n...             return\n...         try:\n...             ticker = getattr(ccxt, exchange)().fetchTicker(symbol)\n...         except Exception as e:\n...             self.send_message(chat_id, str(e))\n...             return\n...         self.send_message(chat_id, str(ticker['last']))\n\n&gt;&gt;&gt; bot = MyTelegramBot(token='YOUR_TOKEN')\n&gt;&gt;&gt; bot.start()\nINFO:vectorbt.utils.messaging:Initializing bot\nINFO:vectorbt.utils.messaging:Loaded chat ids [447924619]\nINFO:vectorbt.utils.messaging:Running bot vectorbt_bot\nINFO:apscheduler.scheduler:Scheduler started\nINFO:vectorbt.utils.messaging:447924619 - Bot: \"I'm back online!\"\nINFO:vectorbt.utils.messaging:447924619 - User: \"/start\"\nINFO:vectorbt.utils.messaging:447924619 - Bot: \"Hello!\"\nINFO:vectorbt.utils.messaging:447924619 - User: \"/help\"\nINFO:vectorbt.utils.messaging:447924619 - Bot: \"Type /get [symbol] [exchange id (optional)] to get the latest price.\"\nINFO:vectorbt.utils.messaging:447924619 - User: \"/get BTC/USDT\"\nINFO:vectorbt.utils.messaging:447924619 - Bot: \"55530.55\"\nINFO:vectorbt.utils.messaging:447924619 - User: \"/get BTC/USD bitmex\"\nINFO:vectorbt.utils.messaging:447924619 - Bot: \"55509.0\"\nINFO:telegram.ext.updater:Received signal 2 (SIGINT), stopping...\nINFO:apscheduler.scheduler:Scheduler has been shut down\n</code></pre> <p>Superclasses</p> <ul> <li>Configured</li> <li>Documented</li> <li>Pickleable</li> </ul> <p>Inherited members</p> <ul> <li>Configured.config</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>Configured.writeable_attrs</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> </ul>","title":"TelegramBot class"},{"location":"api/messaging/telegram/#vectorbt.messaging.telegram.TelegramBot.chat_ids","text":"<p>Chat ids that ever interacted with this bot.</p> <p>A chat id is added upon receiving the \"/start\" command.</p>","title":"chat_ids property"},{"location":"api/messaging/telegram/#vectorbt.messaging.telegram.TelegramBot.custom_handlers","text":"<p>Custom handlers to add.</p> <p>Override to add custom handlers. Order counts.</p>","title":"custom_handlers property"},{"location":"api/messaging/telegram/#vectorbt.messaging.telegram.TelegramBot.dispatcher","text":"<p>Dispatcher.</p>","title":"dispatcher property"},{"location":"api/messaging/telegram/#vectorbt.messaging.telegram.TelegramBot.help_message","text":"<p>Message to be sent upon \"/help\" command.</p> <p>Override to define your own message.</p>","title":"help_message property"},{"location":"api/messaging/telegram/#vectorbt.messaging.telegram.TelegramBot.log_handler","text":"<p>Log handler.</p>","title":"log_handler property"},{"location":"api/messaging/telegram/#vectorbt.messaging.telegram.TelegramBot.running","text":"<p>Whether the bot is running.</p>","title":"running property"},{"location":"api/messaging/telegram/#vectorbt.messaging.telegram.TelegramBot.start_message","text":"<p>Message to be sent upon \"/start\" command.</p> <p>Override to define your own message.</p>","title":"start_message property"},{"location":"api/messaging/telegram/#vectorbt.messaging.telegram.TelegramBot.updater","text":"<p>Updater.</p>","title":"updater property"},{"location":"api/messaging/telegram/#vectorbt.messaging.telegram.TelegramBot.chat_migration_callback","text":"<pre><code>TelegramBot.chat_migration_callback(\n    update,\n    context\n)\n</code></pre> <p>Chat migration callback.</p>","title":"chat_migration_callback method"},{"location":"api/messaging/telegram/#vectorbt.messaging.telegram.TelegramBot.error_callback","text":"<pre><code>TelegramBot.error_callback(\n    update,\n    context,\n    *args\n)\n</code></pre> <p>Error callback.</p>","title":"error_callback method"},{"location":"api/messaging/telegram/#vectorbt.messaging.telegram.TelegramBot.help_callback","text":"<pre><code>TelegramBot.help_callback(\n    update,\n    context\n)\n</code></pre> <p>Help command callback.</p>","title":"help_callback method"},{"location":"api/messaging/telegram/#vectorbt.messaging.telegram.TelegramBot.send","text":"<pre><code>TelegramBot.send(\n    kind,\n    chat_id,\n    *args,\n    log_msg=None,\n    **kwargs\n)\n</code></pre> <p>Send message of any kind to <code>chat_id</code>.</p>","title":"send method"},{"location":"api/messaging/telegram/#vectorbt.messaging.telegram.TelegramBot.send_giphy","text":"<pre><code>TelegramBot.send_giphy(\n    chat_id,\n    text,\n    *args,\n    giphy_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Send GIPHY from text to <code>chat_id</code>.</p>","title":"send_giphy method"},{"location":"api/messaging/telegram/#vectorbt.messaging.telegram.TelegramBot.send_giphy_to_all","text":"<pre><code>TelegramBot.send_giphy_to_all(\n    text,\n    *args,\n    giphy_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Send GIPHY from text to all in TelegramBot.chat_ids.</p>","title":"send_giphy_to_all method"},{"location":"api/messaging/telegram/#vectorbt.messaging.telegram.TelegramBot.send_message","text":"<pre><code>TelegramBot.send_message(\n    chat_id,\n    text,\n    *args,\n    **kwargs\n)\n</code></pre> <p>Send text message to <code>chat_id</code>.</p>","title":"send_message method"},{"location":"api/messaging/telegram/#vectorbt.messaging.telegram.TelegramBot.send_message_to_all","text":"<pre><code>TelegramBot.send_message_to_all(\n    text,\n    *args,\n    **kwargs\n)\n</code></pre> <p>Send text message to all in TelegramBot.chat_ids.</p>","title":"send_message_to_all method"},{"location":"api/messaging/telegram/#vectorbt.messaging.telegram.TelegramBot.send_to_all","text":"<pre><code>TelegramBot.send_to_all(\n    kind,\n    *args,\n    **kwargs\n)\n</code></pre> <p>Send message of any kind to all in TelegramBot.chat_ids.</p>","title":"send_to_all method"},{"location":"api/messaging/telegram/#vectorbt.messaging.telegram.TelegramBot.start","text":"<pre><code>TelegramBot.start(\n    in_background=False,\n    **kwargs\n)\n</code></pre> <p>Start the bot.</p> <p><code>**kwargs</code> are passed to <code>telegram.ext.updater.Updater.start_polling</code> and override settings under <code>messaging.telegram</code> in settings.</p>","title":"start method"},{"location":"api/messaging/telegram/#vectorbt.messaging.telegram.TelegramBot.start_callback","text":"<pre><code>TelegramBot.start_callback(\n    update,\n    context\n)\n</code></pre> <p>Start command callback.</p>","title":"start_callback method"},{"location":"api/messaging/telegram/#vectorbt.messaging.telegram.TelegramBot.started_callback","text":"<pre><code>TelegramBot.started_callback()\n</code></pre> <p>Callback once the bot has been started.</p> <p>Override to execute custom commands upon starting the bot.</p>","title":"started_callback method"},{"location":"api/messaging/telegram/#vectorbt.messaging.telegram.TelegramBot.stop","text":"<pre><code>TelegramBot.stop()\n</code></pre> <p>Stop the bot.</p>","title":"stop method"},{"location":"api/messaging/telegram/#vectorbt.messaging.telegram.TelegramBot.unknown_callback","text":"<pre><code>TelegramBot.unknown_callback(\n    update,\n    context\n)\n</code></pre> <p>Unknown command callback.</p>","title":"unknown_callback method"},{"location":"api/portfolio/","text":"<p>Modules for working with portfolios.</p>","title":"portfolio"},{"location":"api/portfolio/#sub-modules","text":"<ul> <li>vectorbt.portfolio.base</li> <li>vectorbt.portfolio.decorators</li> <li>vectorbt.portfolio.enums</li> <li>vectorbt.portfolio.logs</li> <li>vectorbt.portfolio.nb</li> <li>vectorbt.portfolio.orders</li> <li>vectorbt.portfolio.trades</li> </ul>","title":"Sub-modules"},{"location":"api/portfolio/base/","text":"<p>Base class for modeling portfolio and measuring its performance.</p> <p>Provides the class Portfolio for modeling portfolio performance and calculating various risk and performance metrics. It uses Numba-compiled functions from vectorbt.portfolio.nb for most computations and record classes based on Records for evaluating events such as orders, logs, trades, positions, and drawdowns.</p> <p>The job of the Portfolio class is to create a series of positions allocated  against a cash component, produce an equity curve, incorporate basic transaction costs and produce a set of statistics about its performance. In particular, it outputs position/profit metrics and drawdown information.</p> <p>Run for the examples below:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import talib\n&gt;&gt;&gt; from numba import njit\n\n&gt;&gt;&gt; import vectorbt as vbt\n&gt;&gt;&gt; from vectorbt.utils.colors import adjust_opacity\n&gt;&gt;&gt; from vectorbt.utils.enum import map_enum_fields\n&gt;&gt;&gt; from vectorbt.base.reshape_fns import broadcast, flex_select_auto_nb, to_2d_array\n&gt;&gt;&gt; from vectorbt.portfolio.enums import SizeType, Direction, NoOrder, OrderStatus, OrderSide\n&gt;&gt;&gt; from vectorbt.portfolio import nb\n</code></pre>","title":"base"},{"location":"api/portfolio/base/#workflow","text":"<p>Portfolio class does quite a few things to simulate your strategy.</p> <p>Preparation phase (in the particular class method):</p> <ul> <li>Receives a set of inputs, such as signal arrays and other parameters</li> <li>Resolves parameter defaults by searching for them in the global settings</li> <li>Brings input arrays to a single shape</li> <li>Does some basic validation of inputs and converts Pandas objects to NumPy arrays</li> <li>Passes everything to a Numba-compiled simulation function</li> </ul> <p>Simulation phase (in the particular simulation function using Numba):</p> <ul> <li>The simulation function traverses the broadcasted shape element by element, row by row (time dimension),     column by column (asset dimension)</li> <li>For each asset and timestamp (= element):<ul> <li>Gets all available information related to this element and executes the logic</li> <li>Generates an order or skips the element altogether</li> <li>If an order has been issued, processes the order and fills/ignores/rejects it</li> <li>If the order has been filled, registers the result by appending it to the order records</li> <li>Updates the current state such as the cash and asset balances</li> </ul> </li> </ul> <p>Construction phase (in the particular class method):</p> <ul> <li>Receives the returned order records and initializes a new Portfolio object</li> </ul> <p>Analysis phase (in the Portfolio object)</p> <ul> <li>Offers a broad range of risk &amp; performance metrics based on order records</li> </ul>","title":"Workflow"},{"location":"api/portfolio/base/#simulation-modes","text":"<p>There are three main simulation modes.</p>","title":"Simulation modes"},{"location":"api/portfolio/base/#from-orders","text":"<p>Portfolio.from_orders() is the most straightforward and the fastest out of all simulation modes.</p> <p>An order is a simple instruction that contains size, price, fees, and other information (see Order for details about what information a typical order requires). Instead of creating a Order tuple for each asset and timestamp (which may waste a lot of memory) and appending it to a (potentially huge) list for processing, Portfolio.from_orders() takes each of those information pieces as an array, broadcasts them against each other, and creates a Order tuple out of each element for us.</p> <p>Thanks to broadcasting, we can pass any of the information as a 2-dim array, as a 1-dim array per column or row, and as a constant. And we don't even need to provide every piece of information - vectorbt fills the missing data with default constants, without wasting memory.</p> <p>Here's an example:</p> <pre><code>&gt;&gt;&gt; size = pd.Series([1, -1, 1, -1])  # per row\n&gt;&gt;&gt; price = pd.DataFrame({'a': [1, 2, 3, 4], 'b': [4, 3, 2, 1]})  # per element\n&gt;&gt;&gt; direction = ['longonly', 'shortonly']  # per column\n&gt;&gt;&gt; fees = 0.01  # per frame\n\n&gt;&gt;&gt; pf = vbt.Portfolio.from_orders(price, size, direction=direction, fees=fees)\n&gt;&gt;&gt; pf.orders.records_readable\n   Order Id Column  Timestamp  Size  Price  Fees  Side\n0         0      a          0   1.0    1.0  0.01   Buy\n1         1      a          1   1.0    2.0  0.02  Sell\n2         2      a          2   1.0    3.0  0.03   Buy\n3         3      a          3   1.0    4.0  0.04  Sell\n4         4      b          0   1.0    4.0  0.04  Sell\n5         5      b          1   1.0    3.0  0.03   Buy\n6         6      b          2   1.0    2.0  0.02  Sell\n7         7      b          3   1.0    1.0  0.01   Buy\n</code></pre> <p>This method is particularly useful in situations where you don't need any further logic apart from filling orders at predefined timestamps. If you want to issue orders depending upon the previous performance, the current state, or other custom conditions, head over to Portfolio.from_signals() or Portfolio.from_order_func().</p>","title":"From orders"},{"location":"api/portfolio/base/#from-signals","text":"<p>Portfolio.from_signals() is centered around signals. It adds an abstraction layer on top of Portfolio.from_orders() to automate some signaling processes. For example, by default, it won't let us execute another entry signal if we are already in the position. It also implements stop loss and take profit orders for exiting positions. Nevertheless, this method behaves similarly to Portfolio.from_orders() and accepts most of its arguments; in fact, by setting <code>accumulate=True</code>, it behaves quite similarly to Portfolio.from_orders().</p> <p>Let's replicate the example above using signals:</p> <pre><code>&gt;&gt;&gt; entries = pd.Series([True, False, True, False])\n&gt;&gt;&gt; exits = pd.Series([False, True, False, True])\n\n&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(price, entries, exits, size=1, direction=direction, fees=fees)\n&gt;&gt;&gt; pf.orders.records_readable\n   Order Id Column  Timestamp  Size  Price  Fees  Side\n0         0      a          0   1.0    1.0  0.01   Buy\n1         1      a          1   1.0    2.0  0.02  Sell\n2         2      a          2   1.0    3.0  0.03   Buy\n3         3      a          3   1.0    4.0  0.04  Sell\n4         4      b          0   1.0    4.0  0.04  Sell\n5         5      b          1   1.0    3.0  0.03   Buy\n6         6      b          2   1.0    2.0  0.02  Sell\n7         7      b          3   1.0    1.0  0.01   Buy\n</code></pre> <p>In a nutshell: this method automates some procedures that otherwise would be only possible by using Portfolio.from_order_func() while following the same broadcasting principles as Portfolio.from_orders() - the best of both worlds, given you can express your strategy as a sequence of signals. But as soon as your strategy requires any signal to depend upon more complex conditions or to generate multiple orders at once, it's best to run your custom signaling logic using Portfolio.from_order_func().</p>","title":"From signals"},{"location":"api/portfolio/base/#from-order-function","text":"<p>Portfolio.from_order_func() is the most powerful form of simulation. Instead of pulling information from predefined arrays, it lets us define an arbitrary logic through callbacks. There are multiple kinds of callbacks, each called at some point while the simulation function traverses the shape. For example, apart from the main callback that returns an order (<code>order_func_nb</code>), there is a callback that does preprocessing on the entire group of columns at once. For more details on the general procedure and the callback zoo, see simulate_nb().</p> <p>Let's replicate our example using an order function:</p> <pre><code>&gt;&gt;&gt; @njit\n&gt;&gt;&gt; def order_func_nb(c, size, direction, fees):\n...     return nb.order_nb(\n...         price=c.close[c.i, c.col],\n...         size=size[c.i],\n...         direction=direction[c.col],\n...         fees=fees\n... )\n\n&gt;&gt;&gt; direction_num = map_enum_fields(direction, Direction)\n&gt;&gt;&gt; pf = vbt.Portfolio.from_order_func(\n...     price,\n...     order_func_nb,\n...     np.asarray(size), np.asarray(direction_num), fees\n... )\n&gt;&gt;&gt; pf.orders.records_readable\n   Order Id Column  Timestamp  Size  Price  Fees  Side\n0         0      a          0   1.0    1.0  0.01   Buy\n1         1      a          1   1.0    2.0  0.02  Sell\n2         2      a          2   1.0    3.0  0.03   Buy\n3         3      a          3   1.0    4.0  0.04  Sell\n4         4      b          0   1.0    4.0  0.04  Sell\n5         5      b          1   1.0    3.0  0.03   Buy\n6         6      b          2   1.0    2.0  0.02  Sell\n7         7      b          3   1.0    1.0  0.01   Buy\n</code></pre> <p>There is an even more flexible version available - flex_simulate_nb() (activated by passing <code>flexible=True</code> to Portfolio.from_order_func()) - that allows creating multiple orders per symbol and bar.</p> <p>This method has many advantages:</p> <ul> <li>Realistic simulation as it follows the event-driven approach - less risk of exposure to the look-ahead bias</li> <li>Provides a lot of useful information during the runtime, such as the current position's PnL</li> <li>Enables putting all logic including custom indicators into a single place, and running it as the data  comes in, in a memory-friendly manner</li> </ul> <p>But there are drawbacks too:</p> <ul> <li>Doesn't broadcast arrays - needs to be done by the user prior to the execution</li> <li>Requires at least a basic knowledge of NumPy and Numba</li> <li>Requires at least an intermediate knowledge of both to optimize for efficiency</li> </ul>","title":"From order function"},{"location":"api/portfolio/base/#example","text":"<p>To showcase the features of Portfolio, run the following example: it checks candlestick data of 6 major cryptocurrencies in 2020 against every single pattern found in TA-Lib, and translates them into orders.</p> <pre><code>&gt;&gt;&gt; # Fetch price history\n&gt;&gt;&gt; symbols = ['BTC-USD', 'ETH-USD', 'XRP-USD', 'BNB-USD', 'BCH-USD', 'LTC-USD']\n&gt;&gt;&gt; start = '2020-01-01 UTC'  # crypto is UTC\n&gt;&gt;&gt; end = '2020-09-01 UTC'\n&gt;&gt;&gt; # OHLCV by column\n&gt;&gt;&gt; ohlcv = vbt.YFData.download(symbols, start=start, end=end).concat()\n&gt;&gt;&gt; ohlcv['Open']\n\nsymbol                          BTC-USD     ETH-USD   XRP-USD    BNB-USD  \\\nDate\n2020-01-01 00:00:00+00:00   7194.892090  129.630661  0.192912  13.730962\n2020-01-02 00:00:00+00:00   7202.551270  130.820038  0.192708  13.698126\n2020-01-03 00:00:00+00:00   6984.428711  127.411263  0.187948  13.035329\n...                                 ...         ...       ...        ...\n2020-08-30 00:00:00+00:00  11508.713867  399.616699  0.274568  23.009060\n2020-08-31 00:00:00+00:00  11713.306641  428.509003  0.283065  23.647858\n2020-09-01 00:00:00+00:00  11679.316406  434.874451  0.281612  23.185047\n\nsymbol                        BCH-USD    LTC-USD\nDate\n2020-01-01 00:00:00+00:00  204.671295  41.326534\n2020-01-02 00:00:00+00:00  204.354538  42.018085\n2020-01-03 00:00:00+00:00  196.007690  39.863129\n...                               ...        ...\n2020-08-30 00:00:00+00:00  268.842865  57.207737\n2020-08-31 00:00:00+00:00  279.280426  62.844059\n2020-09-01 00:00:00+00:00  274.480865  61.105076\n\n[244 rows x 6 columns]\n\n&gt;&gt;&gt; # Run every single pattern recognition indicator and combine the results\n&gt;&gt;&gt; result = pd.DataFrame.vbt.empty_like(ohlcv['Open'], fill_value=0.)\n&gt;&gt;&gt; for pattern in talib.get_function_groups()['Pattern Recognition']:\n...     PRecognizer = vbt.IndicatorFactory.from_talib(pattern)\n...     pr = PRecognizer.run(ohlcv['Open'], ohlcv['High'], ohlcv['Low'], ohlcv['Close'])\n...     result = result + pr.integer\n\n&gt;&gt;&gt; # Don't look into the future\n&gt;&gt;&gt; result = result.vbt.fshift(1)\n\n&gt;&gt;&gt; # Treat each number as order value in USD\n&gt;&gt;&gt; size = result / ohlcv['Open']\n\n&gt;&gt;&gt; # Simulate portfolio\n&gt;&gt;&gt; pf = vbt.Portfolio.from_orders(\n...     ohlcv['Close'], size, price=ohlcv['Open'],\n...     init_cash='autoalign', fees=0.001, slippage=0.001)\n\n&gt;&gt;&gt; # Visualize portfolio value\n&gt;&gt;&gt; pf.value().vbt.plot()\n</code></pre> <p></p>","title":"Example"},{"location":"api/portfolio/base/#broadcasting","text":"<p>Portfolio is very flexible towards inputs:</p> <ul> <li>Accepts both Series and DataFrames as inputs</li> <li>Broadcasts inputs to the same shape using vectorbt's own broadcasting rules</li> <li>Many inputs (such as <code>fees</code>) can be passed as a single value, value per column/row, or as a matrix</li> <li>Implements flexible indexing wherever possible to save memory</li> </ul>","title":"Broadcasting"},{"location":"api/portfolio/base/#flexible-indexing","text":"<p>Instead of expensive broadcasting, most methods keep the original shape and do indexing in a smart way. A nice feature of this is that it has almost no memory footprint and can broadcast in any direction indefinitely.</p> <p>For example, let's broadcast three inputs and select the last element using both approaches:</p> <pre><code>&gt;&gt;&gt; # Classic way\n&gt;&gt;&gt; a = np.array([1, 2, 3])\n&gt;&gt;&gt; b = np.array([[4], [5], [6]])\n&gt;&gt;&gt; c = np.array(10)\n&gt;&gt;&gt; a_, b_, c_ = broadcast(a, b, c)\n\n&gt;&gt;&gt; a_\narray([[1, 2, 3],\n       [1, 2, 3],\n       [1, 2, 3]])\n&gt;&gt;&gt; a_[2, 2]\n3\n\n&gt;&gt;&gt; b_\narray([[4, 4, 4],\n       [5, 5, 5],\n       [6, 6, 6]])\n&gt;&gt;&gt; b_[2, 2]\n6\n\n&gt;&gt;&gt; c_\narray([[10, 10, 10],\n       [10, 10, 10],\n       [10, 10, 10]])\n&gt;&gt;&gt; c_[2, 2]\n10\n\n&gt;&gt;&gt; # Flexible indexing being done during simulation\n&gt;&gt;&gt; flex_select_auto_nb(a, 2, 2)\n3\n&gt;&gt;&gt; flex_select_auto_nb(b, 2, 2)\n6\n&gt;&gt;&gt; flex_select_auto_nb(c, 2, 2)\n10\n</code></pre>","title":"Flexible indexing"},{"location":"api/portfolio/base/#defaults","text":"<p>If you look at the arguments of each class method, you will notice that most of them default to None. None has a special meaning in vectorbt: it's a command to pull the default value from the global settings config - settings. The branch for the Portfolio can be found under the key 'portfolio'. For example, the default size used in Portfolio.from_signals() and Portfolio.from_orders() is <code>np.inf</code>:</p> <pre><code>&gt;&gt;&gt; vbt.settings.portfolio['size']\ninf\n</code></pre>","title":"Defaults"},{"location":"api/portfolio/base/#grouping","text":"<p>One of the key features of Portfolio is the ability to group columns. Groups can be specified by <code>group_by</code>, which can be anything from positions or names of column levels, to a NumPy array with actual groups. Groups can be formed to share capital between columns (make sure to pass <code>cash_sharing=True</code>) or to compute metrics for a combined portfolio of multiple independent columns.</p> <p>For example, let's divide our portfolio into two groups sharing the same cash balance:</p> <pre><code>&gt;&gt;&gt; # Simulate combined portfolio\n&gt;&gt;&gt; group_by = pd.Index([\n...     'first', 'first', 'first',\n...     'second', 'second', 'second'\n... ], name='group')\n&gt;&gt;&gt; comb_pf = vbt.Portfolio.from_orders(\n...     ohlcv['Close'], size, price=ohlcv['Open'],\n...     init_cash='autoalign', fees=0.001, slippage=0.001,\n...     group_by=group_by, cash_sharing=True)\n\n&gt;&gt;&gt; # Get total profit per group\n&gt;&gt;&gt; comb_pf.total_profit()\ngroup\nfirst     26221.571200\nsecond    10141.952674\nName: total_profit, dtype: float64\n</code></pre> <p>Not only can we analyze each group, but also each column in the group:</p> <pre><code>&gt;&gt;&gt; # Get total profit per column\n&gt;&gt;&gt; comb_pf.total_profit(group_by=False)\nsymbol\nBTC-USD     5792.120252\nETH-USD    16380.039692\nXRP-USD     4049.411256\nBNB-USD     6081.253551\nBCH-USD      400.573418\nLTC-USD     3660.125705\nName: total_profit, dtype: float64\n</code></pre> <p>In the same way, we can introduce new grouping to the method itself:</p> <pre><code>&gt;&gt;&gt; # Get total profit per group\n&gt;&gt;&gt; pf.total_profit(group_by=group_by)\ngroup\nfirst     26221.571200\nsecond    10141.952674\nName: total_profit, dtype: float64\n</code></pre>  <p>Note</p> <p>If cash sharing is enabled, grouping can be disabled but cannot be modified.</p>","title":"Grouping"},{"location":"api/portfolio/base/#indexing","text":"<p>Like any other class subclassing Wrapping, we can do pandas indexing on a Portfolio instance, which forwards indexing operation to each object with columns:</p> <pre><code>&gt;&gt;&gt; pf['BTC-USD']\n&lt;vectorbt.portfolio.base.Portfolio at 0x7fac7517ac88&gt;\n\n&gt;&gt;&gt; pf['BTC-USD'].total_profit()\n5792.120252189081\n</code></pre> <p>Combined portfolio is indexed by group:</p> <pre><code>&gt;&gt;&gt; comb_pf['first']\n&lt;vectorbt.portfolio.base.Portfolio at 0x7fac5756b828&gt;\n\n&gt;&gt;&gt; comb_pf['first'].total_profit()\n26221.57120014546\n</code></pre>  <p>Note</p> <p>Changing index (time axis) is not supported. The object should be treated as a Series rather than a DataFrame; for example, use <code>pf.iloc[0]</code> instead of <code>pf.iloc[:, 0]</code>.</p> <p>Indexing behavior depends solely upon ArrayWrapper. For example, if <code>group_select</code> is enabled indexing will be performed on groups, otherwise on single columns. You can pass wrapper arguments with <code>wrapper_kwargs</code>.</p>","title":"Indexing"},{"location":"api/portfolio/base/#logging","text":"<p>To collect more information on how a specific order was processed or to be able to track the whole simulation from the beginning to the end, we can turn on logging:</p> <pre><code>&gt;&gt;&gt; # Simulate portfolio with logging\n&gt;&gt;&gt; pf = vbt.Portfolio.from_orders(\n...     ohlcv['Close'], size, price=ohlcv['Open'],\n...     init_cash='autoalign', fees=0.001, slippage=0.001, log=True)\n\n&gt;&gt;&gt; pf.logs.records\n        id  group  col  idx  cash    position  debt  free_cash    val_price  \\\n0        0      0    0    0   inf    0.000000   0.0        inf  7194.892090\n1        1      0    0    1   inf    0.000000   0.0        inf  7202.551270\n2        2      0    0    2   inf    0.000000   0.0        inf  6984.428711\n...    ...    ...  ...  ...   ...         ...   ...        ...          ...\n1461  1461      5    5  241   inf  272.389644   0.0        inf    57.207737\n1462  1462      5    5  242   inf  274.137659   0.0        inf    62.844059\n1463  1463      5    5  243   inf  282.093860   0.0        inf    61.105076\n\n      value  ...  new_free_cash  new_val_price  new_value  res_size  \\\n0       inf  ...            inf    7194.892090        inf       NaN\n1       inf  ...            inf    7202.551270        inf       NaN\n2       inf  ...            inf    6984.428711        inf       NaN\n...     ...  ...            ...            ...        ...       ...\n1461    inf  ...            inf      57.207737        inf  1.748015\n1462    inf  ...            inf      62.844059        inf  7.956202\n1463    inf  ...            inf      61.105076        inf  1.636525\n\n        res_price  res_fees  res_side  res_status  res_status_info  order_id\n0             NaN       NaN        -1           1                0        -1\n1             NaN       NaN        -1           1                5        -1\n2             NaN       NaN        -1           1                5        -1\n...           ...       ...       ...         ...              ...       ...\n1461    57.264945    0.1001         0           0               -1      1070\n1462    62.906903    0.5005         0           0               -1      1071\n1463    61.043971    0.0999         1           0               -1      1072\n\n[1464 rows x 37 columns]\n</code></pre> <p>Just as orders, logs are also records and thus can be easily analyzed:</p> <pre><code>&gt;&gt;&gt; pf.logs.res_status.value_counts()\nsymbol   BTC-USD  ETH-USD  XRP-USD  BNB-USD  BCH-USD  LTC-USD\nFilled       184      172      177      178      177      185\nIgnored       60       72       67       66       67       59\n</code></pre> <p>Logging can also be turned on just for one order, row, or column, since as many other variables it's specified per order and can broadcast automatically.</p>  <p>Note</p> <p>Logging can slow down simulation.</p>","title":"Logging"},{"location":"api/portfolio/base/#caching","text":"<p>Portfolio heavily relies upon caching. If a method or a property requires heavy computation, it's wrapped with cached_method() and cached_property respectively. Caching can be disabled globally via <code>caching</code> in settings.</p>  <p>Note</p> <p>Because of caching, class is meant to be immutable and all properties are read-only. To change any attribute, use the <code>copy</code> method and pass the attribute as keyword argument.</p>  <p>Alternatively, we can precisely point at attributes and methods that should or shouldn't be cached. For example, we can blacklist the entire Portfolio class except a few most called methods such as Portfolio.cash_flow() and Portfolio.asset_flow():</p> <pre><code>&gt;&gt;&gt; vbt.settings.caching['blacklist'].append(\n...     vbt.CacheCondition(base_cls='Portfolio')\n... )\n&gt;&gt;&gt; vbt.settings.caching['whitelist'].extend([\n...     vbt.CacheCondition(base_cls='Portfolio', func='cash_flow'),\n...     vbt.CacheCondition(base_cls='Portfolio', func='asset_flow')\n... ])\n</code></pre> <p>Define rules for one instance of Portfolio:</p> <pre><code>&gt;&gt;&gt; vbt.settings.caching['blacklist'].append(\n...     vbt.CacheCondition(instance=pf)\n... )\n&gt;&gt;&gt; vbt.settings.caching['whitelist'].extend([\n...     vbt.CacheCondition(instance=pf, func='cash_flow'),\n...     vbt.CacheCondition(instance=pf, func='asset_flow')\n... ])\n</code></pre> <p>See should_cache() for caching rules.</p> <p>To reset caching:</p> <pre><code>&gt;&gt;&gt; vbt.settings.caching.reset()\n</code></pre>","title":"Caching"},{"location":"api/portfolio/base/#performance-and-memory","text":"<p>If you're running out of memory when working with large arrays, make sure to disable caching and then store most important time series manually. For example, if you're interested in Sharpe ratio or other metrics based on returns, run and save Portfolio.returns() in a variable and then use the ReturnsAccessor to analyze them. Do not use methods akin to Portfolio.sharpe_ratio() because they will re-calculate returns each time.</p> <p>Alternatively, you can track portfolio value and returns using Portfolio.from_order_func() and its callbacks (preferably in <code>post_segment_func_nb</code>):</p> <pre><code>&gt;&gt;&gt; pf_baseline = vbt.Portfolio.from_orders(\n...     ohlcv['Close'], size, price=ohlcv['Open'],\n...     init_cash='autoalign', fees=0.001, slippage=0.001, freq='d')\n&gt;&gt;&gt; pf_baseline.sharpe_ratio()\nsymbol\nBTC-USD    1.743437\nETH-USD    2.800903\nXRP-USD    1.607904\nBNB-USD    1.805373\nBCH-USD    0.269392\nLTC-USD    1.040494\nName: sharpe_ratio, dtype: float64\n\n&gt;&gt;&gt; @njit\n... def order_func_nb(c, size, price, fees, slippage):\n...     return nb.order_nb(\n...         size=nb.get_elem_nb(c, size),\n...         price=nb.get_elem_nb(c, price),\n...         fees=nb.get_elem_nb(c, fees),\n...         slippage=nb.get_elem_nb(c, slippage),\n...     )\n\n&gt;&gt;&gt; @njit\n... def post_segment_func_nb(c, returns_out):\n...     returns_out[c.i, c.group] = c.last_return[c.group]\n\n&gt;&gt;&gt; returns_out = np.empty_like(ohlcv['Close'], dtype=np.float_)\n&gt;&gt;&gt; pf = vbt.Portfolio.from_order_func(\n...     ohlcv['Close'],\n...     order_func_nb,\n...     np.asarray(size),\n...     np.asarray(ohlcv['Open']),\n...     np.asarray(0.001),\n...     np.asarray(0.001),\n...     post_segment_func_nb=post_segment_func_nb,\n...     post_segment_args=(returns_out,),\n...     init_cash=pf_baseline.init_cash\n... )\n\n&gt;&gt;&gt; returns = pf.wrapper.wrap(returns_out)\n&gt;&gt;&gt; del pf\n&gt;&gt;&gt; returns.vbt.returns(freq='d').sharpe_ratio()\nsymbol\nBTC-USD   -2.261443\nETH-USD    0.059538\nXRP-USD    2.159093\nBNB-USD    1.555386\nBCH-USD    0.784214\nLTC-USD    1.460077\nName: sharpe_ratio, dtype: float64\n</code></pre> <p>The only drawback of this approach is that you cannot use <code>init_cash='auto'</code> or <code>init_cash='autoalign'</code> because then, during the simulation, the portfolio value is <code>np.inf</code> and the returns are <code>np.nan</code>.</p>","title":"Performance and memory"},{"location":"api/portfolio/base/#saving-and-loading","text":"<p>Like any other class subclassing Pickleable, we can save a Portfolio instance to the disk with Pickleable.save() and load it with Pickleable.load():</p> <pre><code>&gt;&gt;&gt; pf = vbt.Portfolio.from_orders(\n...     ohlcv['Close'], size, price=ohlcv['Open'],\n...     init_cash='autoalign', fees=0.001, slippage=0.001, freq='d')\n&gt;&gt;&gt; pf.sharpe_ratio()\nsymbol\nBTC-USD    1.743437\nETH-USD    2.800903\nXRP-USD    1.607904\nBNB-USD    1.805373\nBCH-USD    0.269392\nLTC-USD    1.040494\nName: sharpe_ratio, dtype: float64\n\n&gt;&gt;&gt; pf.save('my_pf')\n&gt;&gt;&gt; pf = vbt.Portfolio.load('my_pf')\n&gt;&gt;&gt; pf.sharpe_ratio()\nsymbol\nBTC-USD    1.743437\nETH-USD    2.800903\nXRP-USD    1.607904\nBNB-USD    1.805373\nBCH-USD    0.269392\nLTC-USD    1.040494\nName: sharpe_ratio, dtype: float64\n</code></pre>  <p>Note</p> <p>Save files won't include neither cached results nor global defaults. For example, passing <code>fillna_close</code> as None will also use None when the portfolio is loaded from disk. Make sure to either pass all arguments explicitly or to also save the settings config.</p>","title":"Saving and loading"},{"location":"api/portfolio/base/#stats","text":"<p>Hint</p> <p>See StatsBuilderMixin.stats() and Portfolio.metrics.</p>  <p>Let's simulate a portfolio with two columns:</p> <pre><code>&gt;&gt;&gt; close = vbt.YFData.download(\n...     \"BTC-USD\",\n...     start='2020-01-01 UTC',\n...     end='2020-09-01 UTC'\n... ).get('Close')\n\n&gt;&gt;&gt; pf = vbt.Portfolio.from_random_signals(close, n=[10, 20], seed=42)\n&gt;&gt;&gt; pf.wrapper.columns\nInt64Index([10, 20], dtype='int64', name='rand_n')\n</code></pre>","title":"Stats"},{"location":"api/portfolio/base/#column-group-and-tag-selection","text":"<p>To return the statistics for a particular column/group, use the <code>column</code> argument:</p> <pre><code>&gt;&gt;&gt; pf.stats(column=10)\nUserWarning: Metric 'sharpe_ratio' requires frequency to be set\nUserWarning: Metric 'calmar_ratio' requires frequency to be set\nUserWarning: Metric 'omega_ratio' requires frequency to be set\nUserWarning: Metric 'sortino_ratio' requires frequency to be set\n\nStart                         2020-01-01 00:00:00+00:00\nEnd                           2020-09-01 00:00:00+00:00\nPeriod                                              244\nStart Value                                       100.0\nEnd Value                                    106.721585\nTotal Return [%]                               6.721585\nBenchmark Return [%]                          66.252621\nMax Gross Exposure [%]                            100.0\nTotal Fees Paid                                     0.0\nMax Drawdown [%]                              22.190944\nMax Drawdown Duration                             101.0\nTotal Trades                                         10\nTotal Closed Trades                                  10\nTotal Open Trades                                     0\nOpen Trade PnL                                      0.0\nWin Rate [%]                                       60.0\nBest Trade [%]                                 15.31962\nWorst Trade [%]                               -9.904223\nAvg Winning Trade [%]                          4.671959\nAvg Losing Trade [%]                          -4.851205\nAvg Winning Trade Duration                    11.333333\nAvg Losing Trade Duration                         14.25\nProfit Factor                                  1.347457\nExpectancy                                     0.672158\nName: 10, dtype: object\n</code></pre> <p>If vectorbt couldn't parse the frequency of <code>close</code>:</p> <p>1) it won't return any duration in time units, 2) it won't return any metric that requires annualization, and 3) it will throw a bunch of warnings (you can silence those by passing <code>silence_warnings=True</code>)</p> <p>We can provide the frequency as part of the settings dict:</p> <pre><code>&gt;&gt;&gt; pf.stats(column=10, settings=dict(freq='d'))\nUserWarning: Changing the frequency will create a copy of this object.\nConsider setting the frequency upon object creation to re-use existing cache.\n\nStart                         2020-01-01 00:00:00+00:00\nEnd                           2020-09-01 00:00:00+00:00\nPeriod                                244 days 00:00:00\nStart Value                                       100.0\nEnd Value                                    106.721585\nTotal Return [%]                               6.721585\nBenchmark Return [%]                          66.252621\nMax Gross Exposure [%]                            100.0\nTotal Fees Paid                                     0.0\nMax Drawdown [%]                              22.190944\nMax Drawdown Duration                 101 days 00:00:00\nTotal Trades                                         10\nTotal Closed Trades                                  10\nTotal Open Trades                                     0\nOpen Trade PnL                                      0.0\nWin Rate [%]                                       60.0\nBest Trade [%]                                 15.31962\nWorst Trade [%]                               -9.904223\nAvg Winning Trade [%]                          4.671959\nAvg Losing Trade [%]                          -4.851205\nAvg Winning Trade Duration             11 days 08:00:00\nAvg Losing Trade Duration              14 days 06:00:00\nProfit Factor                                  1.347457\nExpectancy                                     0.672158\nSharpe Ratio                                   0.445231\nCalmar Ratio                                   0.460573\nOmega Ratio                                    1.099192\nSortino Ratio                                  0.706986\nName: 10, dtype: object\n</code></pre> <p>But in this case, our portfolio will be copied to set the new frequency and we wouldn't be able to re-use its cached attributes. Let's define the frequency upon the simulation instead:</p> <pre><code>&gt;&gt;&gt; pf = vbt.Portfolio.from_random_signals(close, n=[10, 20], seed=42, freq='d')\n</code></pre> <p>We can change the grouping of the portfolio on the fly. Let's form a single group:</p> <pre><code>&gt;&gt;&gt; pf.stats(group_by=True)\nStart                         2020-01-01 00:00:00+00:00\nEnd                           2020-09-01 00:00:00+00:00\nPeriod                                244 days 00:00:00\nStart Value                                       200.0\nEnd Value                                     277.49299\nTotal Return [%]                              38.746495\nBenchmark Return [%]                          66.252621\nMax Gross Exposure [%]                            100.0\nTotal Fees Paid                                     0.0\nMax Drawdown [%]                              14.219327\nMax Drawdown Duration                  86 days 00:00:00\nTotal Trades                                         30\nTotal Closed Trades                                  30\nTotal Open Trades                                     0\nOpen Trade PnL                                      0.0\nWin Rate [%]                                  66.666667\nBest Trade [%]                                18.332559\nWorst Trade [%]                               -9.904223\nAvg Winning Trade [%]                          5.754788\nAvg Losing Trade [%]                          -4.718907\nAvg Winning Trade Duration              7 days 19:12:00\nAvg Losing Trade Duration               8 days 07:12:00\nProfit Factor                                  2.427948\nExpectancy                                       2.5831\nSharpe Ratio                                    1.57907\nCalmar Ratio                                   4.445448\nOmega Ratio                                    1.334032\nSortino Ratio                                   2.59669\nName: group, dtype: object\n</code></pre> <p>We can see how the initial cash has changed from $100 to $200, indicating that both columns now contribute to the performance.</p>","title":"Column, group, and tag selection"},{"location":"api/portfolio/base/#aggregation","text":"<p>If the portfolio consists of multiple columns/groups and no column/group has been selected, each metric is aggregated across all columns/groups based on <code>agg_func</code>, which is <code>np.mean</code> by default.</p> <pre><code>&gt;&gt;&gt; pf.stats()\nUserWarning: Object has multiple columns. Aggregating using &lt;function mean at 0x7fc77152bb70&gt;.\nPass column to select a single column/group.\n\nStart                         2020-01-01 00:00:00+00:00\nEnd                           2020-09-01 00:00:00+00:00\nPeriod                                244 days 00:00:00\nStart Value                                       100.0\nEnd Value                                    138.746495\nTotal Return [%]                              38.746495\nBenchmark Return [%]                          66.252621\nMax Gross Exposure [%]                            100.0\nTotal Fees Paid                                     0.0\nMax Drawdown [%]                               20.35869\nMax Drawdown Duration                  93 days 00:00:00\nTotal Trades                                       15.0\nTotal Closed Trades                                15.0\nTotal Open Trades                                   0.0\nOpen Trade PnL                                      0.0\nWin Rate [%]                                       65.0\nBest Trade [%]                                 16.82609\nWorst Trade [%]                               -9.701273\nAvg Winning Trade [%]                          5.445408\nAvg Losing Trade [%]                          -4.740956\nAvg Winning Trade Duration    8 days 19:25:42.857142857\nAvg Losing Trade Duration               9 days 07:00:00\nProfit Factor                                  2.186957\nExpectancy                                     2.105364\nSharpe Ratio                                   1.165695\nCalmar Ratio                                   3.541079\nOmega Ratio                                    1.331624\nSortino Ratio                                  2.084565\nName: agg_func_mean, dtype: object\n</code></pre> <p>Here, the Sharpe ratio of 0.445231 (column=10) and 1.88616 (column=20) lead to the avarage of 1.16569.</p> <p>We can also return a DataFrame with statistics per column/group by passing <code>agg_func=None</code>:</p> <pre><code>&gt;&gt;&gt; pf.stats(agg_func=None)\n                           Start                       End   Period  ...  Sortino Ratio\nrand_n                                                               ...\n10     2020-01-01 00:00:00+00:00 2020-09-01 00:00:00+00:00 244 days  ...       0.706986\n20     2020-01-01 00:00:00+00:00 2020-09-01 00:00:00+00:00 244 days  ...       3.462144\n\n[2 rows x 25 columns]\n</code></pre>","title":"Aggregation"},{"location":"api/portfolio/base/#metric-selection","text":"<p>To select metrics, use the <code>metrics</code> argument (see Portfolio.metrics for supported metrics):</p> <pre><code>&gt;&gt;&gt; pf.stats(metrics=['sharpe_ratio', 'sortino_ratio'], column=10)\nSharpe Ratio     0.445231\nSortino Ratio    0.706986\nName: 10, dtype: float64\n</code></pre> <p>We can also select specific tags (see any metric from Portfolio.metrics that has the <code>tag</code> key):</p> <pre><code>&gt;&gt;&gt; pf.stats(column=10, tags=['trades'])\nTotal Trades                                10\nTotal Open Trades                            0\nOpen Trade PnL                               0\nLong Trades [%]                            100\nWin Rate [%]                                60\nBest Trade [%]                         15.3196\nWorst Trade [%]                       -9.90422\nAvg Winning Trade [%]                  4.67196\nAvg Winning Trade Duration    11 days 08:00:00\nAvg Losing Trade [%]                   -4.8512\nAvg Losing Trade Duration     14 days 06:00:00\nProfit Factor                          1.34746\nExpectancy                            0.672158\nName: 10, dtype: object\n</code></pre> <p>Or provide a boolean expression:</p> <pre><code>&gt;&gt;&gt; pf.stats(column=10, tags='trades and open and not closed')\nTotal Open Trades    0.0\nOpen Trade PnL       0.0\nName: 10, dtype: float64\n</code></pre> <p>The reason why we included \"not closed\" along with \"open\" is because some metrics such as the win rate have both tags attached since they are based upon both open and closed trades/positions (to see this, pass <code>settings=dict(incl_open=True)</code> and <code>tags='trades and open'</code>).</p>","title":"Metric selection"},{"location":"api/portfolio/base/#passing-parameters","text":"<p>We can use <code>settings</code> to pass parameters used across multiple metrics. For example, let's pass required and risk-free return to all return metrics:</p> <pre><code>&gt;&gt;&gt; pf.stats(column=10, settings=dict(required_return=0.1, risk_free=0.01))\nStart                         2020-01-01 00:00:00+00:00\nEnd                           2020-09-01 00:00:00+00:00\nPeriod                                244 days 00:00:00\nStart Value                                       100.0\nEnd Value                                    106.721585\nTotal Return [%]                               6.721585\nBenchmark Return [%]                          66.252621\nMax Gross Exposure [%]                            100.0\nTotal Fees Paid                                     0.0\nMax Drawdown [%]                              22.190944\nMax Drawdown Duration                 101 days 00:00:00\nTotal Trades                                         10\nTotal Closed Trades                                  10\nTotal Open Trades                                     0\nOpen Trade PnL                                      0.0\nWin Rate [%]                                       60.0\nBest Trade [%]                                 15.31962\nWorst Trade [%]                               -9.904223\nAvg Winning Trade [%]                          4.671959\nAvg Losing Trade [%]                          -4.851205\nAvg Winning Trade Duration             11 days 08:00:00\nAvg Losing Trade Duration              14 days 06:00:00\nProfit Factor                                  1.347457\nExpectancy                                     0.672158\nSharpe Ratio                                  -9.504742  &lt;&lt; here\nCalmar Ratio                                   0.460573  &lt;&lt; here\nOmega Ratio                                    0.233279  &lt;&lt; here\nSortino Ratio                                -18.763407  &lt;&lt; here\nName: 10, dtype: object\n</code></pre> <p>Passing any argument inside of <code>settings</code> either overrides an existing default, or acts as an optional argument that is passed to the calculation function upon resolution (see below). Both <code>required_return</code> and <code>risk_free</code> can be found in the signature of the 4 ratio methods, so vectorbt knows exactly it has to pass them.</p> <p>Let's imagine that the signature of ReturnsAccessor.sharpe_ratio() doesn't list those arguments: vectorbt would simply call this method without passing those two arguments. In such case, we have two options:</p> <p>1) Set parameters globally using <code>settings</code> and set <code>pass_{arg}=True</code> individually using <code>metric_settings</code>:</p> <pre><code>&gt;&gt;&gt; pf.stats(\n...     column=10,\n...     settings=dict(required_return=0.1, risk_free=0.01),\n...     metric_settings=dict(\n...         sharpe_ratio=dict(pass_risk_free=True),\n...         omega_ratio=dict(pass_required_return=True, pass_risk_free=True),\n...         sortino_ratio=dict(pass_required_return=True)\n...     )\n... )\n</code></pre> <p>2) Set parameters individually using <code>metric_settings</code>:</p> <pre><code>&gt;&gt;&gt; pf.stats(\n...     column=10,\n...     metric_settings=dict(\n...         sharpe_ratio=dict(risk_free=0.01),\n...         omega_ratio=dict(required_return=0.1, risk_free=0.01),\n...         sortino_ratio=dict(required_return=0.1)\n...     )\n... )\n</code></pre>","title":"Passing parameters"},{"location":"api/portfolio/base/#custom-metrics","text":"<p>To calculate a custom metric, we need to provide at least two things: short name and a settings dict with the title and calculation function (see arguments in StatsBuilderMixin):</p> <pre><code>&gt;&gt;&gt; max_winning_streak = (\n...     'max_winning_streak',\n...     dict(\n...         title='Max Winning Streak',\n...         calc_func=lambda trades: trades.winning_streak.max(),\n...         resolve_trades=True\n...     )\n... )\n&gt;&gt;&gt; pf.stats(metrics=max_winning_streak, column=10)\nMax Winning Streak    3.0\nName: 10, dtype: float64\n</code></pre> <p>You might wonder how vectorbt knows which arguments to pass to <code>calc_func</code>? In the example above, the calculation function expects two arguments: <code>trades</code> and <code>group_by</code>. To automatically pass any of the them, vectorbt searches for each in the current settings. As <code>trades</code> cannot be found, it either throws an error or tries to resolve this argument if <code>resolve_{arg}=True</code> was passed. Argument resolution is the process of searching for property/method with the same name (also with prefix <code>get_</code>) in the attributes of the current portfolio, automatically passing the current settings such as <code>group_by</code> if they are present in the method's signature (a similar resolution procedure), and calling the method/property. The result of the resolution process is then passed as <code>arg</code> (or <code>trades</code> in our example).</p> <p>Here's an example without resolution of arguments:</p> <pre><code>&gt;&gt;&gt; max_winning_streak = (\n...     'max_winning_streak',\n...     dict(\n...         title='Max Winning Streak',\n...         calc_func=lambda self, group_by:\n...         self.get_trades(group_by=group_by).winning_streak.max()\n...     )\n... )\n&gt;&gt;&gt; pf.stats(metrics=max_winning_streak, column=10)\nMax Winning Streak    3.0\nName: 10, dtype: float64\n</code></pre> <p>And here's an example without resolution of the calculation function:</p> <pre><code>&gt;&gt;&gt; max_winning_streak = (\n...     'max_winning_streak',\n...     dict(\n...         title='Max Winning Streak',\n...         calc_func=lambda self, settings:\n...         self.get_trades(group_by=settings['group_by']).winning_streak.max(),\n...         resolve_calc_func=False\n...     )\n... )\n&gt;&gt;&gt; pf.stats(metrics=max_winning_streak, column=10)\nMax Winning Streak    3.0\nName: 10, dtype: float64\n</code></pre> <p>Since <code>max_winning_streak</code> method can be expressed as a path from this portfolio, we can simply write:</p> <pre><code>&gt;&gt;&gt; max_winning_streak = (\n...     'max_winning_streak',\n...     dict(\n...         title='Max Winning Streak',\n...         calc_func='trades.winning_streak.max'\n...     )\n... )\n</code></pre> <p>In this case, we don't have to pass <code>resolve_trades=True</code> any more as vectorbt does it automatically. Another advantage is that vectorbt can access the signature of the last method in the path (MappedArray.max() in our case) and resolve its arguments.</p> <p>To switch between entry trades, exit trades, and positions, use the <code>trades_type</code> setting. Additionally, you can pass <code>incl_open=True</code> to also include open trades.</p> <pre><code>&gt;&gt;&gt; pf.stats(column=10, settings=dict(trades_type='positions', incl_open=True))\nStart                         2020-01-01 00:00:00+00:00\nEnd                           2020-09-01 00:00:00+00:00\nPeriod                                244 days 00:00:00\nStart Value                                       100.0\nEnd Value                                    106.721585\nTotal Return [%]                               6.721585\nBenchmark Return [%]                          66.252621\nMax Gross Exposure [%]                            100.0\nTotal Fees Paid                                     0.0\nMax Drawdown [%]                              22.190944\nMax Drawdown Duration                 100 days 00:00:00\nTotal Trades                                         10\nTotal Closed Trades                                  10\nTotal Open Trades                                     0\nOpen Trade PnL                                      0.0\nWin Rate [%]                                       60.0\nBest Trade [%]                                 15.31962\nWorst Trade [%]                               -9.904223\nAvg Winning Trade [%]                          4.671959\nAvg Losing Trade [%]                          -4.851205\nAvg Winning Trade Duration             11 days 08:00:00\nAvg Losing Trade Duration              14 days 06:00:00\nProfit Factor                                  1.347457\nExpectancy                                     0.672158\nSharpe Ratio                                   0.445231\nCalmar Ratio                                   0.460573\nOmega Ratio                                    1.099192\nSortino Ratio                                  0.706986\nName: 10, dtype: object\n</code></pre> <p>Any default metric setting or even global setting can be overridden by the user using metric-specific keyword arguments. Here, we override the global aggregation function for <code>max_dd_duration</code>:</p> <pre><code>&gt;&gt;&gt; pf.stats(agg_func=lambda sr: sr.mean(),\n...     metric_settings=dict(\n...         max_dd_duration=dict(agg_func=lambda sr: sr.max())\n...     )\n... )\nUserWarning: Object has multiple columns. Aggregating using &lt;function &lt;lambda&gt; at 0x7fbf6e77b268&gt;.\nPass column to select a single column/group.\n\nStart                         2020-01-01 00:00:00+00:00\nEnd                           2020-09-01 00:00:00+00:00\nPeriod                                244 days 00:00:00\nStart Value                                       100.0\nEnd Value                                    138.746495\nTotal Return [%]                              38.746495\nBenchmark Return [%]                          66.252621\nMax Gross Exposure [%]                            100.0\nTotal Fees Paid                                     0.0\nMax Drawdown [%]                               20.35869\nMax Drawdown Duration                 101 days 00:00:00  &lt;&lt; here\nTotal Trades                                       15.0\nTotal Closed Trades                                15.0\nTotal Open Trades                                   0.0\nOpen Trade PnL                                      0.0\nWin Rate [%]                                       65.0\nBest Trade [%]                                 16.82609\nWorst Trade [%]                               -9.701273\nAvg Winning Trade [%]                          5.445408\nAvg Losing Trade [%]                          -4.740956\nAvg Winning Trade Duration    8 days 19:25:42.857142857\nAvg Losing Trade Duration               9 days 07:00:00\nProfit Factor                                  2.186957\nExpectancy                                     2.105364\nSharpe Ratio                                   1.165695\nCalmar Ratio                                   3.541079\nOmega Ratio                                    1.331624\nSortino Ratio                                  2.084565\nName: agg_func_&lt;lambda&gt;, dtype: object\n</code></pre> <p>Let's create a simple metric that returns a passed value to demonstrate how vectorbt overrides settings, from least to most important:</p> <pre><code>&gt;&gt;&gt; # vbt.settings.portfolio.stats\n&gt;&gt;&gt; vbt.settings.portfolio.stats['settings']['my_arg'] = 100\n&gt;&gt;&gt; my_arg_metric = ('my_arg_metric', dict(title='My Arg', calc_func=lambda my_arg: my_arg))\n&gt;&gt;&gt; pf.stats(my_arg_metric, column=10)\nMy Arg    100\nName: 10, dtype: int64\n\n&gt;&gt;&gt; # settings &gt;&gt;&gt; vbt.settings.portfolio.stats\n&gt;&gt;&gt; pf.stats(my_arg_metric, column=10, settings=dict(my_arg=200))\nMy Arg    200\nName: 10, dtype: int64\n\n&gt;&gt;&gt; # metric settings &gt;&gt;&gt; settings\n&gt;&gt;&gt; my_arg_metric = ('my_arg_metric', dict(title='My Arg', my_arg=300, calc_func=lambda my_arg: my_arg))\n&gt;&gt;&gt; pf.stats(my_arg_metric, column=10, settings=dict(my_arg=200))\nMy Arg    300\nName: 10, dtype: int64\n\n&gt;&gt;&gt; # metric_settings &gt;&gt;&gt; metric settings\n&gt;&gt;&gt; pf.stats(my_arg_metric, column=10, settings=dict(my_arg=200),\n...     metric_settings=dict(my_arg_metric=dict(my_arg=400)))\nMy Arg    400\nName: 10, dtype: int64\n</code></pre> <p>Here's an example of a parametrized metric. Let's get the number of trades with PnL over some amount:</p> <pre><code>&gt;&gt;&gt; trade_min_pnl_cnt = (\n...     'trade_min_pnl_cnt',\n...     dict(\n...         title=vbt.Sub('Trades with PnL over $$${min_pnl}'),\n...         calc_func=lambda trades, min_pnl: trades.apply_mask(\n...             trades.pnl.values &gt;= min_pnl).count(),\n...         resolve_trades=True\n...     )\n... )\n&gt;&gt;&gt; pf.stats(\n...     metrics=trade_min_pnl_cnt, column=10,\n...     metric_settings=dict(trade_min_pnl_cnt=dict(min_pnl=0)))\nTrades with PnL over $0    6\nName: stats, dtype: int64\n\n&gt;&gt;&gt; pf.stats(\n...     metrics=trade_min_pnl_cnt, column=10,\n...     metric_settings=dict(trade_min_pnl_cnt=dict(min_pnl=10)))\nTrades with PnL over $10    1\nName: stats, dtype: int64\n</code></pre> <p>If the same metric name was encountered more than once, vectorbt automatically appends an underscore and its position, so we can pass keyword arguments to each metric separately:</p> <pre><code>&gt;&gt;&gt; pf.stats(\n...     metrics=[\n...         trade_min_pnl_cnt,\n...         trade_min_pnl_cnt,\n...         trade_min_pnl_cnt\n...     ],\n...     column=10,\n...     metric_settings=dict(\n...         trade_min_pnl_cnt_0=dict(min_pnl=0),\n...         trade_min_pnl_cnt_1=dict(min_pnl=10),\n...         trade_min_pnl_cnt_2=dict(min_pnl=20))\n...     )\nTrades with PnL over $0     6\nTrades with PnL over $10    1\nTrades with PnL over $20    0\nName: stats, dtype: int64\n</code></pre> <p>To add a custom metric to the list of all metrics, we have three options.</p> <p>The first option is to change the Portfolio.metrics dict in-place (this will append to the end):</p> <pre><code>&gt;&gt;&gt; pf.metrics['max_winning_streak'] = max_winning_streak[1]\n&gt;&gt;&gt; pf.stats(column=10)\nStart                         2020-01-01 00:00:00+00:00\nEnd                           2020-09-01 00:00:00+00:00\nPeriod                                244 days 00:00:00\nStart Value                                       100.0\nEnd Value                                    106.721585\nTotal Return [%]                               6.721585\nBenchmark Return [%]                          66.252621\nMax Gross Exposure [%]                            100.0\nTotal Fees Paid                                     0.0\nMax Drawdown [%]                              22.190944\nMax Drawdown Duration                 101 days 00:00:00\nTotal Trades                                         10\nTotal Closed Trades                                  10\nTotal Open Trades                                     0\nOpen Trade PnL                                      0.0\nWin Rate [%]                                       60.0\nBest Trade [%]                                 15.31962\nWorst Trade [%]                               -9.904223\nAvg Winning Trade [%]                          4.671959\nAvg Losing Trade [%]                          -4.851205\nAvg Winning Trade Duration             11 days 08:00:00\nAvg Losing Trade Duration              14 days 06:00:00\nProfit Factor                                  1.347457\nExpectancy                                     0.672158\nSharpe Ratio                                   0.445231\nCalmar Ratio                                   0.460573\nOmega Ratio                                    1.099192\nSortino Ratio                                  0.706986\nMax Winning Streak                                  3.0  &lt;&lt; here\nName: 10, dtype: object\n</code></pre> <p>Since Portfolio.metrics is of type Config, we can reset it at any time to get default metrics:</p> <pre><code>&gt;&gt;&gt; pf.metrics.reset()\n</code></pre> <p>The second option is to copy Portfolio.metrics, append our metric, and pass as <code>metrics</code> argument:</p> <pre><code>&gt;&gt;&gt; my_metrics = list(pf.metrics.items()) + [max_winning_streak]\n&gt;&gt;&gt; pf.stats(metrics=my_metrics, column=10)\n</code></pre> <p>The third option is to set <code>metrics</code> globally under <code>portfolio.stats</code> in settings.</p> <pre><code>&gt;&gt;&gt; vbt.settings.portfolio['stats']['metrics'] = my_metrics\n&gt;&gt;&gt; pf.stats(column=10)\n</code></pre>","title":"Custom metrics"},{"location":"api/portfolio/base/#returns-stats","text":"<p>We can compute the stats solely based on the portfolio's returns using Portfolio.returns_stats(), which calls StatsBuilderMixin.stats().</p> <pre><code>&gt;&gt;&gt; pf.returns_stats(column=10)\nStart                        2020-01-01 00:00:00+00:00\nEnd                          2020-09-01 00:00:00+00:00\nPeriod                               244 days 00:00:00\nTotal Return [%]                              6.721585\nBenchmark Return [%]                         66.252621\nAnnualized Return [%]                         10.22056\nAnnualized Volatility [%]                    36.683518\nMax Drawdown [%]                             22.190944\nMax Drawdown Duration                100 days 00:00:00\nSharpe Ratio                                  0.445231\nCalmar Ratio                                  0.460573\nOmega Ratio                                   1.099192\nSortino Ratio                                 0.706986\nSkew                                          1.328259\nKurtosis                                      10.80246\nTail Ratio                                    1.057913\nCommon Sense Ratio                            1.166037\nValue at Risk                                -0.031011\nAlpha                                        -0.075109\nBeta                                          0.220351\nName: 10, dtype: object\n</code></pre> <p>Most metrics defined in ReturnsAccessor are also available as attributes of Portfolio:</p> <pre><code>&gt;&gt;&gt; pf.sharpe_ratio()\nrandnx_n\n10    0.445231\n20    1.886158\nName: sharpe_ratio, dtype: float64\n</code></pre> <p>Moreover, we can access quantstats functions using QSAdapter:</p> <pre><code>&gt;&gt;&gt; pf.qs.sharpe()\nrandnx_n\n10    0.445231\n20    1.886158\ndtype: float64\n\n&gt;&gt;&gt; pf[10].qs.plot_snapshot()\n</code></pre> <p></p>","title":"Returns stats"},{"location":"api/portfolio/base/#plots","text":"<p>Hint</p> <p>See PlotsBuilderMixin.plots().</p> <p>The features implemented in this method are very similar to StatsBuilderMixin.stats(). See also the examples under StatsBuilderMixin.stats().</p>  <p>Plot portfolio of a random strategy:</p> <pre><code>&gt;&gt;&gt; pf.plot(column=10)\n</code></pre> <p></p> <p>You can choose any of the subplots in Portfolio.subplots, in any order, and control their appearance using keyword arguments:</p> <pre><code>&gt;&gt;&gt; pf.plot(\n...     subplots=['drawdowns', 'underwater'],\n...     column=10,\n...     subplot_settings=dict(\n...         drawdowns=dict(top_n=3),\n...         underwater=dict(\n...             trace_kwargs=dict(\n...                 line=dict(color='#FF6F00'),\n...                 fillcolor=adjust_opacity('#FF6F00', 0.3)\n...             )\n...         )\n...     )\n... )\n</code></pre> <p></p> <p>To create a new subplot, a preferred way is to pass a plotting function:</p> <pre><code>&gt;&gt;&gt; def plot_order_size(pf, size, column=None, add_trace_kwargs=None, fig=None):\n...     size = pf.select_one_from_obj(size, pf.wrapper.regroup(False), column=column)\n...     size.rename('Order Size').vbt.barplot(\n...         add_trace_kwargs=add_trace_kwargs, fig=fig)\n\n&gt;&gt;&gt; order_size = pf.orders.size.to_pd(fill_value=0.)\n&gt;&gt;&gt; pf.plot(subplots=[\n...     'orders',\n...     ('order_size', dict(\n...         title='Order Size',\n...         yaxis_kwargs=dict(title='Order size'),\n...         check_is_not_grouped=True,\n...         plot_func=plot_order_size\n...     ))\n... ],\n...     column=10,\n...     subplot_settings=dict(\n...         order_size=dict(\n...             size=order_size\n...         )\n...     )\n... )\n</code></pre> <p>Alternatively, you can create a placeholder and overwrite it manually later:</p> <pre><code>&gt;&gt;&gt; fig = pf.plot(subplots=[\n...     'orders',\n...     ('order_size', dict(\n...         title='Order Size',\n...         yaxis_kwargs=dict(title='Order size'),\n...         check_is_not_grouped=True\n...     ))  # placeholder\n... ], column=10)\n&gt;&gt;&gt; order_size[10].rename('Order Size').vbt.barplot(\n...     add_trace_kwargs=dict(row=2, col=1),\n...     fig=fig\n... )\n</code></pre> <p></p> <p>If a plotting function can in any way be accessed from the current portfolio, you can pass the path to this function (see deep_getattr() for the path format). You can additionally use templates to make some parameters to depend upon passed keyword arguments:</p> <pre><code>&gt;&gt;&gt; subplots = [\n...     ('cumulative_returns', dict(\n...         title='Cumulative Returns',\n...         yaxis_kwargs=dict(title='Cumulative returns'),\n...         plot_func='returns.vbt.returns.cumulative.vbt.plot',\n...         pass_add_trace_kwargs=True\n...     )),\n...     ('rolling_drawdown', dict(\n...         title='Rolling Drawdown',\n...         yaxis_kwargs=dict(title='Rolling drawdown'),\n...         plot_func=[\n...             'returns.vbt.returns',  # returns accessor\n...             (\n...                 'rolling_max_drawdown',  # function name\n...                 (vbt.Rep('window'),)),  # positional arguments\n...             'vbt.plot'  # plotting function\n...         ],\n...         pass_add_trace_kwargs=True,\n...         trace_names=[vbt.Sub('rolling_drawdown(${window})')],  # add window to the trace name\n...     ))\n... ]\n&gt;&gt;&gt; pf.plot(\n...     subplots,\n...     column=10,\n...     subplot_settings=dict(\n...         rolling_drawdown=dict(\n...             template_mapping=dict(\n...                 window=10\n...             )\n...         )\n...     )\n... )\n</code></pre> <p>You can also replace templates across all subplots by using the global template mapping:</p> <pre><code>&gt;&gt;&gt; pf.plot(subplots, column=10, template_mapping=dict(window=10))\n</code></pre> <p></p>","title":"Plots"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.returns_acc_config","text":"<p>Config of returns accessor methods to be added to Portfolio.</p> <pre><code>Config({\n    \"daily_returns\": {\n        \"source_name\": \"daily\"\n    },\n    \"annual_returns\": {\n        \"source_name\": \"annual\"\n    },\n    \"cumulative_returns\": {\n        \"source_name\": \"cumulative\"\n    },\n    \"annualized_return\": {\n        \"source_name\": \"annualized\"\n    },\n    \"annualized_volatility\": {},\n    \"calmar_ratio\": {},\n    \"omega_ratio\": {},\n    \"sharpe_ratio\": {},\n    \"deflated_sharpe_ratio\": {},\n    \"downside_risk\": {},\n    \"sortino_ratio\": {},\n    \"information_ratio\": {},\n    \"beta\": {},\n    \"alpha\": {},\n    \"tail_ratio\": {},\n    \"value_at_risk\": {},\n    \"cond_value_at_risk\": {},\n    \"capture\": {},\n    \"up_capture\": {},\n    \"down_capture\": {},\n    \"drawdown\": {},\n    \"max_drawdown\": {}\n})\n</code></pre>","title":"returns_acc_config variable"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.MetaPortfolio","text":"<pre><code>MetaPortfolio(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Meta class that exposes a read-only class property <code>StatsBuilderMixin.metrics</code>.</p> <p>Superclasses</p> <ul> <li>MetaPlotsBuilderMixin</li> <li>MetaStatsBuilderMixin</li> <li><code>builtins.type</code></li> </ul> <p>Inherited members</p> <ul> <li>MetaPlotsBuilderMixin.subplots</li> <li>MetaStatsBuilderMixin.metrics</li> </ul>","title":"MetaPortfolio class"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio","text":"<pre><code>Portfolio(\n    wrapper,\n    close,\n    order_records,\n    log_records,\n    init_cash,\n    cash_sharing,\n    call_seq=None,\n    fillna_close=None,\n    trades_type=None\n)\n</code></pre> <p>Class for modeling portfolio and measuring its performance.</p> <p>Args</p>  <code>wrapper</code> :\u2002<code>ArrayWrapper</code>  <p>Array wrapper.</p> <p>See ArrayWrapper.</p>  <code>close</code> :\u2002<code>array_like</code> Last asset price at each time step. <code>order_records</code> :\u2002<code>array_like</code> A structured NumPy array of order records. <code>log_records</code> :\u2002<code>array_like</code> A structured NumPy array of log records. <code>init_cash</code> :\u2002<code>InitCashMode</code>, <code>float</code> or <code>array_like</code> of <code>float</code> Initial capital. <code>cash_sharing</code> :\u2002<code>bool</code> Whether to share cash within the same group. <code>call_seq</code> :\u2002<code>array_like</code> of <code>int</code> Sequence of calls per row and group. Defaults to None. <code>fillna_close</code> :\u2002<code>bool</code>  <p>Whether to forward and backward fill NaN values in <code>close</code>.</p> <p>Applied after the simulation to avoid NaNs in asset value.</p> <p>See Portfolio.get_filled_close().</p>  <code>trades_type</code> :\u2002<code>str</code> or <code>int</code>  <p>Default Trades to use across Portfolio.</p> <p>See TradesType.</p>   <p>For defaults, see <code>portfolio</code> in settings.</p>  <p>Note</p> <p>Use class methods with <code>from_</code> prefix to build a portfolio. The <code>__init__</code> method is reserved for indexing purposes.</p>   <p>Note</p> <p>This class is meant to be immutable. To change any attribute, use Configured.replace().</p>  <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.config</li> <li>Wrapping.iloc</li> <li>Wrapping.indexing_kwargs</li> <li>Wrapping.loc</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> <li>Wrapping.self_aliases</li> <li>Wrapping.wrapper</li> <li>Wrapping.writeable_attrs</li> </ul>","title":"Portfolio class"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.metrics","text":"<p>Metrics supported by Portfolio.</p> <pre><code>Config({\n    \"start\": {\n        \"title\": \"Start\",\n        \"calc_func\": \"&lt;function Portfolio.&lt;lambda&gt; at 0x7ff535ef6730&gt;\",\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"end\": {\n        \"title\": \"End\",\n        \"calc_func\": \"&lt;function Portfolio.&lt;lambda&gt; at 0x7ff535ef67b8&gt;\",\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"period\": {\n        \"title\": \"Period\",\n        \"calc_func\": \"&lt;function Portfolio.&lt;lambda&gt; at 0x7ff535ef6840&gt;\",\n        \"apply_to_timedelta\": true,\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"start_value\": {\n        \"title\": \"Start Value\",\n        \"calc_func\": \"get_init_cash\",\n        \"tags\": \"portfolio\"\n    },\n    \"end_value\": {\n        \"title\": \"End Value\",\n        \"calc_func\": \"final_value\",\n        \"tags\": \"portfolio\"\n    },\n    \"total_return\": {\n        \"title\": \"Total Return [%]\",\n        \"calc_func\": \"total_return\",\n        \"post_calc_func\": \"&lt;function Portfolio.&lt;lambda&gt; at 0x7ff535ef68c8&gt;\",\n        \"tags\": \"portfolio\"\n    },\n    \"benchmark_return\": {\n        \"title\": \"Benchmark Return [%]\",\n        \"calc_func\": \"benchmark_rets.vbt.returns.total\",\n        \"post_calc_func\": \"&lt;function Portfolio.&lt;lambda&gt; at 0x7ff535ef6950&gt;\",\n        \"tags\": \"portfolio\"\n    },\n    \"max_gross_exposure\": {\n        \"title\": \"Max Gross Exposure [%]\",\n        \"calc_func\": \"gross_exposure.vbt.max\",\n        \"post_calc_func\": \"&lt;function Portfolio.&lt;lambda&gt; at 0x7ff535ef69d8&gt;\",\n        \"tags\": \"portfolio\"\n    },\n    \"total_fees_paid\": {\n        \"title\": \"Total Fees Paid\",\n        \"calc_func\": \"orders.fees.sum\",\n        \"tags\": [\n            \"portfolio\",\n            \"orders\"\n        ]\n    },\n    \"max_dd\": {\n        \"title\": \"Max Drawdown [%]\",\n        \"calc_func\": \"drawdowns.max_drawdown\",\n        \"post_calc_func\": \"&lt;function Portfolio.&lt;lambda&gt; at 0x7ff535ef6a60&gt;\",\n        \"tags\": [\n            \"portfolio\",\n            \"drawdowns\"\n        ]\n    },\n    \"max_dd_duration\": {\n        \"title\": \"Max Drawdown Duration\",\n        \"calc_func\": \"drawdowns.max_duration\",\n        \"fill_wrap_kwargs\": true,\n        \"tags\": [\n            \"portfolio\",\n            \"drawdowns\",\n            \"duration\"\n        ]\n    },\n    \"total_trades\": {\n        \"title\": \"Total Trades\",\n        \"calc_func\": \"trades.count\",\n        \"incl_open\": true,\n        \"tags\": [\n            \"portfolio\",\n            \"trades\"\n        ]\n    },\n    \"total_closed_trades\": {\n        \"title\": \"Total Closed Trades\",\n        \"calc_func\": \"trades.closed.count\",\n        \"tags\": [\n            \"portfolio\",\n            \"trades\",\n            \"closed\"\n        ]\n    },\n    \"total_open_trades\": {\n        \"title\": \"Total Open Trades\",\n        \"calc_func\": \"trades.open.count\",\n        \"incl_open\": true,\n        \"tags\": [\n            \"portfolio\",\n            \"trades\",\n            \"open\"\n        ]\n    },\n    \"open_trade_pnl\": {\n        \"title\": \"Open Trade PnL\",\n        \"calc_func\": \"trades.open.pnl.sum\",\n        \"incl_open\": true,\n        \"tags\": [\n            \"portfolio\",\n            \"trades\",\n            \"open\"\n        ]\n    },\n    \"win_rate\": {\n        \"title\": \"Win Rate [%]\",\n        \"calc_func\": \"trades.win_rate\",\n        \"post_calc_func\": \"&lt;function Portfolio.&lt;lambda&gt; at 0x7ff535ef6ae8&gt;\",\n        \"tags\": \"RepEval(expression=\\\"['portfolio', 'trades', *incl_open_tags]\\\", mapping={})\"\n    },\n    \"best_trade\": {\n        \"title\": \"Best Trade [%]\",\n        \"calc_func\": \"trades.returns.max\",\n        \"post_calc_func\": \"&lt;function Portfolio.&lt;lambda&gt; at 0x7ff535ef6b70&gt;\",\n        \"tags\": \"RepEval(expression=\\\"['portfolio', 'trades', *incl_open_tags]\\\", mapping={})\"\n    },\n    \"worst_trade\": {\n        \"title\": \"Worst Trade [%]\",\n        \"calc_func\": \"trades.returns.min\",\n        \"post_calc_func\": \"&lt;function Portfolio.&lt;lambda&gt; at 0x7ff535ef6bf8&gt;\",\n        \"tags\": \"RepEval(expression=\\\"['portfolio', 'trades', *incl_open_tags]\\\", mapping={})\"\n    },\n    \"avg_winning_trade\": {\n        \"title\": \"Avg Winning Trade [%]\",\n        \"calc_func\": \"trades.winning.returns.mean\",\n        \"post_calc_func\": \"&lt;function Portfolio.&lt;lambda&gt; at 0x7ff535ef6c80&gt;\",\n        \"tags\": \"RepEval(expression=\\\"['portfolio', 'trades', *incl_open_tags, 'winning']\\\", mapping={})\"\n    },\n    \"avg_losing_trade\": {\n        \"title\": \"Avg Losing Trade [%]\",\n        \"calc_func\": \"trades.losing.returns.mean\",\n        \"post_calc_func\": \"&lt;function Portfolio.&lt;lambda&gt; at 0x7ff535ef6d08&gt;\",\n        \"tags\": \"RepEval(expression=\\\"['portfolio', 'trades', *incl_open_tags, 'losing']\\\", mapping={})\"\n    },\n    \"avg_winning_trade_duration\": {\n        \"title\": \"Avg Winning Trade Duration\",\n        \"calc_func\": \"trades.winning.duration.mean\",\n        \"apply_to_timedelta\": true,\n        \"tags\": \"RepEval(expression=\\\"['portfolio', 'trades', *incl_open_tags, 'winning', 'duration']\\\", mapping={})\"\n    },\n    \"avg_losing_trade_duration\": {\n        \"title\": \"Avg Losing Trade Duration\",\n        \"calc_func\": \"trades.losing.duration.mean\",\n        \"apply_to_timedelta\": true,\n        \"tags\": \"RepEval(expression=\\\"['portfolio', 'trades', *incl_open_tags, 'losing', 'duration']\\\", mapping={})\"\n    },\n    \"profit_factor\": {\n        \"title\": \"Profit Factor\",\n        \"calc_func\": \"trades.profit_factor\",\n        \"tags\": \"RepEval(expression=\\\"['portfolio', 'trades', *incl_open_tags]\\\", mapping={})\"\n    },\n    \"expectancy\": {\n        \"title\": \"Expectancy\",\n        \"calc_func\": \"trades.expectancy\",\n        \"tags\": \"RepEval(expression=\\\"['portfolio', 'trades', *incl_open_tags]\\\", mapping={})\"\n    },\n    \"sharpe_ratio\": {\n        \"title\": \"Sharpe Ratio\",\n        \"calc_func\": \"returns_acc.sharpe_ratio\",\n        \"check_has_freq\": true,\n        \"check_has_year_freq\": true,\n        \"tags\": [\n            \"portfolio\",\n            \"returns\"\n        ]\n    },\n    \"calmar_ratio\": {\n        \"title\": \"Calmar Ratio\",\n        \"calc_func\": \"returns_acc.calmar_ratio\",\n        \"check_has_freq\": true,\n        \"check_has_year_freq\": true,\n        \"tags\": [\n            \"portfolio\",\n            \"returns\"\n        ]\n    },\n    \"omega_ratio\": {\n        \"title\": \"Omega Ratio\",\n        \"calc_func\": \"returns_acc.omega_ratio\",\n        \"check_has_freq\": true,\n        \"check_has_year_freq\": true,\n        \"tags\": [\n            \"portfolio\",\n            \"returns\"\n        ]\n    },\n    \"sortino_ratio\": {\n        \"title\": \"Sortino Ratio\",\n        \"calc_func\": \"returns_acc.sortino_ratio\",\n        \"check_has_freq\": true,\n        \"check_has_year_freq\": true,\n        \"tags\": [\n            \"portfolio\",\n            \"returns\"\n        ]\n    }\n})\n</code></pre> <p>Returns <code>Portfolio._metrics</code>, which gets (deep) copied upon creation of each instance. Thus, changing this config won't affect the class.</p> <p>To change metrics, you can either change the config in-place, override this property, or overwrite the instance variable <code>Portfolio._metrics</code>.</p>","title":"metrics class variable"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.subplots","text":"<p>Subplots supported by Portfolio.</p> <pre><code>Config({\n    \"orders\": {\n        \"title\": \"Orders\",\n        \"yaxis_kwargs\": {\n            \"title\": \"Price\"\n        },\n        \"check_is_not_grouped\": true,\n        \"plot_func\": \"orders.plot\",\n        \"tags\": [\n            \"portfolio\",\n            \"orders\"\n        ]\n    },\n    \"trades\": {\n        \"title\": \"Trades\",\n        \"yaxis_kwargs\": {\n            \"title\": \"Price\"\n        },\n        \"check_is_not_grouped\": true,\n        \"plot_func\": \"trades.plot\",\n        \"tags\": [\n            \"portfolio\",\n            \"trades\"\n        ]\n    },\n    \"trade_pnl\": {\n        \"title\": \"Trade PnL\",\n        \"yaxis_kwargs\": {\n            \"title\": \"Trade PnL\"\n        },\n        \"check_is_not_grouped\": true,\n        \"plot_func\": \"trades.plot_pnl\",\n        \"tags\": [\n            \"portfolio\",\n            \"trades\"\n        ]\n    },\n    \"asset_flow\": {\n        \"title\": \"Asset Flow\",\n        \"yaxis_kwargs\": {\n            \"title\": \"Asset flow\"\n        },\n        \"check_is_not_grouped\": true,\n        \"plot_func\": \"plot_asset_flow\",\n        \"pass_add_trace_kwargs\": true,\n        \"tags\": [\n            \"portfolio\",\n            \"assets\"\n        ]\n    },\n    \"cash_flow\": {\n        \"title\": \"Cash Flow\",\n        \"yaxis_kwargs\": {\n            \"title\": \"Cash flow\"\n        },\n        \"plot_func\": \"plot_cash_flow\",\n        \"pass_add_trace_kwargs\": true,\n        \"tags\": [\n            \"portfolio\",\n            \"cash\"\n        ]\n    },\n    \"assets\": {\n        \"title\": \"Assets\",\n        \"yaxis_kwargs\": {\n            \"title\": \"Assets\"\n        },\n        \"check_is_not_grouped\": true,\n        \"plot_func\": \"plot_assets\",\n        \"pass_add_trace_kwargs\": true,\n        \"tags\": [\n            \"portfolio\",\n            \"assets\"\n        ]\n    },\n    \"cash\": {\n        \"title\": \"Cash\",\n        \"yaxis_kwargs\": {\n            \"title\": \"Cash\"\n        },\n        \"plot_func\": \"plot_cash\",\n        \"pass_add_trace_kwargs\": true,\n        \"tags\": [\n            \"portfolio\",\n            \"cash\"\n        ]\n    },\n    \"asset_value\": {\n        \"title\": \"Asset Value\",\n        \"yaxis_kwargs\": {\n            \"title\": \"Asset value\"\n        },\n        \"plot_func\": \"plot_asset_value\",\n        \"pass_add_trace_kwargs\": true,\n        \"tags\": [\n            \"portfolio\",\n            \"assets\",\n            \"value\"\n        ]\n    },\n    \"value\": {\n        \"title\": \"Value\",\n        \"yaxis_kwargs\": {\n            \"title\": \"Value\"\n        },\n        \"plot_func\": \"plot_value\",\n        \"pass_add_trace_kwargs\": true,\n        \"tags\": [\n            \"portfolio\",\n            \"value\"\n        ]\n    },\n    \"cum_returns\": {\n        \"title\": \"Cumulative Returns\",\n        \"yaxis_kwargs\": {\n            \"title\": \"Cumulative returns\"\n        },\n        \"plot_func\": \"plot_cum_returns\",\n        \"pass_hline_shape_kwargs\": true,\n        \"pass_add_trace_kwargs\": true,\n        \"pass_xref\": true,\n        \"pass_yref\": true,\n        \"tags\": [\n            \"portfolio\",\n            \"returns\"\n        ]\n    },\n    \"drawdowns\": {\n        \"title\": \"Drawdowns\",\n        \"yaxis_kwargs\": {\n            \"title\": \"Value\"\n        },\n        \"plot_func\": \"plot_drawdowns\",\n        \"pass_add_trace_kwargs\": true,\n        \"pass_xref\": true,\n        \"pass_yref\": true,\n        \"tags\": [\n            \"portfolio\",\n            \"value\",\n            \"drawdowns\"\n        ]\n    },\n    \"underwater\": {\n        \"title\": \"Underwater\",\n        \"yaxis_kwargs\": {\n            \"title\": \"Drawdown\"\n        },\n        \"plot_func\": \"plot_underwater\",\n        \"pass_add_trace_kwargs\": true,\n        \"tags\": [\n            \"portfolio\",\n            \"value\",\n            \"drawdowns\"\n        ]\n    },\n    \"gross_exposure\": {\n        \"title\": \"Gross Exposure\",\n        \"yaxis_kwargs\": {\n            \"title\": \"Gross exposure\"\n        },\n        \"plot_func\": \"plot_gross_exposure\",\n        \"pass_add_trace_kwargs\": true,\n        \"tags\": [\n            \"portfolio\",\n            \"exposure\"\n        ]\n    },\n    \"net_exposure\": {\n        \"title\": \"Net Exposure\",\n        \"yaxis_kwargs\": {\n            \"title\": \"Net exposure\"\n        },\n        \"plot_func\": \"plot_net_exposure\",\n        \"pass_add_trace_kwargs\": true,\n        \"tags\": [\n            \"portfolio\",\n            \"exposure\"\n        ]\n    }\n})\n</code></pre> <p>Returns <code>Portfolio._subplots</code>, which gets (deep) copied upon creation of each instance. Thus, changing this config won't affect the class.</p> <p>To change subplots, you can either change the config in-place, override this property, or overwrite the instance variable <code>Portfolio._subplots</code>.</p>","title":"subplots class variable"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.from_holding","text":"<pre><code>Portfolio.from_holding(\n    close,\n    **kwargs\n)\n</code></pre> <p>Simulate portfolio from holding.</p> <p>Based on Portfolio.from_signals().</p> <pre><code>&gt;&gt;&gt; close = pd.Series([1, 2, 3, 4, 5])\n&gt;&gt;&gt; pf = vbt.Portfolio.from_holding(close)\n&gt;&gt;&gt; pf.final_value()\n500.0\n</code></pre>","title":"from_holding class method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.from_order_func","text":"<pre><code>Portfolio.from_order_func(\n    close,\n    order_func_nb,\n    *order_args,\n    flexible=None,\n    init_cash=None,\n    cash_sharing=None,\n    call_seq=None,\n    segment_mask=None,\n    call_pre_segment=None,\n    call_post_segment=None,\n    pre_sim_func_nb=no_pre_func_nb,\n    pre_sim_args=(),\n    post_sim_func_nb=no_post_func_nb,\n    post_sim_args=(),\n    pre_group_func_nb=no_pre_func_nb,\n    pre_group_args=(),\n    post_group_func_nb=no_post_func_nb,\n    post_group_args=(),\n    pre_row_func_nb=no_pre_func_nb,\n    pre_row_args=(),\n    post_row_func_nb=no_post_func_nb,\n    post_row_args=(),\n    pre_segment_func_nb=no_pre_func_nb,\n    pre_segment_args=(),\n    post_segment_func_nb=no_post_func_nb,\n    post_segment_args=(),\n    post_order_func_nb=no_post_func_nb,\n    post_order_args=(),\n    ffill_val_price=None,\n    update_value=None,\n    fill_pos_record=None,\n    row_wise=None,\n    use_numba=None,\n    max_orders=None,\n    max_logs=None,\n    seed=None,\n    group_by=None,\n    broadcast_named_args=None,\n    broadcast_kwargs=None,\n    template_mapping=None,\n    wrapper_kwargs=None,\n    freq=None,\n    attach_call_seq=None,\n    **kwargs\n)\n</code></pre> <p>Build portfolio from a custom order function.</p>  <p>Hint</p> <p>See simulate_nb() for illustrations and argument definitions.</p>  <p>For more details on individual simulation functions:</p> <ul> <li>not <code>row_wise</code> and not <code>flexible</code>: See simulate_nb()</li> <li>not <code>row_wise</code> and <code>flexible</code>: See flex_simulate_nb()</li> <li><code>row_wise</code> and not <code>flexible</code>: See simulate_row_wise_nb()</li> <li><code>row_wise</code> and <code>flexible</code>: See flex_simulate_row_wise_nb()</li> </ul> <p>Args</p>  <code>close</code> :\u2002<code>array_like</code>  <p>Last asset price at each time step. Will broadcast to <code>target_shape</code>.</p> <p>Used for calculating unrealized PnL and portfolio value.</p>  <code>order_func_nb</code> :\u2002<code>callable</code> Order generation function. <code>*order_args</code> Arguments passed to <code>order_func_nb</code>. <code>flexible</code> :\u2002<code>bool</code>  <p>Whether to simulate using a flexible order function.</p> <p>This lifts the limit of one order per tick and symbol.</p>  <code>init_cash</code> :\u2002<code>InitCashMode</code>, <code>float</code> or <code>array_like</code> of <code>float</code>  <p>Initial capital.</p> <p>See <code>init_cash</code> in Portfolio.from_orders().</p>  <code>cash_sharing</code> :\u2002<code>bool</code>  <p>Whether to share cash within the same group.</p> <p>If <code>group_by</code> is None, <code>group_by</code> becomes True to form a single group with cash sharing.</p>  <code>call_seq</code> :\u2002<code>CallSeqType</code> or <code>array_like</code>  <p>Default sequence of calls per row and group.</p> <ul> <li>Use CallSeqType to select a sequence type.</li> <li>Set to array to specify custom sequence. Will not broadcast.</li> </ul>  <p>Note</p> <p>CallSeqType.Auto should be implemented manually. Use sort_call_seq_nb() or sort_call_seq_out_nb() in <code>pre_segment_func_nb</code>.</p>   <code>segment_mask</code> :\u2002<code>int</code> or <code>array_like</code> of <code>bool</code>  <p>Mask of whether a particular segment should be executed.</p> <p>Supplying an integer will activate every n-th row. Supplying a boolean or an array of boolean will broadcast to the number of rows and groups.</p> <p>Does not broadcast together with <code>close</code> and <code>broadcast_named_args</code>, only against the final shape.</p>  <code>call_pre_segment</code> :\u2002<code>bool</code> Whether to call <code>pre_segment_func_nb</code> regardless of <code>segment_mask</code>. <code>call_post_segment</code> :\u2002<code>bool</code> Whether to call <code>post_segment_func_nb</code> regardless of <code>segment_mask</code>. <code>pre_sim_func_nb</code> :\u2002<code>callable</code> Function called before simulation. Defaults to no_pre_func_nb(). <code>pre_sim_args</code> :\u2002<code>tuple</code> Packed arguments passed to <code>pre_sim_func_nb</code>. Defaults to <code>()</code>. <code>post_sim_func_nb</code> :\u2002<code>callable</code> Function called after simulation. Defaults to no_post_func_nb(). <code>post_sim_args</code> :\u2002<code>tuple</code> Packed arguments passed to <code>post_sim_func_nb</code>. Defaults to <code>()</code>. <code>pre_group_func_nb</code> :\u2002<code>callable</code>  <p>Function called before each group. Defaults to no_pre_func_nb().</p> <p>Called only if <code>row_wise</code> is False.</p>  <code>pre_group_args</code> :\u2002<code>tuple</code> Packed arguments passed to <code>pre_group_func_nb</code>. Defaults to <code>()</code>. <code>post_group_func_nb</code> :\u2002<code>callable</code>  <p>Function called after each group. Defaults to no_post_func_nb().</p> <p>Called only if <code>row_wise</code> is False.</p>  <code>post_group_args</code> :\u2002<code>tuple</code> Packed arguments passed to <code>post_group_func_nb</code>. Defaults to <code>()</code>. <code>pre_row_func_nb</code> :\u2002<code>callable</code>  <p>Function called before each row. Defaults to no_pre_func_nb().</p> <p>Called only if <code>row_wise</code> is True.</p>  <code>pre_row_args</code> :\u2002<code>tuple</code> Packed arguments passed to <code>pre_row_func_nb</code>. Defaults to <code>()</code>. <code>post_row_func_nb</code> :\u2002<code>callable</code>  <p>Function called after each row. Defaults to no_post_func_nb().</p> <p>Called only if <code>row_wise</code> is True.</p>  <code>post_row_args</code> :\u2002<code>tuple</code> Packed arguments passed to <code>post_row_func_nb</code>. Defaults to <code>()</code>. <code>pre_segment_func_nb</code> :\u2002<code>callable</code> Function called before each segment. Defaults to no_pre_func_nb(). <code>pre_segment_args</code> :\u2002<code>tuple</code> Packed arguments passed to <code>pre_segment_func_nb</code>. Defaults to <code>()</code>. <code>post_segment_func_nb</code> :\u2002<code>callable</code> Function called after each segment. Defaults to no_post_func_nb(). <code>post_segment_args</code> :\u2002<code>tuple</code> Packed arguments passed to <code>post_segment_func_nb</code>. Defaults to <code>()</code>. <code>post_order_func_nb</code> :\u2002<code>callable</code> Callback that is called after the order has been processed. <code>post_order_args</code> :\u2002<code>tuple</code> Packed arguments passed to <code>post_order_func_nb</code>. Defaults to <code>()</code>. <code>ffill_val_price</code> :\u2002<code>bool</code>  <p>Whether to track valuation price only if it's known.</p> <p>Otherwise, unknown <code>close</code> will lead to NaN in valuation price at the next timestamp.</p>  <code>update_value</code> :\u2002<code>bool</code> Whether to update group value after each filled order. <code>fill_pos_record</code> :\u2002<code>bool</code>  <p>Whether to fill position record.</p> <p>Disable this to make simulation a bit faster for simple use cases.</p>  <code>row_wise</code> :\u2002<code>bool</code> Whether to iterate over rows rather than columns/groups. <code>use_numba</code> :\u2002<code>bool</code>  <p>Whether to run the main simulation function using Numba.</p>  <p>Note</p> <p>Disabling it does not disable Numba for other functions. If neccessary, you should ensure that every other function does not uses Numba as well. You can do this by using the <code>py_func</code> attribute of that function. Or, you could disable Numba globally by doing <code>os.environ['NUMBA_DISABLE_JIT'] = '1'</code>.</p>   <code>max_orders</code> :\u2002<code>int</code>  <p>Size of the order records array. Defaults to the number of elements in the broadcasted shape.</p> <p>Set to a lower number if you run out of memory.</p>  <code>max_logs</code> :\u2002<code>int</code>  <p>Size of the log records array. Defaults to the number of elements in the broadcasted shape.</p> <p>Set to a lower number if you run out of memory.</p>  <code>seed</code> :\u2002<code>int</code> See Portfolio.from_orders(). <code>group_by</code> :\u2002<code>any</code> See Portfolio.from_orders(). <code>broadcast_named_args</code> :\u2002<code>dict</code> See Portfolio.from_signals(). <code>broadcast_kwargs</code> :\u2002<code>dict</code> See Portfolio.from_orders(). <code>template_mapping</code> :\u2002<code>mapping</code> See Portfolio.from_signals(). <code>wrapper_kwargs</code> :\u2002<code>dict</code> See Portfolio.from_orders(). <code>freq</code> :\u2002<code>any</code> See Portfolio.from_orders(). <code>attach_call_seq</code> :\u2002<code>bool</code> See Portfolio.from_orders(). <code>**kwargs</code> Keyword arguments passed to the <code>__init__</code> method.  <p>For defaults, see <code>portfolio</code> in settings.</p>  <p>Note</p> <p>All passed functions should be Numba-compiled if Numba is enabled.</p> <p>Also see notes on Portfolio.from_orders().</p>   <p>Note</p> <p>In contrast to other methods, the valuation price is previous <code>close</code> instead of the order price since the price of an order is unknown before the call (which is more realistic by the way). You can still override the valuation price in <code>pre_segment_func_nb</code>.</p>  <p>Usage</p> <ul> <li>Buy 10 units each tick using closing price:</li> </ul> <pre><code>&gt;&gt;&gt; @njit\n... def order_func_nb(c, size):\n...     return nb.order_nb(size=size)\n\n&gt;&gt;&gt; close = pd.Series([1, 2, 3, 4, 5])\n&gt;&gt;&gt; pf = vbt.Portfolio.from_order_func(close, order_func_nb, 10)\n\n&gt;&gt;&gt; pf.assets()\n0    10.0\n1    20.0\n2    30.0\n3    40.0\n4    40.0\ndtype: float64\n&gt;&gt;&gt; pf.cash()\n0    90.0\n1    70.0\n2    40.0\n3     0.0\n4     0.0\ndtype: float64\n</code></pre> <ul> <li>Reverse each position by first closing it. Keep state of last position to determine which position to open next (just as an example, there are easier ways to do this):</li> </ul> <pre><code>&gt;&gt;&gt; @njit\n... def pre_group_func_nb(c):\n...     last_pos_state = np.array([-1])\n...     return (last_pos_state,)\n\n&gt;&gt;&gt; @njit\n... def order_func_nb(c, last_pos_state):\n...     if c.position_now != 0:\n...         return nb.close_position_nb()\n...\n...     if last_pos_state[0] == 1:\n...         size = -np.inf  # open short\n...         last_pos_state[0] = -1\n...     else:\n...         size = np.inf  # open long\n...         last_pos_state[0] = 1\n...     return nb.order_nb(size=size)\n\n&gt;&gt;&gt; pf = vbt.Portfolio.from_order_func(\n...     close,\n...     order_func_nb,\n...     pre_group_func_nb=pre_group_func_nb\n... )\n\n&gt;&gt;&gt; pf.assets()\n0    100.000000\n1      0.000000\n2    -66.666667\n3      0.000000\n4     26.666667\ndtype: float64\n&gt;&gt;&gt; pf.cash()\n0      0.000000\n1    200.000000\n2    400.000000\n3    133.333333\n4      0.000000\ndtype: float64\n</code></pre> <ul> <li>Equal-weighted portfolio as in the example under simulate_nb():</li> </ul> <pre><code>&gt;&gt;&gt; @njit\n... def pre_group_func_nb(c):\n...     order_value_out = np.empty(c.group_len, dtype=np.float_)\n...     return (order_value_out,)\n\n&gt;&gt;&gt; @njit\n... def pre_segment_func_nb(c, order_value_out, size, price, size_type, direction):\n...     for col in range(c.from_col, c.to_col):\n...         c.last_val_price[col] = nb.get_col_elem_nb(c, col, price)\n...     nb.sort_call_seq_nb(c, size, size_type, direction, order_value_out)\n...     return ()\n\n&gt;&gt;&gt; @njit\n... def order_func_nb(c, size, price, size_type, direction, fees, fixed_fees, slippage):\n...     return nb.order_nb(\n...         size=nb.get_elem_nb(c, size),\n...         price=nb.get_elem_nb(c, price),\n...         size_type=nb.get_elem_nb(c, size_type),\n...         direction=nb.get_elem_nb(c, direction),\n...         fees=nb.get_elem_nb(c, fees),\n...         fixed_fees=nb.get_elem_nb(c, fixed_fees),\n...         slippage=nb.get_elem_nb(c, slippage)\n...     )\n\n&gt;&gt;&gt; np.random.seed(42)\n&gt;&gt;&gt; close = np.random.uniform(1, 10, size=(5, 3))\n&gt;&gt;&gt; size_template = vbt.RepEval('np.asarray(1 / group_lens[0])')\n\n&gt;&gt;&gt; pf = vbt.Portfolio.from_order_func(\n...     close,\n...     order_func_nb,\n...     size_template,  # order_args as *args\n...     vbt.Rep('price'),\n...     vbt.Rep('size_type'),\n...     vbt.Rep('direction'),\n...     vbt.Rep('fees'),\n...     vbt.Rep('fixed_fees'),\n...     vbt.Rep('slippage'),\n...     segment_mask=2,  # rebalance every second tick\n...     pre_group_func_nb=pre_group_func_nb,\n...     pre_segment_func_nb=pre_segment_func_nb,\n...     pre_segment_args=(\n...         size_template,\n...         vbt.Rep('price'),\n...         vbt.Rep('size_type'),\n...         vbt.Rep('direction')\n...     ),\n...     broadcast_named_args=dict(  # broadcast against each other\n...         price=close,\n...         size_type=SizeType.TargetPercent,\n...         direction=Direction.LongOnly,\n...         fees=0.001,\n...         fixed_fees=1.,\n...         slippage=0.001\n...     ),\n...     template_mapping=dict(np=np),  # required by size_template\n...     cash_sharing=True, group_by=True,  # one group with cash sharing\n... )\n\n&gt;&gt;&gt; pf.asset_value(group_by=False).vbt.plot()\n</code></pre> <p></p> <p>Templates are a very powerful tool to prepare any custom arguments after they are broadcast and before they are passed to the simulation function. In the example above, we use <code>broadcast_named_args</code> to broadcast some arguments against each other and templates to pass those objects to callbacks. Additionally, we used an evaluation template to compute the size based on the number of assets in each group.</p> <p>You may ask: why should we bother using broadcasting and templates if we could just pass <code>size=1/3</code>? Because of flexibility those features provide: we can now pass whatever parameter combinations we want and it will work flawlessly. For example, to create two groups of equally-allocated positions, we need to change only two parameters:</p> <pre><code>&gt;&gt;&gt; close = np.random.uniform(1, 10, size=(5, 6))  # 6 columns instead of 3\n&gt;&gt;&gt; group_by = ['g1', 'g1', 'g1', 'g2', 'g2', 'g2']  # 2 groups instead of 1\n\n&gt;&gt;&gt; pf['g1'].asset_value(group_by=False).vbt.plot()\n&gt;&gt;&gt; pf['g2'].asset_value(group_by=False).vbt.plot()\n</code></pre> <p></p> <p></p> <ul> <li>Combine multiple exit conditions. Exit early if the price hits some threshold before an actual exit:</li> </ul> <pre><code>&gt;&gt;&gt; @njit\n... def pre_sim_func_nb(c):\n...     # We need to define stop price per column once\n...     stop_price = np.full(c.target_shape[1], np.nan, dtype=np.float_)\n...     return (stop_price,)\n\n&gt;&gt;&gt; @njit\n... def order_func_nb(c, stop_price, entries, exits, size):\n...     # Select info related to this order\n...     entry_now = nb.get_elem_nb(c, entries)\n...     exit_now = nb.get_elem_nb(c, exits)\n...     size_now = nb.get_elem_nb(c, size)\n...     price_now = nb.get_elem_nb(c, c.close)\n...     stop_price_now = stop_price[c.col]\n...\n...     # Our logic\n...     if entry_now:\n...         if c.position_now == 0:\n...             return nb.order_nb(\n...                 size=size_now,\n...                 price=price_now,\n...                 direction=Direction.LongOnly)\n...     elif exit_now or price_now &gt;= stop_price_now:\n...         if c.position_now &gt; 0:\n...             return nb.order_nb(\n...                 size=-size_now,\n...                 price=price_now,\n...                 direction=Direction.LongOnly)\n...     return NoOrder\n\n&gt;&gt;&gt; @njit\n... def post_order_func_nb(c, stop_price, stop):\n...     # Same broadcasting as for size\n...     stop_now = nb.get_elem_nb(c, stop)\n...\n...     if c.order_result.status == OrderStatus.Filled:\n...         if c.order_result.side == OrderSide.Buy:\n...             # Position entered: Set stop condition\n...             stop_price[c.col] = (1 + stop_now) * c.order_result.price\n...         else:\n...             # Position exited: Remove stop condition\n...             stop_price[c.col] = np.nan\n\n&gt;&gt;&gt; def simulate(close, entries, exits, size, threshold):\n...     return vbt.Portfolio.from_order_func(\n...         close,\n...         order_func_nb,\n...         vbt.Rep('entries'), vbt.Rep('exits'), vbt.Rep('size'),  # order_args\n...         pre_sim_func_nb=pre_sim_func_nb,\n...         post_order_func_nb=post_order_func_nb,\n...         post_order_args=(vbt.Rep('threshold'),),\n...         broadcast_named_args=dict(  # broadcast against each other\n...             entries=entries,\n...             exits=exits,\n...             size=size,\n...             threshold=threshold\n...         )\n...     )\n\n&gt;&gt;&gt; close = pd.Series([10, 11, 12, 13, 14])\n&gt;&gt;&gt; entries = pd.Series([True, True, False, False, False])\n&gt;&gt;&gt; exits = pd.Series([False, False, False, True, True])\n&gt;&gt;&gt; simulate(close, entries, exits, np.inf, 0.1).asset_flow()\n0    10.0\n1     0.0\n2   -10.0\n3     0.0\n4     0.0\ndtype: float64\n\n&gt;&gt;&gt; simulate(close, entries, exits, np.inf, 0.2).asset_flow()\n0    10.0\n1     0.0\n2   -10.0\n3     0.0\n4     0.0\ndtype: float64\n\n&gt;&gt;&gt; simulate(close, entries, exits, np.nan).asset_flow()\n0    10.0\n1     0.0\n2     0.0\n3   -10.0\n4     0.0\ndtype: float64\n</code></pre> <p>The reason why stop of 10% does not result in an order at the second time step is because it comes at the same time as entry, so it must wait until no entry is present. This can be changed by replacing the statement \"elif\" with \"if\", which would execute an exit regardless if an entry is present (similar to using <code>ConflictMode.Opposite</code> in Portfolio.from_signals()).</p> <p>We can also test the parameter combinations above all at once (thanks to broadcasting):</p> <pre><code>&gt;&gt;&gt; size = pd.DataFrame(\n...     [[0.1, 0.2, np.nan]],\n...     columns=pd.Index(['0.1', '0.2', 'nan'], name='size')\n... )\n&gt;&gt;&gt; simulate(close, entries, exits, np.inf, size).asset_flow()\nsize   0.1   0.2   nan\n0     10.0  10.0  10.0\n1      0.0   0.0   0.0\n2    -10.0 -10.0   0.0\n3      0.0   0.0 -10.0\n4      0.0   0.0   0.0\n</code></pre> <ul> <li>Let's illustrate how to generate multiple orders per symbol and bar. For each bar, buy at open and sell at close:</li> </ul> <pre><code>&gt;&gt;&gt; @njit\n... def flex_order_func_nb(c, open, size):\n...     if c.call_idx == 0:\n...         return c.from_col, nb.order_nb(size=size, price=open[c.i, c.from_col])\n...     if c.call_idx == 1:\n...         return c.from_col, nb.close_position_nb(price=c.close[c.i, c.from_col])\n...     return -1, NoOrder\n\n&gt;&gt;&gt; open = pd.DataFrame({'a': [1, 2, 3], 'b': [4, 5, 6]})\n&gt;&gt;&gt; close = pd.DataFrame({'a': [2, 3, 4], 'b': [3, 4, 5]})\n&gt;&gt;&gt; size = 1\n&gt;&gt;&gt; pf = vbt.Portfolio.from_order_func(\n...     close,\n...     flex_order_func_nb,\n...     to_2d_array(open), size,\n...     flexible=True, max_orders=close.shape[0] * close.shape[1] * 2)\n\n&gt;&gt;&gt; pf.orders.records_readable\n    Order Id  Timestamp Column  Size  Price  Fees  Side\n0          0          0      a   1.0    1.0   0.0   Buy\n1          1          0      a   1.0    2.0   0.0  Sell\n2          2          1      a   1.0    2.0   0.0   Buy\n3          3          1      a   1.0    3.0   0.0  Sell\n4          4          2      a   1.0    3.0   0.0   Buy\n5          5          2      a   1.0    4.0   0.0  Sell\n6          6          0      b   1.0    4.0   0.0   Buy\n7          7          0      b   1.0    3.0   0.0  Sell\n8          8          1      b   1.0    5.0   0.0   Buy\n9          9          1      b   1.0    4.0   0.0  Sell\n10        10          2      b   1.0    6.0   0.0   Buy\n11        11          2      b   1.0    5.0   0.0  Sell\n</code></pre>  <p>Warning</p> <p>Each bar is effectively a black box - we don't know how the price moves inside. Since trades must come in an order that replicates that of the real world, the only reliable pieces of information are the opening and the closing price.</p>","title":"from_order_func class method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.from_orders","text":"<pre><code>Portfolio.from_orders(\n    close,\n    size=None,\n    size_type=None,\n    direction=None,\n    price=None,\n    fees=None,\n    fixed_fees=None,\n    slippage=None,\n    min_size=None,\n    max_size=None,\n    size_granularity=None,\n    reject_prob=None,\n    lock_cash=None,\n    allow_partial=None,\n    raise_reject=None,\n    log=None,\n    val_price=None,\n    init_cash=None,\n    cash_sharing=None,\n    call_seq=None,\n    ffill_val_price=None,\n    update_value=None,\n    max_orders=None,\n    max_logs=None,\n    seed=None,\n    group_by=None,\n    broadcast_kwargs=None,\n    wrapper_kwargs=None,\n    freq=None,\n    attach_call_seq=None,\n    **kwargs\n)\n</code></pre> <p>Simulate portfolio from orders - size, price, fees, and other information.</p> <p>Args</p>  <code>close</code> :\u2002<code>array_like</code>  <p>Last asset price at each time step. Will broadcast.</p> <p>Used for calculating unrealized PnL and portfolio value.</p>  <code>size</code> :\u2002<code>float</code> or <code>array_like</code> Size to order. See Order.size. Will broadcast. <code>size_type</code> :\u2002<code>SizeType</code> or <code>array_like</code>  <p>See SizeType. See Order.size_type. Will broadcast.</p>  <p>Note</p> <p><code>SizeType.Percent</code> does not support position reversal. Switch to a single direction.</p>   <p>Warning</p> <p>Be cautious using <code>SizeType.Percent</code> with <code>call_seq</code> set to 'auto'. To execute sell orders before buy orders, the value of each order in the group needs to be approximated in advance. But since <code>SizeType.Percent</code> depends upon the cash balance, which cannot be calculated in advance since it may change after each order, this can yield a non-optimal call sequence.</p>   <code>direction</code> :\u2002<code>Direction</code> or <code>array_like</code> See Direction. See Order.direction. Will broadcast. <code>price</code> :\u2002<code>array_like</code> of <code>float</code>  <p>Order price. See Order.price. Defaults to <code>np.inf</code>. Will broadcast.</p>  <p>Note</p> <p>Make sure to use the same timestamp for all order prices in the group with cash sharing and <code>call_seq</code> set to <code>CallSeqType.Auto</code>.</p>   <code>fees</code> :\u2002<code>float</code> or <code>array_like</code> Fees in percentage of the order value. See Order.fees. Will broadcast. <code>fixed_fees</code> :\u2002<code>float</code> or <code>array_like</code> Fixed amount of fees to pay per order. See Order.fixed_fees. Will broadcast. <code>slippage</code> :\u2002<code>float</code> or <code>array_like</code> Slippage in percentage of price. See Order.slippage. Will broadcast. <code>min_size</code> :\u2002<code>float</code> or <code>array_like</code> Minimum size for an order to be accepted. See Order.min_size. Will broadcast. <code>max_size</code> :\u2002<code>float</code> or <code>array_like</code>  <p>Maximum size for an order. See Order.max_size. Will broadcast.</p> <p>Will be partially filled if exceeded.</p>  <code>size_granularity</code> :\u2002<code>float</code> or <code>array_like</code> Granularity of the size. See Order.size_granularity. Will broadcast. <code>reject_prob</code> :\u2002<code>float</code> or <code>array_like</code> Order rejection probability. See Order.reject_prob. Will broadcast. <code>lock_cash</code> :\u2002<code>bool</code> or <code>array_like</code> Whether to lock cash when shorting. See Order.lock_cash. Will broadcast. <code>allow_partial</code> :\u2002<code>bool</code> or <code>array_like</code>  <p>Whether to allow partial fills. See Order.allow_partial. Will broadcast.</p> <p>Does not apply when size is <code>np.inf</code>.</p>  <code>raise_reject</code> :\u2002<code>bool</code> or <code>array_like</code> Whether to raise an exception if order gets rejected. See Order.raise_reject. Will broadcast. <code>log</code> :\u2002<code>bool</code> or <code>array_like</code> Whether to log orders. See Order.log. Will broadcast. <code>val_price</code> :\u2002<code>array_like</code> of <code>float</code>  <p>Asset valuation price. Will broadcast.</p> <ul> <li>Any <code>-np.inf</code> element is replaced by the latest valuation price (the previous <code>close</code> or     the latest known valuation price if <code>ffill_val_price</code>).</li> <li>Any <code>np.inf</code> element is replaced by the current order price.</li> </ul> <p>Used at the time of decision making to calculate value of each asset in the group, for example, to convert target value into target amount.</p>  <p>Note</p> <p>In contrast to Portfolio.from_order_func(), order price is known beforehand (kind of), thus <code>val_price</code> is set to the current order price (using <code>np.inf</code>) by default. To valuate using previous close, set it in the settings to <code>-np.inf</code>.</p>   <p>Note</p> <p>Make sure to use timestamp for <code>val_price</code> that comes before timestamps of all orders in the group with cash sharing (previous <code>close</code> for example), otherwise you're cheating yourself.</p>   <code>init_cash</code> :\u2002<code>InitCashMode</code>, <code>float</code> or <code>array_like</code> of <code>float</code>  <p>Initial capital.</p> <p>By default, will broadcast to the number of columns. If cash sharing is enabled, will broadcast to the number of groups. See InitCashMode to find optimal initial cash.</p>  <p>Note</p> <p>Mode <code>InitCashMode.AutoAlign</code> is applied after the portfolio is initialized to set the same initial cash for all columns/groups. Changing grouping will change the initial cash, so be aware when indexing.</p>   <code>cash_sharing</code> :\u2002<code>bool</code>  <p>Whether to share cash within the same group.</p> <p>If <code>group_by</code> is None, <code>group_by</code> becomes True to form a single group with cash sharing.</p>  <p>Warning</p> <p>Introduces cross-asset dependencies.</p> <p>This method presumes that in a group of assets that share the same capital all orders will be executed within the same tick and retain their price regardless of their position in the queue, even though they depend upon each other and thus cannot be executed in parallel.</p>   <code>call_seq</code> :\u2002<code>CallSeqType</code> or <code>array_like</code>  <p>Default sequence of calls per row and group.</p> <p>Each value in this sequence should indicate the position of column in the group to call next. Processing of <code>call_seq</code> goes always from left to right. For example, <code>[2, 0, 1]</code> would first call column 'c', then 'a', and finally 'b'.</p> <ul> <li>Use CallSeqType to select a sequence type.</li> <li>Set to array to specify custom sequence. Will not broadcast.</li> </ul> <p>If <code>CallSeqType.Auto</code> selected, rearranges calls dynamically based on order value. Calculates value of all orders per row and group, and sorts them by this value. Sell orders will be executed first to release funds for buy orders.</p>  <p>Warning</p> <p><code>CallSeqType.Auto</code> should be used with caution:</p> <ul> <li>It not only presumes that order prices are known beforehand, but also that     orders can be executed in arbitrary order and still retain their price.     In reality, this is hardly the case: after processing one asset, some time     has passed and the price for other assets might have already changed.</li> <li>Even if you're able to specify a slippage large enough to compensate for     this behavior, slippage itself should depend upon execution order.     This method doesn't let you do that.</li> <li>If one order is rejected, it still may execute next orders and possibly     leave them without required funds.</li> </ul> <p>For more control, use Portfolio.from_order_func().</p>   <code>ffill_val_price</code> :\u2002<code>bool</code>  <p>Whether to track valuation price only if it's known.</p> <p>Otherwise, unknown <code>close</code> will lead to NaN in valuation price at the next timestamp.</p>  <code>update_value</code> :\u2002<code>bool</code> Whether to update group value after each filled order. <code>max_orders</code> :\u2002<code>int</code>  <p>Size of the order records array. Defaults to the number of elements in the broadcasted shape.</p> <p>Set to a lower number if you run out of memory.</p>  <code>max_logs</code> :\u2002<code>int</code>  <p>Size of the log records array. Defaults to the number of elements in the broadcasted shape if any of the <code>log</code> is True, otherwise to 1.</p> <p>Set to a lower number if you run out of memory.</p>  <code>seed</code> :\u2002<code>int</code> Seed to be set for both <code>call_seq</code> and at the beginning of the simulation. <code>group_by</code> :\u2002<code>any</code> Group columns. See ColumnGrouper. <code>broadcast_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to broadcast(). <code>wrapper_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to ArrayWrapper. <code>freq</code> :\u2002<code>any</code> Index frequency in case it cannot be parsed from <code>close</code>. <code>attach_call_seq</code> :\u2002<code>bool</code>  <p>Whether to pass <code>call_seq</code> to the constructor.</p> <p>Makes sense if you want to analyze some metrics in the simulation order. Otherwise, just takes memory.</p>  <code>**kwargs</code> Keyword arguments passed to the <code>__init__</code> method.  <p>All broadcastable arguments will broadcast using broadcast() but keep original shape to utilize flexible indexing and to save memory.</p> <p>For defaults, see <code>portfolio</code> in settings.</p>  <p>Note</p> <p>When <code>call_seq</code> is not <code>CallSeqType.Auto</code>, at each timestamp, processing of the assets in a group goes strictly in order defined in <code>call_seq</code>. This order can't be changed dynamically.</p> <p>This has one big implication for this particular method: the last asset in the call stack cannot be processed until other assets are processed. This is the reason why rebalancing cannot work properly in this setting: one has to specify percentages for all assets beforehand and then tweak the processing order to sell to-be-sold assets first in order to release funds for to-be-bought assets. This can be automatically done by using <code>CallSeqType.Auto</code>.</p>   <p>Hint</p> <p>All broadcastable arguments can be set per frame, series, row, column, or element.</p>  <p>Usage</p> <ul> <li>Buy 10 units each tick:</li> </ul> <pre><code>&gt;&gt;&gt; close = pd.Series([1, 2, 3, 4, 5])\n&gt;&gt;&gt; pf = vbt.Portfolio.from_orders(close, 10)\n\n&gt;&gt;&gt; pf.assets()\n0    10.0\n1    20.0\n2    30.0\n3    40.0\n4    40.0\ndtype: float64\n&gt;&gt;&gt; pf.cash()\n0    90.0\n1    70.0\n2    40.0\n3     0.0\n4     0.0\ndtype: float64\n</code></pre> <ul> <li>Reverse each position by first closing it:</li> </ul> <pre><code>&gt;&gt;&gt; size = [1, 0, -1, 0, 1]\n&gt;&gt;&gt; pf = vbt.Portfolio.from_orders(close, size, size_type='targetpercent')\n\n&gt;&gt;&gt; pf.assets()\n0    100.000000\n1      0.000000\n2    -66.666667\n3      0.000000\n4     26.666667\ndtype: float64\n&gt;&gt;&gt; pf.cash()\n0      0.000000\n1    200.000000\n2    400.000000\n3    133.333333\n4      0.000000\ndtype: float64\n</code></pre> <ul> <li>Equal-weighted portfolio as in simulate_nb() example (it's more compact but has less control over execution):</li> </ul> <pre><code>&gt;&gt;&gt; np.random.seed(42)\n&gt;&gt;&gt; close = pd.DataFrame(np.random.uniform(1, 10, size=(5, 3)))\n&gt;&gt;&gt; size = pd.Series(np.full(5, 1/3))  # each column 33.3%\n&gt;&gt;&gt; size[1::2] = np.nan  # skip every second tick\n\n&gt;&gt;&gt; pf = vbt.Portfolio.from_orders(\n...     close,  # acts both as reference and order price here\n...     size,\n...     size_type='targetpercent',\n...     call_seq='auto',  # first sell then buy\n...     group_by=True,  # one group\n...     cash_sharing=True,  # assets share the same cash\n...     fees=0.001, fixed_fees=1., slippage=0.001  # costs\n... )\n\n&gt;&gt;&gt; pf.asset_value(group_by=False).vbt.plot()\n</code></pre> <p></p>","title":"from_orders class method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.from_random_signals","text":"<pre><code>Portfolio.from_random_signals(\n    close,\n    n=None,\n    prob=None,\n    entry_prob=None,\n    exit_prob=None,\n    param_product=False,\n    seed=None,\n    run_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Simulate portfolio from random entry and exit signals.</p> <p>Generates signals based either on the number of signals <code>n</code> or the probability of encountering a signal <code>prob</code>.</p> <ul> <li>If <code>n</code> is set, see RANDNX.</li> <li>If <code>prob</code> is set, see RPROBNX.</li> </ul> <p>Based on Portfolio.from_signals().</p>  <p>Note</p> <p>To generate random signals, the shape of <code>close</code> is used. Broadcasting with other arrays happens after the generation.</p>  <p>Usage</p> <ul> <li>Test multiple combinations of random entries and exits:</li> </ul> <pre><code>&gt;&gt;&gt; close = pd.Series([1, 2, 3, 4, 5])\n&gt;&gt;&gt; pf = vbt.Portfolio.from_random_signals(close, n=[2, 1, 0], seed=42)\n&gt;&gt;&gt; pf.orders.count()\nrandnx_n\n2    4\n1    2\n0    0\nName: count, dtype: int64\n</code></pre> <ul> <li>Test the Cartesian product of entry and exit encounter probabilities:</li> </ul> <pre><code>&gt;&gt;&gt; pf = vbt.Portfolio.from_random_signals(\n...     close,\n...     entry_prob=[0, 0.5, 1],\n...     exit_prob=[0, 0.5, 1],\n...     param_product=True,\n...     seed=42)\n&gt;&gt;&gt; pf.orders.count()\nrprobnx_entry_prob  rprobnx_exit_prob\n0.0                 0.0                  0\n                    0.5                  0\n                    1.0                  0\n0.5                 0.0                  1\n                    0.5                  4\n                    1.0                  3\n1.0                 0.0                  1\n                    0.5                  4\n                    1.0                  5\nName: count, dtype: int64\n</code></pre>","title":"from_random_signals class method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.from_signals","text":"<pre><code>Portfolio.from_signals(\n    close,\n    entries=None,\n    exits=None,\n    short_entries=None,\n    short_exits=None,\n    signal_func_nb=no_signal_func_nb,\n    signal_args=(),\n    size=None,\n    size_type=None,\n    price=None,\n    fees=None,\n    fixed_fees=None,\n    slippage=None,\n    min_size=None,\n    max_size=None,\n    size_granularity=None,\n    reject_prob=None,\n    lock_cash=None,\n    allow_partial=None,\n    raise_reject=None,\n    log=None,\n    accumulate=None,\n    upon_long_conflict=None,\n    upon_short_conflict=None,\n    upon_dir_conflict=None,\n    upon_opposite_entry=None,\n    direction=None,\n    val_price=None,\n    open=None,\n    high=None,\n    low=None,\n    sl_stop=None,\n    sl_trail=None,\n    tp_stop=None,\n    stop_entry_price=None,\n    stop_exit_price=None,\n    upon_stop_exit=None,\n    upon_stop_update=None,\n    adjust_sl_func_nb=no_adjust_sl_func_nb,\n    adjust_sl_args=(),\n    adjust_tp_func_nb=no_adjust_tp_func_nb,\n    adjust_tp_args=(),\n    use_stops=None,\n    init_cash=None,\n    cash_sharing=None,\n    call_seq=None,\n    ffill_val_price=None,\n    update_value=None,\n    max_orders=None,\n    max_logs=None,\n    seed=None,\n    group_by=None,\n    broadcast_named_args=None,\n    broadcast_kwargs=None,\n    template_mapping=None,\n    wrapper_kwargs=None,\n    freq=None,\n    attach_call_seq=None,\n    **kwargs\n)\n</code></pre> <p>Simulate portfolio from entry and exit signals.</p> <p>See simulate_from_signal_func_nb().</p> <p>You have three options to provide signals:</p> <ul> <li> <p><code>entries</code> and <code>exits</code>: The direction of each pair of signals is taken from <code>direction</code> argument.     Best to use when the direction doesn't change throughout time.</p> <p>Uses dir_enex_signal_func_nb() as <code>signal_func_nb</code>.</p>  <p>Hint</p> <p><code>entries</code> and <code>exits</code> can be easily translated to direction-aware signals:</p> <ul> <li>(True, True, 'longonly') -&gt; True, True, False, False</li> <li>(True, True, 'shortonly') -&gt; False, False, True, True</li> <li>(True, True, 'both') -&gt; True, False, True, False</li> </ul>  </li> <li> <p><code>entries</code> (acting as long), <code>exits</code> (acting as long), <code>short_entries</code>, and <code>short_exits</code>:     The direction is already built into the arrays. Best to use when the direction changes frequently     (for example, if you have one indicator providing long signals and one providing short signals).</p> <p>Uses ls_enex_signal_func_nb() as <code>signal_func_nb</code>.</p> </li> <li> <p><code>signal_func_nb</code> and <code>signal_args</code>: Custom signal function that returns direction-aware signals.     Best to use when signals should be placed dynamically based on custom conditions.</p> </li> </ul> <p>Args</p>  <code>close</code> :\u2002<code>array_like</code> See Portfolio.from_orders(). <code>entries</code> :\u2002<code>array_like</code> of <code>bool</code>  <p>Boolean array of entry signals. Defaults to True if all other signal arrays are not set, otherwise False. Will broadcast.</p> <ul> <li>If <code>short_entries</code> and <code>short_exits</code> are not set: Acts as a long signal if <code>direction</code>     is <code>all</code> or <code>longonly</code>, otherwise short.</li> <li>If <code>short_entries</code> or <code>short_exits</code> are set: Acts as <code>long_entries</code>.</li> </ul>  <code>exits</code> :\u2002<code>array_like</code> of <code>bool</code>  <p>Boolean array of exit signals. Defaults to False. Will broadcast.</p> <ul> <li>If <code>short_entries</code> and <code>short_exits</code> are not set: Acts as a short signal if <code>direction</code>     is <code>all</code> or <code>longonly</code>, otherwise long.</li> <li>If <code>short_entries</code> or <code>short_exits</code> are set: Acts as <code>long_exits</code>.</li> </ul>  <code>short_entries</code> :\u2002<code>array_like</code> of <code>bool</code> Boolean array of short entry signals. Defaults to False. Will broadcast. <code>short_exits</code> :\u2002<code>array_like</code> of <code>bool</code> Boolean array of short exit signals. Defaults to False. Will broadcast. <code>signal_func_nb</code> :\u2002<code>callable</code>  <p>Function called to generate signals.</p> <p>Should accept SignalContext and <code>*signal_args</code>. Should return long entry signal, long exit signal, short entry signal, and short exit signal.</p>  <p>Note</p> <p>Stop signal has priority: <code>signal_func_nb</code> is executed only if there is no stop signal.</p>   <code>signal_args</code> :\u2002<code>tuple</code> Packed arguments passed to <code>signal_func_nb</code>. Defaults to <code>()</code>. <code>size</code> :\u2002<code>float</code> or <code>array_like</code>  <p>See Portfolio.from_orders().</p>  <p>Note</p> <p>Negative size is not allowed. You should express direction using signals.</p>   <code>size_type</code> :\u2002<code>SizeType</code> or <code>array_like</code>  <p>See Portfolio.from_orders().</p> <p>Only <code>SizeType.Amount</code>, <code>SizeType.Value</code>, and <code>SizeType.Percent</code> are supported. Other modes such as target percentage are not compatible with signals since their logic may contradict the direction of the signal.</p>  <p>Note</p> <p><code>SizeType.Percent</code> does not support position reversal. Switch to a single direction or use <code>vectorbt.portfolio.enums.OppositeEntryMode.Close</code> to close the position first.</p>  <p>See warning in Portfolio.from_orders().</p>  <code>price</code> :\u2002<code>array_like</code> of <code>float</code> See Portfolio.from_orders(). <code>fees</code> :\u2002<code>float</code> or <code>array_like</code> See Portfolio.from_orders(). <code>fixed_fees</code> :\u2002<code>float</code> or <code>array_like</code> See Portfolio.from_orders(). <code>slippage</code> :\u2002<code>float</code> or <code>array_like</code> See Portfolio.from_orders(). <code>min_size</code> :\u2002<code>float</code> or <code>array_like</code> See Portfolio.from_orders(). <code>max_size</code> :\u2002<code>float</code> or <code>array_like</code>  <p>See Portfolio.from_orders().</p> <p>Will be partially filled if exceeded. You might not be able to properly close the position if accumulation is enabled and <code>max_size</code> is too low.</p>  <code>size_granularity</code> :\u2002<code>float</code> or <code>array_like</code> See Portfolio.from_orders(). <code>reject_prob</code> :\u2002<code>float</code> or <code>array_like</code> See Portfolio.from_orders(). <code>lock_cash</code> :\u2002<code>bool</code> or <code>array_like</code> See Portfolio.from_orders(). <code>allow_partial</code> :\u2002<code>bool</code> or <code>array_like</code> See Portfolio.from_orders(). <code>raise_reject</code> :\u2002<code>bool</code> or <code>array_like</code> See Portfolio.from_orders(). <code>log</code> :\u2002<code>bool</code> or <code>array_like</code> See Portfolio.from_orders(). <code>accumulate</code> :\u2002<code>bool</code>, <code>AccumulationMode</code> or <code>array_like</code>  <p>See AccumulationMode. If True, becomes 'both'. If False, becomes 'disabled'. Will broadcast.</p> <p>When enabled, Portfolio.from_signals() behaves similarly to Portfolio.from_orders().</p>  <code>upon_long_conflict</code> :\u2002<code>ConflictMode</code> or <code>array_like</code> Conflict mode for long signals. See ConflictMode. Will broadcast. <code>upon_short_conflict</code> :\u2002<code>ConflictMode</code> or <code>array_like</code> Conflict mode for short signals. See ConflictMode. Will broadcast. <code>upon_dir_conflict</code> :\u2002<code>DirectionConflictMode</code> or <code>array_like</code> See DirectionConflictMode. Will broadcast. <code>upon_opposite_entry</code> :\u2002<code>OppositeEntryMode</code> or <code>array_like</code> See OppositeEntryMode. Will broadcast. <code>direction</code> :\u2002<code>Direction</code> or <code>array_like</code>  <p>See Portfolio.from_orders().</p> <p>Takes only effect if <code>short_entries</code> and <code>short_exits</code> are not set.</p>  <code>val_price</code> :\u2002<code>array_like</code> of <code>float</code> See Portfolio.from_orders(). <code>open</code> :\u2002<code>array_like</code> of <code>float</code>  <p>First asset price at each time step. Defaults to <code>np.nan</code>, which gets replaced by <code>close</code>. Will broadcast.</p> <p>Used solely for stop signals.</p>  <code>high</code> :\u2002<code>array_like</code> of <code>float</code>  <p>Highest asset price at each time step. Defaults to <code>np.nan</code>, which gets replaced by the maximum out of <code>open</code> and <code>close</code>. Will broadcast.</p> <p>Used solely for stop signals.</p>  <code>low</code> :\u2002<code>array_like</code> of <code>float</code>  <p>Lowest asset price at each time step. Defaults to <code>np.nan</code>, which gets replaced by the minimum out of <code>open</code> and <code>close</code>. Will broadcast.</p> <p>Used solely for stop signals.</p>  <code>sl_stop</code> :\u2002<code>array_like</code> of <code>float</code>  <p>Stop loss. Will broadcast.</p> <p>A percentage below/above the acquisition price for long/short position. Note that 0.01 = 1%.</p>  <code>sl_trail</code> :\u2002<code>array_like</code> of <code>bool</code> Whether <code>sl_stop</code> should be trailing. Will broadcast. <code>tp_stop</code> :\u2002<code>array_like</code> of <code>float</code>  <p>Take profit. Will broadcast.</p> <p>A percentage above/below the acquisition price for long/short position. Note that 0.01 = 1%.</p>  <code>stop_entry_price</code> :\u2002<code>StopEntryPrice</code> or <code>array_like</code>  <p>See StopEntryPrice. Will broadcast.</p> <p>If provided on per-element basis, gets applied upon entry.</p>  <code>stop_exit_price</code> :\u2002<code>StopExitPrice</code> or <code>array_like</code>  <p>See StopExitPrice. Will broadcast.</p> <p>If provided on per-element basis, gets applied upon exit.</p>  <code>upon_stop_exit</code> :\u2002<code>StopExitMode</code> or <code>array_like</code>  <p>See StopExitMode. Will broadcast.</p> <p>If provided on per-element basis, gets applied upon exit.</p>  <code>upon_stop_update</code> :\u2002<code>StopUpdateMode</code> or <code>array_like</code>  <p>See StopUpdateMode. Will broadcast.</p> <p>Only has effect if accumulation is enabled.</p> <p>If provided on per-element basis, gets applied upon repeated entry.</p>  <code>adjust_sl_func_nb</code> :\u2002<code>callable</code>  <p>Function to adjust stop loss. Defaults to no_adjust_sl_func_nb().</p> <p>Called for each element before each row.</p> <p>Should accept AdjustSLContext and <code>*adjust_sl_args</code>. Should return a tuple of a new stop value and trailing flag.</p>  <code>adjust_sl_args</code> :\u2002<code>tuple</code> Packed arguments passed to <code>adjust_sl_func_nb</code>. Defaults to <code>()</code>. <code>adjust_tp_func_nb</code> :\u2002<code>callable</code>  <p>Function to adjust take profit. Defaults to no_adjust_tp_func_nb().</p> <p>Called for each element before each row.</p> <p>Should accept AdjustTPContext and <code>*adjust_tp_args</code>. of the stop, and <code>*adjust_tp_args</code>. Should return a new stop value.</p>  <code>adjust_tp_args</code> :\u2002<code>tuple</code> Packed arguments passed to <code>adjust_tp_func_nb</code>. Defaults to <code>()</code>. <code>use_stops</code> :\u2002<code>bool</code>  <p>Whether to use stops. Defaults to None, which becomes True if any of the stops are not NaN or any of the adjustment functions are custom.</p> <p>Disable this to make simulation a bit faster for simple use cases.</p>  <code>init_cash</code> :\u2002<code>InitCashMode</code>, <code>float</code> or <code>array_like</code> of <code>float</code> See Portfolio.from_orders(). <code>cash_sharing</code> :\u2002<code>bool</code> See Portfolio.from_orders(). <code>call_seq</code> :\u2002<code>CallSeqType</code> or <code>array_like</code> See Portfolio.from_orders(). <code>ffill_val_price</code> :\u2002<code>bool</code> See Portfolio.from_orders(). <code>update_value</code> :\u2002<code>bool</code> See Portfolio.from_orders(). <code>max_orders</code> :\u2002<code>int</code> See Portfolio.from_orders(). <code>max_logs</code> :\u2002<code>int</code> See Portfolio.from_orders(). <code>seed</code> :\u2002<code>int</code> See Portfolio.from_orders(). <code>group_by</code> :\u2002<code>any</code> See Portfolio.from_orders(). <code>broadcast_named_args</code> :\u2002<code>dict</code>  <p>Dictionary with named arguments to broadcast.</p> <p>You can then pass argument names to the functions and this method will substitute them by their corresponding broadcasted objects.</p>  <code>broadcast_kwargs</code> :\u2002<code>dict</code> See Portfolio.from_orders(). <code>template_mapping</code> :\u2002<code>mapping</code> Mapping to replace templates in arguments. <code>wrapper_kwargs</code> :\u2002<code>dict</code> See Portfolio.from_orders(). <code>freq</code> :\u2002<code>any</code> See Portfolio.from_orders(). <code>attach_call_seq</code> :\u2002<code>bool</code> See Portfolio.from_orders(). <code>**kwargs</code> Keyword arguments passed to the <code>__init__</code> method.  <p>All broadcastable arguments will broadcast using broadcast() but keep original shape to utilize flexible indexing and to save memory.</p> <p>For defaults, see <code>portfolio</code> in settings.</p>  <p>Note</p> <p>Stop signal has priority - it's executed before other signals within the same bar. That is, if a stop signal is present, no other signals are generated and executed since there is a limit of one order per symbol and bar.</p>   <p>Hint</p> <p>If you generated signals using close price, don't forget to shift your signals by one tick forward, for example, with <code>signals.vbt.fshift(1)</code>. In general, make sure to use a price that comes after the signal.</p>  <p>Also see notes and hints for Portfolio.from_orders().</p> <p>Usage</p> <ul> <li>By default, if all signal arrays are None, <code>entries</code> becomes True, which opens a position at the very first tick and does nothing else:</li> </ul> <pre><code>&gt;&gt;&gt; close = pd.Series([1, 2, 3, 4, 5])\n&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(close, size=1)\n&gt;&gt;&gt; pf.asset_flow()\n0    1.0\n1    0.0\n2    0.0\n3    0.0\n4    0.0\ndtype: float64\n</code></pre> <ul> <li>Entry opens long, exit closes long:</li> </ul> <pre><code>&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(\n...     close,\n...     entries=pd.Series([True, True, True, False, False]),\n...     exits=pd.Series([False, False, True, True, True]),\n...     size=1,\n...     direction='longonly'\n... )\n&gt;&gt;&gt; pf.asset_flow()\n0    1.0\n1    0.0\n2    0.0\n3   -1.0\n4    0.0\ndtype: float64\n\n&gt;&gt;&gt; # Using direction-aware arrays instead of `direction`\n&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(\n...     close,\n...     entries=pd.Series([True, True, True, False, False]),  # long_entries\n...     exits=pd.Series([False, False, True, True, True]),  # long_exits\n...     short_entries=False,\n...     short_exits=False,\n...     size=1\n... )\n&gt;&gt;&gt; pf.asset_flow()\n0    1.0\n1    0.0\n2    0.0\n3   -1.0\n4    0.0\ndtype: float64\n</code></pre> <p>Notice how both <code>short_entries</code> and <code>short_exits</code> are provided as constants - as any other broadcastable argument, they are treated as arrays where each element is False.</p> <ul> <li>Entry opens short, exit closes short:</li> </ul> <pre><code>&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(\n...     close,\n...     entries=pd.Series([True, True, True, False, False]),\n...     exits=pd.Series([False, False, True, True, True]),\n...     size=1,\n...     direction='shortonly'\n... )\n&gt;&gt;&gt; pf.asset_flow()\n0   -1.0\n1    0.0\n2    0.0\n3    1.0\n4    0.0\ndtype: float64\n\n&gt;&gt;&gt; # Using direction-aware arrays instead of `direction`\n&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(\n...     close,\n...     entries=False,  # long_entries\n...     exits=False,  # long_exits\n...     short_entries=pd.Series([True, True, True, False, False]),\n...     short_exits=pd.Series([False, False, True, True, True]),\n...     size=1\n... )\n&gt;&gt;&gt; pf.asset_flow()\n0   -1.0\n1    0.0\n2    0.0\n3    1.0\n4    0.0\ndtype: float64\n</code></pre> <ul> <li>Entry opens long and closes short, exit closes long and opens short:</li> </ul> <pre><code>&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(\n...     close,\n...     entries=pd.Series([True, True, True, False, False]),\n...     exits=pd.Series([False, False, True, True, True]),\n...     size=1,\n...     direction='both'\n... )\n&gt;&gt;&gt; pf.asset_flow()\n0    1.0\n1    0.0\n2    0.0\n3   -2.0\n4    0.0\ndtype: float64\n\n&gt;&gt;&gt; # Using direction-aware arrays instead of `direction`\n&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(\n...     close,\n...     entries=pd.Series([True, True, True, False, False]),  # long_entries\n...     exits=False,  # long_exits\n...     short_entries=pd.Series([False, False, True, True, True]),\n...     short_exits=False,\n...     size=1\n... )\n&gt;&gt;&gt; pf.asset_flow()\n0    1.0\n1    0.0\n2    0.0\n3   -2.0\n4    0.0\ndtype: float64\n</code></pre> <ul> <li>More complex signal combinations are best expressed using direction-aware arrays. For example, ignore opposite signals as long as the current position is open:</li> </ul> <pre><code>&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(\n...     close,\n...     entries      =pd.Series([True, False, False, False, False]),  # long_entries\n...     exits        =pd.Series([False, False, True, False, False]),  # long_exits\n...     short_entries=pd.Series([False, True, False, True, False]),\n...     short_exits  =pd.Series([False, False, False, False, True]),\n...     size=1,\n...     upon_opposite_entry='ignore'\n... )\n&gt;&gt;&gt; pf.asset_flow()\n0    1.0\n1    0.0\n2   -1.0\n3   -1.0\n4    1.0\ndtype: float64\n</code></pre> <ul> <li>First opposite signal closes the position, second one opens a new position:</li> </ul> <pre><code>&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(\n...     close,\n...     entries=pd.Series([True, True, True, False, False]),\n...     exits=pd.Series([False, False, True, True, True]),\n...     size=1,\n...     direction='both',\n...     upon_opposite_entry='close'\n... )\n&gt;&gt;&gt; pf.asset_flow()\n0    1.0\n1    0.0\n2    0.0\n3   -1.0\n4   -1.0\ndtype: float64\n</code></pre> <ul> <li>If both long entry and exit signals are True (a signal conflict), choose exit:</li> </ul> <pre><code>&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(\n...     close,\n...     entries=pd.Series([True, True, True, False, False]),\n...     exits=pd.Series([False, False, True, True, True]),\n...     size=1.,\n...     direction='longonly',\n...     upon_long_conflict='exit')\n&gt;&gt;&gt; pf.asset_flow()\n0    1.0\n1    0.0\n2   -1.0\n3    0.0\n4    0.0\ndtype: float64\n</code></pre> <ul> <li>If both long entry and short entry signal are True (a direction conflict), choose short:</li> </ul> <pre><code>&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(\n...     close,\n...     entries=pd.Series([True, True, True, False, False]),\n...     exits=pd.Series([False, False, True, True, True]),\n...     size=1.,\n...     direction='both',\n...     upon_dir_conflict='short')\n&gt;&gt;&gt; pf.asset_flow()\n0    1.0\n1    0.0\n2   -2.0\n3    0.0\n4    0.0\ndtype: float64\n</code></pre>  <p>Note</p> <p>Remember that when direction is set to 'both', entries become <code>long_entries</code> and exits become <code>short_entries</code>, so this becomes a conflict of directions rather than signals.</p>  <ul> <li>If there are both signal and direction conflicts:</li> </ul> <pre><code>&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(\n...     close,\n...     entries=True,  # long_entries\n...     exits=True,  # long_exits\n...     short_entries=True,\n...     short_exits=True,\n...     size=1,\n...     upon_long_conflict='entry',\n...     upon_short_conflict='entry',\n...     upon_dir_conflict='short'\n... )\n&gt;&gt;&gt; pf.asset_flow()\n0   -1.0\n1    0.0\n2    0.0\n3    0.0\n4    0.0\ndtype: float64\n</code></pre> <ul> <li>Turn on accumulation of signals. Entry means long order, exit means short order (acts similar to <code>from_orders</code>):</li> </ul> <pre><code>&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(\n...     close,\n...     entries=pd.Series([True, True, True, False, False]),\n...     exits=pd.Series([False, False, True, True, True]),\n...     size=1.,\n...     direction='both',\n...     accumulate=True)\n&gt;&gt;&gt; pf.asset_flow()\n0    1.0\n1    1.0\n2    0.0\n3   -1.0\n4   -1.0\ndtype: float64\n</code></pre> <ul> <li>Allow increasing a position (of any direction), deny decreasing a position:</li> </ul> <pre><code>&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(\n...     close,\n...     entries=pd.Series([True, True, True, False, False]),\n...     exits=pd.Series([False, False, True, True, True]),\n...     size=1.,\n...     direction='both',\n...     accumulate='addonly')\n&gt;&gt;&gt; pf.asset_flow()\n0    1.0  &lt;&lt; open a long position\n1    1.0  &lt;&lt; add to the position\n2    0.0\n3   -3.0  &lt;&lt; close and open a short position\n4   -1.0  &lt;&lt; add to the position\ndtype: float64\n</code></pre> <ul> <li>Testing multiple parameters (via broadcasting):</li> </ul> <pre><code>&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(\n...     close,\n...     entries=pd.Series([True, True, True, False, False]),\n...     exits=pd.Series([False, False, True, True, True]),\n...     direction=[list(Direction)],\n...     broadcast_kwargs=dict(columns_from=Direction._fields))\n&gt;&gt;&gt; pf.asset_flow()\n    Long  Short    All\n0  100.0 -100.0  100.0\n1    0.0    0.0    0.0\n2    0.0    0.0    0.0\n3 -100.0   50.0 -200.0\n4    0.0    0.0    0.0\n</code></pre> <ul> <li>Set risk/reward ratio by passing trailing stop loss and take profit thresholds:</li> </ul> <pre><code>&gt;&gt;&gt; close = pd.Series([10, 11, 12, 11, 10, 9])\n&gt;&gt;&gt; entries = pd.Series([True, False, False, False, False, False])\n&gt;&gt;&gt; exits = pd.Series([False, False, False, False, False, True])\n&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(\n...     close, entries, exits,\n...     sl_stop=0.1, sl_trail=True, tp_stop=0.2)  # take profit hit\n&gt;&gt;&gt; pf.asset_flow()\n0    10.0\n1     0.0\n2   -10.0\n3     0.0\n4     0.0\n5     0.0\ndtype: float64\n\n&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(\n...     close, entries, exits,\n...     sl_stop=0.1, sl_trail=True, tp_stop=0.3)  # stop loss hit\n&gt;&gt;&gt; pf.asset_flow()\n0    10.0\n1     0.0\n2     0.0\n3     0.0\n4   -10.0\n5     0.0\ndtype: float64\n\n&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(\n...     close, entries, exits,\n...     sl_stop=np.inf, sl_trail=True, tp_stop=np.inf)  # nothing hit, exit as usual\n&gt;&gt;&gt; pf.asset_flow()\n0    10.0\n1     0.0\n2     0.0\n3     0.0\n4     0.0\n5   -10.0\ndtype: float64\n</code></pre>  <p>Note</p> <p>When the stop price is hit, the stop signal invalidates any other signal defined for this bar. Thus, make sure that your signaling logic happens at the very end of the bar (for example, by using the closing price), otherwise you may expose yourself to a look-ahead bias.</p> <p>See StopExitPrice for more details.</p>  <ul> <li>We can implement our own stop loss or take profit, or adjust the existing one at each time step. Let's implement stepped stop-loss:</li> </ul> <pre><code>&gt;&gt;&gt; @njit\n... def adjust_sl_func_nb(c):\n...     current_profit = (c.val_price_now - c.init_price) / c.init_price\n...     if current_profit &gt;= 0.40:\n...         return 0.25, True\n...     elif current_profit &gt;= 0.25:\n...         return 0.15, True\n...     elif current_profit &gt;= 0.20:\n...         return 0.07, True\n...     return c.curr_stop, c.curr_trail\n\n&gt;&gt;&gt; close = pd.Series([10, 11, 12, 11, 10])\n&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(close, adjust_sl_func_nb=adjust_sl_func_nb)\n&gt;&gt;&gt; pf.asset_flow()\n0    10.0\n1     0.0\n2     0.0\n3   -10.0  # 7% from 12 hit\n4    11.0\ndtype: float64\n</code></pre> <ul> <li>Sometimes there is a need to provide or transform signals dynamically. For this, we can implement a custom signal function <code>signal_func_nb</code>. For example, let's implement a signal function that takes two numerical arrays - long and short one - and transforms them into 4 direction-aware boolean arrays that vectorbt understands:</li> </ul> <pre><code>&gt;&gt;&gt; @njit\n... def signal_func_nb(c, long_num_arr, short_num_arr):\n...     long_num = nb.get_elem_nb(c, long_num_arr)\n...     short_num = nb.get_elem_nb(c, short_num_arr)\n...     is_long_entry = long_num &gt; 0\n...     is_long_exit = long_num &lt; 0\n...     is_short_entry = short_num &gt; 0\n...     is_short_exit = short_num &lt; 0\n...     return is_long_entry, is_long_exit, is_short_entry, is_short_exit\n\n&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(\n...     pd.Series([1, 2, 3, 4, 5]),\n...     signal_func_nb=signal_func_nb,\n...     signal_args=(vbt.Rep('long_num_arr'), vbt.Rep('short_num_arr')),\n...     broadcast_named_args=dict(\n...         long_num_arr=pd.Series([1, 0, -1, 0, 0]),\n...         short_num_arr=pd.Series([0, 1, 0, 1, -1])\n...     ),\n...     size=1,\n...     upon_opposite_entry='ignore'\n... )\n&gt;&gt;&gt; pf.asset_flow()\n0    1.0\n1    0.0\n2   -1.0\n3   -1.0\n4    1.0\ndtype: float64\n</code></pre> <p>Passing both arrays as <code>broadcast_named_args</code> broadcasts them internally as any other array, so we don't have to worry about their dimensions every time we change our data.</p>","title":"from_signals class method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.call_seq","text":"<p>Sequence of calls per row and group.</p>","title":"call_seq property"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.cash_sharing","text":"<p>Whether to share cash within the same group.</p>","title":"cash_sharing property"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.close","text":"<p>Price per unit series.</p>","title":"close property"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.drawdowns","text":"<p>Portfolio.get_drawdowns() with default arguments.</p>","title":"drawdowns variable"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.entry_trades","text":"<p>Portfolio.get_entry_trades() with default arguments.</p>","title":"entry_trades variable"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.exit_trades","text":"<p>Portfolio.get_exit_trades() with default arguments.</p>","title":"exit_trades variable"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.fillna_close","text":"<p>Whether to forward-backward fill NaN values in Portfolio.close.</p>","title":"fillna_close property"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.init_cash","text":"<p>Portfolio.get_init_cash() with default arguments.</p>","title":"init_cash variable"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.log_records","text":"<p>A structured NumPy array of log records.</p>","title":"log_records property"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.logs","text":"<p>Portfolio.get_logs() with default arguments.</p>","title":"logs variable"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.order_records","text":"<p>A structured NumPy array of order records.</p>","title":"order_records property"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.orders","text":"<p>Portfolio.get_orders() with default arguments.</p>","title":"orders variable"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.plots_defaults","text":"<p>Defaults for PlotsBuilderMixin.plots().</p> <p>Merges PlotsBuilderMixin.plots_defaults and <code>portfolio.plots</code> from settings.</p>","title":"plots_defaults property"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.positions","text":"<p>Portfolio.get_positions() with default arguments.</p>","title":"positions variable"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.qs","text":"<p>Portfolio.get_qs() with default arguments.</p>","title":"qs variable"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.returns_acc","text":"<p>Portfolio.get_returns_acc() with default arguments.</p>","title":"returns_acc property"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.stats_defaults","text":"<p>Defaults for StatsBuilderMixin.stats().</p> <p>Merges StatsBuilderMixin.stats_defaults and <code>portfolio.stats</code> from settings.</p>","title":"stats_defaults property"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.trades","text":"<p>Portfolio.get_trades() with default arguments.</p>","title":"trades variable"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.trades_type","text":"<p>Default Trades to use across Portfolio.</p>","title":"trades_type property"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.plot","text":"<pre><code>PlotsBuilderMixin.plots(\n    subplots=None,\n    tags=None,\n    column=None,\n    group_by=None,\n    silence_warnings=None,\n    template_mapping=None,\n    settings=None,\n    filters=None,\n    subplot_settings=None,\n    show_titles=None,\n    hide_id_labels=None,\n    group_id_labels=None,\n    make_subplots_kwargs=None,\n    **layout_kwargs\n)\n</code></pre> <p>See PlotsBuilderMixin.plots().</p>","title":"plot method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.alpha","text":"<pre><code>Portfolio.alpha(\n    *,\n    group_by=None,\n    benchmark_rets=None,\n    freq=None,\n    year_freq=None,\n    use_asset_returns=False,\n    **kwargs\n)\n</code></pre> <p>See ReturnsAccessor.alpha().</p>","title":"alpha method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.annual_returns","text":"<pre><code>Portfolio.annual_returns(\n    *,\n    group_by=None,\n    benchmark_rets=None,\n    freq=None,\n    year_freq=None,\n    use_asset_returns=False,\n    **kwargs\n)\n</code></pre> <p>See ReturnsAccessor.annual().</p>","title":"annual_returns method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.annualized_return","text":"<pre><code>Portfolio.annualized_return(\n    *,\n    group_by=None,\n    benchmark_rets=None,\n    freq=None,\n    year_freq=None,\n    use_asset_returns=False,\n    **kwargs\n)\n</code></pre> <p>See ReturnsAccessor.annualized().</p>","title":"annualized_return method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.annualized_volatility","text":"<pre><code>Portfolio.annualized_volatility(\n    *,\n    group_by=None,\n    benchmark_rets=None,\n    freq=None,\n    year_freq=None,\n    use_asset_returns=False,\n    **kwargs\n)\n</code></pre> <p>See ReturnsAccessor.annualized_volatility().</p>","title":"annualized_volatility method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.asset_flow","text":"<pre><code>Portfolio.asset_flow(\n    direction='both',\n    wrap_kwargs=None\n)\n</code></pre> <p>Get asset flow series per column.</p> <p>Returns the total transacted amount of assets at each time step.</p>","title":"asset_flow method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.asset_returns","text":"<pre><code>Portfolio.asset_returns(\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Get asset return series per column/group.</p> <p>This type of returns is based solely on cash flows and asset value rather than portfolio value. It ignores passive cash and thus it will return the same numbers irrespective of the amount of cash currently available, even <code>np.inf</code>. The scale of returns is comparable to that of going all in and keeping available cash at zero.</p>","title":"asset_returns method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.asset_value","text":"<pre><code>Portfolio.asset_value(\n    direction='both',\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Get asset value series per column/group.</p>","title":"asset_value method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.assets","text":"<pre><code>Portfolio.assets(\n    direction='both',\n    wrap_kwargs=None\n)\n</code></pre> <p>Get asset series per column.</p> <p>Returns the current position at each time step.</p>","title":"assets method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.benchmark_returns","text":"<pre><code>Portfolio.benchmark_returns(\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Get return series per column/group based on benchmark value.</p>","title":"benchmark_returns method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.benchmark_rets","text":"<pre><code>Portfolio.benchmark_returns(\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Get return series per column/group based on benchmark value.</p>","title":"benchmark_rets method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.benchmark_value","text":"<pre><code>Portfolio.benchmark_value(\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Get market benchmark value series per column/group.</p> <p>If grouped, evenly distributes the initial cash among assets in the group.</p>  <p>Note</p> <p>Does not take into account fees and slippage. For this, create a separate portfolio.</p>","title":"benchmark_value method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.beta","text":"<pre><code>Portfolio.beta(\n    *,\n    group_by=None,\n    benchmark_rets=None,\n    freq=None,\n    year_freq=None,\n    use_asset_returns=False,\n    **kwargs\n)\n</code></pre> <p>See ReturnsAccessor.beta().</p>","title":"beta method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.calmar_ratio","text":"<pre><code>Portfolio.calmar_ratio(\n    *,\n    group_by=None,\n    benchmark_rets=None,\n    freq=None,\n    year_freq=None,\n    use_asset_returns=False,\n    **kwargs\n)\n</code></pre> <p>See ReturnsAccessor.calmar_ratio().</p>","title":"calmar_ratio method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.capture","text":"<pre><code>Portfolio.capture(\n    *,\n    group_by=None,\n    benchmark_rets=None,\n    freq=None,\n    year_freq=None,\n    use_asset_returns=False,\n    **kwargs\n)\n</code></pre> <p>See ReturnsAccessor.capture().</p>","title":"capture method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.cash","text":"<pre><code>Portfolio.cash(\n    group_by=None,\n    in_sim_order=False,\n    free=False,\n    wrap_kwargs=None\n)\n</code></pre> <p>Get cash balance series per column/group.</p> <p>See the explanation on <code>in_sim_order</code> in Portfolio.value(). For <code>free</code>, see Portfolio.cash_flow().</p>","title":"cash method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.cash_flow","text":"<pre><code>Portfolio.cash_flow(\n    group_by=None,\n    free=False,\n    wrap_kwargs=None\n)\n</code></pre> <p>Get cash flow series per column/group.</p> <p>Use <code>free</code> to return the flow of the free cash, which never goes above the initial level, because an operation always costs money.</p>","title":"cash_flow method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.cond_value_at_risk","text":"<pre><code>Portfolio.cond_value_at_risk(\n    *,\n    group_by=None,\n    benchmark_rets=None,\n    freq=None,\n    year_freq=None,\n    use_asset_returns=False,\n    **kwargs\n)\n</code></pre> <p>See ReturnsAccessor.cond_value_at_risk().</p>","title":"cond_value_at_risk method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.cumulative_returns","text":"<pre><code>Portfolio.cumulative_returns(\n    *,\n    group_by=None,\n    benchmark_rets=None,\n    freq=None,\n    year_freq=None,\n    use_asset_returns=False,\n    **kwargs\n)\n</code></pre> <p>See ReturnsAccessor.cumulative().</p>","title":"cumulative_returns method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.daily_returns","text":"<pre><code>Portfolio.daily_returns(\n    *,\n    group_by=None,\n    benchmark_rets=None,\n    freq=None,\n    year_freq=None,\n    use_asset_returns=False,\n    **kwargs\n)\n</code></pre> <p>See ReturnsAccessor.daily().</p>","title":"daily_returns method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.deflated_sharpe_ratio","text":"<pre><code>Portfolio.deflated_sharpe_ratio(\n    *,\n    group_by=None,\n    benchmark_rets=None,\n    freq=None,\n    year_freq=None,\n    use_asset_returns=False,\n    **kwargs\n)\n</code></pre> <p>See ReturnsAccessor.deflated_sharpe_ratio().</p>","title":"deflated_sharpe_ratio method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.down_capture","text":"<pre><code>Portfolio.down_capture(\n    *,\n    group_by=None,\n    benchmark_rets=None,\n    freq=None,\n    year_freq=None,\n    use_asset_returns=False,\n    **kwargs\n)\n</code></pre> <p>See ReturnsAccessor.down_capture().</p>","title":"down_capture method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.downside_risk","text":"<pre><code>Portfolio.downside_risk(\n    *,\n    group_by=None,\n    benchmark_rets=None,\n    freq=None,\n    year_freq=None,\n    use_asset_returns=False,\n    **kwargs\n)\n</code></pre> <p>See ReturnsAccessor.downside_risk().</p>","title":"downside_risk method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.drawdown","text":"<pre><code>Portfolio.drawdown(\n    *,\n    group_by=None,\n    benchmark_rets=None,\n    freq=None,\n    year_freq=None,\n    use_asset_returns=False,\n    **kwargs\n)\n</code></pre> <p>See ReturnsAccessor.drawdown().</p>","title":"drawdown method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.final_value","text":"<pre><code>Portfolio.final_value(\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Get total profit per column/group.</p>","title":"final_value method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.get_drawdowns","text":"<pre><code>Portfolio.get_drawdowns(\n    group_by=None,\n    wrap_kwargs=None,\n    wrapper_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Get drawdown records from Portfolio.value().</p> <p>See Drawdowns.</p>","title":"get_drawdowns method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.get_entry_trades","text":"<pre><code>Portfolio.get_entry_trades(\n    group_by=None,\n    **kwargs\n)\n</code></pre> <p>Get entry trade records.</p> <p>See EntryTrades.</p>","title":"get_entry_trades method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.get_exit_trades","text":"<pre><code>Portfolio.get_exit_trades(\n    group_by=None,\n    **kwargs\n)\n</code></pre> <p>Get exit trade records.</p> <p>See ExitTrades.</p>","title":"get_exit_trades method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.get_filled_close","text":"<pre><code>Portfolio.get_filled_close(\n    wrap_kwargs=None\n)\n</code></pre> <p>Forward-backward-fill NaN values in Portfolio.close</p>","title":"get_filled_close method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.get_init_cash","text":"<pre><code>Portfolio.get_init_cash(\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Initial amount of cash per column/group with default arguments.</p>  <p>Note</p> <p>If the initial cash balance was found automatically and no own cash is used throughout the simulation (for example, when shorting), it will be set to 1 instead of 0 to enable smooth calculation of returns.</p>","title":"get_init_cash method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.get_logs","text":"<pre><code>Portfolio.get_logs(\n    group_by=None,\n    **kwargs\n)\n</code></pre> <p>Get log records.</p> <p>See Logs.</p>","title":"get_logs method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.get_orders","text":"<pre><code>Portfolio.get_orders(\n    group_by=None,\n    **kwargs\n)\n</code></pre> <p>Get order records.</p> <p>See Orders.</p>","title":"get_orders method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.get_positions","text":"<pre><code>Portfolio.get_positions(\n    group_by=None,\n    **kwargs\n)\n</code></pre> <p>Get position records.</p> <p>See Positions.</p>","title":"get_positions method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.get_qs","text":"<pre><code>Portfolio.get_qs(\n    group_by=None,\n    benchmark_rets=None,\n    freq=None,\n    year_freq=None,\n    use_asset_returns=False,\n    **kwargs\n)\n</code></pre> <p>Get quantstats adapter of type QSAdapter.</p> <p><code>**kwargs</code> are passed to the adapter constructor.</p>","title":"get_qs method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.get_returns_acc","text":"<pre><code>Portfolio.get_returns_acc(\n    group_by=None,\n    benchmark_rets=None,\n    freq=None,\n    year_freq=None,\n    use_asset_returns=False,\n    defaults=None,\n    **kwargs\n)\n</code></pre> <p>Get returns accessor of type ReturnsAccessor.</p>  <p>Hint</p> <p>You can find most methods of this accessor as (cacheable) attributes of this portfolio.</p>","title":"get_returns_acc method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.get_trades","text":"<pre><code>Portfolio.get_trades(\n    group_by=None,\n    **kwargs\n)\n</code></pre> <p>Get trade/position records depending upon Portfolio.trades_type.</p>","title":"get_trades method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.gross_exposure","text":"<pre><code>Portfolio.gross_exposure(\n    direction='both',\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Get gross exposure.</p>","title":"gross_exposure method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.indexing_func","text":"<pre><code>Portfolio.indexing_func(\n    pd_indexing_func,\n    **kwargs\n)\n</code></pre> <p>Perform indexing on Portfolio.</p>","title":"indexing_func method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.information_ratio","text":"<pre><code>Portfolio.information_ratio(\n    *,\n    group_by=None,\n    benchmark_rets=None,\n    freq=None,\n    year_freq=None,\n    use_asset_returns=False,\n    **kwargs\n)\n</code></pre> <p>See ReturnsAccessor.information_ratio().</p>","title":"information_ratio method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.max_drawdown","text":"<pre><code>Portfolio.max_drawdown(\n    *,\n    group_by=None,\n    benchmark_rets=None,\n    freq=None,\n    year_freq=None,\n    use_asset_returns=False,\n    **kwargs\n)\n</code></pre> <p>See ReturnsAccessor.max_drawdown().</p>","title":"max_drawdown method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.net_exposure","text":"<pre><code>Portfolio.net_exposure(\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Get net exposure.</p>","title":"net_exposure method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.omega_ratio","text":"<pre><code>Portfolio.omega_ratio(\n    *,\n    group_by=None,\n    benchmark_rets=None,\n    freq=None,\n    year_freq=None,\n    use_asset_returns=False,\n    **kwargs\n)\n</code></pre> <p>See ReturnsAccessor.omega_ratio().</p>","title":"omega_ratio method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.plot_asset_flow","text":"<pre><code>Portfolio.plot_asset_flow(\n    column=None,\n    direction='both',\n    xref='x',\n    yref='y',\n    hline_shape_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Plot one column of asset flow.</p> <p>Args</p>  <code>column</code> :\u2002<code>str</code> Name of the column to plot. <code>direction</code> :\u2002<code>Direction</code> See Direction. <code>xref</code> :\u2002<code>str</code> X coordinate axis. <code>yref</code> :\u2002<code>str</code> Y coordinate axis. <code>hline_shape_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for zeroline. <code>**kwargs</code> Keyword arguments passed to GenericAccessor.plot().","title":"plot_asset_flow method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.plot_asset_value","text":"<pre><code>Portfolio.plot_asset_value(\n    column=None,\n    group_by=None,\n    direction='both',\n    xref='x',\n    yref='y',\n    hline_shape_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Plot one column/group of asset value.</p> <p>Args</p>  <code>column</code> :\u2002<code>str</code> Name of the column/group to plot. <code>group_by</code> :\u2002<code>any</code> Group or ungroup columns. See ColumnGrouper. <code>direction</code> :\u2002<code>Direction</code> See Direction. <code>xref</code> :\u2002<code>str</code> X coordinate axis. <code>yref</code> :\u2002<code>str</code> Y coordinate axis. <code>hline_shape_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for zeroline. <code>**kwargs</code> Keyword arguments passed to GenericSRAccessor.plot_against().","title":"plot_asset_value method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.plot_assets","text":"<pre><code>Portfolio.plot_assets(\n    column=None,\n    direction='both',\n    xref='x',\n    yref='y',\n    hline_shape_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Plot one column of assets.</p> <p>Args</p>  <code>column</code> :\u2002<code>str</code> Name of the column to plot. <code>direction</code> :\u2002<code>Direction</code> See Direction. <code>xref</code> :\u2002<code>str</code> X coordinate axis. <code>yref</code> :\u2002<code>str</code> Y coordinate axis. <code>hline_shape_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for zeroline. <code>**kwargs</code> Keyword arguments passed to GenericSRAccessor.plot_against().","title":"plot_assets method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.plot_cash","text":"<pre><code>Portfolio.plot_cash(\n    column=None,\n    group_by=None,\n    free=False,\n    xref='x',\n    yref='y',\n    hline_shape_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Plot one column/group of cash balance.</p> <p>Args</p>  <code>column</code> :\u2002<code>str</code> Name of the column/group to plot. <code>group_by</code> :\u2002<code>any</code> Group or ungroup columns. See ColumnGrouper. <code>free</code> :\u2002<code>bool</code> Whether to plot the flow of the free cash. <code>xref</code> :\u2002<code>str</code> X coordinate axis. <code>yref</code> :\u2002<code>str</code> Y coordinate axis. <code>hline_shape_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for zeroline. <code>**kwargs</code> Keyword arguments passed to GenericSRAccessor.plot_against().","title":"plot_cash method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.plot_cash_flow","text":"<pre><code>Portfolio.plot_cash_flow(\n    column=None,\n    group_by=None,\n    free=False,\n    xref='x',\n    yref='y',\n    hline_shape_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Plot one column/group of cash flow.</p> <p>Args</p>  <code>column</code> :\u2002<code>str</code> Name of the column/group to plot. <code>group_by</code> :\u2002<code>any</code> Group or ungroup columns. See ColumnGrouper. <code>free</code> :\u2002<code>bool</code> Whether to plot the flow of the free cash. <code>xref</code> :\u2002<code>str</code> X coordinate axis. <code>yref</code> :\u2002<code>str</code> Y coordinate axis. <code>hline_shape_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for zeroline. <code>**kwargs</code> Keyword arguments passed to GenericAccessor.plot().","title":"plot_cash_flow method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.plot_cum_returns","text":"<pre><code>Portfolio.plot_cum_returns(\n    column=None,\n    group_by=None,\n    benchmark_rets=None,\n    use_asset_returns=False,\n    **kwargs\n)\n</code></pre> <p>Plot one column/group of cumulative returns.</p> <p>Args</p>  <code>column</code> :\u2002<code>str</code> Name of the column/group to plot. <code>group_by</code> :\u2002<code>any</code> Group or ungroup columns. See ColumnGrouper. <code>benchmark_rets</code> :\u2002<code>array_like</code>  <p>Benchmark returns.</p> <p>If None, will use Portfolio.benchmark_returns().</p>  <code>use_asset_returns</code> :\u2002<code>bool</code> Whether to plot asset returns. <code>**kwargs</code> Keyword arguments passed to ReturnsSRAccessor.plot_cumulative().","title":"plot_cum_returns method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.plot_drawdowns","text":"<pre><code>Portfolio.plot_drawdowns(\n    column=None,\n    group_by=None,\n    **kwargs\n)\n</code></pre> <p>Plot one column/group of drawdowns.</p> <p>Args</p>  <code>column</code> :\u2002<code>str</code> Name of the column/group to plot. <code>group_by</code> :\u2002<code>any</code> Group or ungroup columns. See ColumnGrouper. <code>**kwargs</code> Keyword arguments passed to Drawdowns.plot().","title":"plot_drawdowns method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.plot_gross_exposure","text":"<pre><code>Portfolio.plot_gross_exposure(\n    column=None,\n    group_by=None,\n    direction='both',\n    xref='x',\n    yref='y',\n    hline_shape_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Plot one column/group of gross exposure.</p> <p>Args</p>  <code>column</code> :\u2002<code>str</code> Name of the column/group to plot. <code>group_by</code> :\u2002<code>any</code> Group or ungroup columns. See ColumnGrouper. <code>direction</code> :\u2002<code>Direction</code> See Direction. <code>xref</code> :\u2002<code>str</code> X coordinate axis. <code>yref</code> :\u2002<code>str</code> Y coordinate axis. <code>hline_shape_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for zeroline. <code>**kwargs</code> Keyword arguments passed to GenericSRAccessor.plot_against().","title":"plot_gross_exposure method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.plot_net_exposure","text":"<pre><code>Portfolio.plot_net_exposure(\n    column=None,\n    group_by=None,\n    xref='x',\n    yref='y',\n    hline_shape_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Plot one column/group of net exposure.</p> <p>Args</p>  <code>column</code> :\u2002<code>str</code> Name of the column/group to plot. <code>group_by</code> :\u2002<code>any</code> Group or ungroup columns. See ColumnGrouper. <code>xref</code> :\u2002<code>str</code> X coordinate axis. <code>yref</code> :\u2002<code>str</code> Y coordinate axis. <code>hline_shape_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for zeroline. <code>**kwargs</code> Keyword arguments passed to GenericSRAccessor.plot_against().","title":"plot_net_exposure method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.plot_orders","text":"<pre><code>Portfolio.plot_orders(\n    column=None,\n    **kwargs\n)\n</code></pre> <p>Plot one column/group of orders.</p>","title":"plot_orders method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.plot_position_pnl","text":"<pre><code>Portfolio.plot_position_pnl(\n    column=None,\n    **kwargs\n)\n</code></pre> <p>Plot one column/group of position PnL.</p>","title":"plot_position_pnl method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.plot_positions","text":"<pre><code>Portfolio.plot_positions(\n    column=None,\n    **kwargs\n)\n</code></pre> <p>Plot one column/group of positions.</p>","title":"plot_positions method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.plot_trade_pnl","text":"<pre><code>Portfolio.plot_trade_pnl(\n    column=None,\n    **kwargs\n)\n</code></pre> <p>Plot one column/group of trade PnL.</p>","title":"plot_trade_pnl method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.plot_trades","text":"<pre><code>Portfolio.plot_trades(\n    column=None,\n    **kwargs\n)\n</code></pre> <p>Plot one column/group of trades.</p>","title":"plot_trades method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.plot_underwater","text":"<pre><code>Portfolio.plot_underwater(\n    column=None,\n    group_by=None,\n    xref='x',\n    yref='y',\n    hline_shape_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Plot one column/group of underwater.</p> <p>Args</p>  <code>column</code> :\u2002<code>str</code> Name of the column/group to plot. <code>group_by</code> :\u2002<code>any</code> Group or ungroup columns. See ColumnGrouper. <code>xref</code> :\u2002<code>str</code> X coordinate axis. <code>yref</code> :\u2002<code>str</code> Y coordinate axis. <code>hline_shape_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for zeroline. <code>**kwargs</code> Keyword arguments passed to GenericAccessor.plot().","title":"plot_underwater method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.plot_value","text":"<pre><code>Portfolio.plot_value(\n    column=None,\n    group_by=None,\n    xref='x',\n    yref='y',\n    hline_shape_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Plot one column/group of value.</p> <p>Args</p>  <code>column</code> :\u2002<code>str</code> Name of the column/group to plot. <code>group_by</code> :\u2002<code>any</code> Group or ungroup columns. See ColumnGrouper. <code>free</code> :\u2002<code>bool</code> Whether to plot free cash flow. <code>xref</code> :\u2002<code>str</code> X coordinate axis. <code>yref</code> :\u2002<code>str</code> Y coordinate axis. <code>hline_shape_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for zeroline. <code>**kwargs</code> Keyword arguments passed to GenericSRAccessor.plot_against().","title":"plot_value method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.position_coverage","text":"<pre><code>Portfolio.position_coverage(\n    direction='both',\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Get position coverage per column/group.</p>","title":"position_coverage method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.position_mask","text":"<pre><code>Portfolio.position_mask(\n    direction='both',\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Get position mask per column/group.</p> <p>An element is True if the asset is in the market at this tick.</p>","title":"position_mask method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.post_resolve_attr","text":"<pre><code>Portfolio.post_resolve_attr(\n    attr,\n    out,\n    final_kwargs=None\n)\n</code></pre> <p>Post-process an object after resolution.</p> <p>Uses the following keys:</p> <ul> <li><code>incl_open</code>: Whether to include open trades/positions when resolving an argument     that is an instance of Trades.</li> </ul>","title":"post_resolve_attr method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.pre_resolve_attr","text":"<pre><code>Portfolio.pre_resolve_attr(\n    attr,\n    final_kwargs=None\n)\n</code></pre> <p>Pre-process an attribute before resolution.</p> <p>Uses the following keys:</p> <ul> <li><code>use_asset_returns</code>: Whether to use Portfolio.asset_returns() when resolving <code>returns</code> argument.</li> <li><code>trades_type</code>: Which trade type to use when resolving <code>trades</code> argument.</li> </ul>","title":"pre_resolve_attr method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.regroup","text":"<pre><code>Portfolio.regroup(\n    group_by,\n    **kwargs\n)\n</code></pre> <p>Regroup this object.</p> <p>See Wrapping.regroup().</p>  <p>Note</p> <p>All cached objects will be lost.</p>","title":"regroup method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.returns","text":"<pre><code>Portfolio.returns(\n    group_by=None,\n    in_sim_order=False,\n    wrap_kwargs=None\n)\n</code></pre> <p>Get return series per column/group based on portfolio value.</p>","title":"returns method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.returns_stats","text":"<pre><code>Portfolio.returns_stats(\n    group_by=None,\n    benchmark_rets=None,\n    freq=None,\n    year_freq=None,\n    use_asset_returns=False,\n    defaults=None,\n    **kwargs\n)\n</code></pre> <p>Compute various statistics on returns of this portfolio.</p> <p>See Portfolio.returns_acc and ReturnsAccessor.metrics.</p> <p><code>kwargs</code> will be passed to StatsBuilderMixin.stats() method. If <code>benchmark_rets</code> is not set, uses Portfolio.benchmark_returns().</p>","title":"returns_stats method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.sharpe_ratio","text":"<pre><code>Portfolio.sharpe_ratio(\n    *,\n    group_by=None,\n    benchmark_rets=None,\n    freq=None,\n    year_freq=None,\n    use_asset_returns=False,\n    **kwargs\n)\n</code></pre> <p>See ReturnsAccessor.sharpe_ratio().</p>","title":"sharpe_ratio method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.sortino_ratio","text":"<pre><code>Portfolio.sortino_ratio(\n    *,\n    group_by=None,\n    benchmark_rets=None,\n    freq=None,\n    year_freq=None,\n    use_asset_returns=False,\n    **kwargs\n)\n</code></pre> <p>See ReturnsAccessor.sortino_ratio().</p>","title":"sortino_ratio method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.tail_ratio","text":"<pre><code>Portfolio.tail_ratio(\n    *,\n    group_by=None,\n    benchmark_rets=None,\n    freq=None,\n    year_freq=None,\n    use_asset_returns=False,\n    **kwargs\n)\n</code></pre> <p>See ReturnsAccessor.tail_ratio().</p>","title":"tail_ratio method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.total_benchmark_return","text":"<pre><code>Portfolio.total_benchmark_return(\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Get total benchmark return.</p>","title":"total_benchmark_return method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.total_profit","text":"<pre><code>Portfolio.total_profit(\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Get total profit per column/group.</p> <p>Calculated directly from order records (fast).</p>","title":"total_profit method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.total_return","text":"<pre><code>Portfolio.total_return(\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Get total profit per column/group.</p>","title":"total_return method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.up_capture","text":"<pre><code>Portfolio.up_capture(\n    *,\n    group_by=None,\n    benchmark_rets=None,\n    freq=None,\n    year_freq=None,\n    use_asset_returns=False,\n    **kwargs\n)\n</code></pre> <p>See ReturnsAccessor.up_capture().</p>","title":"up_capture method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.value","text":"<pre><code>Portfolio.value(\n    group_by=None,\n    in_sim_order=False,\n    wrap_kwargs=None\n)\n</code></pre> <p>Get portfolio value series per column/group.</p> <p>By default, will generate portfolio value for each asset based on cash flows and thus independent from other assets, with the initial cash balance and position being that of the entire group. Useful for generating returns and comparing assets within the same group.</p> <p>When <code>group_by</code> is False and <code>in_sim_order</code> is True, returns value generated in simulation order (see row-major order. This value cannot be used for generating returns as-is. Useful to analyze how value evolved throughout simulation.</p>","title":"value method"},{"location":"api/portfolio/base/#vectorbt.portfolio.base.Portfolio.value_at_risk","text":"<pre><code>Portfolio.value_at_risk(\n    *,\n    group_by=None,\n    benchmark_rets=None,\n    freq=None,\n    year_freq=None,\n    use_asset_returns=False,\n    **kwargs\n)\n</code></pre> <p>See ReturnsAccessor.value_at_risk().</p>","title":"value_at_risk method"},{"location":"api/portfolio/decorators/","text":"<p>Class and function decorators.</p>","title":"decorators"},{"location":"api/portfolio/decorators/#vectorbt.portfolio.decorators.attach_returns_acc_methods","text":"<pre><code>attach_returns_acc_methods(\n    config\n)\n</code></pre> <p>Class decorator to add returns accessor methods.</p> <p><code>config</code> should contain target method names (keys) and dictionaries (values) with the following keys:</p> <ul> <li><code>source_name</code>: Name of the source method. Defaults to the target name.</li> <li><code>docstring</code>: Method docstring. Defaults to \"See <code>vectorbt.returns.accessors.ReturnsAccessor.{source_name}</code>.\".</li> </ul> <p>The class should be a subclass of Portfolio.</p>","title":"attach_returns_acc_methods function"},{"location":"api/portfolio/enums/","text":"<p>Named tuples and enumerated types.</p> <p>Defines enums and other schemas for vectorbt.portfolio.</p>","title":"enums"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.AccumulationMode","text":"<p>Accumulation mode.</p> <pre><code>{\n    \"Disabled\": 0,\n    \"Both\": 1,\n    \"AddOnly\": 2,\n    \"RemoveOnly\": 3\n}\n</code></pre> <p>Accumulation allows gradually increasing and decreasing positions by a size.</p> <p>Attributes</p>  <code>Disabled</code> Disable accumulation. <code>Both</code> Allow both adding to and removing from the position. <code>AddOnly</code> Allow accumulation to only add to the position. <code>RemoveOnly</code> Allow accumulation to only remove from the position.   <p>Note</p> <p>Accumulation acts differently for exits and opposite entries: exits reduce the current position but won't enter the opposite one, while opposite entries reduce the position by the same amount, but as soon as this position is closed, they begin to increase the opposite position.</p> <p>The behavior for opposite entries can be changed by OppositeEntryMode and for stop orders by StopExitMode.</p>","title":"AccumulationMode variable"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.CallSeqType","text":"<p>Call sequence type.</p> <pre><code>{\n    \"Default\": 0,\n    \"Reversed\": 1,\n    \"Random\": 2,\n    \"Auto\": 3\n}\n</code></pre> <p>Attributes</p>  <code>Default</code> Place calls from left to right. <code>Reversed</code> Place calls from right to left. <code>Random</code> Place calls randomly. <code>Auto</code> Place calls dynamically based on order value.","title":"CallSeqType variable"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.ConflictMode","text":"<p>Conflict mode.</p> <pre><code>{\n    \"Ignore\": 0,\n    \"Entry\": 1,\n    \"Exit\": 2,\n    \"Adjacent\": 3,\n    \"Opposite\": 4\n}\n</code></pre> <p>What should happen if both entry and exit signals occur simultaneously?</p> <p>Attributes</p>  <code>Ignore</code> Ignore both signals. <code>Entry</code> Execute the entry signal. <code>Exit</code> Execute the exit signal. <code>Adjacent</code>  <p>Execute the adjacent signal.</p> <p>Takes effect only when in position, otherwise ignores.</p>  <code>Opposite</code>  <p>Execute the opposite signal.</p> <p>Takes effect only when in position, otherwise ignores.</p>","title":"ConflictMode variable"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.Direction","text":"<p>Position direction.</p> <pre><code>{\n    \"LongOnly\": 0,\n    \"ShortOnly\": 1,\n    \"Both\": 2\n}\n</code></pre> <p>Attributes</p>  <code>LongOnly</code> Only long positions. <code>ShortOnly</code> Only short positions. <code>Both</code> Both long and short positions.","title":"Direction variable"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.DirectionConflictMode","text":"<p>Direction conflict mode.</p> <pre><code>{\n    \"Ignore\": 0,\n    \"Long\": 1,\n    \"Short\": 2,\n    \"Adjacent\": 3,\n    \"Opposite\": 4\n}\n</code></pre> <p>What should happen if both long and short entry signals occur simultaneously?</p> <p>Attributes</p>  <code>Ignore</code> Ignore both entry signals. <code>Long</code> Execute the long entry signal. <code>Short</code> Execute the short entry signal. <code>Adjacent</code>  <p>Execute the adjacent entry signal. </p> <p>Takes effect only when in position, otherwise ignores.</p>  <code>Opposite</code>  <p>Execute the opposite entry signal. </p> <p>Takes effect only when in position, otherwise ignores.</p>","title":"DirectionConflictMode variable"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.InitCashMode","text":"<p>Initial cash mode.</p> <pre><code>{\n    \"Auto\": 0,\n    \"AutoAlign\": 1\n}\n</code></pre> <p>Attributes</p>  <code>Auto</code> Initial cash is infinite within simulation, and then set to the total cash spent. <code>AutoAlign</code> Initial cash is set to the total cash spent across all columns.","title":"InitCashMode variable"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.NoOrder","text":"<p>Order that should not be processed.</p>","title":"NoOrder variable"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OppositeEntryMode","text":"<p>Opposite entry mode.</p> <pre><code>{\n    \"Ignore\": 0,\n    \"Close\": 1,\n    \"CloseReduce\": 2,\n    \"Reverse\": 3,\n    \"ReverseReduce\": 4\n}\n</code></pre> <p>What should happen if an entry signal of opposite direction occurs before an exit signal?</p> <p>Attributes</p>  <code>Ignore</code> Ignore the opposite entry signal. <code>Close</code> Close the current position. <code>CloseReduce</code> Close the current position or reduce it if accumulation is enabled. <code>Reverse</code> Reverse the current position. <code>ReverseReduce</code> Reverse the current position or reduce it if accumulation is enabled.","title":"OppositeEntryMode variable"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderSide","text":"<p>Order side.</p> <pre><code>{\n    \"Buy\": 0,\n    \"Sell\": 1\n}\n</code></pre>","title":"OrderSide variable"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderStatus","text":"<p>Order status.</p> <pre><code>{\n    \"Filled\": 0,\n    \"Ignored\": 1,\n    \"Rejected\": 2\n}\n</code></pre> <p>Attributes</p>  <code>Filled</code> Order has been filled. <code>Ignored</code> Order has been ignored. <code>Rejected</code> Order has been rejected.","title":"OrderStatus variable"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderStatusInfo","text":"<p>Order status information.</p> <pre><code>{\n    \"SizeNaN\": 0,\n    \"PriceNaN\": 1,\n    \"ValPriceNaN\": 2,\n    \"ValueNaN\": 3,\n    \"ValueZeroNeg\": 4,\n    \"SizeZero\": 5,\n    \"NoCashShort\": 6,\n    \"NoCashLong\": 7,\n    \"NoOpenPosition\": 8,\n    \"MaxSizeExceeded\": 9,\n    \"RandomEvent\": 10,\n    \"CantCoverFees\": 11,\n    \"MinSizeNotReached\": 12,\n    \"PartialFill\": 13\n}\n</code></pre>","title":"OrderStatusInfo variable"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SizeType","text":"<p>Size type.</p> <pre><code>{\n    \"Amount\": 0,\n    \"Value\": 1,\n    \"Percent\": 2,\n    \"TargetAmount\": 3,\n    \"TargetValue\": 4,\n    \"TargetPercent\": 5\n}\n</code></pre> <p>Attributes</p>  <code>Amount</code> Amount of assets to trade. <code>Value</code>  <p>Asset value to trade.</p> <p>Gets converted into <code>SizeType.Amount</code> using OrderContext.val_price_now.</p>  <code>Percent</code>  <p>Percentage of available resources to use in either direction (not to be confused with  the percentage of position value!)</p> <ul> <li>When buying, it's the percentage of OrderContext.cash_now. </li> <li>When selling, it's the percentage of OrderContext.position_now.</li> <li>When short selling, it's the percentage of OrderContext.free_cash_now.</li> <li>When selling and short selling (i.e. reversing position), it's the percentage of  OrderContext.position_now and OrderContext.free_cash_now.</li> </ul>  <p>Note</p> <p>Takes into account fees and slippage to find the limit. In reality, slippage and fees are not known beforehand.</p>   <code>TargetAmount</code>  <p>Target amount of assets to hold (= target position).</p> <p>Uses OrderContext.position_now to get the current position. Gets converted into <code>SizeType.Amount</code>.</p>  <code>TargetValue</code>  <p>Target asset value. </p> <p>Uses OrderContext.val_price_now to get the current asset value.  Gets converted into <code>SizeType.TargetAmount</code>.</p>  <code>TargetPercent</code>  <p>Target percentage of total value. </p> <p>Uses OrderContext.value_now to get the current total value. Gets converted into <code>SizeType.TargetValue</code>.</p>","title":"SizeType variable"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.StopEntryPrice","text":"<p>Stop entry price.</p> <pre><code>{\n    \"ValPrice\": 0,\n    \"Price\": 1,\n    \"FillPrice\": 2,\n    \"Close\": 3\n}\n</code></pre> <p>Which price to use as an initial stop price?</p> <p>Attributes</p>  <code>ValPrice</code> Asset valuation price. <code>Price</code> Default price. <code>FillPrice</code> Fill price (that is, slippage is already applied). <code>Close</code> Closing price.","title":"StopEntryPrice variable"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.StopExitMode","text":"<p>Stop exit mode.</p> <pre><code>{\n    \"Close\": 0,\n    \"CloseReduce\": 1,\n    \"Reverse\": 2,\n    \"ReverseReduce\": 3\n}\n</code></pre> <p>How to exit the current position upon a stop signal?</p> <p>Attributes</p>  <code>Close</code> Close the current position. <code>CloseReduce</code> Close the current position or reduce it if accumulation is enabled. <code>Reverse</code> Reverse the current position. <code>ReverseReduce</code> Reverse the current position or reduce it if accumulation is enabled.","title":"StopExitMode variable"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.StopExitPrice","text":"<p>Stop exit price.</p> <pre><code>{\n    \"StopLimit\": 0,\n    \"StopMarket\": 1,\n    \"Price\": 2,\n    \"Close\": 3\n}\n</code></pre> <p>Which price to use when exiting a position upon a stop signal?</p> <p>Attributes</p>  <code>StopLimit</code>  <p>Stop price as from a limit order.</p> <p>If the stop was hit before, the opening price at the next bar is used. User-defined slippage is not applied.</p>  <code>StopMarket</code>  <p>Stop price as from a market order.</p> <p>If the stop was hit before, the opening price at the next bar is used. User-defined slippage is applied.</p>  <code>Price</code>  <p>Default price.</p> <p>User-defined slippage is applied.</p>  <p>Note</p> <p>Make sure to use <code>StopExitPrice.Price</code> only together with <code>StopEntryPrice.Close</code>. Otherwise, there is no proof that the price comes after the stop price.</p>   <code>Close</code>  <p>Closing price.</p> <p>User-defined slippage is applied.</p>    <p>Note</p> <p>We can execute only one signal per asset and bar. This means the following:</p> <p>1) Stop signal cannot be processed at the same bar as the entry signal.</p> <p>2) When dealing with stop orders, we have another signal - stop signal - that may be in a conflict  with the signals placed by the user. To choose between both, we assume that any stop signal comes  before any other signal in time. Thus, make sure to always execute ordinary signals using the  closing price when using stop orders. Otherwise, you're looking into the future.</p>","title":"StopExitPrice variable"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.StopUpdateMode","text":"<p>Stop update mode.</p> <pre><code>{\n    \"Keep\": 0,\n    \"Override\": 1,\n    \"OverrideNaN\": 2\n}\n</code></pre> <p>What to do with the old stop upon new acquisition? </p> <p>Attributes</p>  <code>Keep</code> Keep the old stop. <code>Override</code> Override the old stop, but only if the new stop is not NaN. <code>OverrideNaN</code> Override the old stop, even if the new stop is NaN.","title":"StopUpdateMode variable"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.TradeDirection","text":"<p>Event direction.</p> <pre><code>{\n    \"Long\": 0,\n    \"Short\": 1\n}\n</code></pre>","title":"TradeDirection variable"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.TradeStatus","text":"<p>Event status.</p> <pre><code>{\n    \"Open\": 0,\n    \"Closed\": 1\n}\n</code></pre>","title":"TradeStatus variable"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.TradesType","text":"<p>Trades type.</p> <pre><code>{\n    \"EntryTrades\": 0,\n    \"ExitTrades\": 1,\n    \"Positions\": 2\n}\n</code></pre>","title":"TradesType variable"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.log_dt","text":"<p><code>np.dtype</code> of log records.</p> <pre><code>{\n    \"id\": \"int64\",\n    \"group\": \"int64\",\n    \"col\": \"int64\",\n    \"idx\": \"int64\",\n    \"cash\": \"float64\",\n    \"position\": \"float64\",\n    \"debt\": \"float64\",\n    \"free_cash\": \"float64\",\n    \"val_price\": \"float64\",\n    \"value\": \"float64\",\n    \"req_size\": \"float64\",\n    \"req_price\": \"float64\",\n    \"req_size_type\": \"int64\",\n    \"req_direction\": \"int64\",\n    \"req_fees\": \"float64\",\n    \"req_fixed_fees\": \"float64\",\n    \"req_slippage\": \"float64\",\n    \"req_min_size\": \"float64\",\n    \"req_max_size\": \"float64\",\n    \"req_size_granularity\": \"float64\",\n    \"req_reject_prob\": \"float64\",\n    \"req_lock_cash\": \"bool\",\n    \"req_allow_partial\": \"bool\",\n    \"req_raise_reject\": \"bool\",\n    \"req_log\": \"bool\",\n    \"new_cash\": \"float64\",\n    \"new_position\": \"float64\",\n    \"new_debt\": \"float64\",\n    \"new_free_cash\": \"float64\",\n    \"new_val_price\": \"float64\",\n    \"new_value\": \"float64\",\n    \"res_size\": \"float64\",\n    \"res_price\": \"float64\",\n    \"res_fees\": \"float64\",\n    \"res_side\": \"int64\",\n    \"res_status\": \"int64\",\n    \"res_status_info\": \"int64\",\n    \"order_id\": \"int64\"\n}\n</code></pre>","title":"log_dt variable"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.order_dt","text":"<p><code>np.dtype</code> of order records.</p> <pre><code>{\n    \"id\": \"int64\",\n    \"col\": \"int64\",\n    \"idx\": \"int64\",\n    \"size\": \"float64\",\n    \"price\": \"float64\",\n    \"fees\": \"float64\",\n    \"side\": \"int64\"\n}\n</code></pre>","title":"order_dt variable"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.trade_dt","text":"<p><code>np.dtype</code> of trade records.</p> <pre><code>{\n    \"id\": \"int64\",\n    \"col\": \"int64\",\n    \"size\": \"float64\",\n    \"entry_idx\": \"int64\",\n    \"entry_price\": \"float64\",\n    \"entry_fees\": \"float64\",\n    \"exit_idx\": \"int64\",\n    \"exit_price\": \"float64\",\n    \"exit_fees\": \"float64\",\n    \"pnl\": \"float64\",\n    \"return\": \"float64\",\n    \"direction\": \"int64\",\n    \"status\": \"int64\",\n    \"parent_id\": \"int64\"\n}\n</code></pre>","title":"trade_dt variable"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.AdjustSLContext","text":"<pre><code>AdjustSLContext(\n    i,\n    col,\n    position_now,\n    val_price_now,\n    init_i,\n    init_price,\n    curr_i,\n    curr_price,\n    curr_stop,\n    curr_trail\n)\n</code></pre> <p>A named tuple representing the context for generation of signals.</p> <p>Superclasses</p> <ul> <li><code>builtins.tuple</code></li> </ul>","title":"AdjustSLContext class"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.AdjustSLContext.col","text":"<p>Current column.</p> <p>Has range <code>[0, target_shape[1])</code> and is always within <code>[from_col, to_col)</code>.</p>","title":"col property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.AdjustSLContext.curr_i","text":"<p>Index of the row of the updated stop.</p> <p>Gets updated once the price is updated.</p>","title":"curr_i property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.AdjustSLContext.curr_price","text":"<p>Current stop price.</p> <p>Gets updated in trailing SL once a higher price is discovered.</p>","title":"curr_price property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.AdjustSLContext.curr_stop","text":"<p>Current stop value.</p> <p>Can be updated by adjustment function.</p>","title":"curr_stop property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.AdjustSLContext.curr_trail","text":"<p>Current trailing flag.</p> <p>Can be updated by adjustment function.</p>","title":"curr_trail property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.AdjustSLContext.i","text":"<p>Index of the current row.</p> <p>Has range <code>[0, target_shape[0])</code>.</p>","title":"i property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.AdjustSLContext.init_i","text":"<p>Index of the row of the initial stop.</p> <p>Doesn't change.</p>","title":"init_i property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.AdjustSLContext.init_price","text":"<p>Price of the initial stop.</p> <p>Doesn't change.</p>","title":"init_price property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.AdjustSLContext.position_now","text":"<p>Latest position.</p>","title":"position_now property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.AdjustSLContext.val_price_now","text":"<p>Latest valuation price.</p>","title":"val_price_now property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.AdjustTPContext","text":"<pre><code>AdjustTPContext(\n    i,\n    col,\n    position_now,\n    val_price_now,\n    init_i,\n    init_price,\n    curr_stop\n)\n</code></pre> <p>A named tuple representing the context for adjusting take profit.</p> <p>Superclasses</p> <ul> <li><code>builtins.tuple</code></li> </ul>","title":"AdjustTPContext class"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.AdjustTPContext.col","text":"<p>See AdjustSLContext.col.</p>","title":"col property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.AdjustTPContext.curr_stop","text":"<p>See AdjustSLContext.curr_stop.</p>","title":"curr_stop property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.AdjustTPContext.i","text":"<p>See AdjustSLContext.i.</p>","title":"i property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.AdjustTPContext.init_i","text":"<p>See AdjustSLContext.init_i.</p>","title":"init_i property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.AdjustTPContext.init_price","text":"<p>See AdjustSLContext.curr_price.</p>","title":"init_price property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.AdjustTPContext.position_now","text":"<p>See AdjustSLContext.position_now.</p>","title":"position_now property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.AdjustTPContext.val_price_now","text":"<p>See AdjustSLContext.val_price_now.</p>","title":"val_price_now property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.ExecuteOrderState","text":"<pre><code>ExecuteOrderState(\n    cash,\n    position,\n    debt,\n    free_cash\n)\n</code></pre> <p>State after order execution.</p> <p>Superclasses</p> <ul> <li><code>builtins.tuple</code></li> </ul>","title":"ExecuteOrderState class"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.ExecuteOrderState.cash","text":"<p>See ProcessOrderState.cash.</p>","title":"cash property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.ExecuteOrderState.debt","text":"<p>See ProcessOrderState.debt.</p>","title":"debt property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.ExecuteOrderState.free_cash","text":"<p>See ProcessOrderState.free_cash.</p>","title":"free_cash property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.ExecuteOrderState.position","text":"<p>See ProcessOrderState.position.</p>","title":"position property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext","text":"<pre><code>FlexOrderContext(\n    target_shape,\n    group_lens,\n    init_cash,\n    cash_sharing,\n    call_seq,\n    segment_mask,\n    call_pre_segment,\n    call_post_segment,\n    close,\n    ffill_val_price,\n    update_value,\n    fill_pos_record,\n    flex_2d,\n    order_records,\n    log_records,\n    last_cash,\n    last_position,\n    last_debt,\n    last_free_cash,\n    last_val_price,\n    last_value,\n    second_last_value,\n    last_return,\n    last_oidx,\n    last_lidx,\n    last_pos_record,\n    group,\n    group_len,\n    from_col,\n    to_col,\n    i,\n    call_seq_now,\n    call_idx\n)\n</code></pre> <p>A named tuple representing the context of a flexible order.</p> <p>Contains all fields from SegmentContext plus the current call index.</p> <p>Passed to <code>flex_order_func_nb</code>.</p> <p>Superclasses</p> <ul> <li><code>builtins.tuple</code></li> </ul>","title":"FlexOrderContext class"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.call_idx","text":"<p>Index of the current call.</p>","title":"call_idx property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.call_post_segment","text":"<p>See SimulationContext.call_post_segment.</p>","title":"call_post_segment property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.call_pre_segment","text":"<p>See SimulationContext.call_pre_segment.</p>","title":"call_pre_segment property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.call_seq","text":"<p>See SimulationContext.call_seq.</p>","title":"call_seq property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.call_seq_now","text":"<p>See SegmentContext.call_seq_now.</p>","title":"call_seq_now property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.cash_sharing","text":"<p>See SimulationContext.cash_sharing.</p>","title":"cash_sharing property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.close","text":"<p>See SimulationContext.close.</p>","title":"close property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.ffill_val_price","text":"<p>See SimulationContext.ffill_val_price.</p>","title":"ffill_val_price property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.fill_pos_record","text":"<p>See SimulationContext.fill_pos_record.</p>","title":"fill_pos_record property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.flex_2d","text":"<p>See SimulationContext.flex_2d.</p>","title":"flex_2d property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.from_col","text":"<p>See GroupContext.from_col.</p>","title":"from_col property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.group","text":"<p>See GroupContext.group.</p>","title":"group property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.group_len","text":"<p>See GroupContext.group_len.</p>","title":"group_len property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.group_lens","text":"<p>See SimulationContext.group_lens.</p>","title":"group_lens property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.i","text":"<p>See RowContext.i.</p>","title":"i property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.init_cash","text":"<p>See SimulationContext.init_cash.</p>","title":"init_cash property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.last_cash","text":"<p>See SimulationContext.last_cash.</p>","title":"last_cash property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.last_debt","text":"<p>See SimulationContext.last_debt.</p>","title":"last_debt property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.last_free_cash","text":"<p>See SimulationContext.last_free_cash.</p>","title":"last_free_cash property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.last_lidx","text":"<p>See SimulationContext.last_lidx.</p>","title":"last_lidx property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.last_oidx","text":"<p>See SimulationContext.last_oidx.</p>","title":"last_oidx property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.last_pos_record","text":"<p>See SimulationContext.last_pos_record.</p>","title":"last_pos_record property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.last_position","text":"<p>See SimulationContext.last_position.</p>","title":"last_position property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.last_return","text":"<p>See SimulationContext.last_return.</p>","title":"last_return property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.last_val_price","text":"<p>See SimulationContext.last_val_price.</p>","title":"last_val_price property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.last_value","text":"<p>See SimulationContext.last_value.</p>","title":"last_value property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.log_records","text":"<p>See SimulationContext.log_records.</p>","title":"log_records property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.order_records","text":"<p>See SimulationContext.order_records.</p>","title":"order_records property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.second_last_value","text":"<p>See SimulationContext.second_last_value.</p>","title":"second_last_value property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.segment_mask","text":"<p>See SimulationContext.segment_mask.</p>","title":"segment_mask property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.target_shape","text":"<p>See SimulationContext.target_shape.</p>","title":"target_shape property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.to_col","text":"<p>See GroupContext.to_col.</p>","title":"to_col property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.FlexOrderContext.update_value","text":"<p>See SimulationContext.update_value.</p>","title":"update_value property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.GroupContext","text":"<pre><code>GroupContext(\n    target_shape,\n    group_lens,\n    init_cash,\n    cash_sharing,\n    call_seq,\n    segment_mask,\n    call_pre_segment,\n    call_post_segment,\n    close,\n    ffill_val_price,\n    update_value,\n    fill_pos_record,\n    flex_2d,\n    order_records,\n    log_records,\n    last_cash,\n    last_position,\n    last_debt,\n    last_free_cash,\n    last_val_price,\n    last_value,\n    second_last_value,\n    last_return,\n    last_oidx,\n    last_lidx,\n    last_pos_record,\n    group,\n    group_len,\n    from_col,\n    to_col\n)\n</code></pre> <p>A named tuple representing the context of a group.</p> <p>A group is a set of nearby columns that are somehow related (for example, by sharing the same capital). In each row, the columns under the same group are bound to the same segment.</p> <p>Contains all fields from SimulationContext plus fields describing the current group.</p> <p>Passed to <code>pre_group_func_nb</code> and <code>post_group_func_nb</code>.</p> <p>Example</p> <p>Consider a group of three columns, a group of two columns, and one more column:</p>    group group_len from_col to_col     0 3 0 3   1 2 3 5   2 1 5 6    <p>Superclasses</p> <ul> <li><code>builtins.tuple</code></li> </ul>","title":"GroupContext class"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.GroupContext.call_post_segment","text":"<p>See SimulationContext.call_post_segment.</p>","title":"call_post_segment property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.GroupContext.call_pre_segment","text":"<p>See SimulationContext.call_pre_segment.</p>","title":"call_pre_segment property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.GroupContext.call_seq","text":"<p>See SimulationContext.call_seq.</p>","title":"call_seq property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.GroupContext.cash_sharing","text":"<p>See SimulationContext.cash_sharing.</p>","title":"cash_sharing property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.GroupContext.close","text":"<p>See SimulationContext.close.</p>","title":"close property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.GroupContext.ffill_val_price","text":"<p>See SimulationContext.ffill_val_price.</p>","title":"ffill_val_price property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.GroupContext.fill_pos_record","text":"<p>See SimulationContext.fill_pos_record.</p>","title":"fill_pos_record property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.GroupContext.flex_2d","text":"<p>See SimulationContext.flex_2d.</p>","title":"flex_2d property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.GroupContext.from_col","text":"<p>Index of the first column in the current group.</p> <p>Has range <code>[0, target_shape[1])</code>.</p>","title":"from_col property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.GroupContext.group","text":"<p>Index of the current group.</p> <p>Has range <code>[0, group_lens.shape[0])</code>.</p>","title":"group property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.GroupContext.group_len","text":"<p>Number of columns in the current group.</p> <p>Scalar value. Same as <code>group_lens[group]</code>.</p>","title":"group_len property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.GroupContext.group_lens","text":"<p>See SimulationContext.group_lens.</p>","title":"group_lens property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.GroupContext.init_cash","text":"<p>See SimulationContext.init_cash.</p>","title":"init_cash property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.GroupContext.last_cash","text":"<p>See SimulationContext.last_cash.</p>","title":"last_cash property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.GroupContext.last_debt","text":"<p>See SimulationContext.last_debt.</p>","title":"last_debt property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.GroupContext.last_free_cash","text":"<p>See SimulationContext.last_free_cash.</p>","title":"last_free_cash property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.GroupContext.last_lidx","text":"<p>See SimulationContext.last_lidx.</p>","title":"last_lidx property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.GroupContext.last_oidx","text":"<p>See SimulationContext.last_oidx.</p>","title":"last_oidx property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.GroupContext.last_pos_record","text":"<p>See SimulationContext.last_pos_record.</p>","title":"last_pos_record property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.GroupContext.last_position","text":"<p>See SimulationContext.last_position.</p>","title":"last_position property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.GroupContext.last_return","text":"<p>See SimulationContext.last_return.</p>","title":"last_return property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.GroupContext.last_val_price","text":"<p>See SimulationContext.last_val_price.</p>","title":"last_val_price property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.GroupContext.last_value","text":"<p>See SimulationContext.last_value.</p>","title":"last_value property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.GroupContext.log_records","text":"<p>See SimulationContext.log_records.</p>","title":"log_records property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.GroupContext.order_records","text":"<p>See SimulationContext.order_records.</p>","title":"order_records property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.GroupContext.second_last_value","text":"<p>See SimulationContext.second_last_value.</p>","title":"second_last_value property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.GroupContext.segment_mask","text":"<p>See SimulationContext.segment_mask.</p>","title":"segment_mask property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.GroupContext.target_shape","text":"<p>See SimulationContext.target_shape.</p>","title":"target_shape property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.GroupContext.to_col","text":"<p>Index of the last column in the current group plus one.</p> <p>Has range <code>[1, target_shape[1] + 1)</code>. </p> <p>If columns are not grouped, equals to <code>from_col + 1</code>.</p>  <p>Warning</p> <p>In the last group, <code>to_col</code> points at a column that doesn't exist.</p>","title":"to_col property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.GroupContext.update_value","text":"<p>See SimulationContext.update_value.</p>","title":"update_value property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.Order","text":"<pre><code>Order(\n    size=inf,\n    price=inf,\n    size_type=0,\n    direction=2,\n    fees=0.0,\n    fixed_fees=0.0,\n    slippage=0.0,\n    min_size=0.0,\n    max_size=inf,\n    size_granularity=nan,\n    reject_prob=0.0,\n    lock_cash=False,\n    allow_partial=True,\n    raise_reject=False,\n    log=False\n)\n</code></pre> <p>A named tuple representing an order.</p>  <p>Note</p> <p>Currently, Numba has issues with using defaults when filling named tuples.  Use order_nb() to create an order.</p>  <p>Superclasses</p> <ul> <li><code>builtins.tuple</code></li> </ul>","title":"Order class"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.Order.allow_partial","text":"<p>Whether to allow partial fill.</p> <p>Otherwise, the order gets rejected.</p> <p>Does not apply when Order.size is <code>np.inf</code>.</p>","title":"allow_partial property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.Order.direction","text":"<p>See Direction.</p>","title":"direction property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.Order.fees","text":"<p>Fees in percentage of the order value.</p> <p>Negative trading fees like -0.05 means earning 0.05% per trade instead of paying a fee.</p>  <p>Note</p> <p>0.01 = 1%.</p>","title":"fees property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.Order.fixed_fees","text":"<p>Fixed amount of fees to pay for this order.</p>","title":"fixed_fees property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.Order.lock_cash","text":"<p>Whether to lock cash when shorting. </p> <p>If enabled, prevents <code>free_cash</code> from turning negative when buying or short selling. A negative <code>free_cash</code> means one column used collateral of another column, which is generally undesired.</p>","title":"lock_cash property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.Order.log","text":"<p>Whether to log this order by filling a log record. </p> <p>Remember to increase <code>max_logs</code>.</p>","title":"log property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.Order.max_size","text":"<p>Maximum size in both directions. </p> <p>Higher than that will be partly filled.</p>","title":"max_size property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.Order.min_size","text":"<p>Minimum size in both directions. </p> <p>Lower than that will be rejected.</p>","title":"min_size property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.Order.price","text":"<p>Price per unit. </p> <p>Final price will depend upon slippage.</p> <ul> <li>If <code>-np.inf</code>, replaced by the current open (if available) or the previous close (\u2248 the current open in crypto).</li> <li>If <code>np.inf</code>, replaced by the current close.</li> </ul>  <p>Note</p> <p>Make sure to use timestamps that come between (and ideally not including) the current open and close.</p>","title":"price property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.Order.raise_reject","text":"<p>Whether to raise exception if order has been rejected.</p> <p>Terminates the simulation.</p>","title":"raise_reject property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.Order.reject_prob","text":"<p>Probability of rejecting this order to simulate a random rejection event.</p> <p>Not everything goes smoothly in real life. Use random rejections to test your order management for robustness.</p>","title":"reject_prob property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.Order.size","text":"<p>Size in units.</p> <p>Behavior depends upon Order.size_type and Order.direction.</p> <p>For any fixed size:</p> <ul> <li>Set to any number to buy/sell some fixed amount or value.     Longs are limited by the current cash balance, while shorts are only limited if Order.lock_cash.</li> <li>Set to <code>np.inf</code> to buy for all cash, or <code>-np.inf</code> to sell for all free cash.     If Order.direction is not <code>Direction.Both</code>, <code>-np.inf</code> will close the position.</li> <li>Set to <code>np.nan</code> or 0 to skip.</li> </ul> <p>For any target size:</p> <ul> <li>Set to any number to buy/sell an amount relative to the current position or value.</li> <li>Set to 0 to close the current position.</li> <li>Set to <code>np.nan</code> to skip.</li> </ul>","title":"size property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.Order.size_granularity","text":"<p>Granularity of the size.</p> <p>For example, granularity of 1.0 makes the quantity to behave like an integer.  Placing an order of 12.5 shares (in any direction) will order exactly 12.0 shares.</p>  <p>Note</p> <p>The filled size remains a floating number.</p>","title":"size_granularity property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.Order.size_type","text":"<p>See SizeType.</p>","title":"size_type property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.Order.slippage","text":"<p>Slippage in percentage of Order.price. </p> <p>Slippage is a penalty applied on the price.</p>  <p>Note</p> <p>0.01 = 1%.</p>","title":"slippage property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext","text":"<pre><code>OrderContext(\n    target_shape,\n    group_lens,\n    init_cash,\n    cash_sharing,\n    call_seq,\n    segment_mask,\n    call_pre_segment,\n    call_post_segment,\n    close,\n    ffill_val_price,\n    update_value,\n    fill_pos_record,\n    flex_2d,\n    order_records,\n    log_records,\n    last_cash,\n    last_position,\n    last_debt,\n    last_free_cash,\n    last_val_price,\n    last_value,\n    second_last_value,\n    last_return,\n    last_oidx,\n    last_lidx,\n    last_pos_record,\n    group,\n    group_len,\n    from_col,\n    to_col,\n    i,\n    call_seq_now,\n    col,\n    call_idx,\n    cash_now,\n    position_now,\n    debt_now,\n    free_cash_now,\n    val_price_now,\n    value_now,\n    return_now,\n    pos_record_now\n)\n</code></pre> <p>A named tuple representing the context of an order.</p> <p>Contains all fields from SegmentContext plus fields describing the current state.</p> <p>Passed to <code>order_func_nb</code>.</p> <p>Superclasses</p> <ul> <li><code>builtins.tuple</code></li> </ul>","title":"OrderContext class"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.call_idx","text":"<p>Index of the current call in SegmentContext.call_seq_now.</p> <p>Has range <code>[0, group_len)</code>.</p>","title":"call_idx property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.call_post_segment","text":"<p>See SimulationContext.call_post_segment.</p>","title":"call_post_segment property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.call_pre_segment","text":"<p>See SimulationContext.call_pre_segment.</p>","title":"call_pre_segment property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.call_seq","text":"<p>See SimulationContext.call_seq.</p>","title":"call_seq property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.call_seq_now","text":"<p>See SegmentContext.call_seq_now.</p>","title":"call_seq_now property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.cash_now","text":"<p>SimulationContext.last_cash for the current column/group.</p>","title":"cash_now property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.cash_sharing","text":"<p>See SimulationContext.cash_sharing.</p>","title":"cash_sharing property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.close","text":"<p>See SimulationContext.close.</p>","title":"close property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.col","text":"<p>Current column.</p> <p>Has range <code>[0, target_shape[1])</code> and is always within <code>[from_col, to_col)</code>.</p>","title":"col property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.debt_now","text":"<p>SimulationContext.last_debt for the current column.</p>","title":"debt_now property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.ffill_val_price","text":"<p>See SimulationContext.ffill_val_price.</p>","title":"ffill_val_price property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.fill_pos_record","text":"<p>See SimulationContext.fill_pos_record.</p>","title":"fill_pos_record property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.flex_2d","text":"<p>See SimulationContext.flex_2d.</p>","title":"flex_2d property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.free_cash_now","text":"<p>SimulationContext.last_free_cash for the current column/group.</p>","title":"free_cash_now property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.from_col","text":"<p>See GroupContext.from_col.</p>","title":"from_col property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.group","text":"<p>See GroupContext.group.</p>","title":"group property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.group_len","text":"<p>See GroupContext.group_len.</p>","title":"group_len property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.group_lens","text":"<p>See SimulationContext.group_lens.</p>","title":"group_lens property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.i","text":"<p>See RowContext.i.</p>","title":"i property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.init_cash","text":"<p>See SimulationContext.init_cash.</p>","title":"init_cash property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.last_cash","text":"<p>See SimulationContext.last_cash.</p>","title":"last_cash property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.last_debt","text":"<p>See SimulationContext.last_debt.</p>","title":"last_debt property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.last_free_cash","text":"<p>See SimulationContext.last_free_cash.</p>","title":"last_free_cash property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.last_lidx","text":"<p>See SimulationContext.last_lidx.</p>","title":"last_lidx property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.last_oidx","text":"<p>See SimulationContext.last_oidx.</p>","title":"last_oidx property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.last_pos_record","text":"<p>See SimulationContext.last_pos_record.</p>","title":"last_pos_record property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.last_position","text":"<p>See SimulationContext.last_position.</p>","title":"last_position property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.last_return","text":"<p>See SimulationContext.last_return.</p>","title":"last_return property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.last_val_price","text":"<p>See SimulationContext.last_val_price.</p>","title":"last_val_price property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.last_value","text":"<p>See SimulationContext.last_value.</p>","title":"last_value property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.log_records","text":"<p>See SimulationContext.log_records.</p>","title":"log_records property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.order_records","text":"<p>See SimulationContext.order_records.</p>","title":"order_records property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.pos_record_now","text":"<p>SimulationContext.last_pos_record for the current column.</p>","title":"pos_record_now property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.position_now","text":"<p>SimulationContext.last_position for the current column.</p>","title":"position_now property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.return_now","text":"<p>SimulationContext.last_return for the current column/group.</p>","title":"return_now property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.second_last_value","text":"<p>See SimulationContext.second_last_value.</p>","title":"second_last_value property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.segment_mask","text":"<p>See SimulationContext.segment_mask.</p>","title":"segment_mask property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.target_shape","text":"<p>See SimulationContext.target_shape.</p>","title":"target_shape property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.to_col","text":"<p>See GroupContext.to_col.</p>","title":"to_col property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.update_value","text":"<p>See SimulationContext.update_value.</p>","title":"update_value property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.val_price_now","text":"<p>SimulationContext.last_val_price for the current column.</p>","title":"val_price_now property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderContext.value_now","text":"<p>SimulationContext.last_value for the current column/group.</p>","title":"value_now property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderResult","text":"<pre><code>OrderResult(\n    size,\n    price,\n    fees,\n    side,\n    status,\n    status_info\n)\n</code></pre> <p>A named tuple representing an order result.</p> <p>Superclasses</p> <ul> <li><code>builtins.tuple</code></li> </ul>","title":"OrderResult class"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderResult.fees","text":"<p>Total fees paid for this order.</p>","title":"fees property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderResult.price","text":"<p>Filled price per unit, adjusted with slippage.</p>","title":"price property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderResult.side","text":"<p>See OrderSide.</p>","title":"side property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderResult.size","text":"<p>Filled size.</p>","title":"size property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderResult.status","text":"<p>See OrderStatus.</p>","title":"status property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.OrderResult.status_info","text":"<p>See OrderStatusInfo.</p>","title":"status_info property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext","text":"<pre><code>PostOrderContext(\n    target_shape,\n    group_lens,\n    init_cash,\n    cash_sharing,\n    call_seq,\n    segment_mask,\n    call_pre_segment,\n    call_post_segment,\n    close,\n    ffill_val_price,\n    update_value,\n    fill_pos_record,\n    flex_2d,\n    order_records,\n    log_records,\n    last_cash,\n    last_position,\n    last_debt,\n    last_free_cash,\n    last_val_price,\n    last_value,\n    second_last_value,\n    last_return,\n    last_oidx,\n    last_lidx,\n    last_pos_record,\n    group,\n    group_len,\n    from_col,\n    to_col,\n    i,\n    call_seq_now,\n    col,\n    call_idx,\n    cash_before,\n    position_before,\n    debt_before,\n    free_cash_before,\n    val_price_before,\n    value_before,\n    order_result,\n    cash_now,\n    position_now,\n    debt_now,\n    free_cash_now,\n    val_price_now,\n    value_now,\n    return_now,\n    pos_record_now\n)\n</code></pre> <p>A named tuple representing the context after an order has been processed.</p> <p>Contains all fields from OrderContext plus fields describing the order result and the previous state.</p> <p>Passed to <code>post_order_func_nb</code>.</p> <p>Superclasses</p> <ul> <li><code>builtins.tuple</code></li> </ul>","title":"PostOrderContext class"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.call_idx","text":"<p>See OrderContext.call_idx.</p>","title":"call_idx property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.call_post_segment","text":"<p>See SimulationContext.call_post_segment.</p>","title":"call_post_segment property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.call_pre_segment","text":"<p>See SimulationContext.call_pre_segment.</p>","title":"call_pre_segment property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.call_seq","text":"<p>See SimulationContext.call_seq.</p>","title":"call_seq property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.call_seq_now","text":"<p>See SegmentContext.call_seq_now.</p>","title":"call_seq_now property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.cash_before","text":"<p>OrderContext.cash_now before execution.</p>","title":"cash_before property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.cash_now","text":"<p>OrderContext.cash_now after execution.</p>","title":"cash_now property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.cash_sharing","text":"<p>See SimulationContext.cash_sharing.</p>","title":"cash_sharing property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.close","text":"<p>See SimulationContext.close.</p>","title":"close property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.col","text":"<p>See OrderContext.col.</p>","title":"col property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.debt_before","text":"<p>OrderContext.debt_now before execution.</p>","title":"debt_before property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.debt_now","text":"<p>OrderContext.debt_now after execution.</p>","title":"debt_now property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.ffill_val_price","text":"<p>See SimulationContext.ffill_val_price.</p>","title":"ffill_val_price property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.fill_pos_record","text":"<p>See SimulationContext.fill_pos_record.</p>","title":"fill_pos_record property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.flex_2d","text":"<p>See SimulationContext.flex_2d.</p>","title":"flex_2d property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.free_cash_before","text":"<p>OrderContext.free_cash_now before execution.</p>","title":"free_cash_before property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.free_cash_now","text":"<p>OrderContext.free_cash_now after execution.</p>","title":"free_cash_now property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.from_col","text":"<p>See GroupContext.from_col.</p>","title":"from_col property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.group","text":"<p>See GroupContext.group.</p>","title":"group property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.group_len","text":"<p>See GroupContext.group_len.</p>","title":"group_len property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.group_lens","text":"<p>See SimulationContext.group_lens.</p>","title":"group_lens property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.i","text":"<p>See RowContext.i.</p>","title":"i property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.init_cash","text":"<p>See SimulationContext.init_cash.</p>","title":"init_cash property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.last_cash","text":"<p>See SimulationContext.last_cash.</p>","title":"last_cash property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.last_debt","text":"<p>See SimulationContext.last_debt.</p>","title":"last_debt property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.last_free_cash","text":"<p>See SimulationContext.last_free_cash.</p>","title":"last_free_cash property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.last_lidx","text":"<p>See SimulationContext.last_lidx.</p>","title":"last_lidx property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.last_oidx","text":"<p>See SimulationContext.last_oidx.</p>","title":"last_oidx property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.last_pos_record","text":"<p>See SimulationContext.last_pos_record.</p>","title":"last_pos_record property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.last_position","text":"<p>See SimulationContext.last_position.</p>","title":"last_position property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.last_return","text":"<p>See SimulationContext.last_return.</p>","title":"last_return property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.last_val_price","text":"<p>See SimulationContext.last_val_price.</p>","title":"last_val_price property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.last_value","text":"<p>See SimulationContext.last_value.</p>","title":"last_value property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.log_records","text":"<p>See SimulationContext.log_records.</p>","title":"log_records property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.order_records","text":"<p>See SimulationContext.order_records.</p>","title":"order_records property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.order_result","text":"<p>Order result of type OrderResult.</p> <p>Can be used to check whether the order has been filled, ignored, or rejected.</p>","title":"order_result property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.pos_record_now","text":"<p>OrderContext.pos_record_now after execution.</p>","title":"pos_record_now property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.position_before","text":"<p>OrderContext.position_now before execution.</p>","title":"position_before property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.position_now","text":"<p>OrderContext.position_now after execution.</p>","title":"position_now property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.return_now","text":"<p>OrderContext.return_now after execution.</p>","title":"return_now property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.second_last_value","text":"<p>See SimulationContext.second_last_value.</p>","title":"second_last_value property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.segment_mask","text":"<p>See SimulationContext.segment_mask.</p>","title":"segment_mask property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.target_shape","text":"<p>See SimulationContext.target_shape.</p>","title":"target_shape property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.to_col","text":"<p>See GroupContext.to_col.</p>","title":"to_col property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.update_value","text":"<p>See SimulationContext.update_value.</p>","title":"update_value property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.val_price_before","text":"<p>OrderContext.val_price_now before execution.</p>","title":"val_price_before property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.val_price_now","text":"<p>OrderContext.val_price_now after execution.</p> <p>If SimulationContext.update_value, gets replaced with the fill price,  as it becomes the most recently known price. Otherwise, stays the same.</p>","title":"val_price_now property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.value_before","text":"<p>OrderContext.value_now before execution.</p>","title":"value_before property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.PostOrderContext.value_now","text":"<p>OrderContext.value_now after execution.</p> <p>If SimulationContext.update_value, gets updated with the new cash and value of the column. Otherwise, stays the same.</p>","title":"value_now property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.ProcessOrderState","text":"<pre><code>ProcessOrderState(\n    cash,\n    position,\n    debt,\n    free_cash,\n    val_price,\n    value,\n    oidx,\n    lidx\n)\n</code></pre> <p>State before or after order processing.</p> <p>Superclasses</p> <ul> <li><code>builtins.tuple</code></li> </ul>","title":"ProcessOrderState class"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.ProcessOrderState.cash","text":"<p>Cash in the current column or group with cash sharing.</p>","title":"cash property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.ProcessOrderState.debt","text":"<p>Debt from shorting in the current column.</p>","title":"debt property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.ProcessOrderState.free_cash","text":"<p>Free cash in the current column or group with cash sharing.</p>","title":"free_cash property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.ProcessOrderState.lidx","text":"<p>Index of log record.</p>","title":"lidx property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.ProcessOrderState.oidx","text":"<p>Index of order record.</p>","title":"oidx property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.ProcessOrderState.position","text":"<p>Position in the current column.</p>","title":"position property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.ProcessOrderState.val_price","text":"<p>Valuation price in the current column.</p>","title":"val_price property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.ProcessOrderState.value","text":"<p>Value in the current column or group with cash sharing.</p>","title":"value property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.RejectedOrderError","text":"<pre><code>RejectedOrderError(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Rejected order error.</p> <p>Superclasses</p> <ul> <li><code>builtins.BaseException</code></li> <li><code>builtins.Exception</code></li> </ul>","title":"RejectedOrderError class"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.RowContext","text":"<pre><code>RowContext(\n    target_shape,\n    group_lens,\n    init_cash,\n    cash_sharing,\n    call_seq,\n    segment_mask,\n    call_pre_segment,\n    call_post_segment,\n    close,\n    ffill_val_price,\n    update_value,\n    fill_pos_record,\n    flex_2d,\n    order_records,\n    log_records,\n    last_cash,\n    last_position,\n    last_debt,\n    last_free_cash,\n    last_val_price,\n    last_value,\n    second_last_value,\n    last_return,\n    last_oidx,\n    last_lidx,\n    last_pos_record,\n    i\n)\n</code></pre> <p>A named tuple representing the context of a row.</p> <p>A row is a time step in which segments are executed.</p> <p>Contains all fields from SimulationContext plus fields describing the current row.</p> <p>Passed to <code>pre_row_func_nb</code> and <code>post_row_func_nb</code>.</p> <p>Superclasses</p> <ul> <li><code>builtins.tuple</code></li> </ul>","title":"RowContext class"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.RowContext.call_post_segment","text":"<p>See SimulationContext.call_post_segment.</p>","title":"call_post_segment property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.RowContext.call_pre_segment","text":"<p>See SimulationContext.call_pre_segment.</p>","title":"call_pre_segment property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.RowContext.call_seq","text":"<p>See SimulationContext.call_seq.</p>","title":"call_seq property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.RowContext.cash_sharing","text":"<p>See SimulationContext.cash_sharing.</p>","title":"cash_sharing property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.RowContext.close","text":"<p>See SimulationContext.close.</p>","title":"close property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.RowContext.ffill_val_price","text":"<p>See SimulationContext.ffill_val_price.</p>","title":"ffill_val_price property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.RowContext.fill_pos_record","text":"<p>See SimulationContext.fill_pos_record.</p>","title":"fill_pos_record property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.RowContext.flex_2d","text":"<p>See SimulationContext.flex_2d.</p>","title":"flex_2d property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.RowContext.group_lens","text":"<p>See SimulationContext.group_lens.</p>","title":"group_lens property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.RowContext.i","text":"<p>Index of the current row.</p> <p>Has range <code>[0, target_shape[0])</code>.</p>","title":"i property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.RowContext.init_cash","text":"<p>See SimulationContext.init_cash.</p>","title":"init_cash property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.RowContext.last_cash","text":"<p>See SimulationContext.last_cash.</p>","title":"last_cash property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.RowContext.last_debt","text":"<p>See SimulationContext.last_debt.</p>","title":"last_debt property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.RowContext.last_free_cash","text":"<p>See SimulationContext.last_free_cash.</p>","title":"last_free_cash property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.RowContext.last_lidx","text":"<p>See SimulationContext.last_lidx.</p>","title":"last_lidx property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.RowContext.last_oidx","text":"<p>See SimulationContext.last_oidx.</p>","title":"last_oidx property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.RowContext.last_pos_record","text":"<p>See SimulationContext.last_pos_record.</p>","title":"last_pos_record property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.RowContext.last_position","text":"<p>See SimulationContext.last_position.</p>","title":"last_position property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.RowContext.last_return","text":"<p>See SimulationContext.last_return.</p>","title":"last_return property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.RowContext.last_val_price","text":"<p>See SimulationContext.last_val_price.</p>","title":"last_val_price property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.RowContext.last_value","text":"<p>See SimulationContext.last_value.</p>","title":"last_value property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.RowContext.log_records","text":"<p>See SimulationContext.log_records.</p>","title":"log_records property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.RowContext.order_records","text":"<p>See SimulationContext.order_records.</p>","title":"order_records property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.RowContext.second_last_value","text":"<p>See SimulationContext.second_last_value.</p>","title":"second_last_value property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.RowContext.segment_mask","text":"<p>See SimulationContext.segment_mask.</p>","title":"segment_mask property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.RowContext.target_shape","text":"<p>See SimulationContext.target_shape.</p>","title":"target_shape property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.RowContext.update_value","text":"<p>See SimulationContext.update_value.</p>","title":"update_value property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext","text":"<pre><code>SegmentContext(\n    target_shape,\n    group_lens,\n    init_cash,\n    cash_sharing,\n    call_seq,\n    segment_mask,\n    call_pre_segment,\n    call_post_segment,\n    close,\n    ffill_val_price,\n    update_value,\n    fill_pos_record,\n    flex_2d,\n    order_records,\n    log_records,\n    last_cash,\n    last_position,\n    last_debt,\n    last_free_cash,\n    last_val_price,\n    last_value,\n    second_last_value,\n    last_return,\n    last_oidx,\n    last_lidx,\n    last_pos_record,\n    group,\n    group_len,\n    from_col,\n    to_col,\n    i,\n    call_seq_now\n)\n</code></pre> <p>A named tuple representing the context of a segment.</p> <p>A segment is an intersection between groups and rows. It's an entity that defines how and in which order elements within the same group and row are processed.</p> <p>Contains all fields from SimulationContext, GroupContext, and RowContext, plus fields  describing the current segment.</p> <p>Passed to <code>pre_segment_func_nb</code> and <code>post_segment_func_nb</code>.</p> <p>Superclasses</p> <ul> <li><code>builtins.tuple</code></li> </ul>","title":"SegmentContext class"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext.call_post_segment","text":"<p>See SimulationContext.call_post_segment.</p>","title":"call_post_segment property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext.call_pre_segment","text":"<p>See SimulationContext.call_pre_segment.</p>","title":"call_pre_segment property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext.call_seq","text":"<p>See SimulationContext.call_seq.</p>","title":"call_seq property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext.call_seq_now","text":"<p>Sequence of calls within the current segment.</p> <p>Has shape <code>(group_len,)</code>. </p> <p>Each value in this sequence should indicate the position of column in the group to call next. Processing goes always from left to right.</p> <p>You can use <code>pre_segment_func_nb</code> to override <code>call_seq_now</code>.</p> <p>Example</p> <p><code>[2, 0, 1]</code> would first call column 2, then 0, and finally 1.</p>","title":"call_seq_now property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext.cash_sharing","text":"<p>See SimulationContext.cash_sharing.</p>","title":"cash_sharing property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext.close","text":"<p>See SimulationContext.close.</p>","title":"close property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext.ffill_val_price","text":"<p>See SimulationContext.ffill_val_price.</p>","title":"ffill_val_price property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext.fill_pos_record","text":"<p>See SimulationContext.fill_pos_record.</p>","title":"fill_pos_record property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext.flex_2d","text":"<p>See SimulationContext.flex_2d.</p>","title":"flex_2d property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext.from_col","text":"<p>See GroupContext.from_col.</p>","title":"from_col property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext.group","text":"<p>See GroupContext.group.</p>","title":"group property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext.group_len","text":"<p>See GroupContext.group_len.</p>","title":"group_len property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext.group_lens","text":"<p>See SimulationContext.group_lens.</p>","title":"group_lens property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext.i","text":"<p>See RowContext.i.</p>","title":"i property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext.init_cash","text":"<p>See SimulationContext.init_cash.</p>","title":"init_cash property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext.last_cash","text":"<p>See SimulationContext.last_cash.</p>","title":"last_cash property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext.last_debt","text":"<p>See SimulationContext.last_debt.</p>","title":"last_debt property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext.last_free_cash","text":"<p>See SimulationContext.last_free_cash.</p>","title":"last_free_cash property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext.last_lidx","text":"<p>See SimulationContext.last_lidx.</p>","title":"last_lidx property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext.last_oidx","text":"<p>See SimulationContext.last_oidx.</p>","title":"last_oidx property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext.last_pos_record","text":"<p>See SimulationContext.last_pos_record.</p>","title":"last_pos_record property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext.last_position","text":"<p>See SimulationContext.last_position.</p>","title":"last_position property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext.last_return","text":"<p>See SimulationContext.last_return.</p>","title":"last_return property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext.last_val_price","text":"<p>See SimulationContext.last_val_price.</p>","title":"last_val_price property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext.last_value","text":"<p>See SimulationContext.last_value.</p>","title":"last_value property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext.log_records","text":"<p>See SimulationContext.log_records.</p>","title":"log_records property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext.order_records","text":"<p>See SimulationContext.order_records.</p>","title":"order_records property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext.second_last_value","text":"<p>See SimulationContext.second_last_value.</p>","title":"second_last_value property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext.segment_mask","text":"<p>See SimulationContext.segment_mask.</p>","title":"segment_mask property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext.target_shape","text":"<p>See SimulationContext.target_shape.</p>","title":"target_shape property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext.to_col","text":"<p>See GroupContext.to_col.</p>","title":"to_col property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SegmentContext.update_value","text":"<p>See SimulationContext.update_value.</p>","title":"update_value property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SignalContext","text":"<pre><code>SignalContext(\n    i,\n    col,\n    position_now,\n    val_price_now,\n    flex_2d\n)\n</code></pre> <p>SignalContext(i, col, position_now, val_price_now, flex_2d)</p> <p>Superclasses</p> <ul> <li><code>builtins.tuple</code></li> </ul>","title":"SignalContext class"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SignalContext.col","text":"<p>Alias for field number 1</p>","title":"col property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SignalContext.flex_2d","text":"<p>Alias for field number 4</p>","title":"flex_2d property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SignalContext.i","text":"<p>Alias for field number 0</p>","title":"i property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SignalContext.position_now","text":"<p>Alias for field number 2</p>","title":"position_now property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SignalContext.val_price_now","text":"<p>Alias for field number 3</p>","title":"val_price_now property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SimulationContext","text":"<pre><code>SimulationContext(\n    target_shape,\n    group_lens,\n    init_cash,\n    cash_sharing,\n    call_seq,\n    segment_mask,\n    call_pre_segment,\n    call_post_segment,\n    close,\n    ffill_val_price,\n    update_value,\n    fill_pos_record,\n    flex_2d,\n    order_records,\n    log_records,\n    last_cash,\n    last_position,\n    last_debt,\n    last_free_cash,\n    last_val_price,\n    last_value,\n    second_last_value,\n    last_return,\n    last_oidx,\n    last_lidx,\n    last_pos_record\n)\n</code></pre> <p>A named tuple representing the context of a simulation.</p> <p>Contains general information available to all other contexts.</p> <p>Passed to <code>pre_sim_func_nb</code> and <code>post_sim_func_nb</code>.</p> <p>Superclasses</p> <ul> <li><code>builtins.tuple</code></li> </ul>","title":"SimulationContext class"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SimulationContext.call_post_segment","text":"<p>Whether to call <code>post_segment_func_nb</code> regardless of  SimulationContext.segment_mask.</p> <p>Allows, for example, to write user-defined arrays such as returns at the end of each segment.</p>","title":"call_post_segment property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SimulationContext.call_pre_segment","text":"<p>Whether to call <code>pre_segment_func_nb</code> regardless of  SimulationContext.segment_mask.</p>","title":"call_pre_segment property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SimulationContext.call_seq","text":"<p>Default sequence of calls per segment.</p> <p>Controls the sequence in which <code>order_func_nb</code> is executed within each segment.</p> <p>Has shape SimulationContext.target_shape and each value must exist in the range <code>[0, group_len)</code>.</p>  <p>Note</p> <p>To use <code>sort_call_seq_nb</code>, should be generated using <code>CallSeqType.Default</code>.</p> <p>To change the call sequence dynamically, better change SegmentContext.call_seq_now in-place.</p>  <p>Example</p> <p>The default call sequence for three data points and two groups with three columns each:</p> <pre><code>np.array([\n    [0, 1, 2, 0, 1, 2],\n    [0, 1, 2, 0, 1, 2],\n    [0, 1, 2, 0, 1, 2]\n])\n</code></pre>","title":"call_seq property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SimulationContext.cash_sharing","text":"<p>Whether cash sharing is enabled.</p>","title":"cash_sharing property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SimulationContext.close","text":"<p>Latest asset price at each time step.</p> <p>Utilizes flexible indexing using flex_select_auto_nb() and <code>flex_2d</code>,  so it can be passed as </p> <ul> <li>2-dim array, </li> <li>1-dim array per column (requires <code>flex_2d=True</code>), </li> <li>1-dim array per row (requires <code>flex_2d=False</code>), and</li> <li>a scalar. </li> </ul> <p>Broadcasts to the shape SimulationContext.target_shape.</p>  <p>Note</p> <p>To modify the array in place, make sure to build an array of the full shape.</p>","title":"close property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SimulationContext.ffill_val_price","text":"<p>Whether to track valuation price only if it's known.</p> <p>Otherwise, unknown SimulationContext.close will lead to NaN in valuation price at the next timestamp.</p>","title":"ffill_val_price property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SimulationContext.fill_pos_record","text":"<p>Whether to fill position record.</p> <p>Disable this to make simulation a bit faster for simple use cases.</p>","title":"fill_pos_record property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SimulationContext.flex_2d","text":"<p>Whether the elements in a 1-dim array should be treated per column rather than per row.</p> <p>This flag is set automatically when using Portfolio.from_order_func() depending upon  whether there is any argument that has been broadcast to 2 dimensions.</p> <p>Has only effect when using flexible indexing, for example, with flex_select_auto_nb().</p>","title":"flex_2d property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SimulationContext.group_lens","text":"<p>Number of columns in each group.</p> <p>Even if columns are not grouped, <code>group_lens</code> contains ones - one column per group.</p> <p>Example</p> <p>In pairs trading, <code>group_lens</code> would be <code>np.array([2])</code>, while three independent columns would be represented by <code>group_lens</code> of <code>np.array([1, 1, 1])</code>.</p>","title":"group_lens property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SimulationContext.init_cash","text":"<p>Initial capital per column or group with cash sharing.</p> <p>If SimulationContext.cash_sharing, has shape <code>(group_lens.shape[0],)</code>, otherwise has shape <code>(target_shape[1],)</code>.</p> <p>Example</p> <p>Consider three columns, each having $100 of starting capital. If we built one group of two columns with cash sharing and one (imaginary) group with the last column, the <code>init_cash</code> would be  <code>np.array([200, 100])</code>. Without cash sharing, the <code>init_cash</code> would be <code>np.array([100, 100, 100])</code>.</p>","title":"init_cash property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SimulationContext.last_cash","text":"<p>Latest cash per column or group with cash sharing.</p> <p>Has the same shape as SimulationContext.init_cash.</p> <p>Gets updated right after <code>order_func_nb</code>.</p>","title":"last_cash property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SimulationContext.last_debt","text":"<p>Latest debt from shorting per column.</p> <p>Debt is the total value from shorting that hasn't been covered yet. Used to update OrderContext.free_cash_now.</p> <p>Has shape <code>(target_shape[1],)</code>. </p> <p>Gets updated right after <code>order_func_nb</code>.</p>","title":"last_debt property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SimulationContext.last_free_cash","text":"<p>Latest free cash per column or group with cash sharing.</p> <p>Free cash never goes above the initial level, because an operation always costs money.</p> <p>Has shape <code>(target_shape[1],)</code>. </p> <p>Gets updated right after <code>order_func_nb</code>.</p>","title":"last_free_cash property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SimulationContext.last_lidx","text":"<p>Index of the latest log record of each column.</p> <p>Similar to SimulationContext.last_oidx but for log records.</p>","title":"last_lidx property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SimulationContext.last_oidx","text":"<p>Index of the latest order record of each column.</p> <p>Points to SimulationContext.order_records and has shape <code>(target_shape[1],)</code>.</p> <p>Example</p> <p><code>last_oidx</code> of <code>np.array([1, 100, -1])</code> means the latest filled order is <code>order_records[1]</code> for the first column, <code>order_records[100]</code> for the second column, and no orders have been filled yet for the third column.</p>","title":"last_oidx property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SimulationContext.last_pos_record","text":"<p>Latest position record of each column.</p> <p>It's a 1-dimensional array with records of type trade_dt.</p> <p>Has shape <code>(target_shape[1],)</code>.</p> <p>The array is initialized with empty records first (they contain random data) and the field <code>id</code> is set to -1. Once the first position is entered in a column, the <code>id</code> becomes 0 and the record materializes. Once the position is closed, the record fixes its identifier and other data until the next position is entered. </p> <p>The fields <code>entry_price</code> and <code>exit_price</code> are average entry and exit price respectively. The fields <code>pnl</code> and <code>return</code> contain statistics as if the position has been closed and are  re-calculated using SimulationContext.last_val_price after <code>pre_segment_func_nb</code>  (in case SimulationContext.last_val_price has been overridden) and before <code>post_segment_func_nb</code>.</p>  <p>Note</p> <p>In an open position record, the field <code>exit_price</code> doesn't reflect the latest valuation price, but keeps the average price at which the position has been reduced.</p>  <p>The position record is updated after successfully filling an order (after <code>order_func_nb</code> and before <code>post_order_func_nb</code>).</p> <p>Example</p> <p>Consider a simulation that orders <code>order_size</code> for <code>order_price</code> and $1 fixed fees. Here's order info from <code>order_func_nb</code> and the updated position info from <code>post_order_func_nb</code>:</p> <pre><code>    order_size  order_price  id  col  size  entry_idx  entry_price  \\\n0          NaN            1  -1    0   1.0         13    14.000000   \n1          0.5            2   0    0   0.5          1     2.000000   \n2          1.0            3   0    0   1.5          1     2.666667   \n3          NaN            4   0    0   1.5          1     2.666667   \n4         -1.0            5   0    0   1.5          1     2.666667   \n5         -0.5            6   0    0   1.5          1     2.666667   \n6          NaN            7   0    0   1.5          1     2.666667   \n7         -0.5            8   1    0   0.5          7     8.000000   \n8         -1.0            9   1    0   1.5          7     8.666667   \n9          1.0           10   1    0   1.5          7     8.666667   \n10         0.5           11   1    0   1.5          7     8.666667   \n11         1.0           12   2    0   1.0         11    12.000000   \n12        -2.0           13   3    0   1.0         12    13.000000   \n13         2.0           14   4    0   1.0         13    14.000000   \n\n    entry_fees  exit_idx  exit_price  exit_fees   pnl    return  direction  status\n0          0.5        -1         NaN        0.0 -0.50 -0.035714          0       0\n1          1.0        -1         NaN        0.0 -1.00 -1.000000          0       0\n2          2.0        -1         NaN        0.0 -1.50 -0.375000          0       0\n3          2.0        -1         NaN        0.0 -0.75 -0.187500          0       0\n4          2.0        -1    5.000000        1.0  0.50  0.125000          0       0\n5          2.0         5    5.333333        2.0  0.00  0.000000          0       1\n6          2.0         5    5.333333        2.0  0.00  0.000000          0       1\n7          1.0        -1         NaN        0.0 -1.00 -0.250000          1       0\n8          2.0        -1         NaN        0.0 -2.50 -0.192308          1       0\n9          2.0        -1   10.000000        1.0 -5.00 -0.384615          1       0\n10         2.0        10   10.333333        2.0 -6.50 -0.500000          1       1\n11         1.0        -1         NaN        0.0 -1.00 -0.083333          0       0\n12         0.5        -1         NaN        0.0 -0.50 -0.038462          1       0\n13         0.5        -1         NaN        0.0 -0.50 -0.035714          0       0\n</code></pre>","title":"last_pos_record property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SimulationContext.last_position","text":"<p>Latest position per column.</p> <p>Has shape <code>(target_shape[1],)</code>.</p> <p>Gets updated right after <code>order_func_nb</code>.</p>","title":"last_position property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SimulationContext.last_return","text":"<p>Latest return per column or group with cash sharing.</p> <p>Has the same shape as SimulationContext.last_value.</p> <p>Calculated by comparing SimulationContext.last_value to SimulationContext.second_last_value.</p> <p>Gets updated each time SimulationContext.last_value is updated.</p>","title":"last_return property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SimulationContext.last_val_price","text":"<p>Latest valuation price per column.</p> <p>Has shape <code>(target_shape[1],)</code>.</p> <p>Enables <code>SizeType.Value</code>, <code>SizeType.TargetValue</code>, and <code>SizeType.TargetPercent</code>.</p> <p>Gets multiplied by the current position to get the value of the column (see SimulationContext.last_value).</p> <p>Defaults to the SimulationContext.close before <code>post_segment_func_nb</code>. If SimulationContext.ffill_val_price, gets updated only if SimulationContext.close is not NaN. For example, close of <code>[1, 2, np.nan, np.nan, 5]</code> yields valuation price of <code>[1, 2, 2, 2, 5]</code>.</p> <p>Also gets updated right after <code>pre_segment_func_nb</code> - you can use <code>pre_segment_func_nb</code> to override <code>last_val_price</code> in-place, such that <code>order_func_nb</code> can use the new group value.  You are not allowed to use <code>-np.inf</code> or <code>np.inf</code> - only finite values. If SimulationContext.update_value, gets also updated right after <code>order_func_nb</code> using  filled order price as the latest known price.</p>  <p>Note</p> <p>Since the previous SimulationContext.close is NaN in the first row, the first <code>last_val_price</code> is also NaN.</p> <p>Overriding <code>last_val_price</code> with NaN won't apply SimulationContext.ffill_val_price, so your entire group will become NaN.</p>  <p>Example</p> <p>Consider 10 units in column 1 and 20 units in column 2. The previous close of them is $40 and $50 respectively, which is also the default valuation price in the current row, available as <code>last_val_price</code> in <code>pre_segment_func_nb</code>. If both columns are in the same group  with cash sharing, the group is valued at $1400 before any <code>order_func_nb</code> is called, and can  be later accessed via OrderContext.value_now.</p>","title":"last_val_price property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SimulationContext.last_value","text":"<p>Latest value per column or group with cash sharing.</p> <p>Has the same shape as SimulationContext.init_cash.</p> <p>Calculated by multiplying valuation price by the current position. The value of each column in a group with cash sharing is summed to get the value of the entire group.</p> <p>Gets updated using SimulationContext.last_val_price after <code>pre_segment_func_nb</code> and  before <code>post_segment_func_nb</code>. If SimulationContext.update_value, gets also updated right after  <code>order_func_nb</code> using filled order price as the latest known price (the difference will be minimal,  only affected by costs).</p>","title":"last_value property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SimulationContext.log_records","text":"<p>Log records.</p> <p>Similar to SimulationContext.order_records but of type log_dt and index SimulationContext.last_lidx.</p>","title":"log_records property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SimulationContext.order_records","text":"<p>Order records.</p> <p>It's a 1-dimensional array with records of type order_dt.</p> <p>The array is initialized with empty records first (they contain random data), and then  gradually filled with order data. The number of initialized records depends upon <code>max_orders</code>,  but usually it's <code>target_shape[0] * target_shape[1]</code>, meaning there is maximal one order record per element. <code>max_orders</code> can be chosen lower if not every <code>order_func_nb</code> leads to a filled order, to save memory.</p> <p>You can use SimulationContext.last_oidx to get the index of the latest filled order of each column.</p> <p>Example</p> <p>Before filling, each order record looks like this:</p> <pre><code>np.array([(-8070450532247928832, -8070450532247928832, 4, 0., 0., 0., 5764616306889786413)]\n</code></pre> <p>After filling, it becomes like this:</p> <pre><code>np.array([(0, 0, 1, 50., 1., 0., 1)]\n</code></pre>","title":"order_records property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SimulationContext.second_last_value","text":"<p>Second-latest value per column or group with cash sharing.</p> <p>Has the same shape as SimulationContext.last_value.</p> <p>Contains the latest known value two rows before (<code>i - 2</code>) to be compared either with the latest known value  one row before (<code>i - 1</code>) or now (<code>i</code>).</p> <p>Gets updated at the end of each segment/row. </p>","title":"second_last_value property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SimulationContext.segment_mask","text":"<p>Mask of whether a particular segment should be executed.</p> <p>A segment is simply a sequence of <code>order_func_nb</code> calls under the same group and row.</p> <p>If a segment is inactive, any callback function inside of it will not be executed. You can still execute the segment's pre- and postprocessing function by enabling  SimulationContext.call_pre_segment and SimulationContext.call_post_segment respectively.</p> <p>Utilizes flexible indexing using flex_select_auto_nb() and <code>flex_2d</code>,  so it can be passed as </p> <ul> <li>2-dim array, </li> <li>1-dim array per column (requires <code>flex_2d=True</code>), </li> <li>1-dim array per row (requires <code>flex_2d=False</code>), and</li> <li>a scalar. </li> </ul> <p>Broadcasts to the shape <code>(target_shape[0], group_lens.shape[0])</code>.</p>  <p>Note</p> <p>To modify the array in place, make sure to build an array of the full shape.</p>  <p>Example</p> <p>Consider two groups with two columns each and the following activity mask:</p> <pre><code>np.array([[ True, False], \n          [False,  True]])\n</code></pre> <p>The first group is only executed in the first row and the second group is only executed in the second row.</p>","title":"segment_mask property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SimulationContext.target_shape","text":"<p>Target shape of the simulation.</p> <p>A tuple with exactly two elements: the number of rows and columns.</p> <p>Example</p> <p>One day of minute data for three assets would yield a <code>target_shape</code> of <code>(1440, 3)</code>, where the first axis are rows (minutes) and the second axis are columns (assets).</p>","title":"target_shape property"},{"location":"api/portfolio/enums/#vectorbt.portfolio.enums.SimulationContext.update_value","text":"<p>Whether to update group value after each filled order.</p> <p>Otherwise, stays the same for all columns in the group (the value is calculated only once, before executing any order).</p> <p>The change is marginal and mostly driven by transaction costs and slippage.</p>","title":"update_value property"},{"location":"api/portfolio/logs/","text":"<p>Base class for working with log records.</p> <p>Order records capture information on simulation logs. Logs are populated when simulating a portfolio and can be accessed as Portfolio.logs.</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from datetime import datetime, timedelta\n&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; np.random.seed(42)\n&gt;&gt;&gt; price = pd.DataFrame({\n...     'a': np.random.uniform(1, 2, size=100),\n...     'b': np.random.uniform(1, 2, size=100)\n... }, index=[datetime(2020, 1, 1) + timedelta(days=i) for i in range(100)])\n&gt;&gt;&gt; size = pd.DataFrame({\n...     'a': np.random.uniform(-100, 100, size=100),\n...     'b': np.random.uniform(-100, 100, size=100),\n... }, index=[datetime(2020, 1, 1) + timedelta(days=i) for i in range(100)])\n&gt;&gt;&gt; pf = vbt.Portfolio.from_orders(price, size, fees=0.01, freq='d', log=True)\n&gt;&gt;&gt; logs = pf.logs\n\n&gt;&gt;&gt; logs.filled.count()\na    88\nb    99\nName: count, dtype: int64\n\n&gt;&gt;&gt; logs.ignored.count()\na    0\nb    0\nName: count, dtype: int64\n\n&gt;&gt;&gt; logs.rejected.count()\na    12\nb     1\nName: count, dtype: int64\n</code></pre>","title":"logs"},{"location":"api/portfolio/logs/#stats","text":"<p>Hint</p> <p>See StatsBuilderMixin.stats() and Logs.metrics.</p>  <pre><code>&gt;&gt;&gt; logs['a'].stats()\nStart                             2020-01-01 00:00:00\nEnd                               2020-04-09 00:00:00\nPeriod                              100 days 00:00:00\nTotal Records                                     100\nStatus Counts: None                                 0\nStatus Counts: Filled                              88\nStatus Counts: Ignored                              0\nStatus Counts: Rejected                            12\nStatus Info Counts: None                           88\nStatus Info Counts: NoCashLong                     12\nName: a, dtype: object\n</code></pre> <p>StatsBuilderMixin.stats() also supports (re-)grouping:</p> <pre><code>&gt;&gt;&gt; logs.stats(group_by=True)\nStart                             2020-01-01 00:00:00\nEnd                               2020-04-09 00:00:00\nPeriod                              100 days 00:00:00\nTotal Records                                     200\nStatus Counts: None                                 0\nStatus Counts: Filled                             187\nStatus Counts: Ignored                              0\nStatus Counts: Rejected                            13\nStatus Info Counts: None                          187\nStatus Info Counts: NoCashLong                     13\nName: group, dtype: object\n</code></pre>","title":"Stats"},{"location":"api/portfolio/logs/#plots","text":"<p>Hint</p> <p>See PlotsBuilderMixin.plots() and Logs.subplots.</p>  <p>This class does not have any subplots.</p>","title":"Plots"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.logs_attach_field_config","text":"<p>Config of fields to be attached to Logs.</p> <pre><code>Config({\n    \"res_side\": {\n        \"attach_filters\": true\n    },\n    \"res_status\": {\n        \"attach_filters\": true\n    },\n    \"res_status_info\": {\n        \"attach_filters\": true\n    }\n})\n</code></pre>","title":"logs_attach_field_config variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.logs_field_config","text":"<p>Field config for Logs.</p> <pre><code>Config({\n    \"dtype\": {\n        \"id\": \"int64\",\n        \"group\": \"int64\",\n        \"col\": \"int64\",\n        \"idx\": \"int64\",\n        \"cash\": \"float64\",\n        \"position\": \"float64\",\n        \"debt\": \"float64\",\n        \"free_cash\": \"float64\",\n        \"val_price\": \"float64\",\n        \"value\": \"float64\",\n        \"req_size\": \"float64\",\n        \"req_price\": \"float64\",\n        \"req_size_type\": \"int64\",\n        \"req_direction\": \"int64\",\n        \"req_fees\": \"float64\",\n        \"req_fixed_fees\": \"float64\",\n        \"req_slippage\": \"float64\",\n        \"req_min_size\": \"float64\",\n        \"req_max_size\": \"float64\",\n        \"req_size_granularity\": \"float64\",\n        \"req_reject_prob\": \"float64\",\n        \"req_lock_cash\": \"bool\",\n        \"req_allow_partial\": \"bool\",\n        \"req_raise_reject\": \"bool\",\n        \"req_log\": \"bool\",\n        \"new_cash\": \"float64\",\n        \"new_position\": \"float64\",\n        \"new_debt\": \"float64\",\n        \"new_free_cash\": \"float64\",\n        \"new_val_price\": \"float64\",\n        \"new_value\": \"float64\",\n        \"res_size\": \"float64\",\n        \"res_price\": \"float64\",\n        \"res_fees\": \"float64\",\n        \"res_side\": \"int64\",\n        \"res_status\": \"int64\",\n        \"res_status_info\": \"int64\",\n        \"order_id\": \"int64\"\n    },\n    \"settings\": {\n        \"id\": {\n            \"title\": \"Log Id\"\n        },\n        \"group\": {\n            \"title\": \"Group\"\n        },\n        \"cash\": {\n            \"title\": \"Cash\"\n        },\n        \"position\": {\n            \"title\": \"Position\"\n        },\n        \"debt\": {\n            \"title\": \"Debt\"\n        },\n        \"free_cash\": {\n            \"title\": \"Free Cash\"\n        },\n        \"val_price\": {\n            \"title\": \"Val Price\"\n        },\n        \"value\": {\n            \"title\": \"Value\"\n        },\n        \"req_size\": {\n            \"title\": \"Request Size\"\n        },\n        \"req_price\": {\n            \"title\": \"Request Price\"\n        },\n        \"req_size_type\": {\n            \"title\": \"Request Size Type\",\n            \"mapping\": {\n                \"Amount\": 0,\n                \"Value\": 1,\n                \"Percent\": 2,\n                \"TargetAmount\": 3,\n                \"TargetValue\": 4,\n                \"TargetPercent\": 5\n            }\n        },\n        \"req_direction\": {\n            \"title\": \"Request Direction\",\n            \"mapping\": {\n                \"LongOnly\": 0,\n                \"ShortOnly\": 1,\n                \"Both\": 2\n            }\n        },\n        \"req_fees\": {\n            \"title\": \"Request Fees\"\n        },\n        \"req_fixed_fees\": {\n            \"title\": \"Request Fixed Fees\"\n        },\n        \"req_slippage\": {\n            \"title\": \"Request Slippage\"\n        },\n        \"req_min_size\": {\n            \"title\": \"Request Min Size\"\n        },\n        \"req_max_size\": {\n            \"title\": \"Request Max Size\"\n        },\n        \"req_size_granularity\": {\n            \"title\": \"Request Size Granularity\"\n        },\n        \"req_reject_prob\": {\n            \"title\": \"Request Rejection Prob\"\n        },\n        \"req_lock_cash\": {\n            \"title\": \"Request Lock Cash\"\n        },\n        \"req_allow_partial\": {\n            \"title\": \"Request Allow Partial\"\n        },\n        \"req_raise_reject\": {\n            \"title\": \"Request Raise Rejection\"\n        },\n        \"req_log\": {\n            \"title\": \"Request Log\"\n        },\n        \"new_cash\": {\n            \"title\": \"New Cash\"\n        },\n        \"new_position\": {\n            \"title\": \"New Position\"\n        },\n        \"new_debt\": {\n            \"title\": \"New Debt\"\n        },\n        \"new_free_cash\": {\n            \"title\": \"New Free Cash\"\n        },\n        \"new_val_price\": {\n            \"title\": \"New Val Price\"\n        },\n        \"new_value\": {\n            \"title\": \"New Value\"\n        },\n        \"res_size\": {\n            \"title\": \"Result Size\"\n        },\n        \"res_price\": {\n            \"title\": \"Result Price\"\n        },\n        \"res_fees\": {\n            \"title\": \"Result Fees\"\n        },\n        \"res_side\": {\n            \"title\": \"Result Side\",\n            \"mapping\": {\n                \"Buy\": 0,\n                \"Sell\": 1\n            }\n        },\n        \"res_status\": {\n            \"title\": \"Result Status\",\n            \"mapping\": {\n                \"Filled\": 0,\n                \"Ignored\": 1,\n                \"Rejected\": 2\n            }\n        },\n        \"res_status_info\": {\n            \"title\": \"Result Status Info\",\n            \"mapping\": {\n                \"SizeNaN\": 0,\n                \"PriceNaN\": 1,\n                \"ValPriceNaN\": 2,\n                \"ValueNaN\": 3,\n                \"ValueZeroNeg\": 4,\n                \"SizeZero\": 5,\n                \"NoCashShort\": 6,\n                \"NoCashLong\": 7,\n                \"NoOpenPosition\": 8,\n                \"MaxSizeExceeded\": 9,\n                \"RandomEvent\": 10,\n                \"CantCoverFees\": 11,\n                \"MinSizeNotReached\": 12,\n                \"PartialFill\": 13\n            }\n        },\n        \"order_id\": {\n            \"title\": \"Order Id\"\n        }\n    }\n})\n</code></pre>","title":"logs_field_config variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs","text":"<pre><code>Logs(\n    wrapper,\n    records_arr,\n    col_mapper=None,\n    **kwargs\n)\n</code></pre> <p>Extends <code>Records</code> for working with log records.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>Records</li> <li>RecordsWithFields</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>Records.apply()</li> <li>Records.apply_mask()</li> <li>Records.build_field_config_doc()</li> <li>Records.col_arr</li> <li>Records.col_mapper</li> <li>Records.config</li> <li>Records.count()</li> <li>Records.get_apply_mapping_arr()</li> <li>Records.get_by_col_idxs()</li> <li>Records.get_field_arr()</li> <li>Records.get_field_mapping()</li> <li>Records.get_field_name()</li> <li>Records.get_field_setting()</li> <li>Records.get_field_title()</li> <li>Records.get_map_field()</li> <li>Records.get_map_field_to_index()</li> <li>Records.id_arr</li> <li>Records.idx_arr</li> <li>Records.iloc</li> <li>Records.indexing_func()</li> <li>Records.indexing_func_meta()</li> <li>Records.indexing_kwargs</li> <li>Records.is_sorted()</li> <li>Records.loc</li> <li>Records.map()</li> <li>Records.map_array()</li> <li>Records.map_field()</li> <li>Records.override_field_config_doc()</li> <li>Records.records</li> <li>Records.records_arr</li> <li>Records.records_readable</li> <li>Records.replace()</li> <li>Records.self_aliases</li> <li>Records.sort()</li> <li>Records.values</li> <li>Records.wrapper</li> <li>Records.writeable_attrs</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul>","title":"Logs class"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.field_config","text":"<p>Field config of Logs.</p> <pre><code>Config({\n    \"dtype\": {\n        \"id\": \"int64\",\n        \"group\": \"int64\",\n        \"col\": \"int64\",\n        \"idx\": \"int64\",\n        \"cash\": \"float64\",\n        \"position\": \"float64\",\n        \"debt\": \"float64\",\n        \"free_cash\": \"float64\",\n        \"val_price\": \"float64\",\n        \"value\": \"float64\",\n        \"req_size\": \"float64\",\n        \"req_price\": \"float64\",\n        \"req_size_type\": \"int64\",\n        \"req_direction\": \"int64\",\n        \"req_fees\": \"float64\",\n        \"req_fixed_fees\": \"float64\",\n        \"req_slippage\": \"float64\",\n        \"req_min_size\": \"float64\",\n        \"req_max_size\": \"float64\",\n        \"req_size_granularity\": \"float64\",\n        \"req_reject_prob\": \"float64\",\n        \"req_lock_cash\": \"bool\",\n        \"req_allow_partial\": \"bool\",\n        \"req_raise_reject\": \"bool\",\n        \"req_log\": \"bool\",\n        \"new_cash\": \"float64\",\n        \"new_position\": \"float64\",\n        \"new_debt\": \"float64\",\n        \"new_free_cash\": \"float64\",\n        \"new_val_price\": \"float64\",\n        \"new_value\": \"float64\",\n        \"res_size\": \"float64\",\n        \"res_price\": \"float64\",\n        \"res_fees\": \"float64\",\n        \"res_side\": \"int64\",\n        \"res_status\": \"int64\",\n        \"res_status_info\": \"int64\",\n        \"order_id\": \"int64\"\n    },\n    \"settings\": {\n        \"id\": {\n            \"name\": \"id\",\n            \"title\": \"Log Id\"\n        },\n        \"col\": {\n            \"name\": \"col\",\n            \"title\": \"Column\",\n            \"mapping\": \"columns\"\n        },\n        \"idx\": {\n            \"name\": \"idx\",\n            \"title\": \"Timestamp\",\n            \"mapping\": \"index\"\n        },\n        \"group\": {\n            \"title\": \"Group\"\n        },\n        \"cash\": {\n            \"title\": \"Cash\"\n        },\n        \"position\": {\n            \"title\": \"Position\"\n        },\n        \"debt\": {\n            \"title\": \"Debt\"\n        },\n        \"free_cash\": {\n            \"title\": \"Free Cash\"\n        },\n        \"val_price\": {\n            \"title\": \"Val Price\"\n        },\n        \"value\": {\n            \"title\": \"Value\"\n        },\n        \"req_size\": {\n            \"title\": \"Request Size\"\n        },\n        \"req_price\": {\n            \"title\": \"Request Price\"\n        },\n        \"req_size_type\": {\n            \"title\": \"Request Size Type\",\n            \"mapping\": {\n                \"Amount\": 0,\n                \"Value\": 1,\n                \"Percent\": 2,\n                \"TargetAmount\": 3,\n                \"TargetValue\": 4,\n                \"TargetPercent\": 5\n            }\n        },\n        \"req_direction\": {\n            \"title\": \"Request Direction\",\n            \"mapping\": {\n                \"LongOnly\": 0,\n                \"ShortOnly\": 1,\n                \"Both\": 2\n            }\n        },\n        \"req_fees\": {\n            \"title\": \"Request Fees\"\n        },\n        \"req_fixed_fees\": {\n            \"title\": \"Request Fixed Fees\"\n        },\n        \"req_slippage\": {\n            \"title\": \"Request Slippage\"\n        },\n        \"req_min_size\": {\n            \"title\": \"Request Min Size\"\n        },\n        \"req_max_size\": {\n            \"title\": \"Request Max Size\"\n        },\n        \"req_size_granularity\": {\n            \"title\": \"Request Size Granularity\"\n        },\n        \"req_reject_prob\": {\n            \"title\": \"Request Rejection Prob\"\n        },\n        \"req_lock_cash\": {\n            \"title\": \"Request Lock Cash\"\n        },\n        \"req_allow_partial\": {\n            \"title\": \"Request Allow Partial\"\n        },\n        \"req_raise_reject\": {\n            \"title\": \"Request Raise Rejection\"\n        },\n        \"req_log\": {\n            \"title\": \"Request Log\"\n        },\n        \"new_cash\": {\n            \"title\": \"New Cash\"\n        },\n        \"new_position\": {\n            \"title\": \"New Position\"\n        },\n        \"new_debt\": {\n            \"title\": \"New Debt\"\n        },\n        \"new_free_cash\": {\n            \"title\": \"New Free Cash\"\n        },\n        \"new_val_price\": {\n            \"title\": \"New Val Price\"\n        },\n        \"new_value\": {\n            \"title\": \"New Value\"\n        },\n        \"res_size\": {\n            \"title\": \"Result Size\"\n        },\n        \"res_price\": {\n            \"title\": \"Result Price\"\n        },\n        \"res_fees\": {\n            \"title\": \"Result Fees\"\n        },\n        \"res_side\": {\n            \"title\": \"Result Side\",\n            \"mapping\": {\n                \"Buy\": 0,\n                \"Sell\": 1\n            }\n        },\n        \"res_status\": {\n            \"title\": \"Result Status\",\n            \"mapping\": {\n                \"Filled\": 0,\n                \"Ignored\": 1,\n                \"Rejected\": 2\n            }\n        },\n        \"res_status_info\": {\n            \"title\": \"Result Status Info\",\n            \"mapping\": {\n                \"SizeNaN\": 0,\n                \"PriceNaN\": 1,\n                \"ValPriceNaN\": 2,\n                \"ValueNaN\": 3,\n                \"ValueZeroNeg\": 4,\n                \"SizeZero\": 5,\n                \"NoCashShort\": 6,\n                \"NoCashLong\": 7,\n                \"NoOpenPosition\": 8,\n                \"MaxSizeExceeded\": 9,\n                \"RandomEvent\": 10,\n                \"CantCoverFees\": 11,\n                \"MinSizeNotReached\": 12,\n                \"PartialFill\": 13\n            }\n        },\n        \"order_id\": {\n            \"title\": \"Order Id\"\n        }\n    }\n})\n</code></pre>","title":"field_config class variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.metrics","text":"<p>Metrics supported by Logs.</p> <pre><code>Config({\n    \"start\": {\n        \"title\": \"Start\",\n        \"calc_func\": \"&lt;function Logs.&lt;lambda&gt; at 0x7ff52151c378&gt;\",\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"end\": {\n        \"title\": \"End\",\n        \"calc_func\": \"&lt;function Logs.&lt;lambda&gt; at 0x7ff52151c400&gt;\",\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"period\": {\n        \"title\": \"Period\",\n        \"calc_func\": \"&lt;function Logs.&lt;lambda&gt; at 0x7ff52151c488&gt;\",\n        \"apply_to_timedelta\": true,\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"total_records\": {\n        \"title\": \"Total Records\",\n        \"calc_func\": \"count\",\n        \"tags\": \"records\"\n    },\n    \"res_status_counts\": {\n        \"title\": \"Status Counts\",\n        \"calc_func\": \"res_status.value_counts\",\n        \"incl_all_keys\": true,\n        \"post_calc_func\": \"&lt;function Logs.&lt;lambda&gt; at 0x7ff52151c510&gt;\",\n        \"tags\": [\n            \"logs\",\n            \"res_status\",\n            \"value_counts\"\n        ]\n    },\n    \"res_status_info_counts\": {\n        \"title\": \"Status Info Counts\",\n        \"calc_func\": \"res_status_info.value_counts\",\n        \"post_calc_func\": \"&lt;function Logs.&lt;lambda&gt; at 0x7ff52151c598&gt;\",\n        \"tags\": [\n            \"logs\",\n            \"res_status_info\",\n            \"value_counts\"\n        ]\n    }\n})\n</code></pre> <p>Returns <code>Logs._metrics</code>, which gets (deep) copied upon creation of each instance. Thus, changing this config won't affect the class.</p> <p>To change metrics, you can either change the config in-place, override this property, or overwrite the instance variable <code>Logs._metrics</code>.</p>","title":"metrics class variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.subplots","text":"<p>Subplots supported by Logs.</p> <pre><code>Config({})\n</code></pre> <p>Returns <code>Logs._subplots</code>, which gets (deep) copied upon creation of each instance. Thus, changing this config won't affect the class.</p> <p>To change subplots, you can either change the config in-place, override this property, or overwrite the instance variable <code>Logs._subplots</code>.</p>","title":"subplots class variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.buy","text":"<p>Records filtered by <code>res_side == 0</code>.</p>","title":"buy variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.cant_cover_fees","text":"<p>Records filtered by <code>res_status_info == 11</code>.</p>","title":"cant_cover_fees variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.cash","text":"<p>Mapped array of the field <code>cash</code>.</p>","title":"cash variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.col","text":"<p>Mapped array of the field <code>col</code>.</p>","title":"col variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.debt","text":"<p>Mapped array of the field <code>debt</code>.</p>","title":"debt variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.filled","text":"<p>Records filtered by <code>res_status == 0</code>.</p>","title":"filled variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.free_cash","text":"<p>Mapped array of the field <code>free_cash</code>.</p>","title":"free_cash variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.group","text":"<p>Mapped array of the field <code>group</code>.</p>","title":"group variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.id","text":"<p>Mapped array of the field <code>id</code>.</p>","title":"id variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.idx","text":"<p>Mapped array of the field <code>idx</code>.</p>","title":"idx variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.ignored","text":"<p>Records filtered by <code>res_status == 1</code>.</p>","title":"ignored variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.max_size_exceeded","text":"<p>Records filtered by <code>res_status_info == 9</code>.</p>","title":"max_size_exceeded variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.min_size_not_reached","text":"<p>Records filtered by <code>res_status_info == 12</code>.</p>","title":"min_size_not_reached variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.new_cash","text":"<p>Mapped array of the field <code>new_cash</code>.</p>","title":"new_cash variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.new_debt","text":"<p>Mapped array of the field <code>new_debt</code>.</p>","title":"new_debt variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.new_free_cash","text":"<p>Mapped array of the field <code>new_free_cash</code>.</p>","title":"new_free_cash variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.new_position","text":"<p>Mapped array of the field <code>new_position</code>.</p>","title":"new_position variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.new_val_price","text":"<p>Mapped array of the field <code>new_val_price</code>.</p>","title":"new_val_price variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.new_value","text":"<p>Mapped array of the field <code>new_value</code>.</p>","title":"new_value variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.no_cash_long","text":"<p>Records filtered by <code>res_status_info == 7</code>.</p>","title":"no_cash_long variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.no_cash_short","text":"<p>Records filtered by <code>res_status_info == 6</code>.</p>","title":"no_cash_short variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.no_open_position","text":"<p>Records filtered by <code>res_status_info == 8</code>.</p>","title":"no_open_position variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.order_id","text":"<p>Mapped array of the field <code>order_id</code>.</p>","title":"order_id variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.partial_fill","text":"<p>Records filtered by <code>res_status_info == 13</code>.</p>","title":"partial_fill variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.plots_defaults","text":"<p>Defaults for PlotsBuilderMixin.plots().</p> <p>Merges Records.plots_defaults and <code>logs.plots</code> from settings.</p>","title":"plots_defaults property"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.position","text":"<p>Mapped array of the field <code>position</code>.</p>","title":"position variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.price_nan","text":"<p>Records filtered by <code>res_status_info == 1</code>.</p>","title":"price_nan variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.random_event","text":"<p>Records filtered by <code>res_status_info == 10</code>.</p>","title":"random_event variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.rejected","text":"<p>Records filtered by <code>res_status == 2</code>.</p>","title":"rejected variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.req_allow_partial","text":"<p>Mapped array of the field <code>req_allow_partial</code>.</p>","title":"req_allow_partial variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.req_direction","text":"<p>Mapped array of the field <code>req_direction</code>.</p>","title":"req_direction variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.req_fees","text":"<p>Mapped array of the field <code>req_fees</code>.</p>","title":"req_fees variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.req_fixed_fees","text":"<p>Mapped array of the field <code>req_fixed_fees</code>.</p>","title":"req_fixed_fees variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.req_lock_cash","text":"<p>Mapped array of the field <code>req_lock_cash</code>.</p>","title":"req_lock_cash variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.req_log","text":"<p>Mapped array of the field <code>req_log</code>.</p>","title":"req_log variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.req_max_size","text":"<p>Mapped array of the field <code>req_max_size</code>.</p>","title":"req_max_size variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.req_min_size","text":"<p>Mapped array of the field <code>req_min_size</code>.</p>","title":"req_min_size variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.req_price","text":"<p>Mapped array of the field <code>req_price</code>.</p>","title":"req_price variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.req_raise_reject","text":"<p>Mapped array of the field <code>req_raise_reject</code>.</p>","title":"req_raise_reject variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.req_reject_prob","text":"<p>Mapped array of the field <code>req_reject_prob</code>.</p>","title":"req_reject_prob variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.req_size","text":"<p>Mapped array of the field <code>req_size</code>.</p>","title":"req_size variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.req_size_granularity","text":"<p>Mapped array of the field <code>req_size_granularity</code>.</p>","title":"req_size_granularity variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.req_size_type","text":"<p>Mapped array of the field <code>req_size_type</code>.</p>","title":"req_size_type variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.req_slippage","text":"<p>Mapped array of the field <code>req_slippage</code>.</p>","title":"req_slippage variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.res_fees","text":"<p>Mapped array of the field <code>res_fees</code>.</p>","title":"res_fees variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.res_price","text":"<p>Mapped array of the field <code>res_price</code>.</p>","title":"res_price variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.res_side","text":"<p>Mapped array of the field <code>res_side</code>.</p>","title":"res_side variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.res_size","text":"<p>Mapped array of the field <code>res_size</code>.</p>","title":"res_size variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.res_status","text":"<p>Mapped array of the field <code>res_status</code>.</p>","title":"res_status variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.res_status_info","text":"<p>Mapped array of the field <code>res_status_info</code>.</p>","title":"res_status_info variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.sell","text":"<p>Records filtered by <code>res_side == 1</code>.</p>","title":"sell variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.size_nan","text":"<p>Records filtered by <code>res_status_info == 0</code>.</p>","title":"size_nan variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.size_zero","text":"<p>Records filtered by <code>res_status_info == 5</code>.</p>","title":"size_zero variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.stats_defaults","text":"<p>Defaults for StatsBuilderMixin.stats().</p> <p>Merges Records.stats_defaults and <code>logs.stats</code> from settings.</p>","title":"stats_defaults property"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.val_price","text":"<p>Mapped array of the field <code>val_price</code>.</p>","title":"val_price variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.val_price_nan","text":"<p>Records filtered by <code>res_status_info == 2</code>.</p>","title":"val_price_nan variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.value","text":"<p>Mapped array of the field <code>value</code>.</p>","title":"value variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.value_nan","text":"<p>Records filtered by <code>res_status_info == 3</code>.</p>","title":"value_nan variable"},{"location":"api/portfolio/logs/#vectorbt.portfolio.logs.Logs.value_zero_neg","text":"<p>Records filtered by <code>res_status_info == 4</code>.</p>","title":"value_zero_neg variable"},{"location":"api/portfolio/nb/","text":"<p>Numba-compiled functions.</p> <p>Provides an arsenal of Numba-compiled functions that are used for portfolio modeling, such as generating and filling orders. These only accept NumPy arrays and other Numba-compatible types.</p>  <p>Note</p> <p>vectorbt treats matrices as first-class citizens and expects input arrays to be 2-dim, unless function has suffix <code>_1d</code> or is meant to be input to another function.</p> <p>All functions passed as argument should be Numba-compiled.</p> <p>Records should retain the order they were created in.</p>   <p>Warning</p> <p>Accumulation of roundoff error possible. See here for explanation.</p> <p>Rounding errors can cause trades and positions to not close properly:</p> <pre><code>&gt;&gt;&gt; print('%.50f' % 0.1)  # has positive error\n0.10000000000000000555111512312578270211815834045410\n\n&gt;&gt;&gt; # many buy transactions with positive error -&gt; cannot close position\n&gt;&gt;&gt; sum([0.1 for _ in range(1000000)]) - 100000\n1.3328826753422618e-06\n\n&gt;&gt;&gt; print('%.50f' % 0.3)  # has negative error\n0.29999999999999998889776975374843459576368331909180\n\n&gt;&gt;&gt; # many sell transactions with negative error -&gt; cannot close position\n&gt;&gt;&gt; 300000 - sum([0.3 for _ in range(1000000)])\n5.657668225467205e-06\n</code></pre> <p>While vectorbt has implemented tolerance checks when comparing floats for equality, adding/subtracting small amounts large number of times may still introduce a noticable error that cannot be corrected post factum.</p> <p>To mitigate this issue, avoid repeating lots of micro-transactions of the same sign. For example, reduce by <code>np.inf</code> or <code>position_now</code> to close a long/short position.</p> <p>See vectorbt.utils.math_ for current tolerance values.</p>","title":"nb"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.approx_order_value_nb","text":"<pre><code>approx_order_value_nb(\n    size,\n    size_type,\n    direction,\n    cash_now,\n    position_now,\n    free_cash_now,\n    val_price_now,\n    value_now\n)\n</code></pre> <p>Approximate value of an order.</p>","title":"approx_order_value_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.asset_flow_nb","text":"<pre><code>asset_flow_nb(\n    target_shape,\n    order_records,\n    col_map,\n    direction\n)\n</code></pre> <p>Get asset flow series per column.</p> <p>Returns the total transacted amount of assets at each time step.</p>","title":"asset_flow_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.asset_returns_nb","text":"<pre><code>asset_returns_nb(\n    cash_flow,\n    asset_value\n)\n</code></pre> <p>Get asset return series per column/group.</p>","title":"asset_returns_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.asset_value_grouped_nb","text":"<pre><code>asset_value_grouped_nb(\n    asset_value,\n    group_lens\n)\n</code></pre> <p>Get asset value series per group.</p>","title":"asset_value_grouped_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.asset_value_nb","text":"<pre><code>asset_value_nb(\n    close,\n    assets\n)\n</code></pre> <p>Get asset value series per column.</p>","title":"asset_value_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.assets_nb","text":"<pre><code>assets_nb(\n    asset_flow\n)\n</code></pre> <p>Get asset series per column.</p> <p>Returns the current position at each time step.</p>","title":"assets_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.benchmark_value_grouped_nb","text":"<pre><code>benchmark_value_grouped_nb(\n    close,\n    group_lens,\n    init_cash_grouped\n)\n</code></pre> <p>Get market value per group.</p>","title":"benchmark_value_grouped_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.benchmark_value_nb","text":"<pre><code>benchmark_value_nb(\n    close,\n    init_cash\n)\n</code></pre> <p>Get market value per column.</p>","title":"benchmark_value_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.build_call_seq","text":"<pre><code>build_call_seq(\n    target_shape,\n    group_lens,\n    call_seq_type=0\n)\n</code></pre> <p>Not compiled but faster version of build_call_seq_nb().</p>","title":"build_call_seq function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.build_call_seq_nb","text":"<pre><code>build_call_seq_nb(\n    target_shape,\n    group_lens,\n    call_seq_type=0\n)\n</code></pre> <p>Build a new call sequence array.</p>","title":"build_call_seq_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.buy_nb","text":"<pre><code>buy_nb(\n    exec_state,\n    size,\n    price,\n    direction=2,\n    fees=0.0,\n    fixed_fees=0.0,\n    slippage=0.0,\n    min_size=0.0,\n    max_size=inf,\n    size_granularity=nan,\n    lock_cash=False,\n    allow_partial=True,\n    percent=nan\n)\n</code></pre> <p>Buy or/and cover.</p>","title":"buy_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.cash_flow_grouped_nb","text":"<pre><code>cash_flow_grouped_nb(\n    cash_flow,\n    group_lens\n)\n</code></pre> <p>Get cash flow series per group.</p>","title":"cash_flow_grouped_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.cash_flow_nb","text":"<pre><code>cash_flow_nb(\n    target_shape,\n    order_records,\n    col_map,\n    free\n)\n</code></pre> <p>Get (free) cash flow series per column.</p>","title":"cash_flow_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.cash_grouped_nb","text":"<pre><code>cash_grouped_nb(\n    target_shape,\n    cash_flow_grouped,\n    group_lens,\n    init_cash_grouped\n)\n</code></pre> <p>Get cash series per group.</p>","title":"cash_grouped_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.cash_in_sim_order_nb","text":"<pre><code>cash_in_sim_order_nb(\n    cash_flow,\n    group_lens,\n    init_cash_grouped,\n    call_seq\n)\n</code></pre> <p>Get cash series in simulation order.</p>","title":"cash_in_sim_order_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.cash_nb","text":"<pre><code>cash_nb(\n    cash_flow,\n    init_cash\n)\n</code></pre> <p>Get cash series per column.</p>","title":"cash_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.check_group_init_cash_nb","text":"<pre><code>check_group_init_cash_nb(\n    group_lens,\n    n_cols,\n    init_cash,\n    cash_sharing\n)\n</code></pre> <p>Check <code>init_cash</code>.</p>","title":"check_group_init_cash_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.check_group_lens_nb","text":"<pre><code>check_group_lens_nb(\n    group_lens,\n    n_cols\n)\n</code></pre> <p>Check <code>group_lens</code>.</p>","title":"check_group_lens_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.close_position_nb","text":"<pre><code>close_position_nb(\n    price=inf,\n    fees=0.0,\n    fixed_fees=0.0,\n    slippage=0.0,\n    min_size=0.0,\n    max_size=inf,\n    size_granularity=nan,\n    reject_prob=0.0,\n    lock_cash=False,\n    allow_partial=True,\n    raise_reject=False,\n    log=False\n)\n</code></pre> <p>Close the current position.</p>","title":"close_position_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.copy_trade_record_nb","text":"<pre><code>copy_trade_record_nb(\n    record,\n    trade_record\n)\n</code></pre> <p>Copy a trade record.</p>","title":"copy_trade_record_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.dir_enex_signal_func_nb","text":"<pre><code>dir_enex_signal_func_nb(\n    c,\n    entries,\n    exits,\n    direction\n)\n</code></pre> <p>Resolve direction-aware signals out of entries, exits, and direction.</p>","title":"dir_enex_signal_func_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.execute_order_nb","text":"<pre><code>execute_order_nb(\n    state,\n    order\n)\n</code></pre> <p>Execute an order given the current state.</p> <p>Args</p>  <code>state</code> :\u2002<code>ProcessOrderState</code> See ProcessOrderState. <code>order</code> :\u2002<code>Order</code> See Order.  <p>Error is thrown if an input has value that is not expected. Order is ignored if its execution has no effect on current balance. Order is rejected if an input goes over a limit/restriction.</p>","title":"execute_order_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.fill_entry_trades_in_position_nb","text":"<pre><code>fill_entry_trades_in_position_nb(\n    order_records,\n    col_map,\n    col,\n    first_c,\n    last_c,\n    first_entry_size,\n    first_entry_fees,\n    exit_idx,\n    exit_size_sum,\n    exit_gross_sum,\n    exit_fees_sum,\n    direction,\n    status,\n    parent_id,\n    trade_records,\n    tidx\n)\n</code></pre> <p>Fill entry trades located within a single position.</p>","title":"fill_entry_trades_in_position_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.fill_log_record_nb","text":"<pre><code>fill_log_record_nb(\n    record,\n    record_id,\n    i,\n    col,\n    group,\n    cash,\n    position,\n    debt,\n    free_cash,\n    val_price,\n    value,\n    order,\n    new_cash,\n    new_position,\n    new_debt,\n    new_free_cash,\n    new_val_price,\n    new_value,\n    order_result,\n    order_id\n)\n</code></pre> <p>Fill a log record.</p>","title":"fill_log_record_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.fill_order_record_nb","text":"<pre><code>fill_order_record_nb(\n    record,\n    record_id,\n    i,\n    col,\n    order_result\n)\n</code></pre> <p>Fill an order record.</p>","title":"fill_order_record_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.fill_position_record_nb","text":"<pre><code>fill_position_record_nb(\n    record,\n    id_,\n    trade_records\n)\n</code></pre> <p>Fill a position record by aggregating trade records.</p>","title":"fill_position_record_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.fill_trade_record_nb","text":"<pre><code>fill_trade_record_nb(\n    record,\n    id_,\n    col,\n    size,\n    entry_idx,\n    entry_price,\n    entry_fees,\n    exit_idx,\n    exit_price,\n    exit_fees,\n    direction,\n    status,\n    parent_id\n)\n</code></pre> <p>Fill a trade record.</p>","title":"fill_trade_record_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.final_value_nb","text":"<pre><code>final_value_nb(\n    total_profit,\n    init_cash\n)\n</code></pre> <p>Get total profit per column/group.</p>","title":"final_value_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.flex_simulate_nb","text":"<pre><code>flex_simulate_nb(\n    target_shape,\n    group_lens,\n    init_cash,\n    cash_sharing,\n    segment_mask=array(True),\n    call_pre_segment=False,\n    call_post_segment=False,\n    pre_sim_func_nb=no_pre_func_nb,\n    pre_sim_args=(),\n    post_sim_func_nb=no_post_func_nb,\n    post_sim_args=(),\n    pre_group_func_nb=no_pre_func_nb,\n    pre_group_args=(),\n    post_group_func_nb=no_post_func_nb,\n    post_group_args=(),\n    pre_segment_func_nb=no_pre_func_nb,\n    pre_segment_args=(),\n    post_segment_func_nb=no_post_func_nb,\n    post_segment_args=(),\n    flex_order_func_nb=no_flex_order_func_nb,\n    flex_order_args=(),\n    post_order_func_nb=no_post_func_nb,\n    post_order_args=(),\n    close=array(nan),\n    ffill_val_price=True,\n    update_value=False,\n    fill_pos_record=True,\n    max_orders=None,\n    max_logs=0,\n    flex_2d=True\n)\n</code></pre> <p>Same as simulate_nb(), but with no predefined call sequence.</p> <p>In contrast to <code>order_func_nb</code> insimulate_nb(), <code>post_order_func_nb</code> is a segment-level order function that returns a column along with the order, and gets repeatedly called until some condition is met. This allows multiple orders to be issued within a single element and in an arbitrary order.</p> <p>The order function should accept FlexOrderContext, unpacked tuple from <code>pre_segment_func_nb</code>, and <code>*flex_order_args</code>. Should return column and Order. To break out of the loop, return column of -1.</p>  <p>Note</p> <p>Since one element can now accommodate multiple orders, you may run into \"order_records index out of range\" exception. In this case, you should increase <code>max_orders</code>. This cannot be done automatically and dynamically to avoid performance degradation.</p>  <p>Usage</p> <ul> <li>The same example as in simulate_nb():</li> </ul> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from numba import njit\n&gt;&gt;&gt; from vectorbt.portfolio.enums import SizeType, Direction\n&gt;&gt;&gt; from vectorbt.portfolio.nb import (\n...     get_col_elem_nb,\n...     order_nb,\n...     order_nothing_nb,\n...     flex_simulate_nb,\n...     flex_simulate_row_wise_nb,\n...     sort_call_seq_out_nb\n... )\n\n&gt;&gt;&gt; @njit\n... def pre_sim_func_nb(c):\n...     print('before simulation')\n...     return ()\n\n&gt;&gt;&gt; @njit\n... def pre_group_func_nb(c):\n...     print('\\tbefore group', c.group)\n...     # Create temporary arrays and pass them down the stack\n...     order_value_out = np.empty(c.group_len, dtype=np.float_)\n...     call_seq_out = np.empty(c.group_len, dtype=np.int_)\n...     # Forward down the stack\n...     return (order_value_out, call_seq_out)\n\n&gt;&gt;&gt; @njit\n... def pre_segment_func_nb(c, order_value_out, call_seq_out, size, price, size_type, direction):\n...     print('\\t\\tbefore segment', c.i)\n...     for col in range(c.from_col, c.to_col):\n...         # Here we use order price for group valuation\n...         c.last_val_price[col] = get_col_elem_nb(c, col, price)\n...\n...     # Same as for simulate_nb, but since we don't have a predefined c.call_seq_now anymore,\n...     # we need to store our new call sequence somewhere else\n...     call_seq_out[:] = np.arange(c.group_len)\n...     sort_call_seq_out_nb(c, size, size_type, direction, order_value_out, call_seq_out)\n...\n...     # Forward the sorted call sequence\n...     return (call_seq_out,)\n\n&gt;&gt;&gt; @njit\n... def flex_order_func_nb(c, call_seq_out, size, price, size_type, direction, fees, fixed_fees, slippage):\n...     if c.call_idx &lt; c.group_len:\n...         col = c.from_col + call_seq_out[c.call_idx]\n...         print('\\t\\t\\tcreating order', c.call_idx, 'at column', col)\n...         # # Create and return an order\n...         return col, order_nb(\n...             size=get_col_elem_nb(c, col, size),\n...             price=get_col_elem_nb(c, col, price),\n...             size_type=get_col_elem_nb(c, col, size_type),\n...             direction=get_col_elem_nb(c, col, direction),\n...             fees=get_col_elem_nb(c, col, fees),\n...             fixed_fees=get_col_elem_nb(c, col, fixed_fees),\n...             slippage=get_col_elem_nb(c, col, slippage)\n...         )\n...     # All columns already processed -&gt; break the loop\n...     print('\\t\\t\\tbreaking out of the loop')\n...     return -1, order_nothing_nb()\n\n&gt;&gt;&gt; @njit\n... def post_order_func_nb(c, call_seq_out):\n...     print('\\t\\t\\t\\torder status:', c.order_result.status)\n...     return None\n\n&gt;&gt;&gt; @njit\n... def post_segment_func_nb(c, order_value_out, call_seq_out):\n...     print('\\t\\tafter segment', c.i)\n...     return None\n\n&gt;&gt;&gt; @njit\n... def post_group_func_nb(c):\n...     print('\\tafter group', c.group)\n...     return None\n\n&gt;&gt;&gt; @njit\n... def post_sim_func_nb(c):\n...     print('after simulation')\n...     return None\n\n&gt;&gt;&gt; target_shape = (5, 3)\n&gt;&gt;&gt; np.random.seed(42)\n&gt;&gt;&gt; group_lens = np.array([3])  # one group of three columns\n&gt;&gt;&gt; init_cash = np.array([100.])  # one capital per group\n&gt;&gt;&gt; cash_sharing = True\n&gt;&gt;&gt; call_seq = build_call_seq(target_shape, group_lens)  # will be overridden\n&gt;&gt;&gt; segment_mask = np.array([True, False, True, False, True])[:, None]\n&gt;&gt;&gt; segment_mask = np.copy(np.broadcast_to(segment_mask, target_shape))\n&gt;&gt;&gt; size = np.asarray(1 / target_shape[1])  # scalars must become 0-dim arrays\n&gt;&gt;&gt; price = close = np.random.uniform(1, 10, size=target_shape)\n&gt;&gt;&gt; size_type = np.asarray(SizeType.TargetPercent)\n&gt;&gt;&gt; direction = np.asarray(Direction.LongOnly)\n&gt;&gt;&gt; fees = np.asarray(0.001)\n&gt;&gt;&gt; fixed_fees = np.asarray(1.)\n&gt;&gt;&gt; slippage = np.asarray(0.001)\n\n&gt;&gt;&gt; order_records, log_records = flex_simulate_nb(\n...     target_shape,\n...     group_lens,\n...     init_cash,\n...     cash_sharing,\n...     segment_mask=segment_mask,\n...     pre_sim_func_nb=pre_sim_func_nb,\n...     post_sim_func_nb=post_sim_func_nb,\n...     pre_group_func_nb=pre_group_func_nb,\n...     post_group_func_nb=post_group_func_nb,\n...     pre_segment_func_nb=pre_segment_func_nb,\n...     pre_segment_args=(size, price, size_type, direction),\n...     post_segment_func_nb=post_segment_func_nb,\n...     flex_order_func_nb=flex_order_func_nb,\n...     flex_order_args=(size, price, size_type, direction, fees, fixed_fees, slippage),\n...     post_order_func_nb=post_order_func_nb\n... )\nbefore simulation\n    before group 0\n        before segment 0\n            creating order 0 at column 0\n                order status: 0\n            creating order 1 at column 1\n                order status: 0\n            creating order 2 at column 2\n                order status: 0\n            breaking out of the loop\n        after segment 0\n        before segment 2\n            creating order 0 at column 1\n                order status: 0\n            creating order 1 at column 2\n                order status: 0\n            creating order 2 at column 0\n                order status: 0\n            breaking out of the loop\n        after segment 2\n        before segment 4\n            creating order 0 at column 0\n                order status: 0\n            creating order 1 at column 2\n                order status: 0\n            creating order 2 at column 1\n                order status: 0\n            breaking out of the loop\n        after segment 4\n    after group 0\nafter simulation\n</code></pre>","title":"flex_simulate_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.flex_simulate_row_wise_nb","text":"<pre><code>flex_simulate_row_wise_nb(\n    target_shape,\n    group_lens,\n    init_cash,\n    cash_sharing,\n    segment_mask=array(True),\n    call_pre_segment=False,\n    call_post_segment=False,\n    pre_sim_func_nb=no_pre_func_nb,\n    pre_sim_args=(),\n    post_sim_func_nb=no_post_func_nb,\n    post_sim_args=(),\n    pre_row_func_nb=no_pre_func_nb,\n    pre_row_args=(),\n    post_row_func_nb=no_post_func_nb,\n    post_row_args=(),\n    pre_segment_func_nb=no_pre_func_nb,\n    pre_segment_args=(),\n    post_segment_func_nb=no_post_func_nb,\n    post_segment_args=(),\n    flex_order_func_nb=no_flex_order_func_nb,\n    flex_order_args=(),\n    post_order_func_nb=no_post_func_nb,\n    post_order_args=(),\n    close=array(nan),\n    ffill_val_price=True,\n    update_value=False,\n    fill_pos_record=True,\n    max_orders=None,\n    max_logs=0,\n    flex_2d=True\n)\n</code></pre> <p>Same as flex_simulate_nb(), but iterates using row-major order, with the rows changing fastest, and the columns/groups changing slowest.</p>","title":"flex_simulate_row_wise_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.generate_stop_signal_nb","text":"<pre><code>generate_stop_signal_nb(\n    position_now,\n    upon_stop_exit,\n    accumulate\n)\n</code></pre> <p>Generate stop signal and change accumulation if needed.</p>","title":"generate_stop_signal_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.get_col_elem_nb","text":"<pre><code>get_col_elem_nb(\n    ctx,\n    col,\n    a\n)\n</code></pre> <p>Get the current element using flexible indexing given the context and the column.</p>","title":"get_col_elem_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.get_elem_nb","text":"<pre><code>get_elem_nb(\n    ctx,\n    a\n)\n</code></pre> <p>Get the current element using flexible indexing given just the context.</p>","title":"get_elem_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.get_entry_trades_nb","text":"<pre><code>get_entry_trades_nb(\n    order_records,\n    close,\n    col_map\n)\n</code></pre> <p>Fill entry trade records by aggregating order records.</p> <p>Entry trade records are buy orders in a long position and sell orders in a short position.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from numba import njit\n&gt;&gt;&gt; from vectorbt.records.nb import col_map_nb\n&gt;&gt;&gt; from vectorbt.portfolio.nb import simulate_from_orders_nb, get_entry_trades_nb\n\n&gt;&gt;&gt; close = order_price = np.array([\n...     [1, 6],\n...     [2, 5],\n...     [3, 4],\n...     [4, 3],\n...     [5, 2],\n...     [6, 1]\n... ])\n&gt;&gt;&gt; size = np.asarray([\n...     [1, -1],\n...     [0.1, -0.1],\n...     [-1, 1],\n...     [-0.1, 0.1],\n...     [1, -1],\n...     [-2, 2]\n... ])\n&gt;&gt;&gt; target_shape = close.shape\n&gt;&gt;&gt; group_lens = np.full(target_shape[1], 1)\n&gt;&gt;&gt; init_cash = np.full(target_shape[1], 100)\n&gt;&gt;&gt; call_seq = np.full(target_shape, 0)\n\n&gt;&gt;&gt; order_records, log_records = simulate_from_orders_nb(\n...     target_shape,\n...     group_lens,\n...     init_cash,\n...     call_seq,\n...     size=size,\n...     price=close,\n...     fees=np.asarray(0.01),\n...     slippage=np.asarray(0.01)\n... )\n\n&gt;&gt;&gt; col_map = col_map_nb(order_records['col'], target_shape[1])\n&gt;&gt;&gt; entry_trade_records = get_entry_trades_nb(order_records, close, col_map)\n&gt;&gt;&gt; pd.DataFrame.from_records(entry_trade_records)\n   id  col  size  entry_idx  entry_price  entry_fees  exit_idx  exit_price  \\\n0   0    0   1.0          0         1.01     0.01010         3    3.060000\n1   1    0   0.1          1         2.02     0.00202         3    3.060000\n2   2    0   1.0          4         5.05     0.05050         5    5.940000\n3   3    0   1.0          5         5.94     0.05940         5    6.000000\n4   4    1   1.0          0         5.94     0.05940         3    3.948182\n5   5    1   0.1          1         4.95     0.00495         3    3.948182\n6   6    1   1.0          4         1.98     0.01980         5    1.010000\n7   7    1   1.0          5         1.01     0.01010         5    1.000000\n\n   exit_fees       pnl    return  direction  status  parent_id\n0   0.030600  2.009300  1.989406          0       1          0\n1   0.003060  0.098920  0.489703          0       1          0\n2   0.059400  0.780100  0.154475          0       1          1\n3   0.000000 -0.119400 -0.020101          1       0          2\n4   0.039482  1.892936  0.318676          1       1          3\n5   0.003948  0.091284  0.184411          1       1          3\n6   0.010100  0.940100  0.474798          1       1          4\n7   0.000000 -0.020100 -0.019901          0       0          5\n</code></pre>","title":"get_entry_trades_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.get_exit_trades_nb","text":"<pre><code>get_exit_trades_nb(\n    order_records,\n    close,\n    col_map\n)\n</code></pre> <p>Fill exit trade records by aggregating order records.</p> <p>Exit trade records are sell orders in a long position and buy orders in a short position.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from numba import njit\n&gt;&gt;&gt; from vectorbt.records.nb import col_map_nb\n&gt;&gt;&gt; from vectorbt.portfolio.nb import simulate_from_orders_nb, get_exit_trades_nb\n\n&gt;&gt;&gt; close = order_price = np.array([\n...     [1, 6],\n...     [2, 5],\n...     [3, 4],\n...     [4, 3],\n...     [5, 2],\n...     [6, 1]\n... ])\n&gt;&gt;&gt; size = np.asarray([\n...     [1, -1],\n...     [0.1, -0.1],\n...     [-1, 1],\n...     [-0.1, 0.1],\n...     [1, -1],\n...     [-2, 2]\n... ])\n&gt;&gt;&gt; target_shape = close.shape\n&gt;&gt;&gt; group_lens = np.full(target_shape[1], 1)\n&gt;&gt;&gt; init_cash = np.full(target_shape[1], 100)\n&gt;&gt;&gt; call_seq = np.full(target_shape, 0)\n\n&gt;&gt;&gt; order_records, log_records = simulate_from_orders_nb(\n...     target_shape,\n...     group_lens,\n...     init_cash,\n...     call_seq,\n...     size=size,\n...     price=close,\n...     fees=np.asarray(0.01),\n...     slippage=np.asarray(0.01)\n... )\n\n&gt;&gt;&gt; col_map = col_map_nb(order_records['col'], target_shape[1])\n&gt;&gt;&gt; exit_trade_records = get_exit_trades_nb(order_records, close, col_map)\n&gt;&gt;&gt; pd.DataFrame.from_records(exit_trade_records)\n   id  col  size  entry_idx  entry_price  entry_fees  exit_idx  exit_price  \\\n0   0    0   1.0          0     1.101818    0.011018         2        2.97\n1   1    0   0.1          0     1.101818    0.001102         3        3.96\n2   2    0   1.0          4     5.050000    0.050500         5        5.94\n3   3    0   1.0          5     5.940000    0.059400         5        6.00\n4   4    1   1.0          0     5.850000    0.058500         2        4.04\n5   5    1   0.1          0     5.850000    0.005850         3        3.03\n6   6    1   1.0          4     1.980000    0.019800         5        1.01\n7   7    1   1.0          5     1.010000    0.010100         5        1.00\n\n   exit_fees       pnl    return  direction  status  parent_id\n0    0.02970  1.827464  1.658589          0       1          0\n1    0.00396  0.280756  2.548119          0       1          0\n2    0.05940  0.780100  0.154475          0       1          1\n3    0.00000 -0.119400 -0.020101          1       0          2\n4    0.04040  1.711100  0.292496          1       1          3\n5    0.00303  0.273120  0.466872          1       1          3\n6    0.01010  0.940100  0.474798          1       1          4\n7    0.00000 -0.020100 -0.019901          0       0          5\n</code></pre>","title":"get_exit_trades_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.get_free_cash_diff_nb","text":"<pre><code>get_free_cash_diff_nb(\n    position_before,\n    position_now,\n    debt_now,\n    price,\n    fees\n)\n</code></pre> <p>Get updated debt and free cash flow.</p>","title":"get_free_cash_diff_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.get_group_value_ctx_nb","text":"<pre><code>get_group_value_ctx_nb(\n    seg_ctx\n)\n</code></pre> <p>Get group value from context.</p> <p>Accepts SegmentContext.</p> <p>Best called once from <code>pre_segment_func_nb</code>. To set the valuation price, change <code>last_val_price</code> of the context in-place.</p>  <p>Note</p> <p>Cash sharing must be enabled.</p>","title":"get_group_value_ctx_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.get_group_value_nb","text":"<pre><code>get_group_value_nb(\n    from_col,\n    to_col,\n    cash_now,\n    last_position,\n    last_val_price\n)\n</code></pre> <p>Get group value.</p>","title":"get_group_value_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.get_long_size_nb","text":"<pre><code>get_long_size_nb(\n    position_before,\n    position_now\n)\n</code></pre> <p>Get long size.</p>","title":"get_long_size_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.get_positions_nb","text":"<pre><code>get_positions_nb(\n    trade_records,\n    col_map\n)\n</code></pre> <p>Fill position records by aggregating trade records.</p> <p>Trades can be entry trades, exit trades, and even positions themselves - all will produce the same results.</p> <p>Usage</p> <ul> <li>Building upon the example in get_exit_trades_nb():</li> </ul> <pre><code>&gt;&gt;&gt; from vectorbt.portfolio.nb import get_positions_nb\n\n&gt;&gt;&gt; col_map = col_map_nb(exit_trade_records['col'], target_shape[1])\n&gt;&gt;&gt; position_records = get_positions_nb(exit_trade_records, col_map)\n&gt;&gt;&gt; pd.DataFrame.from_records(position_records)\n   id  col  size  entry_idx  entry_price  entry_fees  exit_idx  exit_price  \\\n0   0    0   1.1          0     1.101818     0.01212         3    3.060000\n1   1    0   1.0          4     5.050000     0.05050         5    5.940000\n2   2    0   1.0          5     5.940000     0.05940         5    6.000000\n3   3    1   1.1          0     5.850000     0.06435         3    3.948182\n4   4    1   1.0          4     1.980000     0.01980         5    1.010000\n5   5    1   1.0          5     1.010000     0.01010         5    1.000000\n\n   exit_fees      pnl    return  direction  status  parent_id\n0    0.03366  2.10822  1.739455          0       1          0\n1    0.05940  0.78010  0.154475          0       1          1\n2    0.00000 -0.11940 -0.020101          1       0          2\n3    0.04343  1.98422  0.308348          1       1          3\n4    0.01010  0.94010  0.474798          1       1          4\n5    0.00000 -0.02010 -0.019901          0       0          5\n</code></pre>","title":"get_positions_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.get_short_size_nb","text":"<pre><code>get_short_size_nb(\n    position_before,\n    position_now\n)\n</code></pre> <p>Get short size.</p>","title":"get_short_size_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.get_stop_price_nb","text":"<pre><code>get_stop_price_nb(\n    position_now,\n    stop_price,\n    stop,\n    open,\n    low,\n    high,\n    hit_below\n)\n</code></pre> <p>Get stop price.</p> <p>If hit before open, returns open.</p>","title":"get_stop_price_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.get_trade_stats_nb","text":"<pre><code>get_trade_stats_nb(\n    size,\n    entry_price,\n    entry_fees,\n    exit_price,\n    exit_fees,\n    direction\n)\n</code></pre> <p>Get trade statistics.</p>","title":"get_trade_stats_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.gross_exposure_nb","text":"<pre><code>gross_exposure_nb(\n    asset_value,\n    cash\n)\n</code></pre> <p>Get gross exposure per column/group.</p>","title":"gross_exposure_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.group_mean_reduce_nb","text":"<pre><code>group_mean_reduce_nb(\n    group,\n    a\n)\n</code></pre> <p>Mean reducer for grouped columns.</p>","title":"group_mean_reduce_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.i_group_any_reduce_nb","text":"<pre><code>i_group_any_reduce_nb(\n    i,\n    group,\n    a\n)\n</code></pre> <p>Boolean \"any\" reducer for grouped columns.</p>","title":"i_group_any_reduce_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.init_cash_grouped_nb","text":"<pre><code>init_cash_grouped_nb(\n    init_cash,\n    group_lens,\n    cash_sharing\n)\n</code></pre> <p>Get initial cash per group.</p>","title":"init_cash_grouped_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.init_cash_nb","text":"<pre><code>init_cash_nb(\n    init_cash,\n    group_lens,\n    cash_sharing\n)\n</code></pre> <p>Get initial cash per column.</p>","title":"init_cash_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.init_records_nb","text":"<pre><code>init_records_nb(\n    target_shape,\n    max_orders=None,\n    max_logs=0\n)\n</code></pre> <p>Initialize order and log records.</p>","title":"init_records_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.is_grouped_nb","text":"<pre><code>is_grouped_nb(\n    group_lens\n)\n</code></pre> <p>Check if columm,ns are grouped, that is, more than one column per group.</p>","title":"is_grouped_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.ls_enex_signal_func_nb","text":"<pre><code>ls_enex_signal_func_nb(\n    c,\n    long_entries,\n    long_exits,\n    short_entries,\n    short_exits\n)\n</code></pre> <p>Get an element of direction-aware signals.</p>","title":"ls_enex_signal_func_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.no_adjust_sl_func_nb","text":"<pre><code>no_adjust_sl_func_nb(\n    c,\n    *args\n)\n</code></pre> <p>Placeholder function that returns the initial stop-loss value and trailing flag.</p>","title":"no_adjust_sl_func_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.no_adjust_tp_func_nb","text":"<pre><code>no_adjust_tp_func_nb(\n    c,\n    *args\n)\n</code></pre> <p>Placeholder function that returns the initial take-profit value.</p>","title":"no_adjust_tp_func_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.no_flex_order_func_nb","text":"<pre><code>no_flex_order_func_nb(\n    c,\n    *args\n)\n</code></pre> <p>Placeholder flexible order function that returns break column and no order.</p>","title":"no_flex_order_func_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.no_order_func_nb","text":"<pre><code>no_order_func_nb(\n    c,\n    *args\n)\n</code></pre> <p>Placeholder order function that returns no order.</p>","title":"no_order_func_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.no_post_func_nb","text":"<pre><code>no_post_func_nb(\n    c,\n    *args\n)\n</code></pre> <p>Placeholder postprocessing function that returns nothing.</p>","title":"no_post_func_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.no_pre_func_nb","text":"<pre><code>no_pre_func_nb(\n    c,\n    *args\n)\n</code></pre> <p>Placeholder preprocessing function that forwards received arguments down the stack.</p>","title":"no_pre_func_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.no_signal_func_nb","text":"<pre><code>no_signal_func_nb(\n    c,\n    *args\n)\n</code></pre> <p>Placeholder signal function that returns no signal.</p>","title":"no_signal_func_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.order_nb","text":"<pre><code>order_nb(\n    size=nan,\n    price=inf,\n    size_type=0,\n    direction=2,\n    fees=0.0,\n    fixed_fees=0.0,\n    slippage=0.0,\n    min_size=0.0,\n    max_size=inf,\n    size_granularity=nan,\n    reject_prob=0.0,\n    lock_cash=False,\n    allow_partial=True,\n    raise_reject=False,\n    log=False\n)\n</code></pre> <p>Create an order.</p> <p>See Order for details on arguments.</p>","title":"order_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.order_not_filled_nb","text":"<pre><code>order_not_filled_nb(\n    status,\n    status_info\n)\n</code></pre> <p>Return <code>OrderResult</code> for order that hasn't been filled.</p>","title":"order_not_filled_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.order_nothing_nb","text":"<pre><code>order_nothing_nb()\n</code></pre> <p>Convenience function to order nothing.</p>","title":"order_nothing_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.position_coverage_grouped_nb","text":"<pre><code>position_coverage_grouped_nb(\n    position_mask,\n    group_lens\n)\n</code></pre> <p>Get coverage of position for each row and group.</p>","title":"position_coverage_grouped_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.position_mask_grouped_nb","text":"<pre><code>position_mask_grouped_nb(\n    position_mask,\n    group_lens\n)\n</code></pre> <p>Get whether in position for each row and group.</p>","title":"position_mask_grouped_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.process_order_nb","text":"<pre><code>process_order_nb(\n    i,\n    col,\n    group,\n    state,\n    update_value,\n    order,\n    order_records,\n    log_records\n)\n</code></pre> <p>Process an order by executing it, saving relevant information to the logs, and returning a new state.</p>","title":"process_order_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.raise_rejected_order_nb","text":"<pre><code>raise_rejected_order_nb(\n    order_result\n)\n</code></pre> <p>Raise an RejectedOrderError.</p>","title":"raise_rejected_order_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.replace_inf_price_nb","text":"<pre><code>replace_inf_price_nb(\n    prev_close,\n    close,\n    order\n)\n</code></pre> <p>Replace infinity price in an order.</p>","title":"replace_inf_price_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.require_call_seq","text":"<pre><code>require_call_seq(\n    call_seq\n)\n</code></pre> <p>Force the call sequence array to pass our requirements.</p>","title":"require_call_seq function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.resolve_dir_conflict_nb","text":"<pre><code>resolve_dir_conflict_nb(\n    position_now,\n    is_long_entry,\n    is_short_entry,\n    upon_dir_conflict\n)\n</code></pre> <p>Resolve any direction conflict between a long entry and a short entry.</p>","title":"resolve_dir_conflict_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.resolve_opposite_entry_nb","text":"<pre><code>resolve_opposite_entry_nb(\n    position_now,\n    is_long_entry,\n    is_long_exit,\n    is_short_entry,\n    is_short_exit,\n    upon_opposite_entry,\n    accumulate\n)\n</code></pre> <p>Resolve opposite entry.</p>","title":"resolve_opposite_entry_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.resolve_signal_conflict_nb","text":"<pre><code>resolve_signal_conflict_nb(\n    position_now,\n    is_entry,\n    is_exit,\n    direction,\n    conflict_mode\n)\n</code></pre> <p>Resolve any conflict between an entry and an exit.</p>","title":"resolve_signal_conflict_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.resolve_stop_price_and_slippage_nb","text":"<pre><code>resolve_stop_price_and_slippage_nb(\n    stop_price,\n    price,\n    close,\n    slippage,\n    stop_exit_price\n)\n</code></pre> <p>Resolve price and slippage of a stop order.</p>","title":"resolve_stop_price_and_slippage_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.returns_in_sim_order_nb","text":"<pre><code>returns_in_sim_order_nb(\n    value_iso,\n    group_lens,\n    init_cash_grouped,\n    call_seq\n)\n</code></pre> <p>Get portfolio return series in simulation order.</p>","title":"returns_in_sim_order_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.sell_nb","text":"<pre><code>sell_nb(\n    exec_state,\n    size,\n    price,\n    direction=2,\n    fees=0.0,\n    fixed_fees=0.0,\n    slippage=0.0,\n    min_size=0.0,\n    max_size=inf,\n    size_granularity=nan,\n    lock_cash=False,\n    allow_partial=True,\n    percent=nan\n)\n</code></pre> <p>Sell or/and short sell.</p>","title":"sell_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.should_update_stop_nb","text":"<pre><code>should_update_stop_nb(\n    stop,\n    upon_stop_update\n)\n</code></pre> <p>Whether to update stop.</p>","title":"should_update_stop_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.shuffle_call_seq_nb","text":"<pre><code>shuffle_call_seq_nb(\n    call_seq,\n    group_lens\n)\n</code></pre> <p>Shuffle the call sequence array.</p>","title":"shuffle_call_seq_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.signals_to_size_nb","text":"<pre><code>signals_to_size_nb(\n    position_now,\n    is_long_entry,\n    is_long_exit,\n    is_short_entry,\n    is_short_exit,\n    size,\n    size_type,\n    accumulate,\n    val_price_now\n)\n</code></pre> <p>Translate direction-aware signals into size, size type, and direction.</p>","title":"signals_to_size_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.simulate_from_orders_nb","text":"<pre><code>simulate_from_orders_nb(\n    target_shape,\n    group_lens,\n    init_cash,\n    call_seq,\n    size=array(inf),\n    price=array(inf),\n    size_type=array(0),\n    direction=array(2),\n    fees=array(0.),\n    fixed_fees=array(0.),\n    slippage=array(0.),\n    min_size=array(0.),\n    max_size=array(inf),\n    size_granularity=array(nan),\n    reject_prob=array(0.),\n    lock_cash=array(False),\n    allow_partial=array(True),\n    raise_reject=array(False),\n    log=array(False),\n    val_price=array(inf),\n    close=array(nan),\n    auto_call_seq=False,\n    ffill_val_price=True,\n    update_value=False,\n    max_orders=None,\n    max_logs=0,\n    flex_2d=True\n)\n</code></pre> <p>Creates on order out of each element.</p> <p>Iterates in the column-major order. Utilizes flexible broadcasting.</p>  <p>Note</p> <p>Should be only grouped if cash sharing is enabled.</p> <p>If <code>auto_call_seq</code> is True, make sure that <code>call_seq</code> follows <code>CallSeqType.Default</code>.</p> <p>Single value should be passed as a 0-dim array (for example, by using <code>np.asarray(value)</code>).</p>  <p>Usage</p> <ul> <li>Buy and hold using all cash and closing price (default):</li> </ul> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from vectorbt.records.nb import col_map_nb\n&gt;&gt;&gt; from vectorbt.portfolio.nb import simulate_from_orders_nb, asset_flow_nb\n&gt;&gt;&gt; from vectorbt.portfolio.enums import Direction\n\n&gt;&gt;&gt; close = np.array([1, 2, 3, 4, 5])[:, None]\n&gt;&gt;&gt; order_records, _ = simulate_from_orders_nb(\n...     target_shape=close.shape,\n...     close=close,\n...     group_lens=np.array([1]),\n...     init_cash=np.array([100]),\n...     call_seq=np.full(close.shape, 0)\n... )\n&gt;&gt;&gt; col_map = col_map_nb(order_records['col'], close.shape[1])\n&gt;&gt;&gt; asset_flow = asset_flow_nb(close.shape, order_records, col_map, Direction.Both)\n&gt;&gt;&gt; asset_flow\narray([[100.],\n       [  0.],\n       [  0.],\n       [  0.],\n       [  0.]])\n</code></pre>","title":"simulate_from_orders_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.simulate_from_signal_func_nb","text":"<pre><code>simulate_from_signal_func_nb(\n    target_shape,\n    group_lens,\n    init_cash,\n    call_seq,\n    signal_func_nb=no_signal_func_nb,\n    signal_args=(),\n    size=array(inf),\n    price=array(inf),\n    size_type=array(0),\n    fees=array(0.),\n    fixed_fees=array(0.),\n    slippage=array(0.),\n    min_size=array(0.),\n    max_size=array(inf),\n    size_granularity=array(nan),\n    reject_prob=array(0.),\n    lock_cash=array(False),\n    allow_partial=array(True),\n    raise_reject=array(False),\n    log=array(False),\n    accumulate=array(0),\n    upon_long_conflict=array(0),\n    upon_short_conflict=array(0),\n    upon_dir_conflict=array(0),\n    upon_opposite_entry=array(4),\n    val_price=array(inf),\n    open=array(nan),\n    high=array(nan),\n    low=array(nan),\n    close=array(nan),\n    sl_stop=array(nan),\n    sl_trail=array(False),\n    tp_stop=array(nan),\n    stop_entry_price=array(3),\n    stop_exit_price=array(0),\n    upon_stop_exit=array(0),\n    upon_stop_update=array(1),\n    adjust_sl_func_nb=no_adjust_sl_func_nb,\n    adjust_sl_args=(),\n    adjust_tp_func_nb=no_adjust_tp_func_nb,\n    adjust_tp_args=(),\n    use_stops=True,\n    auto_call_seq=False,\n    ffill_val_price=True,\n    update_value=False,\n    max_orders=None,\n    max_logs=0,\n    flex_2d=True\n)\n</code></pre> <p>Creates an order out of each element by resolving entry and exit signals returned by <code>signal_func_nb</code>.</p> <p>Iterates in the column-major order. Utilizes flexible broadcasting.</p> <p>Signals are processed using the following pipeline:</p> <p>1) If there is a stop signal, convert it to direction-aware signals and proceed to 7) 2) Get direction-aware signals using <code>signal_func_nb</code> 3) Resolve any entry and exit conflict of each direction using resolve_signal_conflict_nb() 4) Resolve any direction conflict using resolve_dir_conflict_nb() 5) Resolve an opposite entry signal scenario using resolve_opposite_entry_nb() 7) Convert the final signals into size, size type, and direction using signals_to_size_nb()</p>  <p>Note</p> <p>Should be only grouped if cash sharing is enabled.</p> <p>If <code>auto_call_seq</code> is True, make sure that <code>call_seq</code> follows <code>CallSeqType.Default</code>.</p> <p>Single value should be passed as a 0-dim array (for example, by using <code>np.asarray(value)</code>).</p>  <p>Usage</p> <ul> <li>Buy and hold using all cash and closing price (default):</li> </ul> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from vectorbt.records.nb import col_map_nb\n&gt;&gt;&gt; from vectorbt.portfolio import nb\n&gt;&gt;&gt; from vectorbt.portfolio.enums import Direction\n\n&gt;&gt;&gt; close = np.array([1, 2, 3, 4, 5])[:, None]\n&gt;&gt;&gt; order_records, _ = nb.simulate_from_signal_func_nb(\n...     target_shape=close.shape,\n...     close=close,\n...     group_lens=np.array([1]),\n...     init_cash=np.array([100]),\n...     call_seq=np.full(close.shape, 0),\n...     signal_func_nb=nb.dir_enex_signal_func_nb,\n...     signal_args=(np.asarray(True), np.asarray(False), np.asarray(Direction.LongOnly))\n... )\n&gt;&gt;&gt; col_map = col_map_nb(order_records['col'], close.shape[1])\n&gt;&gt;&gt; asset_flow = nb.asset_flow_nb(close.shape, order_records, col_map, Direction.Both)\n&gt;&gt;&gt; asset_flow\narray([[100.],\n       [  0.],\n       [  0.],\n       [  0.],\n       [  0.]])\n</code></pre>","title":"simulate_from_signal_func_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.simulate_nb","text":"<pre><code>simulate_nb(\n    target_shape,\n    group_lens,\n    init_cash,\n    cash_sharing,\n    call_seq,\n    segment_mask=array(True),\n    call_pre_segment=False,\n    call_post_segment=False,\n    pre_sim_func_nb=no_pre_func_nb,\n    pre_sim_args=(),\n    post_sim_func_nb=no_post_func_nb,\n    post_sim_args=(),\n    pre_group_func_nb=no_pre_func_nb,\n    pre_group_args=(),\n    post_group_func_nb=no_post_func_nb,\n    post_group_args=(),\n    pre_segment_func_nb=no_pre_func_nb,\n    pre_segment_args=(),\n    post_segment_func_nb=no_post_func_nb,\n    post_segment_args=(),\n    order_func_nb=no_order_func_nb,\n    order_args=(),\n    post_order_func_nb=no_post_func_nb,\n    post_order_args=(),\n    close=array(nan),\n    ffill_val_price=True,\n    update_value=False,\n    fill_pos_record=True,\n    max_orders=None,\n    max_logs=0,\n    flex_2d=True\n)\n</code></pre> <p>Fill order and log records by iterating over a shape and calling a range of user-defined functions.</p> <p>Starting with initial cash <code>init_cash</code>, iterates over each group and column in <code>target_shape</code>, and for each data point, generates an order using <code>order_func_nb</code>. Tries then to fulfill that order. Upon success, updates the current state including the cash balance and the position.</p> <p>Returns order records of layout order_dt and log records of layout log_dt.</p> <p>As opposed to simulate_row_wise_nb(), order processing happens in column-major order. Column-major order means processing the entire column/group with all rows before moving to the next one. See Row- and column-major order.</p> <p>Args</p>  <code>target_shape</code> :\u2002<code>tuple</code> See SimulationContext.target_shape. <code>group_lens</code> :\u2002<code>array_like</code> of <code>int</code> See SimulationContext.group_lens. <code>init_cash</code> :\u2002<code>array_like</code> of <code>float</code> See SimulationContext.init_cash. <code>cash_sharing</code> :\u2002<code>bool</code> See SimulationContext.cash_sharing. <code>call_seq</code> :\u2002<code>array_like</code> of <code>int</code> See SimulationContext.call_seq. <code>segment_mask</code> :\u2002<code>array_like</code> of <code>bool</code> See SimulationContext.segment_mask. <code>call_pre_segment</code> :\u2002<code>bool</code> See SimulationContext.call_pre_segment. <code>call_post_segment</code> :\u2002<code>bool</code> See SimulationContext.call_post_segment. <code>pre_sim_func_nb</code> :\u2002<code>callable</code>  <p>Function called before simulation.</p> <p>Can be used for creation of global arrays and setting the seed.</p> <p>Should accept SimulationContext and <code>*pre_sim_args</code>. Should return a tuple of any content, which is then passed to <code>pre_group_func_nb</code> and <code>post_group_func_nb</code>.</p>  <code>pre_sim_args</code> :\u2002<code>tuple</code> Packed arguments passed to <code>pre_sim_func_nb</code>. <code>post_sim_func_nb</code> :\u2002<code>callable</code>  <p>Function called after simulation.</p> <p>Should accept SimulationContext and <code>*post_sim_args</code>. Should return nothing.</p>  <code>post_sim_args</code> :\u2002<code>tuple</code> Packed arguments passed to <code>post_sim_func_nb</code>. <code>pre_group_func_nb</code> :\u2002<code>callable</code>  <p>Function called before each group.</p> <p>Should accept GroupContext, unpacked tuple from <code>pre_sim_func_nb</code>, and <code>*pre_group_args</code>. Should return a tuple of any content, which is then passed to <code>pre_segment_func_nb</code> and <code>post_segment_func_nb</code>.</p>  <code>pre_group_args</code> :\u2002<code>tuple</code> Packed arguments passed to <code>pre_group_func_nb</code>. <code>post_group_func_nb</code> :\u2002<code>callable</code>  <p>Function called after each group.</p> <p>Should accept GroupContext, unpacked tuple from <code>pre_sim_func_nb</code>, and <code>*post_group_args</code>. Should return nothing.</p>  <code>post_group_args</code> :\u2002<code>tuple</code> Packed arguments passed to <code>post_group_func_nb</code>. <code>pre_segment_func_nb</code> :\u2002<code>callable</code>  <p>Function called before each segment.</p> <p>Called if <code>segment_mask</code> or <code>call_pre_segment</code> is True.</p> <p>Should accept SegmentContext, unpacked tuple from <code>pre_group_func_nb</code>, and <code>*pre_segment_args</code>. Should return a tuple of any content, which is then passed to <code>order_func_nb</code> and <code>post_order_func_nb</code>.</p> <p>This is the right place to change call sequence and set the valuation price. Group re-valuation and update of the open position stats happens right after this function, regardless of whether it has been called.</p>  <p>Note</p> <p>To change the call sequence of a segment, access SegmentContext.call_seq_now and change it in-place. Make sure to not generate any new arrays as it may negatively impact performance. Assigning <code>SegmentContext.call_seq_now</code> as any other context (named tuple) value is not supported. See SegmentContext.call_seq_now.</p>   <p>Note</p> <p>You can override elements of <code>last_val_price</code> to manipulate group valuation. See SimulationContext.last_val_price.</p>   <code>pre_segment_args</code> :\u2002<code>tuple</code> Packed arguments passed to <code>pre_segment_func_nb</code>. <code>post_segment_func_nb</code> :\u2002<code>callable</code>  <p>Function called after each segment.</p> <p>Called if <code>segment_mask</code> or <code>call_post_segment</code> is True.</p> <p>The last group re-valuation and update of the open position stats happens right before this function, regardless of whether it has been called.</p> <p>Should accept SegmentContext, unpacked tuple from <code>pre_group_func_nb</code>, and <code>*post_segment_args</code>. Should return nothing.</p>  <code>post_segment_args</code> :\u2002<code>tuple</code> Packed arguments passed to <code>post_segment_func_nb</code>. <code>order_func_nb</code> :\u2002<code>callable</code>  <p>Order generation function.</p> <p>Used for either generating an order or skipping.</p> <p>Should accept OrderContext, unpacked tuple from <code>pre_segment_func_nb</code>, and <code>*order_args</code>. Should return Order.</p>  <p>Note</p> <p>If the returned order has been rejected, there is no way of issuing a new order. You should make sure that the order passes, for example, by using try_order_nb().</p> <p>To have a greater freedom in order management, use flex_simulate_nb().</p>   <code>order_args</code> :\u2002<code>tuple</code> Arguments passed to <code>order_func_nb</code>. <code>post_order_func_nb</code> :\u2002<code>callable</code>  <p>Callback that is called after the order has been processed.</p> <p>Used for checking the order status and doing some post-processing.</p> <p>Should accept PostOrderContext, unpacked tuple from <code>pre_segment_func_nb</code>, and <code>*post_order_args</code>. Should return nothing.</p>  <code>post_order_args</code> :\u2002<code>tuple</code> Arguments passed to <code>post_order_func_nb</code>. <code>close</code> :\u2002<code>array_like</code> of <code>float</code> See SimulationContext.close. <code>ffill_val_price</code> :\u2002<code>bool</code> See SimulationContext.ffill_val_price. <code>update_value</code> :\u2002<code>bool</code> See SimulationContext.update_value. <code>fill_pos_record</code> :\u2002<code>bool</code> See SimulationContext.fill_pos_record. <code>max_orders</code> :\u2002<code>int</code> Size of the order records array. <code>max_logs</code> :\u2002<code>int</code> Size of the log records array. <code>flex_2d</code> :\u2002<code>bool</code> See SimulationContext.flex_2d.   <p>Note</p> <p>Remember that indexing of 2-dim arrays in vectorbt follows that of pandas: <code>a[i, col]</code>.</p>   <p>Warning</p> <p>You can only safely access data of columns that are to the left of the current group and rows that are to the top of the current row within the same group. Other data points have not been processed yet and thus empty. Accessing them will not trigger any errors or warnings, but provide you with arbitrary data (see np.empty).</p>  <p>Call hierarchy</p> <p>Like most things in the vectorbt universe, simulation is also done by iterating over a (imaginary) frame. This frame consists of two dimensions: time (rows) and assets/features (columns). Each element of this frame is a potential order, which gets generated by calling an order function.</p> <p>The question is: how do we move across this frame to simulate trading? There are two movement patterns: column-major (as done by simulate_nb()) and row-major order (as done by simulate_row_wise_nb()). In each of these patterns, we are always moving from top to bottom (time axis) and from left to right (asset/feature axis); the only difference between them is across which axis we are moving faster: do we want to process each column first (thus assuming that columns are independent) or each row? Choosing between them is mostly a matter of preference, but it also makes different data being available when generating an order.</p> <p>The frame is further divided into \"blocks\": columns, groups, rows, segments, and elements. For example, columns can be grouped into groups that may or may not share the same capital. Regardless of capital sharing, each collection of elements within a group and a time step is called a segment, which simply defines a single context (such as shared capital) for one or multiple orders. Each segment can also define a custom sequence (a so-called call sequence) in which orders are executed.</p> <p>You can imagine each of these blocks as a rectangle drawn over different parts of the frame, and having its own context and pre/post-processing function. The pre-processing function is a simple callback that is called before entering the block, and can be provided by the user to, for example, prepare arrays or do some custom calculations. It must return a tuple (can be empty) that is then unpacked and passed as arguments to the pre- and postprocessing function coming next in the call hierarchy. The postprocessing function can be used, for example, to write user-defined arrays such as returns.</p> <p>Let's demonstrate a frame with one group of two columns and one group of one column, and the following call sequence:</p> <pre><code>array([[0, 1, 0],\n       [1, 0, 0]])\n</code></pre> <p></p> <p>And here is the context information available at each step:</p> <p></p> <p>Usage</p> <ul> <li>Create a group of three assets together sharing 100$ and simulate an equal-weighted portfolio that rebalances every second tick, all without leaving Numba:</li> </ul> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from collections import namedtuple\n&gt;&gt;&gt; from numba import njit\n&gt;&gt;&gt; from vectorbt.generic.plotting import Scatter\n&gt;&gt;&gt; from vectorbt.records.nb import col_map_nb\n&gt;&gt;&gt; from vectorbt.portfolio.enums import SizeType, Direction\n&gt;&gt;&gt; from vectorbt.portfolio.nb import (\n...     get_col_elem_nb,\n...     get_elem_nb,\n...     order_nb,\n...     simulate_nb,\n...     simulate_row_wise_nb,\n...     build_call_seq,\n...     sort_call_seq_nb,\n...     asset_flow_nb,\n...     assets_nb,\n...     asset_value_nb\n... )\n\n&gt;&gt;&gt; @njit\n... def pre_sim_func_nb(c):\n...     print('before simulation')\n...     # Create a temporary array and pass it down the stack\n...     order_value_out = np.empty(c.target_shape[1], dtype=np.float_)\n...     return (order_value_out,)\n\n&gt;&gt;&gt; @njit\n... def pre_group_func_nb(c, order_value_out):\n...     print('\\tbefore group', c.group)\n...     # Forward down the stack (you can omit pre_group_func_nb entirely)\n...     return (order_value_out,)\n\n&gt;&gt;&gt; @njit\n... def pre_segment_func_nb(c, order_value_out, size, price, size_type, direction):\n...     print('\\t\\tbefore segment', c.i)\n...     for col in range(c.from_col, c.to_col):\n...         # Here we use order price for group valuation\n...         c.last_val_price[col] = get_col_elem_nb(c, col, price)\n...\n...     # Reorder call sequence of this segment such that selling orders come first and buying last\n...     # Rearranges c.call_seq_now based on order value (size, size_type, direction, and val_price)\n...     # Utilizes flexible indexing using get_col_elem_nb (as we did above)\n...     sort_call_seq_nb(c, size, size_type, direction, order_value_out[c.from_col:c.to_col])\n...     # Forward nothing\n...     return ()\n\n&gt;&gt;&gt; @njit\n... def order_func_nb(c, size, price, size_type, direction, fees, fixed_fees, slippage):\n...     print('\\t\\t\\tcreating order', c.call_idx, 'at column', c.col)\n...     # Create and return an order\n...     return order_nb(\n...         size=get_elem_nb(c, size),\n...         price=get_elem_nb(c, price),\n...         size_type=get_elem_nb(c, size_type),\n...         direction=get_elem_nb(c, direction),\n...         fees=get_elem_nb(c, fees),\n...         fixed_fees=get_elem_nb(c, fixed_fees),\n...         slippage=get_elem_nb(c, slippage)\n...     )\n\n&gt;&gt;&gt; @njit\n... def post_order_func_nb(c):\n...     print('\\t\\t\\t\\torder status:', c.order_result.status)\n...     return None\n\n&gt;&gt;&gt; @njit\n... def post_segment_func_nb(c, order_value_out):\n...     print('\\t\\tafter segment', c.i)\n...     return None\n\n&gt;&gt;&gt; @njit\n... def post_group_func_nb(c, order_value_out):\n...     print('\\tafter group', c.group)\n...     return None\n\n&gt;&gt;&gt; @njit\n... def post_sim_func_nb(c):\n...     print('after simulation')\n...     return None\n\n&gt;&gt;&gt; target_shape = (5, 3)\n&gt;&gt;&gt; np.random.seed(42)\n&gt;&gt;&gt; group_lens = np.array([3])  # one group of three columns\n&gt;&gt;&gt; init_cash = np.array([100.])  # one capital per group\n&gt;&gt;&gt; cash_sharing = True\n&gt;&gt;&gt; call_seq = build_call_seq(target_shape, group_lens)  # will be overridden\n&gt;&gt;&gt; segment_mask = np.array([True, False, True, False, True])[:, None]\n&gt;&gt;&gt; segment_mask = np.copy(np.broadcast_to(segment_mask, target_shape))\n&gt;&gt;&gt; size = np.asarray(1 / target_shape[1])  # scalars must become 0-dim arrays\n&gt;&gt;&gt; price = close = np.random.uniform(1, 10, size=target_shape)\n&gt;&gt;&gt; size_type = np.asarray(SizeType.TargetPercent)\n&gt;&gt;&gt; direction = np.asarray(Direction.LongOnly)\n&gt;&gt;&gt; fees = np.asarray(0.001)\n&gt;&gt;&gt; fixed_fees = np.asarray(1.)\n&gt;&gt;&gt; slippage = np.asarray(0.001)\n\n&gt;&gt;&gt; order_records, log_records = simulate_nb(\n...     target_shape,\n...     group_lens,\n...     init_cash,\n...     cash_sharing,\n...     call_seq,\n...     segment_mask=segment_mask,\n...     pre_sim_func_nb=pre_sim_func_nb,\n...     post_sim_func_nb=post_sim_func_nb,\n...     pre_group_func_nb=pre_group_func_nb,\n...     post_group_func_nb=post_group_func_nb,\n...     pre_segment_func_nb=pre_segment_func_nb,\n...     pre_segment_args=(size, price, size_type, direction),\n...     post_segment_func_nb=post_segment_func_nb,\n...     order_func_nb=order_func_nb,\n...     order_args=(size, price, size_type, direction, fees, fixed_fees, slippage),\n...     post_order_func_nb=post_order_func_nb\n... )\nbefore simulation\n    before group 0\n        before segment 0\n            creating order 0 at column 0\n                order status: 0\n            creating order 1 at column 1\n                order status: 0\n            creating order 2 at column 2\n                order status: 0\n        after segment 0\n        before segment 2\n            creating order 0 at column 1\n                order status: 0\n            creating order 1 at column 2\n                order status: 0\n            creating order 2 at column 0\n                order status: 0\n        after segment 2\n        before segment 4\n            creating order 0 at column 0\n                order status: 0\n            creating order 1 at column 2\n                order status: 0\n            creating order 2 at column 1\n                order status: 0\n        after segment 4\n    after group 0\nafter simulation\n\n&gt;&gt;&gt; pd.DataFrame.from_records(order_records)\n   id  col  idx       size     price      fees  side\n0   0    0    0   7.626262  4.375232  1.033367     0\n1   1    1    0   3.488053  9.565985  1.033367     0\n2   2    2    0   3.972040  7.595533  1.030170     0\n3   3    1    2   0.920352  8.786790  1.008087     1\n4   4    2    2   0.448747  6.403625  1.002874     1\n5   5    0    2   5.210115  1.524275  1.007942     0\n6   6    0    4   7.899568  8.483492  1.067016     1\n7   7    2    4  12.378281  2.639061  1.032667     0\n8   8    1    4  10.713236  2.913963  1.031218     0\n\n&gt;&gt;&gt; call_seq\narray([[0, 1, 2],\n       [0, 1, 2],\n       [1, 2, 0],\n       [0, 1, 2],\n       [0, 2, 1]])\n\n&gt;&gt;&gt; col_map = col_map_nb(order_records['col'], target_shape[1])\n&gt;&gt;&gt; asset_flow = asset_flow_nb(target_shape, order_records, col_map, Direction.Both)\n&gt;&gt;&gt; assets = assets_nb(asset_flow)\n&gt;&gt;&gt; asset_value = asset_value_nb(close, assets)\n&gt;&gt;&gt; Scatter(data=asset_value).fig.show()\n</code></pre> <p></p> <p>Note that the last order in a group with cash sharing is always disadvantaged as it has a bit less funds than the previous orders due to costs, which are not included when valuating the group.</p>","title":"simulate_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.simulate_row_wise_nb","text":"<pre><code>simulate_row_wise_nb(\n    target_shape,\n    group_lens,\n    init_cash,\n    cash_sharing,\n    call_seq,\n    segment_mask=array(True),\n    call_pre_segment=False,\n    call_post_segment=False,\n    pre_sim_func_nb=no_pre_func_nb,\n    pre_sim_args=(),\n    post_sim_func_nb=no_post_func_nb,\n    post_sim_args=(),\n    pre_row_func_nb=no_pre_func_nb,\n    pre_row_args=(),\n    post_row_func_nb=no_post_func_nb,\n    post_row_args=(),\n    pre_segment_func_nb=no_pre_func_nb,\n    pre_segment_args=(),\n    post_segment_func_nb=no_post_func_nb,\n    post_segment_args=(),\n    order_func_nb=no_order_func_nb,\n    order_args=(),\n    post_order_func_nb=no_post_func_nb,\n    post_order_args=(),\n    close=array(nan),\n    ffill_val_price=True,\n    update_value=False,\n    fill_pos_record=True,\n    max_orders=None,\n    max_logs=0,\n    flex_2d=True\n)\n</code></pre> <p>Same as simulate_nb(), but iterates in row-major order.</p> <p>Row-major order means processing the entire row with all groups/columns before moving to the next one.</p> <p>The main difference is that instead of <code>pre_group_func_nb</code> it now exposes <code>pre_row_func_nb</code>, which is executed per entire row. It should accept RowContext.</p>  <p>Note</p> <p>Function <code>pre_row_func_nb</code> is only called if there is at least on active segment in the row. Functions <code>pre_segment_func_nb</code> and <code>order_func_nb</code> are only called if their segment is active. If the main task of <code>pre_row_func_nb</code> is to activate/deactivate segments, all segments should be activated by default to allow <code>pre_row_func_nb</code> to be called.</p>   <p>Warning</p> <p>You can only safely access data points that are to the left of the current group and rows that are to the top of the current row.</p>  <p>Call hierarchy</p> <p>Let's illustrate the same example as in simulate_nb() but adapted for this function:</p> <p></p> <p>Usage</p> <ul> <li>Running the same example as in simulate_nb() but adapted for this function:</li> </ul> <pre><code>&gt;&gt;&gt; @njit\n... def pre_row_func_nb(c, order_value_out):\n...     print('\\tbefore row', c.i)\n...     # Forward down the stack\n...     return (order_value_out,)\n\n&gt;&gt;&gt; @njit\n... def post_row_func_nb(c, order_value_out):\n...     print('\\tafter row', c.i)\n...     return None\n\n&gt;&gt;&gt; call_seq = build_call_seq(target_shape, group_lens)\n&gt;&gt;&gt; order_records, log_records = simulate_row_wise_nb(\n...     target_shape,\n...     group_lens,\n...     init_cash,\n...     cash_sharing,\n...     call_seq,\n...     segment_mask=segment_mask,\n...     pre_sim_func_nb=pre_sim_func_nb,\n...     post_sim_func_nb=post_sim_func_nb,\n...     pre_row_func_nb=pre_row_func_nb,\n...     post_row_func_nb=post_row_func_nb,\n...     pre_segment_func_nb=pre_segment_func_nb,\n...     pre_segment_args=(size, price, size_type, direction),\n...     post_segment_func_nb=post_segment_func_nb,\n...     order_func_nb=order_func_nb,\n...     order_args=(size, price, size_type, direction, fees, fixed_fees, slippage),\n...     post_order_func_nb=post_order_func_nb\n... )\nbefore simulation\n    before row 0\n        before segment 0\n            creating order 0 at column 0\n                order status: 0\n            creating order 1 at column 1\n                order status: 0\n            creating order 2 at column 2\n                order status: 0\n        after segment 0\n    after row 0\n    before row 1\n    after row 1\n    before row 2\n        before segment 2\n            creating order 0 at column 1\n                order status: 0\n            creating order 1 at column 2\n                order status: 0\n            creating order 2 at column 0\n                order status: 0\n        after segment 2\n    after row 2\n    before row 3\n    after row 3\n    before row 4\n        before segment 4\n            creating order 0 at column 0\n                order status: 0\n            creating order 1 at column 2\n                order status: 0\n            creating order 2 at column 1\n                order status: 0\n        after segment 4\n    after row 4\nafter simulation\n</code></pre>","title":"simulate_row_wise_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.sort_call_seq_nb","text":"<pre><code>sort_call_seq_nb(\n    ctx,\n    size,\n    size_type,\n    direction,\n    order_value_out,\n    ctx_select=True\n)\n</code></pre> <p>Sort call sequence attached to SegmentContext.</p> <p>See sort_call_seq_out_nb().</p>  <p>Note</p> <p>Can only be used in non-flexible simulation functions.</p>","title":"sort_call_seq_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.sort_call_seq_out_nb","text":"<pre><code>sort_call_seq_out_nb(\n    ctx,\n    size,\n    size_type,\n    direction,\n    order_value_out,\n    call_seq_out,\n    ctx_select=True\n)\n</code></pre> <p>Sort call sequence <code>call_seq_out</code> based on the value of each potential order.</p> <p>Accepts SegmentContext and other arguments, sorts <code>call_seq_out</code> in place, and returns nothing.</p> <p>Arrays <code>size</code>, <code>size_type</code>, and <code>direction</code> utilize flexible indexing. If <code>ctx_select</code> is True, selects the elements of each <code>size</code>, <code>size_type</code>, and <code>direction</code> using get_col_elem_nb() assuming that each array can broadcast to <code>target_shape</code>. Otherwise, selects using flex_select_auto_nb() assuming that each array can broadcast to <code>group_len</code>.</p> <p>The lengths of <code>order_value_out</code> and <code>call_seq_out</code> should match the number of columns in the group. Array <code>order_value_out</code> should be empty and will contain sorted order values after execution. Array <code>call_seq_out</code> should be filled with integers ranging from 0 to the number of columns in the group (in this exact order).</p> <p>Best called once from <code>pre_segment_func_nb</code>.</p>  <p>Note</p> <p>Cash sharing must be enabled and <code>call_seq_out</code> should follow <code>CallSeqType.Default</code>.</p> <p>Should be used in flexible simulation functions.</p>","title":"sort_call_seq_out_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.sum_grouped_nb","text":"<pre><code>sum_grouped_nb(\n    a,\n    group_lens\n)\n</code></pre> <p>Squeeze each group of columns into a single column using sum operation.</p>","title":"sum_grouped_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.total_benchmark_return_nb","text":"<pre><code>total_benchmark_return_nb(\n    benchmark_value\n)\n</code></pre> <p>Get total market return per column/group.</p>","title":"total_benchmark_return_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.total_profit_grouped_nb","text":"<pre><code>total_profit_grouped_nb(\n    total_profit,\n    group_lens\n)\n</code></pre> <p>Get total profit per group.</p>","title":"total_profit_grouped_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.total_profit_nb","text":"<pre><code>total_profit_nb(\n    target_shape,\n    close,\n    order_records,\n    col_map\n)\n</code></pre> <p>Get total profit per column.</p> <p>A much faster version than the one based on value_nb().</p>","title":"total_profit_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.total_return_nb","text":"<pre><code>total_return_nb(\n    total_profit,\n    init_cash\n)\n</code></pre> <p>Get total return per column/group.</p>","title":"total_return_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.trade_losing_streak_nb","text":"<pre><code>trade_losing_streak_nb(\n    records\n)\n</code></pre> <p>Return the current losing streak of each trade.</p>","title":"trade_losing_streak_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.trade_winning_streak_nb","text":"<pre><code>trade_winning_streak_nb(\n    records\n)\n</code></pre> <p>Return the current winning streak of each trade.</p>","title":"trade_winning_streak_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.try_order_nb","text":"<pre><code>try_order_nb(\n    ctx,\n    order\n)\n</code></pre> <p>Execute an order without persistence.</p>","title":"try_order_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.update_open_pos_stats_nb","text":"<pre><code>update_open_pos_stats_nb(\n    record,\n    position_now,\n    price\n)\n</code></pre> <p>Update statistics of an open position record using custom price.</p>","title":"update_open_pos_stats_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.update_pos_record_nb","text":"<pre><code>update_pos_record_nb(\n    record,\n    i,\n    col,\n    position_before,\n    position_now,\n    order_result\n)\n</code></pre> <p>Update position record after filling an order.</p>","title":"update_pos_record_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.update_value_nb","text":"<pre><code>update_value_nb(\n    cash_before,\n    cash_now,\n    position_before,\n    position_now,\n    val_price_before,\n    price,\n    value_before\n)\n</code></pre> <p>Update valuation price and value.</p>","title":"update_value_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.value_in_sim_order_nb","text":"<pre><code>value_in_sim_order_nb(\n    cash,\n    asset_value,\n    group_lens,\n    call_seq\n)\n</code></pre> <p>Get portfolio value series in simulation order.</p>","title":"value_in_sim_order_nb function"},{"location":"api/portfolio/nb/#vectorbt.portfolio.nb.value_nb","text":"<pre><code>value_nb(\n    cash,\n    asset_value\n)\n</code></pre> <p>Get portfolio value series per column/group.</p>","title":"value_nb function"},{"location":"api/portfolio/orders/","text":"<p>Base class for working with order records.</p> <p>Order records capture information on filled orders. Orders are mainly populated when simulating a portfolio and can be accessed as Portfolio.orders.</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from datetime import datetime, timedelta\n&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; np.random.seed(42)\n&gt;&gt;&gt; price = pd.DataFrame({\n...     'a': np.random.uniform(1, 2, size=100),\n...     'b': np.random.uniform(1, 2, size=100)\n... }, index=[datetime(2020, 1, 1) + timedelta(days=i) for i in range(100)])\n&gt;&gt;&gt; size = pd.DataFrame({\n...     'a': np.random.uniform(-1, 1, size=100),\n...     'b': np.random.uniform(-1, 1, size=100),\n... }, index=[datetime(2020, 1, 1) + timedelta(days=i) for i in range(100)])\n&gt;&gt;&gt; pf = vbt.Portfolio.from_orders(price, size, fees=0.01, freq='d')\n&gt;&gt;&gt; orders = pf.orders\n\n&gt;&gt;&gt; orders.buy.count()\na    58\nb    51\nName: count, dtype: int64\n\n&gt;&gt;&gt; orders.sell.count()\na    42\nb    49\nName: count, dtype: int64\n</code></pre>","title":"orders"},{"location":"api/portfolio/orders/#stats","text":"<p>Hint</p> <p>See StatsBuilderMixin.stats() and Orders.metrics.</p>  <pre><code>&gt;&gt;&gt; orders['a'].stats()\nStart                2020-01-01 00:00:00\nEnd                  2020-04-09 00:00:00\nPeriod                 100 days 00:00:00\nTotal Records                        100\nTotal Buy Orders                      58\nTotal Sell Orders                     42\nMin Size                        0.003033\nMax Size                        0.989877\nAvg Size                        0.508608\nAvg Buy Size                    0.468802\nAvg Sell Size                   0.563577\nAvg Buy Price                   1.437037\nAvg Sell Price                  1.515951\nTotal Fees                      0.740177\nMin Fees                        0.000052\nMax Fees                        0.016224\nAvg Fees                        0.007402\nAvg Buy Fees                    0.006771\nAvg Sell Fees                   0.008273\nName: a, dtype: object\n</code></pre> <p>StatsBuilderMixin.stats() also supports (re-)grouping:</p> <pre><code>&gt;&gt;&gt; orders.stats(group_by=True)\nStart                2020-01-01 00:00:00\nEnd                  2020-04-09 00:00:00\nPeriod                 100 days 00:00:00\nTotal Records                        200\nTotal Buy Orders                     109\nTotal Sell Orders                     91\nMin Size                        0.003033\nMax Size                        0.989877\nAvg Size                        0.506279\nAvg Buy Size                    0.472504\nAvg Sell Size                   0.546735\nAvg Buy Price                    1.47336\nAvg Sell Price                  1.496759\nTotal Fees                      1.483343\nMin Fees                        0.000052\nMax Fees                        0.018319\nAvg Fees                        0.007417\nAvg Buy Fees                    0.006881\nAvg Sell Fees                   0.008058\nName: group, dtype: object\n</code></pre>","title":"Stats"},{"location":"api/portfolio/orders/#plots","text":"<p>Hint</p> <p>See PlotsBuilderMixin.plots() and Orders.subplots.</p>  <p>Orders class has a single subplot based on Orders.plot():</p> <pre><code>&gt;&gt;&gt; orders['a'].plots()\n</code></pre> <p></p>","title":"Plots"},{"location":"api/portfolio/orders/#vectorbt.portfolio.orders.orders_attach_field_config","text":"<p>Config of fields to be attached to Orders.</p> <pre><code>Config({\n    \"side\": {\n        \"attach_filters\": true\n    }\n})\n</code></pre>","title":"orders_attach_field_config variable"},{"location":"api/portfolio/orders/#vectorbt.portfolio.orders.orders_field_config","text":"<p>Field config for Orders.</p> <pre><code>Config({\n    \"dtype\": {\n        \"id\": \"int64\",\n        \"col\": \"int64\",\n        \"idx\": \"int64\",\n        \"size\": \"float64\",\n        \"price\": \"float64\",\n        \"fees\": \"float64\",\n        \"side\": \"int64\"\n    },\n    \"settings\": {\n        \"id\": {\n            \"title\": \"Order Id\"\n        },\n        \"size\": {\n            \"title\": \"Size\"\n        },\n        \"price\": {\n            \"title\": \"Price\"\n        },\n        \"fees\": {\n            \"title\": \"Fees\"\n        },\n        \"side\": {\n            \"title\": \"Side\",\n            \"mapping\": {\n                \"Buy\": 0,\n                \"Sell\": 1\n            }\n        }\n    }\n})\n</code></pre>","title":"orders_field_config variable"},{"location":"api/portfolio/orders/#vectorbt.portfolio.orders.Orders","text":"<pre><code>Orders(\n    wrapper,\n    records_arr,\n    close=None,\n    **kwargs\n)\n</code></pre> <p>Extends <code>Records</code> for working with order records.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>Records</li> <li>RecordsWithFields</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>Records.apply()</li> <li>Records.apply_mask()</li> <li>Records.build_field_config_doc()</li> <li>Records.col_arr</li> <li>Records.col_mapper</li> <li>Records.config</li> <li>Records.count()</li> <li>Records.get_apply_mapping_arr()</li> <li>Records.get_by_col_idxs()</li> <li>Records.get_field_arr()</li> <li>Records.get_field_mapping()</li> <li>Records.get_field_name()</li> <li>Records.get_field_setting()</li> <li>Records.get_field_title()</li> <li>Records.get_map_field()</li> <li>Records.get_map_field_to_index()</li> <li>Records.id_arr</li> <li>Records.idx_arr</li> <li>Records.iloc</li> <li>Records.indexing_func_meta()</li> <li>Records.indexing_kwargs</li> <li>Records.is_sorted()</li> <li>Records.loc</li> <li>Records.map()</li> <li>Records.map_array()</li> <li>Records.map_field()</li> <li>Records.override_field_config_doc()</li> <li>Records.records</li> <li>Records.records_arr</li> <li>Records.records_readable</li> <li>Records.replace()</li> <li>Records.self_aliases</li> <li>Records.sort()</li> <li>Records.values</li> <li>Records.wrapper</li> <li>Records.writeable_attrs</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul>","title":"Orders class"},{"location":"api/portfolio/orders/#vectorbt.portfolio.orders.Orders.field_config","text":"<p>Field config of Orders.</p> <pre><code>Config({\n    \"dtype\": {\n        \"id\": \"int64\",\n        \"col\": \"int64\",\n        \"idx\": \"int64\",\n        \"size\": \"float64\",\n        \"price\": \"float64\",\n        \"fees\": \"float64\",\n        \"side\": \"int64\"\n    },\n    \"settings\": {\n        \"id\": {\n            \"name\": \"id\",\n            \"title\": \"Order Id\"\n        },\n        \"col\": {\n            \"name\": \"col\",\n            \"title\": \"Column\",\n            \"mapping\": \"columns\"\n        },\n        \"idx\": {\n            \"name\": \"idx\",\n            \"title\": \"Timestamp\",\n            \"mapping\": \"index\"\n        },\n        \"size\": {\n            \"title\": \"Size\"\n        },\n        \"price\": {\n            \"title\": \"Price\"\n        },\n        \"fees\": {\n            \"title\": \"Fees\"\n        },\n        \"side\": {\n            \"title\": \"Side\",\n            \"mapping\": {\n                \"Buy\": 0,\n                \"Sell\": 1\n            }\n        }\n    }\n})\n</code></pre>","title":"field_config class variable"},{"location":"api/portfolio/orders/#vectorbt.portfolio.orders.Orders.metrics","text":"<p>Metrics supported by Orders.</p> <pre><code>Config({\n    \"start\": {\n        \"title\": \"Start\",\n        \"calc_func\": \"&lt;function Orders.&lt;lambda&gt; at 0x7ff521531e18&gt;\",\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"end\": {\n        \"title\": \"End\",\n        \"calc_func\": \"&lt;function Orders.&lt;lambda&gt; at 0x7ff521531ea0&gt;\",\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"period\": {\n        \"title\": \"Period\",\n        \"calc_func\": \"&lt;function Orders.&lt;lambda&gt; at 0x7ff521531f28&gt;\",\n        \"apply_to_timedelta\": true,\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"total_records\": {\n        \"title\": \"Total Records\",\n        \"calc_func\": \"count\",\n        \"tags\": \"records\"\n    },\n    \"total_buy_orders\": {\n        \"title\": \"Total Buy Orders\",\n        \"calc_func\": \"buy.count\",\n        \"tags\": [\n            \"orders\",\n            \"buy\"\n        ]\n    },\n    \"total_sell_orders\": {\n        \"title\": \"Total Sell Orders\",\n        \"calc_func\": \"sell.count\",\n        \"tags\": [\n            \"orders\",\n            \"sell\"\n        ]\n    },\n    \"min_size\": {\n        \"title\": \"Min Size\",\n        \"calc_func\": \"size.min\",\n        \"tags\": [\n            \"orders\",\n            \"size\"\n        ]\n    },\n    \"max_size\": {\n        \"title\": \"Max Size\",\n        \"calc_func\": \"size.max\",\n        \"tags\": [\n            \"orders\",\n            \"size\"\n        ]\n    },\n    \"avg_size\": {\n        \"title\": \"Avg Size\",\n        \"calc_func\": \"size.mean\",\n        \"tags\": [\n            \"orders\",\n            \"size\"\n        ]\n    },\n    \"avg_buy_size\": {\n        \"title\": \"Avg Buy Size\",\n        \"calc_func\": \"buy.size.mean\",\n        \"tags\": [\n            \"orders\",\n            \"buy\",\n            \"size\"\n        ]\n    },\n    \"avg_sell_size\": {\n        \"title\": \"Avg Sell Size\",\n        \"calc_func\": \"sell.size.mean\",\n        \"tags\": [\n            \"orders\",\n            \"sell\",\n            \"size\"\n        ]\n    },\n    \"avg_buy_price\": {\n        \"title\": \"Avg Buy Price\",\n        \"calc_func\": \"buy.price.mean\",\n        \"tags\": [\n            \"orders\",\n            \"buy\",\n            \"price\"\n        ]\n    },\n    \"avg_sell_price\": {\n        \"title\": \"Avg Sell Price\",\n        \"calc_func\": \"sell.price.mean\",\n        \"tags\": [\n            \"orders\",\n            \"sell\",\n            \"price\"\n        ]\n    },\n    \"total_fees\": {\n        \"title\": \"Total Fees\",\n        \"calc_func\": \"fees.sum\",\n        \"tags\": [\n            \"orders\",\n            \"fees\"\n        ]\n    },\n    \"min_fees\": {\n        \"title\": \"Min Fees\",\n        \"calc_func\": \"fees.min\",\n        \"tags\": [\n            \"orders\",\n            \"fees\"\n        ]\n    },\n    \"max_fees\": {\n        \"title\": \"Max Fees\",\n        \"calc_func\": \"fees.max\",\n        \"tags\": [\n            \"orders\",\n            \"fees\"\n        ]\n    },\n    \"avg_fees\": {\n        \"title\": \"Avg Fees\",\n        \"calc_func\": \"fees.mean\",\n        \"tags\": [\n            \"orders\",\n            \"fees\"\n        ]\n    },\n    \"avg_buy_fees\": {\n        \"title\": \"Avg Buy Fees\",\n        \"calc_func\": \"buy.fees.mean\",\n        \"tags\": [\n            \"orders\",\n            \"buy\",\n            \"fees\"\n        ]\n    },\n    \"avg_sell_fees\": {\n        \"title\": \"Avg Sell Fees\",\n        \"calc_func\": \"sell.fees.mean\",\n        \"tags\": [\n            \"orders\",\n            \"sell\",\n            \"fees\"\n        ]\n    }\n})\n</code></pre> <p>Returns <code>Orders._metrics</code>, which gets (deep) copied upon creation of each instance. Thus, changing this config won't affect the class.</p> <p>To change metrics, you can either change the config in-place, override this property, or overwrite the instance variable <code>Orders._metrics</code>.</p>","title":"metrics class variable"},{"location":"api/portfolio/orders/#vectorbt.portfolio.orders.Orders.subplots","text":"<p>Subplots supported by Orders.</p> <pre><code>Config({\n    \"plot\": {\n        \"title\": \"Orders\",\n        \"yaxis_kwargs\": {\n            \"title\": \"Price\"\n        },\n        \"check_is_not_grouped\": true,\n        \"plot_func\": \"plot\",\n        \"tags\": \"orders\"\n    }\n})\n</code></pre> <p>Returns <code>Orders._subplots</code>, which gets (deep) copied upon creation of each instance. Thus, changing this config won't affect the class.</p> <p>To change subplots, you can either change the config in-place, override this property, or overwrite the instance variable <code>Orders._subplots</code>.</p>","title":"subplots class variable"},{"location":"api/portfolio/orders/#vectorbt.portfolio.orders.Orders.buy","text":"<p>Records filtered by <code>side == 0</code>.</p>","title":"buy variable"},{"location":"api/portfolio/orders/#vectorbt.portfolio.orders.Orders.close","text":"<p>Reference price such as close (optional).</p>","title":"close property"},{"location":"api/portfolio/orders/#vectorbt.portfolio.orders.Orders.col","text":"<p>Mapped array of the field <code>col</code>.</p>","title":"col variable"},{"location":"api/portfolio/orders/#vectorbt.portfolio.orders.Orders.fees","text":"<p>Mapped array of the field <code>fees</code>.</p>","title":"fees variable"},{"location":"api/portfolio/orders/#vectorbt.portfolio.orders.Orders.id","text":"<p>Mapped array of the field <code>id</code>.</p>","title":"id variable"},{"location":"api/portfolio/orders/#vectorbt.portfolio.orders.Orders.idx","text":"<p>Mapped array of the field <code>idx</code>.</p>","title":"idx variable"},{"location":"api/portfolio/orders/#vectorbt.portfolio.orders.Orders.plots_defaults","text":"<p>Defaults for PlotsBuilderMixin.plots().</p> <p>Merges Records.plots_defaults and <code>orders.plots</code> from settings.</p>","title":"plots_defaults property"},{"location":"api/portfolio/orders/#vectorbt.portfolio.orders.Orders.price","text":"<p>Mapped array of the field <code>price</code>.</p>","title":"price variable"},{"location":"api/portfolio/orders/#vectorbt.portfolio.orders.Orders.sell","text":"<p>Records filtered by <code>side == 1</code>.</p>","title":"sell variable"},{"location":"api/portfolio/orders/#vectorbt.portfolio.orders.Orders.side","text":"<p>Mapped array of the field <code>side</code>.</p>","title":"side variable"},{"location":"api/portfolio/orders/#vectorbt.portfolio.orders.Orders.size","text":"<p>Mapped array of the field <code>size</code>.</p>","title":"size variable"},{"location":"api/portfolio/orders/#vectorbt.portfolio.orders.Orders.stats_defaults","text":"<p>Defaults for StatsBuilderMixin.stats().</p> <p>Merges Records.stats_defaults and <code>orders.stats</code> from settings.</p>","title":"stats_defaults property"},{"location":"api/portfolio/orders/#vectorbt.portfolio.orders.Orders.indexing_func","text":"<pre><code>Orders.indexing_func(\n    pd_indexing_func,\n    **kwargs\n)\n</code></pre> <p>Perform indexing on Orders.</p>","title":"indexing_func method"},{"location":"api/portfolio/orders/#vectorbt.portfolio.orders.Orders.plot","text":"<pre><code>Orders.plot(\n    column=None,\n    close_trace_kwargs=None,\n    buy_trace_kwargs=None,\n    sell_trace_kwargs=None,\n    add_trace_kwargs=None,\n    fig=None,\n    **layout_kwargs\n)\n</code></pre> <p>Plot orders.</p> <p>Args</p>  <code>column</code> :\u2002<code>str</code> Name of the column to plot. <code>close_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for Orders.close. <code>buy_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for \"Buy\" markers. <code>sell_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for \"Sell\" markers. <code>add_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>add_trace</code>. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**layout_kwargs</code> Keyword arguments for layout.  <p>Usage</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from datetime import datetime, timedelta\n&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; price = pd.Series([1., 2., 3., 2., 1.], name='Price')\n&gt;&gt;&gt; price.index = [datetime(2020, 1, 1) + timedelta(days=i) for i in range(len(price))]\n&gt;&gt;&gt; size = pd.Series([1., 1., 1., 1., -1.])\n&gt;&gt;&gt; orders = vbt.Portfolio.from_orders(price, size).orders\n\n&gt;&gt;&gt; orders.plot()\n</code></pre> <p></p>","title":"plot method"},{"location":"api/portfolio/trades/","text":"<p>Base class for working with trade records.</p> <p>Trade records capture information on trades.</p> <p>In vectorbt, a trade is a sequence of orders that starts with an opening order and optionally ends with a closing order. Every pair of opposite orders can be represented by a trade. Each trade has a PnL info attached to quickly assess its performance. An interesting effect of this representation is the ability to aggregate trades: if two or more trades are happening one after another in time, they can be aggregated into a bigger trade. This way, for example, single-order trades can be aggregated into positions; but also multiple positions can be aggregated into a single blob that reflects the performance of the entire symbol.</p>  <p>Warning</p> <p>All classes return both closed AND open trades/positions, which may skew your performance results. To only consider closed trades/positions, you should explicitly query the <code>closed</code> attribute.</p>","title":"trades"},{"location":"api/portfolio/trades/#trade-types","text":"<p>There are three main types of trades.</p>","title":"Trade types"},{"location":"api/portfolio/trades/#entry-trades","text":"<p>An entry trade is created from each order that opens or adds to a position.</p> <p>For example, if we have a single large buy order and 100 smaller sell orders, we will see a single trade with the entry information copied from the buy order and the exit information being a size-weighted average over the exit information of all sell orders. On the other hand, if we have 100 smaller buy orders and a single sell order, we will see 100 trades, each with the entry information copied from the buy order and the exit information being a size-based fraction of the exit information of the sell order.</p> <p>Use EntryTrades.from_orders() to build entry trades from orders. Also available as Portfolio.entry_trades.</p>","title":"Entry trades"},{"location":"api/portfolio/trades/#exit-trades","text":"<p>An exit trade is created from each order that closes or removes from a position.</p> <p>Use ExitTrades.from_orders() to build exit trades from orders. Also available as Portfolio.exit_trades.</p>","title":"Exit trades"},{"location":"api/portfolio/trades/#positions","text":"<p>A position is created from a sequence of entry or exit trades.</p> <p>Use Positions.from_trades() to build positions from entry or exit trades. Also available as Portfolio.positions.</p>","title":"Positions"},{"location":"api/portfolio/trades/#example","text":"<ul> <li>Increasing position:</li> </ul> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from datetime import datetime, timedelta\n&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; # Entry trades\n&gt;&gt;&gt; pf_kwargs = dict(\n...     close=pd.Series([1., 2., 3., 4., 5.]),\n...     size=pd.Series([1., 1., 1., 1., -4.]),\n...     fixed_fees=1.\n... )\n&gt;&gt;&gt; entry_trades = vbt.Portfolio.from_orders(**pf_kwargs).entry_trades\n&gt;&gt;&gt; entry_trades.records_readable\n   Trade Id  Column  Size  Entry Timestamp  Avg Entry Price  Entry Fees  \\\n0         0       0   1.0                0              1.0         1.0\n1         1       0   1.0                1              2.0         1.0\n2         2       0   1.0                2              3.0         1.0\n3         3       0   1.0                3              4.0         1.0\n\n   Exit Timestamp  Avg Exit Price  Exit Fees   PnL  Return Direction  Status  \\\n0               4             5.0       0.25  2.75  2.7500      Long  Closed\n1               4             5.0       0.25  1.75  0.8750      Long  Closed\n2               4             5.0       0.25  0.75  0.2500      Long  Closed\n3               4             5.0       0.25 -0.25 -0.0625      Long  Closed\n\n   Parent Id\n0          0\n1          0\n2          0\n3          0\n\n&gt;&gt;&gt; # Exit trades\n&gt;&gt;&gt; exit_trades = vbt.Portfolio.from_orders(**pf_kwargs).exit_trades\n&gt;&gt;&gt; exit_trades.records_readable\n   Trade Id  Column  Size  Entry Timestamp  Avg Entry Price  Entry Fees  \\\n0         0       0   4.0                0              2.5         4.0\n\n   Exit Timestamp  Avg Exit Price  Exit Fees  PnL  Return Direction  Status  \\\n0               4             5.0        1.0  5.0     0.5      Long  Closed\n\n   Parent Id\n0          0\n\n&gt;&gt;&gt; # Positions\n&gt;&gt;&gt; positions = vbt.Portfolio.from_orders(**pf_kwargs).positions\n&gt;&gt;&gt; positions.records_readable\n   Trade Id  Column  Size  Entry Timestamp  Avg Entry Price  Entry Fees  \\\n0         0       0   4.0                0              2.5         4.0\n\n   Exit Timestamp  Avg Exit Price  Exit Fees  PnL  Return Direction  Status  \\\n0               4             5.0        1.0  5.0     0.5      Long  Closed\n\n   Parent Id\n0          0\n\n&gt;&gt;&gt; entry_trades.pnl.sum() == exit_trades.pnl.sum() == positions.pnl.sum()\nTrue\n</code></pre> <ul> <li>Decreasing position:</li> </ul> <pre><code>&gt;&gt;&gt; # Entry trades\n&gt;&gt;&gt; pf_kwargs = dict(\n...     close=pd.Series([1., 2., 3., 4., 5.]),\n...     size=pd.Series([4., -1., -1., -1., -1.]),\n...     fixed_fees=1.\n... )\n&gt;&gt;&gt; entry_trades = vbt.Portfolio.from_orders(**pf_kwargs).entry_trades\n&gt;&gt;&gt; entry_trades.records_readable\n   Trade Id  Column  Size  Entry Timestamp  Avg Entry Price  Entry Fees  \\\n0         0       0   4.0                0              1.0         1.0\n\n   Exit Timestamp  Avg Exit Price  Exit Fees  PnL  Return Direction  Status  \\\n0               4             3.5        4.0  5.0    1.25      Long  Closed\n\n   Parent Id\n0          0\n\n&gt;&gt;&gt; # Exit trades\n&gt;&gt;&gt; exit_trades = vbt.Portfolio.from_orders(**pf_kwargs).exit_trades\n&gt;&gt;&gt; exit_trades.records_readable\n   Trade Id  Column  Size  Entry Timestamp  Avg Entry Price  Entry Fees  \\\n0         0       0   1.0                0              1.0        0.25\n1         1       0   1.0                0              1.0        0.25\n2         2       0   1.0                0              1.0        0.25\n3         3       0   1.0                0              1.0        0.25\n\n   Exit Timestamp  Avg Exit Price  Exit Fees   PnL  Return Direction  Status  \\\n0               1             2.0        1.0 -0.25   -0.25      Long  Closed\n1               2             3.0        1.0  0.75    0.75      Long  Closed\n2               3             4.0        1.0  1.75    1.75      Long  Closed\n3               4             5.0        1.0  2.75    2.75      Long  Closed\n\n   Parent Id\n0          0\n1          0\n2          0\n3          0\n\n&gt;&gt;&gt; # Positions\n&gt;&gt;&gt; positions = vbt.Portfolio.from_orders(**pf_kwargs).positions\n&gt;&gt;&gt; positions.records_readable\n   Trade Id  Column  Size  Entry Timestamp  Avg Entry Price  Entry Fees  \\\n0         0       0   4.0                0              1.0         1.0\n\n   Exit Timestamp  Avg Exit Price  Exit Fees  PnL  Return Direction  Status  \\\n0               4             3.5        4.0  5.0    1.25      Long  Closed\n\n   Parent Id\n0          0\n\n&gt;&gt;&gt; entry_trades.pnl.sum() == exit_trades.pnl.sum() == positions.pnl.sum()\nTrue\n</code></pre> <ul> <li>Multiple reversing positions:</li> </ul> <pre><code>&gt;&gt;&gt; # Entry trades\n&gt;&gt;&gt; pf_kwargs = dict(\n...     close=pd.Series([1., 2., 3., 4., 5.]),\n...     size=pd.Series([1., -2., 2., -2., 1.]),\n...     fixed_fees=1.\n... )\n&gt;&gt;&gt; entry_trades = vbt.Portfolio.from_orders(**pf_kwargs).entry_trades\n&gt;&gt;&gt; entry_trades.records_readable\n   Trade Id  Column  Size  Entry Timestamp  Avg Entry Price  Entry Fees  \\\n0         0       0   1.0                0              1.0         1.0\n1         1       0   1.0                1              2.0         0.5\n2         2       0   1.0                2              3.0         0.5\n3         3       0   1.0                3              4.0         0.5\n\n   Exit Timestamp  Avg Exit Price  Exit Fees  PnL  Return Direction  Status  \\\n0               1             2.0        0.5 -0.5  -0.500      Long  Closed\n1               2             3.0        0.5 -2.0  -1.000     Short  Closed\n2               3             4.0        0.5  0.0   0.000      Long  Closed\n3               4             5.0        1.0 -2.5  -0.625     Short  Closed\n\n   Parent Id\n0          0\n1          1\n2          2\n3          3\n\n&gt;&gt;&gt; # Exit trades\n&gt;&gt;&gt; exit_trades = vbt.Portfolio.from_orders(**pf_kwargs).exit_trades\n&gt;&gt;&gt; exit_trades.records_readable\n   Trade Id  Column  Size  Entry Timestamp  Avg Entry Price  Entry Fees  \\\n0         0       0   1.0                0              1.0         1.0\n1         1       0   1.0                1              2.0         0.5\n2         2       0   1.0                2              3.0         0.5\n3         3       0   1.0                3              4.0         0.5\n\n   Exit Timestamp  Avg Exit Price  Exit Fees  PnL  Return Direction  Status  \\\n0               1             2.0        0.5 -0.5  -0.500      Long  Closed\n1               2             3.0        0.5 -2.0  -1.000     Short  Closed\n2               3             4.0        0.5  0.0   0.000      Long  Closed\n3               4             5.0        1.0 -2.5  -0.625     Short  Closed\n\n   Parent Id\n0          0\n1          1\n2          2\n3          3\n\n&gt;&gt;&gt; # Positions\n&gt;&gt;&gt; positions = vbt.Portfolio.from_orders(**pf_kwargs).positions\n&gt;&gt;&gt; positions.records_readable\n   Trade Id  Column  Size  Entry Timestamp  Avg Entry Price  Entry Fees  \\\n0         0       0   1.0                0              1.0         1.0\n1         1       0   1.0                1              2.0         0.5\n2         2       0   1.0                2              3.0         0.5\n3         3       0   1.0                3              4.0         0.5\n\n   Exit Timestamp  Avg Exit Price  Exit Fees  PnL  Return Direction  Status  \\\n0               1             2.0        0.5 -0.5  -0.500      Long  Closed\n1               2             3.0        0.5 -2.0  -1.000     Short  Closed\n2               3             4.0        0.5  0.0   0.000      Long  Closed\n3               4             5.0        1.0 -2.5  -0.625     Short  Closed\n\n   Parent Id\n0          0\n1          1\n2          2\n3          3\n\n&gt;&gt;&gt; entry_trades.pnl.sum() == exit_trades.pnl.sum() == positions.pnl.sum()\nTrue\n</code></pre> <ul> <li>Open position:</li> </ul> <pre><code>&gt;&gt;&gt; # Entry trades\n&gt;&gt;&gt; pf_kwargs = dict(\n...     close=pd.Series([1., 2., 3., 4., 5.]),\n...     size=pd.Series([1., 0., 0., 0., 0.]),\n...     fixed_fees=1.\n... )\n&gt;&gt;&gt; entry_trades = vbt.Portfolio.from_orders(**pf_kwargs).entry_trades\n&gt;&gt;&gt; entry_trades.records_readable\n   Trade Id  Column  Size  Entry Timestamp  Avg Entry Price  Entry Fees  \\\n0         0       0   1.0                0              1.0         1.0\n\n   Exit Timestamp  Avg Exit Price  Exit Fees  PnL  Return Direction Status  \\\n0               4             5.0        0.0  3.0     3.0      Long   Open\n\n   Parent Id\n0          0\n\n&gt;&gt;&gt; # Exit trades\n&gt;&gt;&gt; exit_trades = vbt.Portfolio.from_orders(**pf_kwargs).exit_trades\n&gt;&gt;&gt; exit_trades.records_readable\n   Trade Id  Column  Size  Entry Timestamp  Avg Entry Price  Entry Fees  \\\n0         0       0   1.0                0              1.0         1.0\n\n   Exit Timestamp  Avg Exit Price  Exit Fees  PnL  Return Direction Status  \\\n0               4             5.0        0.0  3.0     3.0      Long   Open\n\n   Parent Id\n0          0\n\n&gt;&gt;&gt; # Positions\n&gt;&gt;&gt; positions = vbt.Portfolio.from_orders(**pf_kwargs).positions\n&gt;&gt;&gt; positions.records_readable\n   Trade Id  Column  Size  Entry Timestamp  Avg Entry Price  Entry Fees  \\\n0         0       0   1.0                0              1.0         1.0\n\n   Exit Timestamp  Avg Exit Price  Exit Fees  PnL  Return Direction Status  \\\n0               4             5.0        0.0  3.0     3.0      Long   Open\n\n   Parent Id\n0          0\n\n&gt;&gt;&gt; entry_trades.pnl.sum() == exit_trades.pnl.sum() == positions.pnl.sum()\nTrue\n</code></pre> <p>Get trade count, trade PnL, and winning trade PnL:</p> <pre><code>&gt;&gt;&gt; price = pd.Series([1., 2., 3., 4., 3., 2., 1.])\n&gt;&gt;&gt; size = pd.Series([1., -0.5, -0.5, 2., -0.5, -0.5, -0.5])\n&gt;&gt;&gt; trades = vbt.Portfolio.from_orders(price, size).trades\n\n&gt;&gt;&gt; trades.count()\n6\n\n&gt;&gt;&gt; trades.pnl.sum()\n-3.0\n\n&gt;&gt;&gt; trades.winning.count()\n2\n\n&gt;&gt;&gt; trades.winning.pnl.sum()\n1.5\n</code></pre> <p>Get count and PnL of trades with duration of more than 2 days:</p> <pre><code>&gt;&gt;&gt; mask = (trades.records['exit_idx'] - trades.records['entry_idx']) &gt; 2\n&gt;&gt;&gt; trades_filtered = trades.apply_mask(mask)\n&gt;&gt;&gt; trades_filtered.count()\n2\n\n&gt;&gt;&gt; trades_filtered.pnl.sum()\n-3.0\n</code></pre>","title":"Example"},{"location":"api/portfolio/trades/#stats","text":"<p>Hint</p> <p>See StatsBuilderMixin.stats() and Trades.metrics.</p>  <pre><code>&gt;&gt;&gt; np.random.seed(42)\n&gt;&gt;&gt; price = pd.DataFrame({\n...     'a': np.random.uniform(1, 2, size=100),\n...     'b': np.random.uniform(1, 2, size=100)\n... }, index=[datetime(2020, 1, 1) + timedelta(days=i) for i in range(100)])\n&gt;&gt;&gt; size = pd.DataFrame({\n...     'a': np.random.uniform(-1, 1, size=100),\n...     'b': np.random.uniform(-1, 1, size=100),\n... }, index=[datetime(2020, 1, 1) + timedelta(days=i) for i in range(100)])\n&gt;&gt;&gt; pf = vbt.Portfolio.from_orders(price, size, fees=0.01, freq='d')\n\n&gt;&gt;&gt; pf.trades['a'].stats()\nStart                                2020-01-01 00:00:00\nEnd                                  2020-04-09 00:00:00\nPeriod                                 100 days 00:00:00\nFirst Trade Start                    2020-01-01 00:00:00\nLast Trade End                       2020-04-09 00:00:00\nCoverage                               100 days 00:00:00\nOverlap Coverage                        97 days 00:00:00\nTotal Records                                         48\nTotal Long Trades                                     22\nTotal Short Trades                                    26\nTotal Closed Trades                                   47\nTotal Open Trades                                      1\nOpen Trade PnL                                 -1.290981\nWin Rate [%]                                    51.06383\nMax Win Streak                                         3\nMax Loss Streak                                        3\nBest Trade [%]                                 43.326077\nWorst Trade [%]                               -59.478304\nAvg Winning Trade [%]                          21.418522\nAvg Losing Trade [%]                          -18.856792\nAvg Winning Trade Duration              22 days 22:00:00\nAvg Losing Trade Duration     29 days 01:02:36.521739130\nProfit Factor                                   0.976634\nExpectancy                                     -0.001569\nSQN                                            -0.064929\nName: a, dtype: object\n</code></pre> <p>Positions share almost identical metrics with trades:</p> <pre><code>&gt;&gt;&gt; pf.positions['a'].stats()\nStart                            2020-01-01 00:00:00\nEnd                              2020-04-09 00:00:00\nPeriod                             100 days 00:00:00\nCoverage [%]                                   100.0\nFirst Position Start             2020-01-01 00:00:00\nLast Position End                2020-04-09 00:00:00\nTotal Records                                      3\nTotal Long Positions                               2\nTotal Short Positions                              1\nTotal Closed Positions                             2\nTotal Open Positions                               1\nOpen Position PnL                          -0.929746\nWin Rate [%]                                    50.0\nMax Win Streak                                     1\nMax Loss Streak                                    1\nBest Position [%]                          39.498421\nWorst Position [%]                          -3.32533\nAvg Winning Position [%]                   39.498421\nAvg Losing Position [%]                     -3.32533\nAvg Winning Position Duration        1 days 00:00:00\nAvg Losing Position Duration        47 days 00:00:00\nProfit Factor                               0.261748\nExpectancy                                 -0.217492\nSQN                                        -0.585103\nName: a, dtype: object\n</code></pre> <p>To also include open trades/positions when calculating metrics such as win rate, pass <code>incl_open=True</code>:</p> <pre><code>&gt;&gt;&gt; pf.trades['a'].stats(settings=dict(incl_open=True))\nStart                         2020-01-01 00:00:00\nEnd                           2020-04-09 00:00:00\nPeriod                          100 days 00:00:00\nFirst Trade Start             2020-01-01 00:00:00\nLast Trade End                2020-04-09 00:00:00\nCoverage                        100 days 00:00:00\nOverlap Coverage                 97 days 00:00:00\nTotal Records                                  48\nTotal Long Trades                              22\nTotal Short Trades                             26\nTotal Closed Trades                            47\nTotal Open Trades                               1\nOpen Trade PnL                          -1.290981\nWin Rate [%]                             51.06383\nMax Win Streak                                  3\nMax Loss Streak                                 3\nBest Trade [%]                          43.326077\nWorst Trade [%]                        -59.478304\nAvg Winning Trade [%]                   21.418522\nAvg Losing Trade [%]                   -19.117677\nAvg Winning Trade Duration       22 days 22:00:00\nAvg Losing Trade Duration        30 days 00:00:00\nProfit Factor                            0.693135\nExpectancy                              -0.028432\nSQN                                     -0.794284\nName: a, dtype: object\n</code></pre> <p>StatsBuilderMixin.stats() also supports (re-)grouping:</p> <pre><code>&gt;&gt;&gt; pf.trades.stats(group_by=True)\nStart                                2020-01-01 00:00:00\nEnd                                  2020-04-09 00:00:00\nPeriod                                 100 days 00:00:00\nFirst Trade Start                    2020-01-01 00:00:00\nLast Trade End                       2020-04-09 00:00:00\nCoverage                               100 days 00:00:00\nOverlap Coverage                       100 days 00:00:00\nTotal Records                                        104\nTotal Long Trades                                     32\nTotal Short Trades                                    72\nTotal Closed Trades                                  102\nTotal Open Trades                                      2\nOpen Trade PnL                                 -1.790938\nWin Rate [%]                                   46.078431\nMax Win Streak                                         5\nMax Loss Streak                                        5\nBest Trade [%]                                 43.326077\nWorst Trade [%]                               -87.793448\nAvg Winning Trade [%]                          19.023926\nAvg Losing Trade [%]                          -20.605892\nAvg Winning Trade Duration    24 days 08:40:51.063829787\nAvg Losing Trade Duration     25 days 11:20:43.636363636\nProfit Factor                                   0.909581\nExpectancy                                     -0.006035\nSQN                                            -0.365593\nName: group, dtype: object\n</code></pre>","title":"Stats"},{"location":"api/portfolio/trades/#plots","text":"<p>Hint</p> <p>See PlotsBuilderMixin.plots() and Trades.subplots.</p>  <p>Trades class has two subplots based on Trades.plot() and Trades.plot_pnl():</p> <pre><code>&gt;&gt;&gt; pf.trades['a'].plots(settings=dict(plot_zones=False)).show_svg()\n</code></pre> <p></p>","title":"Plots"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.entry_trades_field_config","text":"<p>Field config for EntryTrades.</p> <pre><code>Config({\n    \"settings\": {\n        \"id\": {\n            \"title\": \"Entry Trade Id\"\n        },\n        \"idx\": {\n            \"name\": \"entry_idx\"\n        }\n    }\n})\n</code></pre>","title":"entry_trades_field_config variable"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.exit_trades_field_config","text":"<p>Field config for ExitTrades.</p> <pre><code>Config({\n    \"settings\": {\n        \"id\": {\n            \"title\": \"Exit Trade Id\"\n        }\n    }\n})\n</code></pre>","title":"exit_trades_field_config variable"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.positions_field_config","text":"<p>Field config for Positions.</p> <pre><code>Config({\n    \"settings\": {\n        \"id\": {\n            \"title\": \"Position Id\"\n        },\n        \"parent_id\": {\n            \"title\": \"Parent Id\",\n            \"ignore\": true\n        }\n    }\n})\n</code></pre>","title":"positions_field_config variable"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.trades_attach_field_config","text":"<p>Config of fields to be attached to Trades.</p> <pre><code>Config({\n    \"return\": {\n        \"attach\": \"returns\"\n    },\n    \"direction\": {\n        \"attach_filters\": true\n    },\n    \"status\": {\n        \"attach_filters\": true,\n        \"on_conflict\": \"ignore\"\n    }\n})\n</code></pre>","title":"trades_attach_field_config variable"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.trades_field_config","text":"<p>Field config for Trades.</p> <pre><code>Config({\n    \"dtype\": {\n        \"id\": \"int64\",\n        \"col\": \"int64\",\n        \"size\": \"float64\",\n        \"entry_idx\": \"int64\",\n        \"entry_price\": \"float64\",\n        \"entry_fees\": \"float64\",\n        \"exit_idx\": \"int64\",\n        \"exit_price\": \"float64\",\n        \"exit_fees\": \"float64\",\n        \"pnl\": \"float64\",\n        \"return\": \"float64\",\n        \"direction\": \"int64\",\n        \"status\": \"int64\",\n        \"parent_id\": \"int64\"\n    },\n    \"settings\": {\n        \"id\": {\n            \"title\": \"Trade Id\"\n        },\n        \"idx\": {\n            \"name\": \"exit_idx\"\n        },\n        \"start_idx\": {\n            \"name\": \"entry_idx\"\n        },\n        \"end_idx\": {\n            \"name\": \"exit_idx\"\n        },\n        \"size\": {\n            \"title\": \"Size\"\n        },\n        \"entry_idx\": {\n            \"title\": \"Entry Timestamp\",\n            \"mapping\": \"index\"\n        },\n        \"entry_price\": {\n            \"title\": \"Avg Entry Price\"\n        },\n        \"entry_fees\": {\n            \"title\": \"Entry Fees\"\n        },\n        \"exit_idx\": {\n            \"title\": \"Exit Timestamp\",\n            \"mapping\": \"index\"\n        },\n        \"exit_price\": {\n            \"title\": \"Avg Exit Price\"\n        },\n        \"exit_fees\": {\n            \"title\": \"Exit Fees\"\n        },\n        \"pnl\": {\n            \"title\": \"PnL\"\n        },\n        \"return\": {\n            \"title\": \"Return\"\n        },\n        \"direction\": {\n            \"title\": \"Direction\",\n            \"mapping\": {\n                \"Long\": 0,\n                \"Short\": 1\n            }\n        },\n        \"status\": {\n            \"title\": \"Status\",\n            \"mapping\": {\n                \"Open\": 0,\n                \"Closed\": 1\n            }\n        },\n        \"parent_id\": {\n            \"title\": \"Position Id\"\n        }\n    }\n})\n</code></pre>","title":"trades_field_config variable"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.EntryTrades","text":"<pre><code>EntryTrades(\n    wrapper,\n    records_arr,\n    close,\n    **kwargs\n)\n</code></pre> <p>Extends Trades for working with entry trade records.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>Ranges</li> <li>Records</li> <li>RecordsWithFields</li> <li>StatsBuilderMixin</li> <li>Trades</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>Ranges.avg_duration()</li> <li>Ranges.coverage()</li> <li>Ranges.max_duration()</li> <li>Ranges.to_mask()</li> <li>Records.apply()</li> <li>Records.apply_mask()</li> <li>Records.build_field_config_doc()</li> <li>Records.count()</li> <li>Records.get_apply_mapping_arr()</li> <li>Records.get_by_col_idxs()</li> <li>Records.get_field_arr()</li> <li>Records.get_field_mapping()</li> <li>Records.get_field_name()</li> <li>Records.get_field_setting()</li> <li>Records.get_field_title()</li> <li>Records.get_map_field()</li> <li>Records.get_map_field_to_index()</li> <li>Records.indexing_func_meta()</li> <li>Records.is_sorted()</li> <li>Records.map()</li> <li>Records.map_array()</li> <li>Records.map_field()</li> <li>Records.override_field_config_doc()</li> <li>Records.replace()</li> <li>Records.sort()</li> <li>RecordsWithFields.field_config</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Trades.close</li> <li>Trades.closed</li> <li>Trades.col</li> <li>Trades.col_arr</li> <li>Trades.col_mapper</li> <li>Trades.config</li> <li>Trades.direction</li> <li>Trades.duration</li> <li>Trades.end_idx</li> <li>Trades.entry_fees</li> <li>Trades.entry_idx</li> <li>Trades.entry_price</li> <li>Trades.exit_fees</li> <li>Trades.exit_idx</li> <li>Trades.exit_price</li> <li>Trades.expectancy()</li> <li>Trades.from_ts()</li> <li>Trades.id</li> <li>Trades.id_arr</li> <li>Trades.idx_arr</li> <li>Trades.iloc</li> <li>Trades.indexing_func()</li> <li>Trades.indexing_kwargs</li> <li>Trades.loc</li> <li>Trades.long</li> <li>Trades.losing</li> <li>Trades.losing_streak</li> <li>Trades.open</li> <li>Trades.parent_id</li> <li>Trades.plot()</li> <li>Trades.plot_pnl()</li> <li>Trades.plots_defaults</li> <li>Trades.pnl</li> <li>Trades.profit_factor()</li> <li>Trades.records</li> <li>Trades.records_arr</li> <li>Trades.records_readable</li> <li>Trades.returns</li> <li>Trades.self_aliases</li> <li>Trades.short</li> <li>Trades.size</li> <li>Trades.sqn()</li> <li>Trades.start_idx</li> <li>Trades.stats_defaults</li> <li>Trades.status</li> <li>Trades.ts</li> <li>Trades.values</li> <li>Trades.win_rate()</li> <li>Trades.winning</li> <li>Trades.winning_streak</li> <li>Trades.wrapper</li> <li>Trades.writeable_attrs</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul>","title":"EntryTrades class"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.EntryTrades.from_orders","text":"<pre><code>EntryTrades.from_orders(\n    orders,\n    close=None,\n    attach_close=True,\n    **kwargs\n)\n</code></pre> <p>Build EntryTrades from Orders.</p>","title":"from_orders class method"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.ExitTrades","text":"<pre><code>ExitTrades(\n    wrapper,\n    records_arr,\n    close,\n    **kwargs\n)\n</code></pre> <p>Extends Trades for working with exit trade records.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>Ranges</li> <li>Records</li> <li>RecordsWithFields</li> <li>StatsBuilderMixin</li> <li>Trades</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>Ranges.avg_duration()</li> <li>Ranges.coverage()</li> <li>Ranges.max_duration()</li> <li>Ranges.to_mask()</li> <li>Records.apply()</li> <li>Records.apply_mask()</li> <li>Records.build_field_config_doc()</li> <li>Records.count()</li> <li>Records.get_apply_mapping_arr()</li> <li>Records.get_by_col_idxs()</li> <li>Records.get_field_arr()</li> <li>Records.get_field_mapping()</li> <li>Records.get_field_name()</li> <li>Records.get_field_setting()</li> <li>Records.get_field_title()</li> <li>Records.get_map_field()</li> <li>Records.get_map_field_to_index()</li> <li>Records.indexing_func_meta()</li> <li>Records.is_sorted()</li> <li>Records.map()</li> <li>Records.map_array()</li> <li>Records.map_field()</li> <li>Records.override_field_config_doc()</li> <li>Records.replace()</li> <li>Records.sort()</li> <li>RecordsWithFields.field_config</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Trades.close</li> <li>Trades.closed</li> <li>Trades.col</li> <li>Trades.col_arr</li> <li>Trades.col_mapper</li> <li>Trades.config</li> <li>Trades.direction</li> <li>Trades.duration</li> <li>Trades.end_idx</li> <li>Trades.entry_fees</li> <li>Trades.entry_idx</li> <li>Trades.entry_price</li> <li>Trades.exit_fees</li> <li>Trades.exit_idx</li> <li>Trades.exit_price</li> <li>Trades.expectancy()</li> <li>Trades.from_ts()</li> <li>Trades.id</li> <li>Trades.id_arr</li> <li>Trades.idx_arr</li> <li>Trades.iloc</li> <li>Trades.indexing_func()</li> <li>Trades.indexing_kwargs</li> <li>Trades.loc</li> <li>Trades.long</li> <li>Trades.losing</li> <li>Trades.losing_streak</li> <li>Trades.open</li> <li>Trades.parent_id</li> <li>Trades.plot()</li> <li>Trades.plot_pnl()</li> <li>Trades.plots_defaults</li> <li>Trades.pnl</li> <li>Trades.profit_factor()</li> <li>Trades.records</li> <li>Trades.records_arr</li> <li>Trades.records_readable</li> <li>Trades.returns</li> <li>Trades.self_aliases</li> <li>Trades.short</li> <li>Trades.size</li> <li>Trades.sqn()</li> <li>Trades.start_idx</li> <li>Trades.stats_defaults</li> <li>Trades.status</li> <li>Trades.ts</li> <li>Trades.values</li> <li>Trades.win_rate()</li> <li>Trades.winning</li> <li>Trades.winning_streak</li> <li>Trades.wrapper</li> <li>Trades.writeable_attrs</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul>","title":"ExitTrades class"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.ExitTrades.from_orders","text":"<pre><code>ExitTrades.from_orders(\n    orders,\n    close=None,\n    attach_close=True,\n    **kwargs\n)\n</code></pre> <p>Build ExitTrades from Orders.</p>","title":"from_orders class method"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Positions","text":"<pre><code>Positions(\n    wrapper,\n    records_arr,\n    close,\n    **kwargs\n)\n</code></pre> <p>Extends Trades for working with position records.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>Ranges</li> <li>Records</li> <li>RecordsWithFields</li> <li>StatsBuilderMixin</li> <li>Trades</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>Ranges.avg_duration()</li> <li>Ranges.coverage()</li> <li>Ranges.max_duration()</li> <li>Ranges.to_mask()</li> <li>Records.apply()</li> <li>Records.apply_mask()</li> <li>Records.build_field_config_doc()</li> <li>Records.count()</li> <li>Records.get_apply_mapping_arr()</li> <li>Records.get_by_col_idxs()</li> <li>Records.get_field_arr()</li> <li>Records.get_field_mapping()</li> <li>Records.get_field_name()</li> <li>Records.get_field_setting()</li> <li>Records.get_field_title()</li> <li>Records.get_map_field()</li> <li>Records.get_map_field_to_index()</li> <li>Records.indexing_func_meta()</li> <li>Records.is_sorted()</li> <li>Records.map()</li> <li>Records.map_array()</li> <li>Records.map_field()</li> <li>Records.override_field_config_doc()</li> <li>Records.replace()</li> <li>Records.sort()</li> <li>RecordsWithFields.field_config</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Trades.close</li> <li>Trades.closed</li> <li>Trades.col</li> <li>Trades.col_arr</li> <li>Trades.col_mapper</li> <li>Trades.config</li> <li>Trades.direction</li> <li>Trades.duration</li> <li>Trades.end_idx</li> <li>Trades.entry_fees</li> <li>Trades.entry_idx</li> <li>Trades.entry_price</li> <li>Trades.exit_fees</li> <li>Trades.exit_idx</li> <li>Trades.exit_price</li> <li>Trades.expectancy()</li> <li>Trades.from_ts()</li> <li>Trades.id</li> <li>Trades.id_arr</li> <li>Trades.idx_arr</li> <li>Trades.iloc</li> <li>Trades.indexing_func()</li> <li>Trades.indexing_kwargs</li> <li>Trades.loc</li> <li>Trades.long</li> <li>Trades.losing</li> <li>Trades.losing_streak</li> <li>Trades.open</li> <li>Trades.parent_id</li> <li>Trades.plot()</li> <li>Trades.plot_pnl()</li> <li>Trades.plots_defaults</li> <li>Trades.pnl</li> <li>Trades.profit_factor()</li> <li>Trades.records</li> <li>Trades.records_arr</li> <li>Trades.records_readable</li> <li>Trades.returns</li> <li>Trades.self_aliases</li> <li>Trades.short</li> <li>Trades.size</li> <li>Trades.sqn()</li> <li>Trades.start_idx</li> <li>Trades.stats_defaults</li> <li>Trades.status</li> <li>Trades.ts</li> <li>Trades.values</li> <li>Trades.win_rate()</li> <li>Trades.winning</li> <li>Trades.winning_streak</li> <li>Trades.wrapper</li> <li>Trades.writeable_attrs</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul>","title":"Positions class"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Positions.from_trades","text":"<pre><code>Positions.from_trades(\n    trades,\n    close=None,\n    attach_close=True,\n    **kwargs\n)\n</code></pre> <p>Build Positions from Trades.</p>","title":"from_trades class method"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Trades","text":"<pre><code>Trades(\n    wrapper,\n    records_arr,\n    close,\n    **kwargs\n)\n</code></pre> <p>Extends Ranges for working with trade-like records, such as entry trades, exit trades, and positions.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>Ranges</li> <li>Records</li> <li>RecordsWithFields</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>Ranges.avg_duration()</li> <li>Ranges.closed</li> <li>Ranges.col</li> <li>Ranges.col_arr</li> <li>Ranges.col_mapper</li> <li>Ranges.config</li> <li>Ranges.coverage()</li> <li>Ranges.duration</li> <li>Ranges.end_idx</li> <li>Ranges.from_ts()</li> <li>Ranges.id</li> <li>Ranges.id_arr</li> <li>Ranges.idx_arr</li> <li>Ranges.iloc</li> <li>Ranges.indexing_kwargs</li> <li>Ranges.loc</li> <li>Ranges.max_duration()</li> <li>Ranges.open</li> <li>Ranges.records</li> <li>Ranges.records_arr</li> <li>Ranges.records_readable</li> <li>Ranges.self_aliases</li> <li>Ranges.start_idx</li> <li>Ranges.status</li> <li>Ranges.to_mask()</li> <li>Ranges.ts</li> <li>Ranges.values</li> <li>Ranges.wrapper</li> <li>Ranges.writeable_attrs</li> <li>Records.apply()</li> <li>Records.apply_mask()</li> <li>Records.build_field_config_doc()</li> <li>Records.count()</li> <li>Records.get_apply_mapping_arr()</li> <li>Records.get_by_col_idxs()</li> <li>Records.get_field_arr()</li> <li>Records.get_field_mapping()</li> <li>Records.get_field_name()</li> <li>Records.get_field_setting()</li> <li>Records.get_field_title()</li> <li>Records.get_map_field()</li> <li>Records.get_map_field_to_index()</li> <li>Records.indexing_func_meta()</li> <li>Records.is_sorted()</li> <li>Records.map()</li> <li>Records.map_array()</li> <li>Records.map_field()</li> <li>Records.override_field_config_doc()</li> <li>Records.replace()</li> <li>Records.sort()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li>EntryTrades</li> <li>ExitTrades</li> <li>Positions</li> </ul>","title":"Trades class"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Trades.field_config","text":"<p>Field config of Trades.</p> <pre><code>Config({\n    \"dtype\": {\n        \"id\": \"int64\",\n        \"col\": \"int64\",\n        \"size\": \"float64\",\n        \"entry_idx\": \"int64\",\n        \"entry_price\": \"float64\",\n        \"entry_fees\": \"float64\",\n        \"exit_idx\": \"int64\",\n        \"exit_price\": \"float64\",\n        \"exit_fees\": \"float64\",\n        \"pnl\": \"float64\",\n        \"return\": \"float64\",\n        \"direction\": \"int64\",\n        \"status\": \"int64\",\n        \"parent_id\": \"int64\"\n    },\n    \"settings\": {\n        \"id\": {\n            \"name\": \"id\",\n            \"title\": \"Trade Id\"\n        },\n        \"col\": {\n            \"name\": \"col\",\n            \"title\": \"Column\",\n            \"mapping\": \"columns\"\n        },\n        \"idx\": {\n            \"name\": \"exit_idx\",\n            \"title\": \"Timestamp\",\n            \"mapping\": \"index\"\n        },\n        \"start_idx\": {\n            \"title\": \"Start Timestamp\",\n            \"mapping\": \"index\",\n            \"name\": \"entry_idx\"\n        },\n        \"end_idx\": {\n            \"title\": \"End Timestamp\",\n            \"mapping\": \"index\",\n            \"name\": \"exit_idx\"\n        },\n        \"status\": {\n            \"title\": \"Status\",\n            \"mapping\": {\n                \"Open\": 0,\n                \"Closed\": 1\n            }\n        },\n        \"size\": {\n            \"title\": \"Size\"\n        },\n        \"entry_idx\": {\n            \"title\": \"Entry Timestamp\",\n            \"mapping\": \"index\"\n        },\n        \"entry_price\": {\n            \"title\": \"Avg Entry Price\"\n        },\n        \"entry_fees\": {\n            \"title\": \"Entry Fees\"\n        },\n        \"exit_idx\": {\n            \"title\": \"Exit Timestamp\",\n            \"mapping\": \"index\"\n        },\n        \"exit_price\": {\n            \"title\": \"Avg Exit Price\"\n        },\n        \"exit_fees\": {\n            \"title\": \"Exit Fees\"\n        },\n        \"pnl\": {\n            \"title\": \"PnL\"\n        },\n        \"return\": {\n            \"title\": \"Return\"\n        },\n        \"direction\": {\n            \"title\": \"Direction\",\n            \"mapping\": {\n                \"Long\": 0,\n                \"Short\": 1\n            }\n        },\n        \"parent_id\": {\n            \"title\": \"Position Id\"\n        }\n    }\n})\n</code></pre>","title":"field_config class variable"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Trades.metrics","text":"<p>Metrics supported by Trades.</p> <pre><code>Config({\n    \"start\": {\n        \"title\": \"Start\",\n        \"calc_func\": \"&lt;function Trades.&lt;lambda&gt; at 0x7ff5215511e0&gt;\",\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"end\": {\n        \"title\": \"End\",\n        \"calc_func\": \"&lt;function Trades.&lt;lambda&gt; at 0x7ff521551268&gt;\",\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"period\": {\n        \"title\": \"Period\",\n        \"calc_func\": \"&lt;function Trades.&lt;lambda&gt; at 0x7ff5215512f0&gt;\",\n        \"apply_to_timedelta\": true,\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"first_trade_start\": {\n        \"title\": \"First Trade Start\",\n        \"calc_func\": \"entry_idx.nth\",\n        \"n\": 0,\n        \"wrap_kwargs\": {\n            \"to_index\": true\n        },\n        \"tags\": [\n            \"trades\",\n            \"index\"\n        ]\n    },\n    \"last_trade_end\": {\n        \"title\": \"Last Trade End\",\n        \"calc_func\": \"exit_idx.nth\",\n        \"n\": -1,\n        \"wrap_kwargs\": {\n            \"to_index\": true\n        },\n        \"tags\": [\n            \"trades\",\n            \"index\"\n        ]\n    },\n    \"coverage\": {\n        \"title\": \"Coverage\",\n        \"calc_func\": \"coverage\",\n        \"overlapping\": false,\n        \"normalize\": false,\n        \"apply_to_timedelta\": true,\n        \"tags\": [\n            \"ranges\",\n            \"coverage\"\n        ]\n    },\n    \"overlap_coverage\": {\n        \"title\": \"Overlap Coverage\",\n        \"calc_func\": \"coverage\",\n        \"overlapping\": true,\n        \"normalize\": false,\n        \"apply_to_timedelta\": true,\n        \"tags\": [\n            \"ranges\",\n            \"coverage\"\n        ]\n    },\n    \"total_records\": {\n        \"title\": \"Total Records\",\n        \"calc_func\": \"count\",\n        \"tags\": \"records\"\n    },\n    \"total_long_trades\": {\n        \"title\": \"Total Long Trades\",\n        \"calc_func\": \"long.count\",\n        \"tags\": [\n            \"trades\",\n            \"long\"\n        ]\n    },\n    \"total_short_trades\": {\n        \"title\": \"Total Short Trades\",\n        \"calc_func\": \"short.count\",\n        \"tags\": [\n            \"trades\",\n            \"short\"\n        ]\n    },\n    \"total_closed_trades\": {\n        \"title\": \"Total Closed Trades\",\n        \"calc_func\": \"closed.count\",\n        \"tags\": [\n            \"trades\",\n            \"closed\"\n        ]\n    },\n    \"total_open_trades\": {\n        \"title\": \"Total Open Trades\",\n        \"calc_func\": \"open.count\",\n        \"tags\": [\n            \"trades\",\n            \"open\"\n        ]\n    },\n    \"open_trade_pnl\": {\n        \"title\": \"Open Trade PnL\",\n        \"calc_func\": \"open.pnl.sum\",\n        \"tags\": [\n            \"trades\",\n            \"open\"\n        ]\n    },\n    \"win_rate\": {\n        \"title\": \"Win Rate [%]\",\n        \"calc_func\": \"closed.win_rate\",\n        \"post_calc_func\": \"&lt;function Trades.&lt;lambda&gt; at 0x7ff521551378&gt;\",\n        \"tags\": \"RepEval(expression=\\\"['trades', *incl_open_tags]\\\", mapping={})\"\n    },\n    \"winning_streak\": {\n        \"title\": \"Max Win Streak\",\n        \"calc_func\": \"RepEval(expression=\\\"'winning_streak.max' if incl_open else 'closed.winning_streak.max'\\\", mapping={})\",\n        \"wrap_kwargs\": {\n            \"dtype\": \"Int64\"\n        },\n        \"tags\": \"RepEval(expression=\\\"['trades', *incl_open_tags, 'streak']\\\", mapping={})\"\n    },\n    \"losing_streak\": {\n        \"title\": \"Max Loss Streak\",\n        \"calc_func\": \"RepEval(expression=\\\"'losing_streak.max' if incl_open else 'closed.losing_streak.max'\\\", mapping={})\",\n        \"wrap_kwargs\": {\n            \"dtype\": \"Int64\"\n        },\n        \"tags\": \"RepEval(expression=\\\"['trades', *incl_open_tags, 'streak']\\\", mapping={})\"\n    },\n    \"best_trade\": {\n        \"title\": \"Best Trade [%]\",\n        \"calc_func\": \"RepEval(expression=\\\"'returns.max' if incl_open else 'closed.returns.max'\\\", mapping={})\",\n        \"post_calc_func\": \"&lt;function Trades.&lt;lambda&gt; at 0x7ff521551400&gt;\",\n        \"tags\": \"RepEval(expression=\\\"['trades', *incl_open_tags]\\\", mapping={})\"\n    },\n    \"worst_trade\": {\n        \"title\": \"Worst Trade [%]\",\n        \"calc_func\": \"RepEval(expression=\\\"'returns.min' if incl_open else 'closed.returns.min'\\\", mapping={})\",\n        \"post_calc_func\": \"&lt;function Trades.&lt;lambda&gt; at 0x7ff521551488&gt;\",\n        \"tags\": \"RepEval(expression=\\\"['trades', *incl_open_tags]\\\", mapping={})\"\n    },\n    \"avg_winning_trade\": {\n        \"title\": \"Avg Winning Trade [%]\",\n        \"calc_func\": \"RepEval(expression=\\\"'winning.returns.mean' if incl_open else 'closed.winning.returns.mean'\\\", mapping={})\",\n        \"post_calc_func\": \"&lt;function Trades.&lt;lambda&gt; at 0x7ff521551510&gt;\",\n        \"tags\": \"RepEval(expression=\\\"['trades', *incl_open_tags, 'winning']\\\", mapping={})\"\n    },\n    \"avg_losing_trade\": {\n        \"title\": \"Avg Losing Trade [%]\",\n        \"calc_func\": \"RepEval(expression=\\\"'losing.returns.mean' if incl_open else 'closed.losing.returns.mean'\\\", mapping={})\",\n        \"post_calc_func\": \"&lt;function Trades.&lt;lambda&gt; at 0x7ff521551598&gt;\",\n        \"tags\": \"RepEval(expression=\\\"['trades', *incl_open_tags, 'losing']\\\", mapping={})\"\n    },\n    \"avg_winning_trade_duration\": {\n        \"title\": \"Avg Winning Trade Duration\",\n        \"calc_func\": \"RepEval(expression=\\\"'winning.avg_duration' if incl_open else 'closed.winning.avg_duration'\\\", mapping={})\",\n        \"fill_wrap_kwargs\": true,\n        \"tags\": \"RepEval(expression=\\\"['trades', *incl_open_tags, 'winning', 'duration']\\\", mapping={})\"\n    },\n    \"avg_losing_trade_duration\": {\n        \"title\": \"Avg Losing Trade Duration\",\n        \"calc_func\": \"RepEval(expression=\\\"'losing.avg_duration' if incl_open else 'closed.losing.avg_duration'\\\", mapping={})\",\n        \"fill_wrap_kwargs\": true,\n        \"tags\": \"RepEval(expression=\\\"['trades', *incl_open_tags, 'losing', 'duration']\\\", mapping={})\"\n    },\n    \"profit_factor\": {\n        \"title\": \"Profit Factor\",\n        \"calc_func\": \"RepEval(expression=\\\"'profit_factor' if incl_open else 'closed.profit_factor'\\\", mapping={})\",\n        \"tags\": \"RepEval(expression=\\\"['trades', *incl_open_tags]\\\", mapping={})\"\n    },\n    \"expectancy\": {\n        \"title\": \"Expectancy\",\n        \"calc_func\": \"RepEval(expression=\\\"'expectancy' if incl_open else 'closed.expectancy'\\\", mapping={})\",\n        \"tags\": \"RepEval(expression=\\\"['trades', *incl_open_tags]\\\", mapping={})\"\n    },\n    \"sqn\": {\n        \"title\": \"SQN\",\n        \"calc_func\": \"RepEval(expression=\\\"'sqn' if incl_open else 'closed.sqn'\\\", mapping={})\",\n        \"tags\": \"RepEval(expression=\\\"['trades', *incl_open_tags]\\\", mapping={})\"\n    }\n})\n</code></pre> <p>Returns <code>Trades._metrics</code>, which gets (deep) copied upon creation of each instance. Thus, changing this config won't affect the class.</p> <p>To change metrics, you can either change the config in-place, override this property, or overwrite the instance variable <code>Trades._metrics</code>.</p>","title":"metrics class variable"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Trades.subplots","text":"<p>Subplots supported by Trades.</p> <pre><code>Config({\n    \"plot\": {\n        \"title\": \"Trades\",\n        \"yaxis_kwargs\": {\n            \"title\": \"Price\"\n        },\n        \"check_is_not_grouped\": true,\n        \"plot_func\": \"plot\",\n        \"tags\": \"trades\"\n    },\n    \"plot_pnl\": {\n        \"title\": \"Trade PnL\",\n        \"yaxis_kwargs\": {\n            \"title\": \"Trade PnL\"\n        },\n        \"check_is_not_grouped\": true,\n        \"plot_func\": \"plot_pnl\",\n        \"tags\": \"trades\"\n    }\n})\n</code></pre> <p>Returns <code>Trades._subplots</code>, which gets (deep) copied upon creation of each instance. Thus, changing this config won't affect the class.</p> <p>To change subplots, you can either change the config in-place, override this property, or overwrite the instance variable <code>Trades._subplots</code>.</p>","title":"subplots class variable"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Trades.close","text":"<p>Reference price such as close (optional).</p>","title":"close property"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Trades.direction","text":"<p>Mapped array of the field <code>direction</code>.</p>","title":"direction variable"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Trades.entry_fees","text":"<p>Mapped array of the field <code>entry_fees</code>.</p>","title":"entry_fees variable"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Trades.entry_idx","text":"<p>Mapped array of the field <code>entry_idx</code>.</p>","title":"entry_idx variable"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Trades.entry_price","text":"<p>Mapped array of the field <code>entry_price</code>.</p>","title":"entry_price variable"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Trades.exit_fees","text":"<p>Mapped array of the field <code>exit_fees</code>.</p>","title":"exit_fees variable"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Trades.exit_idx","text":"<p>Mapped array of the field <code>exit_idx</code>.</p>","title":"exit_idx variable"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Trades.exit_price","text":"<p>Mapped array of the field <code>exit_price</code>.</p>","title":"exit_price variable"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Trades.long","text":"<p>Records filtered by <code>direction == 0</code>.</p>","title":"long variable"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Trades.losing","text":"<p>Losing trades.</p>","title":"losing variable"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Trades.losing_streak","text":"<p>Losing streak at each trade in the current column.</p> <p>See trade_losing_streak_nb().</p>","title":"losing_streak variable"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Trades.parent_id","text":"<p>Mapped array of the field <code>parent_id</code>.</p>","title":"parent_id variable"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Trades.plots_defaults","text":"<p>Defaults for PlotsBuilderMixin.plots().</p> <p>Merges Ranges.plots_defaults and <code>trades.plots</code> from settings.</p>","title":"plots_defaults property"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Trades.pnl","text":"<p>Mapped array of the field <code>pnl</code>.</p>","title":"pnl variable"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Trades.returns","text":"<p>Mapped array of the field <code>return</code>.</p>","title":"returns variable"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Trades.short","text":"<p>Records filtered by <code>direction == 1</code>.</p>","title":"short variable"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Trades.size","text":"<p>Mapped array of the field <code>size</code>.</p>","title":"size variable"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Trades.stats_defaults","text":"<p>Defaults for StatsBuilderMixin.stats().</p> <p>Merges Ranges.stats_defaults and <code>trades.stats</code> from settings.</p>","title":"stats_defaults property"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Trades.winning","text":"<p>Winning trades.</p>","title":"winning variable"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Trades.winning_streak","text":"<p>Winning streak at each trade in the current column.</p> <p>See trade_winning_streak_nb().</p>","title":"winning_streak variable"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Trades.expectancy","text":"<pre><code>Trades.expectancy(\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Average profitability.</p>","title":"expectancy method"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Trades.indexing_func","text":"<pre><code>Trades.indexing_func(\n    pd_indexing_func,\n    **kwargs\n)\n</code></pre> <p>Perform indexing on Trades.</p>","title":"indexing_func method"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Trades.plot","text":"<pre><code>Trades.plot(\n    column=None,\n    plot_zones=True,\n    close_trace_kwargs=None,\n    entry_trace_kwargs=None,\n    exit_trace_kwargs=None,\n    exit_profit_trace_kwargs=None,\n    exit_loss_trace_kwargs=None,\n    active_trace_kwargs=None,\n    profit_shape_kwargs=None,\n    loss_shape_kwargs=None,\n    add_trace_kwargs=None,\n    xref='x',\n    yref='y',\n    fig=None,\n    **layout_kwargs\n)\n</code></pre> <p>Plot orders.</p> <p>Args</p>  <code>column</code> :\u2002<code>str</code> Name of the column to plot. <code>plot_zones</code> :\u2002<code>bool</code>  <p>Whether to plot zones.</p> <p>Set to False if there are many trades within one position.</p>  <code>close_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for Trades.close. <code>entry_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for \"Entry\" markers. <code>exit_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for \"Exit\" markers. <code>exit_profit_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for \"Exit - Profit\" markers. <code>exit_loss_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for \"Exit - Loss\" markers. <code>active_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for \"Active\" markers. <code>profit_shape_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for profit zones. <code>loss_shape_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for loss zones. <code>add_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>add_trace</code>. <code>xref</code> :\u2002<code>str</code> X coordinate axis. <code>yref</code> :\u2002<code>str</code> Y coordinate axis. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**layout_kwargs</code> Keyword arguments for layout.  <p>Usage</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from datetime import datetime, timedelta\n&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; price = pd.Series([1., 2., 3., 4., 3., 2., 1.], name='Price')\n&gt;&gt;&gt; price.index = [datetime(2020, 1, 1) + timedelta(days=i) for i in range(len(price))]\n&gt;&gt;&gt; orders = pd.Series([1., -0.5, -0.5, 2., -0.5, -0.5, -0.5])\n&gt;&gt;&gt; pf = vbt.Portfolio.from_orders(price, orders)\n&gt;&gt;&gt; pf.trades.plot()\n</code></pre> <p></p>","title":"plot method"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Trades.plot_pnl","text":"<pre><code>Trades.plot_pnl(\n    column=None,\n    pct_scale=True,\n    marker_size_range=(7, 14),\n    opacity_range=(0.75, 0.9),\n    closed_profit_trace_kwargs=None,\n    closed_loss_trace_kwargs=None,\n    open_trace_kwargs=None,\n    hline_shape_kwargs=None,\n    add_trace_kwargs=None,\n    xref='x',\n    yref='y',\n    fig=None,\n    **layout_kwargs\n)\n</code></pre> <p>Plot trade PnL and returns.</p> <p>Args</p>  <code>column</code> :\u2002<code>str</code> Name of the column to plot. <code>pct_scale</code> :\u2002<code>bool</code> Whether to set y-axis to Trades.returns, otherwise to Trades.pnl. <code>marker_size_range</code> :\u2002<code>tuple</code> Range of marker size. <code>opacity_range</code> :\u2002<code>tuple</code> Range of marker opacity. <code>closed_profit_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for \"Closed - Profit\" markers. <code>closed_loss_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for \"Closed - Loss\" markers. <code>open_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for \"Open\" markers. <code>hline_shape_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for zeroline. <code>add_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>add_trace</code>. <code>xref</code> :\u2002<code>str</code> X coordinate axis. <code>yref</code> :\u2002<code>str</code> Y coordinate axis. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**layout_kwargs</code> Keyword arguments for layout.  <p>Usage</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from datetime import datetime, timedelta\n&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; price = pd.Series([1., 2., 3., 4., 3., 2., 1.])\n&gt;&gt;&gt; price.index = [datetime(2020, 1, 1) + timedelta(days=i) for i in range(len(price))]\n&gt;&gt;&gt; orders = pd.Series([1., -0.5, -0.5, 2., -0.5, -0.5, -0.5])\n&gt;&gt;&gt; pf = vbt.Portfolio.from_orders(price, orders)\n&gt;&gt;&gt; pf.trades.plot_pnl()\n</code></pre> <p></p>","title":"plot_pnl method"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Trades.profit_factor","text":"<pre><code>Trades.profit_factor(\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Profit factor.</p>","title":"profit_factor method"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Trades.sqn","text":"<pre><code>Trades.sqn(\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>System Quality Number (SQN).</p>","title":"sqn method"},{"location":"api/portfolio/trades/#vectorbt.portfolio.trades.Trades.win_rate","text":"<pre><code>Trades.win_rate(\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Rate of winning trades.</p>","title":"win_rate method"},{"location":"api/records/","text":"<p>Modules for working with records.</p> <p>Records are the second form of data representation in vectorbt. They allow storing sparse event data such as drawdowns, orders, trades, and positions, without converting them back to the matrix form and occupying the user's memory.</p>","title":"records"},{"location":"api/records/#sub-modules","text":"<ul> <li>vectorbt.records.base</li> <li>vectorbt.records.col_mapper</li> <li>vectorbt.records.decorators</li> <li>vectorbt.records.mapped_array</li> <li>vectorbt.records.nb</li> </ul>","title":"Sub-modules"},{"location":"api/records/base/","text":"<p>Base class for working with records.</p> <p>vectorbt works with two different representations of data: matrices and records.</p> <p>A matrix, in this context, is just an array of one-dimensional arrays, each corresponding to a separate feature. The matrix itself holds only one kind of information (one attribute). For example, one can create a matrix for entry signals, with columns being different strategy configurations. But what if the matrix is huge and sparse? What if there is more information we would like to represent by each element? Creating multiple matrices would be a waste of memory.</p> <p>Records make possible representing complex, sparse information in a dense format. They are just an array of one-dimensional arrays of fixed schema. You can imagine records being a DataFrame, where each row represents a record and each column represents a specific attribute.</p> <pre><code>               a     b\n         0   1.0   5.0\nattr1 =  1   2.0   NaN\n         2   NaN   7.0\n         3   4.0   8.0\n               a     b\n         0   9.0  13.0\nattr2 =  1  10.0   NaN\n         2   NaN  15.0\n         3  12.0  16.0\n            |\n            v\n      id  col  idx  attr1  attr2\n0      0    0    0      1      9\n1      1    0    1      2     10\n2      2    0    3      4     12\n3      3    1    0      5     13\n4      4    1    1      7     15\n5      5    1    3      8     16\n</code></pre> <p>Another advantage of records is that they are not constrained by size. Multiple records can map to a single element in a matrix. For example, one can define multiple orders at the same time step, which is impossible to represent in a matrix form without using complex data types.</p> <p>Consider the following example:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from numba import njit\n&gt;&gt;&gt; from collections import namedtuple\n&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; example_dt = np.dtype([\n...     ('id', np.int_),\n...     ('col', np.int_),\n...     ('idx', np.int_),\n...     ('some_field', np.float_)\n... ])\n&gt;&gt;&gt; records_arr = np.array([\n...     (0, 0, 0, 10.),\n...     (1, 0, 1, 11.),\n...     (2, 0, 2, 12.),\n...     (3, 1, 0, 13.),\n...     (4, 1, 1, 14.),\n...     (5, 1, 2, 15.),\n...     (6, 2, 0, 16.),\n...     (7, 2, 1, 17.),\n...     (8, 2, 2, 18.)\n... ], dtype=example_dt)\n&gt;&gt;&gt; wrapper = vbt.ArrayWrapper(index=['x', 'y', 'z'],\n...     columns=['a', 'b', 'c'], ndim=2, freq='1 day')\n&gt;&gt;&gt; records = vbt.Records(wrapper, records_arr)\n</code></pre>","title":"base"},{"location":"api/records/base/#printing","text":"<p>There are two ways to print records:</p> <ul> <li>Raw dataframe that preserves field names and data types:</li> </ul> <pre><code>&gt;&gt;&gt; records.records\n   id  col  idx  some_field\n0   0    0    0        10.0\n1   1    0    1        11.0\n2   2    0    2        12.0\n3   3    1    0        13.0\n4   4    1    1        14.0\n5   5    1    2        15.0\n6   6    2    0        16.0\n7   7    2    1        17.0\n8   8    2    2        18.0\n</code></pre> <ul> <li>Readable dataframe that takes into consideration Records.field_config:</li> </ul> <pre><code>&gt;&gt;&gt; records.records_readable\n   Id Column Timestamp  some_field\n0   0      a         x        10.0\n1   1      a         y        11.0\n2   2      a         z        12.0\n3   3      b         x        13.0\n4   4      b         y        14.0\n5   5      b         z        15.0\n6   6      c         x        16.0\n7   7      c         y        17.0\n8   8      c         z        18.0\n</code></pre>","title":"Printing"},{"location":"api/records/base/#mapping","text":"<p>Records are just structured arrays with a bunch of methods and properties for processing them. Their main feature is to map the records array and to reduce it by column (similar to the MapReduce paradigm). The main advantage is that it all happens without conversion to the matrix form and wasting memory resources.</p> <p>Records can be mapped to MappedArray in several ways:</p> <ul> <li>Use Records.map_field() to map a record field:</li> </ul> <pre><code>&gt;&gt;&gt; records.map_field('some_field')\n&lt;vectorbt.records.mapped_array.MappedArray at 0x7ff49bd31a58&gt;\n\n&gt;&gt;&gt; records.map_field('some_field').values\narray([10., 11., 12., 13., 14., 15., 16., 17., 18.])\n</code></pre> <ul> <li>Use Records.map() to map records using a custom function.</li> </ul> <pre><code>&gt;&gt;&gt; @njit\n... def power_map_nb(record, pow):\n...     return record.some_field ** pow\n\n&gt;&gt;&gt; records.map(power_map_nb, 2)\n&lt;vectorbt.records.mapped_array.MappedArray at 0x7ff49c990cf8&gt;\n\n&gt;&gt;&gt; records.map(power_map_nb, 2).values\narray([100., 121., 144., 169., 196., 225., 256., 289., 324.])\n</code></pre> <ul> <li>Use Records.map_array() to convert an array to MappedArray.</li> </ul> <pre><code>&gt;&gt;&gt; records.map_array(records_arr['some_field'] ** 2)\n&lt;vectorbt.records.mapped_array.MappedArray object at 0x7fe9bccf2978&gt;\n\n&gt;&gt;&gt; records.map_array(records_arr['some_field'] ** 2).values\narray([100., 121., 144., 169., 196., 225., 256., 289., 324.])\n</code></pre> <ul> <li>Use Records.apply() to apply a function on each column/group:</li> </ul> <pre><code>&gt;&gt;&gt; @njit\n... def cumsum_apply_nb(records):\n...     return np.cumsum(records.some_field)\n\n&gt;&gt;&gt; records.apply(cumsum_apply_nb)\n&lt;vectorbt.records.mapped_array.MappedArray at 0x7ff49c990cf8&gt;\n\n&gt;&gt;&gt; records.apply(cumsum_apply_nb).values\narray([10., 21., 33., 13., 27., 42., 16., 33., 51.])\n\n&gt;&gt;&gt; group_by = np.array(['first', 'first', 'second'])\n&gt;&gt;&gt; records.apply(cumsum_apply_nb, group_by=group_by, apply_per_group=True).values\narray([10., 21., 33., 46., 60., 75., 16., 33., 51.])\n</code></pre> <p>Notice how cumsum resets at each column in the first example and at each group in the second example.</p>","title":"Mapping"},{"location":"api/records/base/#filtering","text":"<p>Use Records.apply_mask() to filter elements per column/group:</p> <pre><code>&gt;&gt;&gt; mask = [True, False, True, False, True, False, True, False, True]\n&gt;&gt;&gt; filtered_records = records.apply_mask(mask)\n&gt;&gt;&gt; filtered_records.count()\na    2\nb    1\nc    2\ndtype: int64\n\n&gt;&gt;&gt; filtered_records.values['id']\narray([0, 2, 4, 6, 8])\n</code></pre>","title":"Filtering"},{"location":"api/records/base/#grouping","text":"<p>One of the key features of Records is that you can perform reducing operations on a group of columns as if they were a single column. Groups can be specified by <code>group_by</code>, which can be anything from positions or names of column levels, to a NumPy array with actual groups.</p> <p>There are multiple ways of define grouping:</p> <ul> <li>When creating Records, pass <code>group_by</code> to ArrayWrapper:</li> </ul> <pre><code>&gt;&gt;&gt; group_by = np.array(['first', 'first', 'second'])\n&gt;&gt;&gt; grouped_wrapper = wrapper.replace(group_by=group_by)\n&gt;&gt;&gt; grouped_records = vbt.Records(grouped_wrapper, records_arr)\n\n&gt;&gt;&gt; grouped_records.map_field('some_field').mean()\nfirst     12.5\nsecond    17.0\ndtype: float64\n</code></pre> <ul> <li>Regroup an existing Records:</li> </ul> <pre><code>&gt;&gt;&gt; records.regroup(group_by).map_field('some_field').mean()\nfirst     12.5\nsecond    17.0\ndtype: float64\n</code></pre> <ul> <li>Pass <code>group_by</code> directly to the mapping method:</li> </ul> <pre><code>&gt;&gt;&gt; records.map_field('some_field', group_by=group_by).mean()\nfirst     12.5\nsecond    17.0\ndtype: float64\n</code></pre> <ul> <li>Pass <code>group_by</code> directly to the reducing method:</li> </ul> <pre><code>&gt;&gt;&gt; records.map_field('some_field').mean(group_by=group_by)\na    11.0\nb    14.0\nc    17.0\ndtype: float64\n</code></pre>  <p>Note</p> <p>Grouping applies only to reducing operations, there is no change to the arrays.</p>","title":"Grouping"},{"location":"api/records/base/#indexing","text":"<p>Like any other class subclassing Wrapping, we can do pandas indexing on a Records instance, which forwards indexing operation to each object with columns:</p> <pre><code>&gt;&gt;&gt; records['a'].records\n   id  col  idx  some_field\n0   0    0    0        10.0\n1   1    0    1        11.0\n2   2    0    2        12.0\n\n&gt;&gt;&gt; grouped_records['first'].records\n   id  col  idx  some_field\n0   0    0    0        10.0\n1   1    0    1        11.0\n2   2    0    2        12.0\n3   3    1    0        13.0\n4   4    1    1        14.0\n5   5    1    2        15.0\n</code></pre>  <p>Note</p> <p>Changing index (time axis) is not supported. The object should be treated as a Series rather than a DataFrame; for example, use <code>some_field.iloc[0]</code> instead of <code>some_field.iloc[:, 0]</code>.</p> <p>Indexing behavior depends solely upon ArrayWrapper. For example, if <code>group_select</code> is enabled indexing will be performed on groups, otherwise on single columns.</p>","title":"Indexing"},{"location":"api/records/base/#caching","text":"<p>Records supports caching. If a method or a property requires heavy computation, it's wrapped with cached_method() and cached_property respectively. Caching can be disabled globally via <code>caching</code> in settings.</p>  <p>Note</p> <p>Because of caching, class is meant to be immutable and all properties are read-only. To change any attribute, use the <code>copy</code> method and pass the attribute as keyword argument.</p>","title":"Caching"},{"location":"api/records/base/#saving-and-loading","text":"<p>Like any other class subclassing Pickleable, we can save a Records instance to the disk with Pickleable.save() and load it with Pickleable.load().</p>","title":"Saving and loading"},{"location":"api/records/base/#stats","text":"<p>Hint</p> <p>See StatsBuilderMixin.stats() and Records.metrics.</p>  <pre><code>&gt;&gt;&gt; records.stats(column='a')\nStart                          x\nEnd                            z\nPeriod           3 days 00:00:00\nTotal Records                  3\nName: a, dtype: object\n</code></pre> <p>StatsBuilderMixin.stats() also supports (re-)grouping:</p> <pre><code>&gt;&gt;&gt; grouped_records.stats(column='first')\nStart                          x\nEnd                            z\nPeriod           3 days 00:00:00\nTotal Records                  6\nName: first, dtype: object\n</code></pre>","title":"Stats"},{"location":"api/records/base/#plots","text":"<p>Hint</p> <p>See PlotsBuilderMixin.plots() and Records.subplots.</p>  <p>This class is too generic to have any subplots, but feel free to add custom subplots to your subclass.</p>","title":"Plots"},{"location":"api/records/base/#extending","text":"<p>Records class can be extended by subclassing.</p> <p>In case some of our fields have the same meaning but different naming (such as the base field <code>idx</code>) or other properties, we can override <code>field_config</code> using override_field_config(). It will look for configs of all base classes and merge our config on top of them. This preserves any base class property that is not explicitly listed in our config.</p> <pre><code>&gt;&gt;&gt; from vectorbt.records.decorators import override_field_config\n\n&gt;&gt;&gt; my_dt = np.dtype([\n...     ('my_id', np.int_),\n...     ('my_col', np.int_),\n...     ('my_idx', np.int_)\n... ])\n\n&gt;&gt;&gt; my_fields_config = dict(\n...     dtype=my_dt,\n...     settings=dict(\n...         id=dict(name='my_id'),\n...         col=dict(name='my_col'),\n...         idx=dict(name='my_idx')\n...     )\n... )\n&gt;&gt;&gt; @override_field_config(my_fields_config)\n... class MyRecords(vbt.Records):\n...     pass\n\n&gt;&gt;&gt; records_arr = np.array([\n...     (0, 0, 0),\n...     (1, 0, 1),\n...     (2, 1, 0),\n...     (3, 1, 1)\n... ], dtype=my_dt)\n&gt;&gt;&gt; wrapper = vbt.ArrayWrapper(index=['x', 'y'],\n...     columns=['a', 'b'], ndim=2, freq='1 day')\n&gt;&gt;&gt; my_records = MyRecords(wrapper, records_arr)\n\n&gt;&gt;&gt; my_records.id_arr\narray([0, 1, 2, 3])\n\n&gt;&gt;&gt; my_records.col_arr\narray([0, 0, 1, 1])\n\n&gt;&gt;&gt; my_records.idx_arr\narray([0, 1, 0, 1])\n</code></pre> <p>Alternatively, we can override the <code>_field_config</code> class attribute.</p> <pre><code>&gt;&gt;&gt; @override_field_config\n... class MyRecords(vbt.Records):\n...     _field_config = dict(\n...         dtype=my_dt,\n...         settings=dict(\n...             id=dict(name='my_id'),\n...             idx=dict(name='my_idx'),\n...             col=dict(name='my_col')\n...         )\n...     )\n</code></pre>  <p>Note</p> <p>Don't forget to decorate the class with <code>@override_field_config</code> to inherit configs from base classes.</p> <p>You can stop inheritance by not decorating or passing <code>merge_configs=False</code> to the decorator.</p>","title":"Extending"},{"location":"api/records/base/#vectorbt.records.base.MetaFields","text":"<pre><code>MetaFields(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Meta class that exposes a read-only class property MetaFields.field_config.</p> <p>Superclasses</p> <ul> <li><code>builtins.type</code></li> </ul> <p>Subclasses</p> <ul> <li>MetaRecords</li> </ul>","title":"MetaFields class"},{"location":"api/records/base/#vectorbt.records.base.MetaFields.field_config","text":"<p>Field config.</p>","title":"field_config property"},{"location":"api/records/base/#vectorbt.records.base.MetaRecords","text":"<pre><code>MetaRecords(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Meta class that exposes a read-only class property <code>StatsBuilderMixin.metrics</code>.</p> <p>Superclasses</p> <ul> <li>MetaFields</li> <li>MetaPlotsBuilderMixin</li> <li>MetaStatsBuilderMixin</li> <li><code>builtins.type</code></li> </ul> <p>Inherited members</p> <ul> <li>MetaFields.field_config</li> <li>MetaPlotsBuilderMixin.subplots</li> <li>MetaStatsBuilderMixin.metrics</li> </ul>","title":"MetaRecords class"},{"location":"api/records/base/#vectorbt.records.base.Records","text":"<pre><code>Records(\n    wrapper,\n    records_arr,\n    col_mapper=None,\n    **kwargs\n)\n</code></pre> <p>Wraps the actual records array (such as trades) and exposes methods for mapping it to some array of values (such as PnL of each trade).</p> <p>Args</p>  <code>wrapper</code> :\u2002<code>ArrayWrapper</code>  <p>Array wrapper.</p> <p>See ArrayWrapper.</p>  <code>records_arr</code> :\u2002<code>array_like</code>  <p>A structured NumPy array of records.</p> <p>Must have the fields <code>id</code> (record index) and <code>col</code> (column index).</p>  <code>col_mapper</code> :\u2002<code>ColumnMapper</code>  <p>Column mapper if already known.</p>  <p>Note</p> <p>It depends on <code>records_arr</code>, so make sure to invalidate <code>col_mapper</code> upon creating a Records instance with a modified <code>records_arr</code>.</p> <p>Records.replace() does it automatically.</p>   <code>**kwargs</code>  <p>Custom keyword arguments passed to the config.</p> <p>Useful if any subclass wants to extend the config.</p>   <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>RecordsWithFields</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.config</li> <li>Wrapping.iloc</li> <li>Wrapping.indexing_kwargs</li> <li>Wrapping.loc</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> <li>Wrapping.self_aliases</li> <li>Wrapping.wrapper</li> <li>Wrapping.writeable_attrs</li> </ul> <p>Subclasses</p> <ul> <li>Logs</li> <li>Orders</li> <li>Ranges</li> </ul>","title":"Records class"},{"location":"api/records/base/#vectorbt.records.base.Records.field_config","text":"<p>Field config of Records.</p> <pre><code>Config({\n    \"dtype\": null,\n    \"settings\": {\n        \"id\": {\n            \"name\": \"id\",\n            \"title\": \"Id\"\n        },\n        \"col\": {\n            \"name\": \"col\",\n            \"title\": \"Column\",\n            \"mapping\": \"columns\"\n        },\n        \"idx\": {\n            \"name\": \"idx\",\n            \"title\": \"Timestamp\",\n            \"mapping\": \"index\"\n        }\n    }\n})\n</code></pre>","title":"field_config class variable"},{"location":"api/records/base/#vectorbt.records.base.Records.metrics","text":"<p>Metrics supported by Records.</p> <pre><code>Config({\n    \"start\": {\n        \"title\": \"Start\",\n        \"calc_func\": \"&lt;function Records.&lt;lambda&gt; at 0x7ff533657d90&gt;\",\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"end\": {\n        \"title\": \"End\",\n        \"calc_func\": \"&lt;function Records.&lt;lambda&gt; at 0x7ff533657e18&gt;\",\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"period\": {\n        \"title\": \"Period\",\n        \"calc_func\": \"&lt;function Records.&lt;lambda&gt; at 0x7ff533657ea0&gt;\",\n        \"apply_to_timedelta\": true,\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"count\": {\n        \"title\": \"Count\",\n        \"calc_func\": \"count\",\n        \"tags\": \"records\"\n    }\n})\n</code></pre> <p>Returns <code>Records._metrics</code>, which gets (deep) copied upon creation of each instance. Thus, changing this config won't affect the class.</p> <p>To change metrics, you can either change the config in-place, override this property, or overwrite the instance variable <code>Records._metrics</code>.</p>","title":"metrics class variable"},{"location":"api/records/base/#vectorbt.records.base.Records.subplots","text":"<p>Subplots supported by Records.</p> <pre><code>Config({})\n</code></pre> <p>Returns <code>Records._subplots</code>, which gets (deep) copied upon creation of each instance. Thus, changing this config won't affect the class.</p> <p>To change subplots, you can either change the config in-place, override this property, or overwrite the instance variable <code>Records._subplots</code>.</p>","title":"subplots class variable"},{"location":"api/records/base/#vectorbt.records.base.Records.build_field_config_doc","text":"<pre><code>Records.build_field_config_doc(\n    source_cls=None\n)\n</code></pre> <p>Build field config documentation.</p>","title":"build_field_config_doc class method"},{"location":"api/records/base/#vectorbt.records.base.Records.override_field_config_doc","text":"<pre><code>Records.override_field_config_doc(\n    __pdoc__,\n    source_cls=None\n)\n</code></pre> <p>Call this method on each subclass that overrides <code>field_config</code>.</p>","title":"override_field_config_doc class method"},{"location":"api/records/base/#vectorbt.records.base.Records.col_arr","text":"<p>Get column array.</p>","title":"col_arr property"},{"location":"api/records/base/#vectorbt.records.base.Records.col_mapper","text":"<p>Column mapper.</p> <p>See ColumnMapper.</p>","title":"col_mapper property"},{"location":"api/records/base/#vectorbt.records.base.Records.id_arr","text":"<p>Get id array.</p>","title":"id_arr property"},{"location":"api/records/base/#vectorbt.records.base.Records.idx_arr","text":"<p>Get index array.</p>","title":"idx_arr property"},{"location":"api/records/base/#vectorbt.records.base.Records.plots_defaults","text":"<p>Defaults for PlotsBuilderMixin.plots().</p> <p>Merges PlotsBuilderMixin.plots_defaults and <code>records.plots</code> from settings.</p>","title":"plots_defaults property"},{"location":"api/records/base/#vectorbt.records.base.Records.recarray","text":"","title":"recarray property"},{"location":"api/records/base/#vectorbt.records.base.Records.records","text":"<p>Records.</p>","title":"records property"},{"location":"api/records/base/#vectorbt.records.base.Records.records_arr","text":"<p>Records array.</p>","title":"records_arr property"},{"location":"api/records/base/#vectorbt.records.base.Records.records_readable","text":"<p>Records in readable format.</p>","title":"records_readable property"},{"location":"api/records/base/#vectorbt.records.base.Records.stats_defaults","text":"<p>Defaults for StatsBuilderMixin.stats().</p> <p>Merges StatsBuilderMixin.stats_defaults and <code>records.stats</code> from settings.</p>","title":"stats_defaults property"},{"location":"api/records/base/#vectorbt.records.base.Records.values","text":"<p>Records array.</p>","title":"values property"},{"location":"api/records/base/#vectorbt.records.base.Records.apply","text":"<pre><code>Records.apply(\n    apply_func_nb,\n    *args,\n    group_by=None,\n    apply_per_group=False,\n    dtype=None,\n    **kwargs\n)\n</code></pre> <p>Apply function on records per column/group. Returns mapped array.</p> <p>Applies per group if <code>apply_per_group</code> is True.</p> <p>See apply_on_records_nb().</p> <p><code>**kwargs</code> are passed to Records.map_array().</p>","title":"apply method"},{"location":"api/records/base/#vectorbt.records.base.Records.apply_mask","text":"<pre><code>Records.apply_mask(\n    mask,\n    group_by=None,\n    **kwargs\n)\n</code></pre> <p>Return a new class instance, filtered by mask.</p>","title":"apply_mask method"},{"location":"api/records/base/#vectorbt.records.base.Records.count","text":"<pre><code>Records.count(\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Return count by column.</p>","title":"count method"},{"location":"api/records/base/#vectorbt.records.base.Records.get_apply_mapping_arr","text":"<pre><code>Records.get_apply_mapping_arr(\n    field,\n    **kwargs\n)\n</code></pre> <p>Resolve the mapped array on the field, with mapping applied. Uses Records.field_config.</p>","title":"get_apply_mapping_arr method"},{"location":"api/records/base/#vectorbt.records.base.Records.get_by_col_idxs","text":"<pre><code>Records.get_by_col_idxs(\n    col_idxs\n)\n</code></pre> <p>Get records corresponding to column indices.</p> <p>Returns new records array.</p>","title":"get_by_col_idxs method"},{"location":"api/records/base/#vectorbt.records.base.Records.get_field_arr","text":"<pre><code>Records.get_field_arr(\n    field\n)\n</code></pre> <p>Resolve the array of the field. Uses Records.field_config.</p>","title":"get_field_arr method"},{"location":"api/records/base/#vectorbt.records.base.Records.get_field_mapping","text":"<pre><code>Records.get_field_mapping(\n    field\n)\n</code></pre> <p>Resolve the mapping of the field. Uses Records.field_config.</p>","title":"get_field_mapping method"},{"location":"api/records/base/#vectorbt.records.base.Records.get_field_name","text":"<pre><code>Records.get_field_name(\n    field\n)\n</code></pre> <p>Resolve the name of the field. Uses Records.field_config..</p>","title":"get_field_name method"},{"location":"api/records/base/#vectorbt.records.base.Records.get_field_setting","text":"<pre><code>Records.get_field_setting(\n    field,\n    setting,\n    default=None\n)\n</code></pre> <p>Resolve any setting of the field. Uses Records.field_config.</p>","title":"get_field_setting method"},{"location":"api/records/base/#vectorbt.records.base.Records.get_field_title","text":"<pre><code>Records.get_field_title(\n    field\n)\n</code></pre> <p>Resolve the title of the field. Uses Records.field_config.</p>","title":"get_field_title method"},{"location":"api/records/base/#vectorbt.records.base.Records.get_map_field","text":"<pre><code>Records.get_map_field(\n    field,\n    **kwargs\n)\n</code></pre> <p>Resolve the mapped array of the field. Uses Records.field_config.</p>","title":"get_map_field method"},{"location":"api/records/base/#vectorbt.records.base.Records.get_map_field_to_index","text":"<pre><code>Records.get_map_field_to_index(\n    field,\n    **kwargs\n)\n</code></pre> <p>Resolve the mapped array on the field, with index applied. Uses Records.field_config.</p>","title":"get_map_field_to_index method"},{"location":"api/records/base/#vectorbt.records.base.Records.indexing_func","text":"<pre><code>Records.indexing_func(\n    pd_indexing_func,\n    **kwargs\n)\n</code></pre> <p>Perform indexing on Records.</p>","title":"indexing_func method"},{"location":"api/records/base/#vectorbt.records.base.Records.indexing_func_meta","text":"<pre><code>Records.indexing_func_meta(\n    pd_indexing_func,\n    **kwargs\n)\n</code></pre> <p>Perform indexing on Records and return metadata.</p>","title":"indexing_func_meta method"},{"location":"api/records/base/#vectorbt.records.base.Records.is_sorted","text":"<pre><code>Records.is_sorted(\n    incl_id=False\n)\n</code></pre> <p>Check whether records are sorted.</p>","title":"is_sorted method"},{"location":"api/records/base/#vectorbt.records.base.Records.map","text":"<pre><code>Records.map(\n    map_func_nb,\n    *args,\n    dtype=None,\n    **kwargs\n)\n</code></pre> <p>Map each record to a scalar value. Returns mapped array.</p> <p>See map_records_nb().</p> <p><code>**kwargs</code> are passed to Records.map_array().</p>","title":"map method"},{"location":"api/records/base/#vectorbt.records.base.Records.map_array","text":"<pre><code>Records.map_array(\n    a,\n    idx_arr=None,\n    mapping=None,\n    group_by=None,\n    **kwargs\n)\n</code></pre> <p>Convert array to mapped array.</p> <p>The length of the array should match that of the records.</p>","title":"map_array method"},{"location":"api/records/base/#vectorbt.records.base.Records.map_field","text":"<pre><code>Records.map_field(\n    field,\n    **kwargs\n)\n</code></pre> <p>Convert field to mapped array.</p> <p><code>**kwargs</code> are passed to Records.map_array().</p>","title":"map_field method"},{"location":"api/records/base/#vectorbt.records.base.Records.replace","text":"<pre><code>Records.replace(\n    **kwargs\n)\n</code></pre> <p>See Configured.replace().</p> <p>Also, makes sure that Records.col_mapper is not passed to the new instance.</p>","title":"replace method"},{"location":"api/records/base/#vectorbt.records.base.Records.sort","text":"<pre><code>Records.sort(\n    incl_id=False,\n    group_by=None,\n    **kwargs\n)\n</code></pre> <p>Sort records by columns (primary) and ids (secondary, optional).</p>  <p>Note</p> <p>Sorting is expensive. A better approach is to append records already in the correct order.</p>","title":"sort method"},{"location":"api/records/base/#vectorbt.records.base.RecordsWithFields","text":"<pre><code>RecordsWithFields()\n</code></pre> <p>Class exposes a read-only class property RecordsWithFields.field_config.</p> <p>Subclasses</p> <ul> <li>Records</li> </ul>","title":"RecordsWithFields class"},{"location":"api/records/base/#vectorbt.records.base.RecordsWithFields.field_config","text":"<p>Field config of <code>${cls_name}</code>.</p> <pre><code>${field_config}\n</code></pre>","title":"field_config variable"},{"location":"api/records/col_mapper/","text":"<p>Class for mapping column arrays.</p>","title":"col_mapper"},{"location":"api/records/col_mapper/#vectorbt.records.col_mapper.ColumnMapper","text":"<pre><code>ColumnMapper(\n    wrapper,\n    col_arr,\n    **kwargs\n)\n</code></pre> <p>Used by Records and MappedArray classes to make use of column and group metadata.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>Wrapping.config</li> <li>Wrapping.iloc</li> <li>Wrapping.indexing_func()</li> <li>Wrapping.indexing_kwargs</li> <li>Wrapping.loc</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> <li>Wrapping.self_aliases</li> <li>Wrapping.wrapper</li> <li>Wrapping.writeable_attrs</li> </ul>","title":"ColumnMapper class"},{"location":"api/records/col_mapper/#vectorbt.records.col_mapper.ColumnMapper.col_arr","text":"<p>Column array.</p>","title":"col_arr property"},{"location":"api/records/col_mapper/#vectorbt.records.col_mapper.ColumnMapper.col_map","text":"<p>Column map.</p> <p>More flexible than ColumnMapper.col_range. More suited for mapped arrays.</p>","title":"col_map variable"},{"location":"api/records/col_mapper/#vectorbt.records.col_mapper.ColumnMapper.col_range","text":"<p>Column index.</p> <p>Faster than ColumnMapper.col_map but only compatible with sorted columns. More suited for records.</p>","title":"col_range variable"},{"location":"api/records/col_mapper/#vectorbt.records.col_mapper.ColumnMapper.get_col_arr","text":"<pre><code>ColumnMapper.get_col_arr(\n    group_by=None\n)\n</code></pre> <p>Get group-aware column array.</p>","title":"get_col_arr method"},{"location":"api/records/col_mapper/#vectorbt.records.col_mapper.ColumnMapper.get_col_map","text":"<pre><code>ColumnMapper.get_col_map(\n    group_by=None\n)\n</code></pre> <p>Get group-aware column map.</p>","title":"get_col_map method"},{"location":"api/records/col_mapper/#vectorbt.records.col_mapper.ColumnMapper.get_col_range","text":"<pre><code>ColumnMapper.get_col_range(\n    group_by=None\n)\n</code></pre> <p>Get group-aware column range.</p>","title":"get_col_range method"},{"location":"api/records/col_mapper/#vectorbt.records.col_mapper.ColumnMapper.is_sorted","text":"<pre><code>ColumnMapper.is_sorted()\n</code></pre> <p>Check whether column array is sorted.</p>","title":"is_sorted method"},{"location":"api/records/decorators/","text":"<p>Class and function decorators.</p>","title":"decorators"},{"location":"api/records/decorators/#vectorbt.records.decorators.attach_fields","text":"<pre><code>attach_fields(\n    *args,\n    on_conflict='raise'\n)\n</code></pre> <p>Class decorator to attach field properties in a Records class.</p> <p>Will extract <code>dtype</code> and other relevant information from Records.field_config and map its fields as properties. This behavior can be changed by using <code>config</code>.</p>  <p>Note</p> <p>Make sure to run attach_fields() after override_field_config().</p>  <p><code>config</code> should contain fields (keys) and dictionaries (values) with the following keys:</p> <ul> <li><code>attach</code>: Whether to attach the field property. Can be provided as a string to be used     as a target attribute name. Defaults to True.</li> <li><code>defaults</code>: Dictionary with default keyword arguments for Records.map_field().     Defaults to an empty dict.</li> <li><code>attach_filters</code>: Whether to attach filters based on the field's values. Can be provided as a dict     to be used instead of the mapping (filter value -&gt; target filter name). Defaults to False.     If True, defaults to <code>mapping</code> in Records.field_config.</li> <li><code>filter_defaults</code>: Dictionary with default keyword arguments for Records.apply_mask().     Can be provided by target filter name. Defaults to an empty dict.</li> <li><code>on_conflict</code>: Overrides global <code>on_conflict</code> for both field and filter properties.</li> </ul> <p>Any potential attribute name is prepared by placing underscores between capital letters and converting to the lower case.</p> <p>If an attribute with the same name already exists in the class but the name is not listed in the field config:</p> <ul> <li>it will be overridden if <code>on_conflict</code> is 'override'</li> <li>it will be ignored if <code>on_conflict</code> is 'ignore'</li> <li>an error will be raised if <code>on_conflict</code> is 'raise'</li> </ul>","title":"attach_fields function"},{"location":"api/records/decorators/#vectorbt.records.decorators.override_field_config","text":"<pre><code>override_field_config(\n    *args,\n    merge_configs=True\n)\n</code></pre> <p>Class decorator to override field configs of all base classes in MRO that subclass Records.</p> <p>Instead of overriding <code>_field_config</code> class attribute, you can pass <code>config</code> directly to this decorator.</p> <p>Disable <code>merge_configs</code> to not merge, which will effectively disable field inheritance.</p>","title":"override_field_config function"},{"location":"api/records/mapped_array/","text":"<p>Base class for working with mapped arrays.</p> <p>This class takes the mapped array and the corresponding column and (optionally) index arrays, and offers features to directly process the mapped array without converting it to pandas; for example, to compute various statistics by column, such as standard deviation.</p> <p>Consider the following example:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from numba import njit\n&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; a = np.array([10., 11., 12., 13., 14., 15., 16., 17., 18.])\n&gt;&gt;&gt; col_arr = np.array([0, 0, 0, 1, 1, 1, 2, 2, 2])\n&gt;&gt;&gt; idx_arr = np.array([0, 1, 2, 0, 1, 2, 0, 1, 2])\n&gt;&gt;&gt; wrapper = vbt.ArrayWrapper(index=['x', 'y', 'z'],\n...     columns=['a', 'b', 'c'], ndim=2, freq='1 day')\n&gt;&gt;&gt; ma = vbt.MappedArray(wrapper, a, col_arr, idx_arr=idx_arr)\n</code></pre>","title":"mapped_array"},{"location":"api/records/mapped_array/#reducing","text":"<p>Using MappedArray, you can then reduce by column as follows:</p> <ul> <li>Use already provided reducers such as MappedArray.mean():</li> </ul> <pre><code>&gt;&gt;&gt; ma.mean()\na    11.0\nb    14.0\nc    17.0\ndtype: float64\n</code></pre> <ul> <li>Use MappedArray.to_pd() to map to pandas and then reduce manually (expensive):</li> </ul> <pre><code>&gt;&gt;&gt; ma.to_pd().mean()\na    11.0\nb    14.0\nc    17.0\ndtype: float64\n</code></pre> <ul> <li>Use MappedArray.reduce() to reduce using a custom function:</li> </ul> <pre><code>&gt;&gt;&gt; @njit\n... def pow_mean_reduce_nb(col, a, pow):\n...     return np.mean(a ** pow)\n\n&gt;&gt;&gt; ma.reduce(pow_mean_reduce_nb, 2)\na    121.666667\nb    196.666667\nc    289.666667\ndtype: float64\n\n&gt;&gt;&gt; @njit\n... def min_max_reduce_nb(col, a):\n...     return np.array([np.min(a), np.max(a)])\n\n&gt;&gt;&gt; ma.reduce(min_max_reduce_nb, returns_array=True, index=['min', 'max'])\n        a     b     c\nmin  10.0  13.0  16.0\nmax  12.0  15.0  18.0\n\n&gt;&gt;&gt; @njit\n... def idxmin_idxmax_reduce_nb(col, a):\n...     return np.array([np.argmin(a), np.argmax(a)])\n\n&gt;&gt;&gt; ma.reduce(idxmin_idxmax_reduce_nb, returns_array=True,\n...     returns_idx=True, index=['idxmin', 'idxmax'])\n        a  b  c\nidxmin  x  x  x\nidxmax  z  z  z\n</code></pre>","title":"Reducing"},{"location":"api/records/mapped_array/#mapping","text":"<p>Use MappedArray.apply() to apply a function on each column/group:</p> <pre><code>&gt;&gt;&gt; @njit\n... def cumsum_apply_nb(idxs, col, a):\n...     return np.cumsum(a)\n\n&gt;&gt;&gt; ma.apply(cumsum_apply_nb)\n&lt;vectorbt.records.mapped_array.MappedArray at 0x7ff061382198&gt;\n\n&gt;&gt;&gt; ma.apply(cumsum_apply_nb).values\narray([10., 21., 33., 13., 27., 42., 16., 33., 51.])\n\n&gt;&gt;&gt; group_by = np.array(['first', 'first', 'second'])\n&gt;&gt;&gt; ma.apply(cumsum_apply_nb, group_by=group_by, apply_per_group=True).values\narray([10., 21., 33., 46., 60., 75., 16., 33., 51.])\n\nNotice how cumsum resets at each column in the first example and at each group in the second example.\n\n## Conversion\n\nYou can expand any `MappedArray` instance to pandas:\n\n* Given `idx_arr` was provided:\n\n```pycon\n&gt;&gt;&gt; ma.to_pd()\n      a     b     c\nx  10.0  13.0  16.0\ny  11.0  14.0  17.0\nz  12.0  15.0  18.0\n</code></pre>  <p>Note</p> <p>Will raise an error if there are multiple values pointing to the same position.</p>  <ul> <li>In case <code>group_by</code> was provided, index can be ignored, or there are position conflicts:</li> </ul> <pre><code>&gt;&gt;&gt; ma.to_pd(group_by=np.array(['first', 'first', 'second']), ignore_index=True)\n   first  second\n0   10.0    16.0\n1   11.0    17.0\n2   12.0    18.0\n3   13.0     NaN\n4   14.0     NaN\n5   15.0     NaN\n</code></pre>","title":"Mapping"},{"location":"api/records/mapped_array/#filtering","text":"<p>Use MappedArray.apply_mask() to filter elements per column/group:</p> <pre><code>&gt;&gt;&gt; mask = [True, False, True, False, True, False, True, False, True]\n&gt;&gt;&gt; filtered_ma = ma.apply_mask(mask)\n&gt;&gt;&gt; filtered_ma.count()\na    2\nb    1\nc    2\ndtype: int64\n\n&gt;&gt;&gt; filtered_ma.id_arr\narray([0, 2, 4, 6, 8])\n</code></pre>","title":"Filtering"},{"location":"api/records/mapped_array/#plotting","text":"<p>You can build histograms and boxplots of MappedArray directly:</p> <pre><code>&gt;&gt;&gt; ma.boxplot()\n</code></pre> <p></p> <p>To use scatterplots or any other plots that require index, convert to pandas first:</p> <pre><code>&gt;&gt;&gt; ma.to_pd().vbt.plot()\n</code></pre> <p></p>","title":"Plotting"},{"location":"api/records/mapped_array/#grouping","text":"<p>One of the key features of MappedArray is that you can perform reducing operations on a group of columns as if they were a single column. Groups can be specified by <code>group_by</code>, which can be anything from positions or names of column levels, to a NumPy array with actual groups.</p> <p>There are multiple ways of define grouping:</p> <ul> <li>When creating MappedArray, pass <code>group_by</code> to ArrayWrapper:</li> </ul> <pre><code>&gt;&gt;&gt; group_by = np.array(['first', 'first', 'second'])\n&gt;&gt;&gt; grouped_wrapper = wrapper.replace(group_by=group_by)\n&gt;&gt;&gt; grouped_ma = vbt.MappedArray(grouped_wrapper, a, col_arr, idx_arr=idx_arr)\n\n&gt;&gt;&gt; grouped_ma.mean()\nfirst     12.5\nsecond    17.0\ndtype: float64\n</code></pre> <ul> <li>Regroup an existing MappedArray:</li> </ul> <pre><code>&gt;&gt;&gt; ma.regroup(group_by).mean()\nfirst     12.5\nsecond    17.0\ndtype: float64\n</code></pre> <ul> <li>Pass <code>group_by</code> directly to the reducing method:</li> </ul> <pre><code>&gt;&gt;&gt; ma.mean(group_by=group_by)\nfirst     12.5\nsecond    17.0\ndtype: float64\n</code></pre> <p>By the same way you can disable or modify any existing grouping:</p> <pre><code>&gt;&gt;&gt; grouped_ma.mean(group_by=False)\na    11.0\nb    14.0\nc    17.0\ndtype: float64\n</code></pre>  <p>Note</p> <p>Grouping applies only to reducing operations, there is no change to the arrays.</p>","title":"Grouping"},{"location":"api/records/mapped_array/#operators","text":"<p>MappedArray implements arithmetic, comparison and logical operators. You can perform basic operations (such as addition) on mapped arrays as if they were NumPy arrays.</p> <pre><code>&gt;&gt;&gt; ma ** 2\n&lt;vectorbt.records.mapped_array.MappedArray at 0x7f97bfc49358&gt;\n\n&gt;&gt;&gt; ma * np.array([1, 2, 3, 4, 5, 6])\n&lt;vectorbt.records.mapped_array.MappedArray at 0x7f97bfc65e80&gt;\n\n&gt;&gt;&gt; ma + ma\n&lt;vectorbt.records.mapped_array.MappedArray at 0x7fd638004d30&gt;\n</code></pre>  <p>Note</p> <p>You should ensure that your MappedArray operand is on the left if the other operand is an array.</p> <p>If two MappedArray operands have different metadata, will copy metadata from the first one, but at least their <code>id_arr</code> and <code>col_arr</code> must match.</p>","title":"Operators"},{"location":"api/records/mapped_array/#indexing","text":"<p>Like any other class subclassing Wrapping, we can do pandas indexing on a MappedArray instance, which forwards indexing operation to each object with columns:</p> <pre><code>&gt;&gt;&gt; ma['a'].values\narray([10., 11., 12.])\n\n&gt;&gt;&gt; grouped_ma['first'].values\narray([10., 11., 12., 13., 14., 15.])\n</code></pre>  <p>Note</p> <p>Changing index (time axis) is not supported. The object should be treated as a Series rather than a DataFrame; for example, use <code>some_field.iloc[0]</code> instead of <code>some_field.iloc[:, 0]</code>.</p> <p>Indexing behavior depends solely upon ArrayWrapper. For example, if <code>group_select</code> is enabled indexing will be performed on groups, otherwise on single columns.</p>","title":"Indexing"},{"location":"api/records/mapped_array/#caching","text":"<p>MappedArray supports caching. If a method or a property requires heavy computation, it's wrapped with cached_method() and cached_property respectively. Caching can be disabled globally via <code>caching</code> in settings.</p>  <p>Note</p> <p>Because of caching, class is meant to be immutable and all properties are read-only. To change any attribute, use the <code>copy</code> method and pass the attribute as keyword argument.</p>","title":"Caching"},{"location":"api/records/mapped_array/#saving-and-loading","text":"<p>Like any other class subclassing Pickleable, we can save a MappedArray instance to the disk with Pickleable.save() and load it with Pickleable.load().</p>","title":"Saving and loading"},{"location":"api/records/mapped_array/#stats","text":"<p>Hint</p> <p>See StatsBuilderMixin.stats() and MappedArray.metrics.</p>  <p>Metric for mapped arrays are similar to that for GenericAccessor.</p> <pre><code>&gt;&gt;&gt; ma.stats(column='a')\nStart                      x\nEnd                        z\nPeriod       3 days 00:00:00\nCount                      3\nMean                    11.0\nStd                      1.0\nMin                     10.0\nMedian                  11.0\nMax                     12.0\nMin Index                  x\nMax Index                  z\nName: a, dtype: object\n</code></pre> <p>The main difference unfolds once the mapped array has a mapping: values are then considered as categorical and usual statistics are meaningless to compute. For this case, StatsBuilderMixin.stats() returns the value counts:</p> <pre><code>&gt;&gt;&gt; mapping = {v: \"test_\" + str(v) for v in np.unique(ma.values)}\n&gt;&gt;&gt; ma.stats(column='a', settings=dict(mapping=mapping))\nStart                                    x\nEnd                                      z\nPeriod                     3 days 00:00:00\nCount                                    3\nValue Counts: test_10.0                  1\nValue Counts: test_11.0                  1\nValue Counts: test_12.0                  1\nValue Counts: test_13.0                  0\nValue Counts: test_14.0                  0\nValue Counts: test_15.0                  0\nValue Counts: test_16.0                  0\nValue Counts: test_17.0                  0\nValue Counts: test_18.0                  0\nName: a, dtype: object\n\n`MappedArray.stats` also supports (re-)grouping:\n\n```pycon\n&gt;&gt;&gt; grouped_ma.stats(column='first')\nStart                      x\nEnd                        z\nPeriod       3 days 00:00:00\nCount                      6\nMean                    12.5\nStd                 1.870829\nMin                     10.0\nMedian                  12.5\nMax                     15.0\nMin Index                  x\nMax Index                  z\nName: first, dtype: object\n</code></pre>","title":"Stats"},{"location":"api/records/mapped_array/#plots","text":"<p>Hint</p> <p>See PlotsBuilderMixin.plots() and MappedArray.subplots.</p>  <p>MappedArray class has a single subplot based on MappedArray.to_pd() and GenericAccessor.plot():</p> <pre><code>&gt;&gt;&gt; ma.plots()\n</code></pre> <p></p>","title":"Plots"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.combine_mapped_with_other","text":"<pre><code>combine_mapped_with_other(\n    other,\n    np_func\n)\n</code></pre> <p>Combine MappedArray with other compatible object.</p> <p>If other object is also MappedArray, their <code>id_arr</code> and <code>col_arr</code> must match.</p>","title":"combine_mapped_with_other function"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray","text":"<pre><code>MappedArray(\n    wrapper,\n    mapped_arr,\n    col_arr,\n    id_arr=None,\n    idx_arr=None,\n    mapping=None,\n    col_mapper=None,\n    **kwargs\n)\n</code></pre> <p>Exposes methods for reducing, converting, and plotting arrays mapped by Records class.</p> <p>Args</p>  <code>wrapper</code> :\u2002<code>ArrayWrapper</code>  <p>Array wrapper.</p> <p>See ArrayWrapper.</p>  <code>mapped_arr</code> :\u2002<code>array_like</code> A one-dimensional array of mapped record values. <code>col_arr</code> :\u2002<code>array_like</code>  <p>A one-dimensional column array.</p> <p>Must be of the same size as <code>mapped_arr</code>.</p>  <code>id_arr</code> :\u2002<code>array_like</code>  <p>A one-dimensional id array. Defaults to simple range.</p> <p>Must be of the same size as <code>mapped_arr</code>.</p>  <code>idx_arr</code> :\u2002<code>array_like</code>  <p>A one-dimensional index array. Optional.</p> <p>Must be of the same size as <code>mapped_arr</code>.</p>  <code>mapping</code> :\u2002<code>namedtuple</code>, <code>dict</code> or <code>callable</code> Mapping. <code>col_mapper</code> :\u2002<code>ColumnMapper</code>  <p>Column mapper if already known.</p>  <p>Note</p> <p>It depends upon <code>wrapper</code> and <code>col_arr</code>, so make sure to invalidate <code>col_mapper</code> upon creating a MappedArray instance with a modified <code>wrapper</code> or `col_arr.</p> <p>MappedArray.replace() does it automatically.</p>   <code>**kwargs</code>  <p>Custom keyword arguments passed to the config.</p> <p>Useful if any subclass wants to extend the config.</p>   <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.config</li> <li>Wrapping.iloc</li> <li>Wrapping.indexing_kwargs</li> <li>Wrapping.loc</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> <li>Wrapping.self_aliases</li> <li>Wrapping.wrapper</li> <li>Wrapping.writeable_attrs</li> </ul>","title":"MappedArray class"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.metrics","text":"<p>Metrics supported by MappedArray.</p> <pre><code>Config({\n    \"start\": {\n        \"title\": \"Start\",\n        \"calc_func\": \"&lt;function MappedArray.&lt;lambda&gt; at 0x7ff5336c11e0&gt;\",\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"end\": {\n        \"title\": \"End\",\n        \"calc_func\": \"&lt;function MappedArray.&lt;lambda&gt; at 0x7ff5336c1268&gt;\",\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"period\": {\n        \"title\": \"Period\",\n        \"calc_func\": \"&lt;function MappedArray.&lt;lambda&gt; at 0x7ff5336c12f0&gt;\",\n        \"apply_to_timedelta\": true,\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"count\": {\n        \"title\": \"Count\",\n        \"calc_func\": \"count\",\n        \"tags\": \"mapped_array\"\n    },\n    \"mean\": {\n        \"title\": \"Mean\",\n        \"calc_func\": \"mean\",\n        \"inv_check_has_mapping\": true,\n        \"tags\": [\n            \"mapped_array\",\n            \"describe\"\n        ]\n    },\n    \"std\": {\n        \"title\": \"Std\",\n        \"calc_func\": \"std\",\n        \"inv_check_has_mapping\": true,\n        \"tags\": [\n            \"mapped_array\",\n            \"describe\"\n        ]\n    },\n    \"min\": {\n        \"title\": \"Min\",\n        \"calc_func\": \"min\",\n        \"inv_check_has_mapping\": true,\n        \"tags\": [\n            \"mapped_array\",\n            \"describe\"\n        ]\n    },\n    \"median\": {\n        \"title\": \"Median\",\n        \"calc_func\": \"median\",\n        \"inv_check_has_mapping\": true,\n        \"tags\": [\n            \"mapped_array\",\n            \"describe\"\n        ]\n    },\n    \"max\": {\n        \"title\": \"Max\",\n        \"calc_func\": \"max\",\n        \"inv_check_has_mapping\": true,\n        \"tags\": [\n            \"mapped_array\",\n            \"describe\"\n        ]\n    },\n    \"idx_min\": {\n        \"title\": \"Min Index\",\n        \"calc_func\": \"idxmin\",\n        \"inv_check_has_mapping\": true,\n        \"agg_func\": null,\n        \"tags\": [\n            \"mapped_array\",\n            \"index\"\n        ]\n    },\n    \"idx_max\": {\n        \"title\": \"Max Index\",\n        \"calc_func\": \"idxmax\",\n        \"inv_check_has_mapping\": true,\n        \"agg_func\": null,\n        \"tags\": [\n            \"mapped_array\",\n            \"index\"\n        ]\n    },\n    \"value_counts\": {\n        \"title\": \"Value Counts\",\n        \"calc_func\": \"&lt;function MappedArray.&lt;lambda&gt; at 0x7ff5336c1378&gt;\",\n        \"resolve_value_counts\": true,\n        \"check_has_mapping\": true,\n        \"tags\": [\n            \"mapped_array\",\n            \"value_counts\"\n        ]\n    }\n})\n</code></pre> <p>Returns <code>MappedArray._metrics</code>, which gets (deep) copied upon creation of each instance. Thus, changing this config won't affect the class.</p> <p>To change metrics, you can either change the config in-place, override this property, or overwrite the instance variable <code>MappedArray._metrics</code>.</p>","title":"metrics class variable"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.subplots","text":"<p>Subplots supported by MappedArray.</p> <pre><code>Config({\n    \"to_pd_plot\": {\n        \"check_is_not_grouped\": true,\n        \"plot_func\": \"to_pd.vbt.plot\",\n        \"pass_trace_names\": false,\n        \"tags\": \"mapped_array\"\n    }\n})\n</code></pre> <p>Returns <code>MappedArray._subplots</code>, which gets (deep) copied upon creation of each instance. Thus, changing this config won't affect the class.</p> <p>To change subplots, you can either change the config in-place, override this property, or overwrite the instance variable <code>MappedArray._subplots</code>.</p>","title":"subplots class variable"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.col_arr","text":"<p>Column array.</p>","title":"col_arr property"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.col_mapper","text":"<p>Column mapper.</p> <p>See ColumnMapper.</p>","title":"col_mapper property"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.id_arr","text":"<p>Id array.</p>","title":"id_arr property"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.idx_arr","text":"<p>Index array.</p>","title":"idx_arr property"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.mapped_arr","text":"<p>Mapped array.</p>","title":"mapped_arr property"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.mapping","text":"<p>Mapping.</p>","title":"mapping property"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.plots_defaults","text":"<p>Defaults for PlotsBuilderMixin.plots().</p> <p>Merges PlotsBuilderMixin.plots_defaults and <code>mapped_array.plots</code> from settings.</p>","title":"plots_defaults property"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.stats_defaults","text":"<p>Defaults for StatsBuilderMixin.stats().</p> <p>Merges StatsBuilderMixin.stats_defaults and <code>mapped_array.stats</code> from settings.</p>","title":"stats_defaults property"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.values","text":"<p>Mapped array.</p>","title":"values property"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.apply","text":"<pre><code>MappedArray.apply(\n    apply_func_nb,\n    *args,\n    group_by=None,\n    apply_per_group=False,\n    dtype=None,\n    **kwargs\n)\n</code></pre> <p>Apply function on mapped array per column/group. Returns mapped array.</p> <p>Applies per group if <code>apply_per_group</code> is True.</p> <p>See apply_on_mapped_nb().</p> <p><code>**kwargs</code> are passed to MappedArray.replace().</p>","title":"apply method"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.apply_mapping","text":"<pre><code>MappedArray.apply_mapping(\n    mapping=None,\n    **kwargs\n)\n</code></pre> <p>Apply mapping on each element.</p>","title":"apply_mapping method"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.apply_mask","text":"<pre><code>MappedArray.apply_mask(\n    mask,\n    idx_arr=None,\n    group_by=None,\n    **kwargs\n)\n</code></pre> <p>Return a new class instance, filtered by mask.</p> <p><code>**kwargs</code> are passed to MappedArray.replace().</p>","title":"apply_mask method"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.bottom_n","text":"<pre><code>MappedArray.bottom_n(\n    n,\n    **kwargs\n)\n</code></pre> <p>Filter bottom N elements from each column/group.</p>","title":"bottom_n method"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.bottom_n_mask","text":"<pre><code>MappedArray.bottom_n_mask(\n    n,\n    **kwargs\n)\n</code></pre> <p>Return mask of bottom N elements in each column/group.</p>","title":"bottom_n_mask method"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.boxplot","text":"<pre><code>MappedArray.boxplot(\n    group_by=None,\n    **kwargs\n)\n</code></pre> <p>Plot box plot by column/group.</p>","title":"boxplot method"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.count","text":"<pre><code>MappedArray.count(\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Return number of values by column/group.</p>","title":"count method"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.describe","text":"<pre><code>MappedArray.describe(\n    percentiles=None,\n    ddof=1,\n    group_by=None,\n    wrap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Return statistics by column/group.</p>","title":"describe method"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.histplot","text":"<pre><code>MappedArray.histplot(\n    group_by=None,\n    **kwargs\n)\n</code></pre> <p>Plot histogram by column/group.</p>","title":"histplot method"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.idxmax","text":"<pre><code>MappedArray.idxmax(\n    group_by=None,\n    wrap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Return index of max by column/group.</p>","title":"idxmax method"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.idxmin","text":"<pre><code>MappedArray.idxmin(\n    group_by=None,\n    wrap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Return index of min by column/group.</p>","title":"idxmin method"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.indexing_func","text":"<pre><code>MappedArray.indexing_func(\n    pd_indexing_func,\n    **kwargs\n)\n</code></pre> <p>Perform indexing on MappedArray.</p>","title":"indexing_func method"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.indexing_func_meta","text":"<pre><code>MappedArray.indexing_func_meta(\n    pd_indexing_func,\n    **kwargs\n)\n</code></pre> <p>Perform indexing on MappedArray and return metadata.</p>","title":"indexing_func_meta method"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.is_expandable","text":"<pre><code>MappedArray.is_expandable(\n    idx_arr=None,\n    group_by=None\n)\n</code></pre> <p>See is_mapped_expandable_nb().</p>","title":"is_expandable method"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.is_sorted","text":"<pre><code>MappedArray.is_sorted(\n    incl_id=False\n)\n</code></pre> <p>Check whether mapped array is sorted.</p>","title":"is_sorted method"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.map_to_mask","text":"<pre><code>MappedArray.map_to_mask(\n    inout_map_func_nb,\n    *args,\n    group_by=None\n)\n</code></pre> <p>Map mapped array to a mask.</p> <p>See mapped_to_mask_nb().</p>","title":"map_to_mask method"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.max","text":"<pre><code>MappedArray.max(\n    group_by=None,\n    wrap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Return max by column/group.</p>","title":"max method"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.mean","text":"<pre><code>MappedArray.mean(\n    group_by=None,\n    wrap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Return mean by column/group.</p>","title":"mean method"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.median","text":"<pre><code>MappedArray.median(\n    group_by=None,\n    wrap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Return median by column/group.</p>","title":"median method"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.min","text":"<pre><code>MappedArray.min(\n    group_by=None,\n    wrap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Return min by column/group.</p>","title":"min method"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.nth","text":"<pre><code>MappedArray.nth(\n    n,\n    group_by=None,\n    wrap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Return n-th element of each column/group.</p>","title":"nth method"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.nth_index","text":"<pre><code>MappedArray.nth_index(\n    n,\n    group_by=None,\n    wrap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Return index of n-th element of each column/group.</p>","title":"nth_index method"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.reduce","text":"<pre><code>MappedArray.reduce(\n    reduce_func_nb,\n    *args,\n    idx_arr=None,\n    returns_array=False,\n    returns_idx=False,\n    to_index=True,\n    fill_value=nan,\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Reduce mapped array by column/group.</p> <p>If <code>returns_array</code> is False and <code>returns_idx</code> is False, see reduce_mapped_nb(). If <code>returns_array</code> is False and <code>returns_idx</code> is True, see reduce_mapped_to_idx_nb(). If <code>returns_array</code> is True and <code>returns_idx</code> is False, see reduce_mapped_to_array_nb(). If <code>returns_array</code> is True and <code>returns_idx</code> is True, see reduce_mapped_to_idx_array_nb().</p> <p>If <code>returns_idx</code> is True, must pass <code>idx_arr</code>. Set <code>to_index</code> to False to return raw positions instead of labels. Use <code>fill_value</code> to set the default value. Set <code>group_by</code> to False to disable grouping.</p>","title":"reduce method"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.replace","text":"<pre><code>MappedArray.replace(\n    **kwargs\n)\n</code></pre> <p>See Configured.replace().</p> <p>Also, makes sure that MappedArray.col_mapper is not passed to the new instance.</p>","title":"replace method"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.sort","text":"<pre><code>MappedArray.sort(\n    incl_id=False,\n    idx_arr=None,\n    group_by=None,\n    **kwargs\n)\n</code></pre> <p>Sort mapped array by column array (primary) and id array (secondary, optional).</p> <p><code>**kwargs</code> are passed to MappedArray.replace().</p>","title":"sort method"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.std","text":"<pre><code>MappedArray.std(\n    ddof=1,\n    group_by=None,\n    wrap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Return std by column/group.</p>","title":"std method"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.sum","text":"<pre><code>MappedArray.sum(\n    fill_value=0.0,\n    group_by=None,\n    wrap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Return sum by column/group.</p>","title":"sum method"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.to_index","text":"<pre><code>MappedArray.to_index()\n</code></pre> <p>Convert to index.</p>","title":"to_index method"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.to_pd","text":"<pre><code>MappedArray.to_pd(\n    idx_arr=None,\n    ignore_index=False,\n    fill_value=nan,\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Expand mapped array to a Series/DataFrame.</p> <p>If <code>ignore_index</code>, will ignore the index and stack data points on top of each other in every column/group (see stack_expand_mapped_nb()). Otherwise, see expand_mapped_nb().</p>  <p>Note</p> <p>Will raise an error if there are multiple values pointing to the same position. Set <code>ignore_index</code> to True in this case.</p>   <p>Warning</p> <p>Mapped arrays represent information in the most memory-friendly format. Mapping back to pandas may occupy lots of memory if records are sparse.</p>","title":"to_pd method"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.top_n","text":"<pre><code>MappedArray.top_n(\n    n,\n    **kwargs\n)\n</code></pre> <p>Filter top N elements from each column/group.</p>","title":"top_n method"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.top_n_mask","text":"<pre><code>MappedArray.top_n_mask(\n    n,\n    **kwargs\n)\n</code></pre> <p>Return mask of top N elements in each column/group.</p>","title":"top_n_mask method"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MappedArray.value_counts","text":"<pre><code>MappedArray.value_counts(\n    normalize=False,\n    sort_uniques=True,\n    sort=False,\n    ascending=False,\n    dropna=False,\n    group_by=None,\n    mapping=None,\n    incl_all_keys=False,\n    wrap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>See GenericAccessor.value_counts().</p>  <p>Note</p> <p>Does not take into account missing values.</p>","title":"value_counts method"},{"location":"api/records/mapped_array/#vectorbt.records.mapped_array.MetaMappedArray","text":"<pre><code>MetaMappedArray(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Meta class that exposes a read-only class property <code>StatsBuilderMixin.metrics</code>.</p> <p>Superclasses</p> <ul> <li>MetaPlotsBuilderMixin</li> <li>MetaStatsBuilderMixin</li> <li><code>builtins.type</code></li> </ul> <p>Inherited members</p> <ul> <li>MetaPlotsBuilderMixin.subplots</li> <li>MetaStatsBuilderMixin.metrics</li> </ul>","title":"MetaMappedArray class"},{"location":"api/records/nb/","text":"<p>Numba-compiled functions.</p> <p>Provides an arsenal of Numba-compiled functions for records and mapped arrays. These only accept NumPy arrays and other Numba-compatible types.</p>  <p>Note</p> <p>vectorbt treats matrices as first-class citizens and expects input arrays to be 2-dim, unless function has suffix <code>_1d</code> or is meant to be input to another function. Data is processed along index (axis 0).</p> <p>All functions passed as argument should be Numba-compiled.</p> <p>Records should retain the order they were created in.</p>","title":"nb"},{"location":"api/records/nb/#vectorbt.records.nb.apply_on_mapped_nb","text":"<pre><code>apply_on_mapped_nb(\n    mapped_arr,\n    col_map,\n    apply_func_nb,\n    *args\n)\n</code></pre> <p>Apply function on mapped array per column.</p> <p>Returns the same shape as <code>mapped_arr</code>.</p> <p><code>apply_func_nb</code> should accept the indices of values, index of the column, values of the column, and <code>*args</code>, and return an array.</p>","title":"apply_on_mapped_nb function"},{"location":"api/records/nb/#vectorbt.records.nb.apply_on_records_nb","text":"<pre><code>apply_on_records_nb(\n    records,\n    col_map,\n    apply_func_nb,\n    *args\n)\n</code></pre> <p>Apply function on records per column.</p> <p>Returns the same shape as <code>records</code>.</p> <p><code>apply_func_nb</code> should accept the records of the column and <code>*args</code>, and return an array.</p>","title":"apply_on_records_nb function"},{"location":"api/records/nb/#vectorbt.records.nb.bottom_n_inout_map_nb","text":"<pre><code>bottom_n_inout_map_nb(\n    inout,\n    idxs,\n    col,\n    mapped_arr,\n    n\n)\n</code></pre> <p><code>inout_map_func_nb</code> that returns indices of bottom N elements.</p>","title":"bottom_n_inout_map_nb function"},{"location":"api/records/nb/#vectorbt.records.nb.col_map_nb","text":"<pre><code>col_map_nb(\n    col_arr,\n    n_cols\n)\n</code></pre> <p>Build a map between columns and their indices.</p> <p>Returns an array with indices segmented by column, and an array with count per segment.</p> <p>Works well for unsorted column arrays.</p>","title":"col_map_nb function"},{"location":"api/records/nb/#vectorbt.records.nb.col_map_select_nb","text":"<pre><code>col_map_select_nb(\n    col_map,\n    new_cols\n)\n</code></pre> <p>Same as <code>mapped_col_range_select_nb</code> but using column map <code>col_map</code>.</p>","title":"col_map_select_nb function"},{"location":"api/records/nb/#vectorbt.records.nb.col_range_nb","text":"<pre><code>col_range_nb(\n    col_arr,\n    n_cols\n)\n</code></pre> <p>Build column range for sorted column array.</p> <p>Creates a 2-dim array with first column being start indices (inclusive) and second column being end indices (exclusive).</p>  <p>Note</p> <p>Requires <code>col_arr</code> to be in ascending order. This can be done by sorting.</p>","title":"col_range_nb function"},{"location":"api/records/nb/#vectorbt.records.nb.col_range_select_nb","text":"<pre><code>col_range_select_nb(\n    col_range,\n    new_cols\n)\n</code></pre> <p>Perform indexing on a sorted array using column range <code>col_range</code>.</p> <p>Returns indices of elements corresponding to columns in <code>new_cols</code> and a new column array.</p>","title":"col_range_select_nb function"},{"location":"api/records/nb/#vectorbt.records.nb.expand_mapped_nb","text":"<pre><code>expand_mapped_nb(\n    mapped_arr,\n    col_arr,\n    idx_arr,\n    target_shape,\n    fill_value\n)\n</code></pre> <p>Set each element to a value by boolean mask.</p>","title":"expand_mapped_nb function"},{"location":"api/records/nb/#vectorbt.records.nb.is_col_idx_sorted_nb","text":"<pre><code>is_col_idx_sorted_nb(\n    col_arr,\n    id_arr\n)\n</code></pre> <p>Check whether the column and index arrays are sorted.</p>","title":"is_col_idx_sorted_nb function"},{"location":"api/records/nb/#vectorbt.records.nb.is_col_sorted_nb","text":"<pre><code>is_col_sorted_nb(\n    col_arr\n)\n</code></pre> <p>Check whether the column array is sorted.</p>","title":"is_col_sorted_nb function"},{"location":"api/records/nb/#vectorbt.records.nb.is_mapped_expandable_nb","text":"<pre><code>is_mapped_expandable_nb(\n    col_arr,\n    idx_arr,\n    target_shape\n)\n</code></pre> <p>Check whether mapped array can be expanded without positional conflicts.</p>","title":"is_mapped_expandable_nb function"},{"location":"api/records/nb/#vectorbt.records.nb.map_records_nb","text":"<pre><code>map_records_nb(\n    records,\n    map_func_nb,\n    *args\n)\n</code></pre> <p>Map each record to a single value.</p> <p><code>map_func_nb</code> should accept a single record and <code>*args</code>, and return a single value.</p>","title":"map_records_nb function"},{"location":"api/records/nb/#vectorbt.records.nb.mapped_to_mask_nb","text":"<pre><code>mapped_to_mask_nb(\n    mapped_arr,\n    col_map,\n    inout_map_func_nb,\n    *args\n)\n</code></pre> <p>Map mapped array to a mask per column.</p> <p>Returns the same shape as <code>mapped_arr</code>.</p> <p><code>inout_map_func_nb</code> should accept the boolean array that should be written, indices of values, index of the column, values of the column, and <code>*args</code>, and return nothing.</p>","title":"mapped_to_mask_nb function"},{"location":"api/records/nb/#vectorbt.records.nb.mapped_value_counts_nb","text":"<pre><code>mapped_value_counts_nb(\n    codes,\n    n_uniques,\n    col_map\n)\n</code></pre> <p>Get value counts of an already factorized mapped array.</p>","title":"mapped_value_counts_nb function"},{"location":"api/records/nb/#vectorbt.records.nb.record_col_map_select_nb","text":"<pre><code>record_col_map_select_nb(\n    records,\n    col_map,\n    new_cols\n)\n</code></pre> <p>Same as record_col_range_select_nb() but using column map <code>col_map</code>.</p>","title":"record_col_map_select_nb function"},{"location":"api/records/nb/#vectorbt.records.nb.record_col_range_select_nb","text":"<pre><code>record_col_range_select_nb(\n    records,\n    col_range,\n    new_cols\n)\n</code></pre> <p>Perform indexing on sorted records using column range <code>col_range</code>.</p> <p>Returns new records.</p>","title":"record_col_range_select_nb function"},{"location":"api/records/nb/#vectorbt.records.nb.reduce_mapped_nb","text":"<pre><code>reduce_mapped_nb(\n    mapped_arr,\n    col_map,\n    fill_value,\n    reduce_func_nb,\n    *args\n)\n</code></pre> <p>Reduce mapped array by column to a single value.</p> <p>Faster than expand_mapped_nb() and <code>vbt.*</code> used together, and also requires less memory. But does not take advantage of caching.</p> <p><code>reduce_func_nb</code> should accept index of the column, mapped array and <code>*args</code>, and return a single value.</p>","title":"reduce_mapped_nb function"},{"location":"api/records/nb/#vectorbt.records.nb.reduce_mapped_to_array_nb","text":"<pre><code>reduce_mapped_to_array_nb(\n    mapped_arr,\n    col_map,\n    fill_value,\n    reduce_func_nb,\n    *args\n)\n</code></pre> <p>Reduce mapped array by column to an array.</p> <p><code>reduce_func_nb</code> same as for reduce_mapped_nb() but should return an array.</p>","title":"reduce_mapped_to_array_nb function"},{"location":"api/records/nb/#vectorbt.records.nb.reduce_mapped_to_idx_array_nb","text":"<pre><code>reduce_mapped_to_idx_array_nb(\n    mapped_arr,\n    col_map,\n    idx_arr,\n    fill_value,\n    reduce_func_nb,\n    *args\n)\n</code></pre> <p>Reduce mapped array by column to an index array.</p> <p>Same as reduce_mapped_to_array_nb() except <code>idx_arr</code> should be passed.</p>  <p>Note</p> <p>Must return integers or raise an exception.</p>","title":"reduce_mapped_to_idx_array_nb function"},{"location":"api/records/nb/#vectorbt.records.nb.reduce_mapped_to_idx_nb","text":"<pre><code>reduce_mapped_to_idx_nb(\n    mapped_arr,\n    col_map,\n    idx_arr,\n    fill_value,\n    reduce_func_nb,\n    *args\n)\n</code></pre> <p>Reduce mapped array by column to an index.</p> <p>Same as reduce_mapped_nb() except <code>idx_arr</code> should be passed.</p>  <p>Note</p> <p>Must return integers or raise an exception.</p>","title":"reduce_mapped_to_idx_nb function"},{"location":"api/records/nb/#vectorbt.records.nb.stack_expand_mapped_nb","text":"<pre><code>stack_expand_mapped_nb(\n    mapped_arr,\n    col_map,\n    fill_value\n)\n</code></pre> <p>Expand mapped array by stacking without using index data.</p>","title":"stack_expand_mapped_nb function"},{"location":"api/records/nb/#vectorbt.records.nb.top_n_inout_map_nb","text":"<pre><code>top_n_inout_map_nb(\n    inout,\n    idxs,\n    col,\n    mapped_arr,\n    n\n)\n</code></pre> <p><code>inout_map_func_nb</code> that returns indices of top N elements.</p>","title":"top_n_inout_map_nb function"},{"location":"api/returns/","text":"<p>Modules for working with returns.</p> <p>Offers common financial risk and performance metrics as found in empyrical, an adapter for quantstats, and other features based on returns.</p>","title":"returns"},{"location":"api/returns/#sub-modules","text":"<ul> <li>vectorbt.returns.accessors</li> <li>vectorbt.returns.metrics</li> <li>vectorbt.returns.nb</li> <li>vectorbt.returns.qs_adapter</li> </ul>","title":"Sub-modules"},{"location":"api/returns/accessors/","text":"<p>Custom pandas accessors for returns data.</p> <p>Methods can be accessed as follows:</p> <ul> <li>ReturnsSRAccessor -&gt; <code>pd.Series.vbt.returns.*</code></li> <li>ReturnsDFAccessor -&gt; <code>pd.DataFrame.vbt.returns.*</code></li> </ul>  <p>Note</p> <p>The underlying Series/DataFrame must already be a return series. To convert price to returns, use ReturnsAccessor.from_value().</p> <p>Grouping is only supported by the methods that accept the <code>group_by</code> argument.</p> <p>Accessors do not utilize caching.</p>  <p>There are three options to compute returns and get the accessor:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; price = pd.Series([1.1, 1.2, 1.3, 1.2, 1.1])\n\n&gt;&gt;&gt; # 1. pd.Series.pct_change\n&gt;&gt;&gt; rets = price.pct_change()\n&gt;&gt;&gt; ret_acc = rets.vbt.returns(freq='d')\n\n&gt;&gt;&gt; # 2. vectorbt.generic.accessors.GenericAccessor.to_returns\n&gt;&gt;&gt; rets = price.vbt.to_returns()\n&gt;&gt;&gt; ret_acc = rets.vbt.returns(freq='d')\n\n&gt;&gt;&gt; # 3. vectorbt.returns.accessors.ReturnsAccessor.from_value\n&gt;&gt;&gt; ret_acc = pd.Series.vbt.returns.from_value(price, freq='d')\n\n&gt;&gt;&gt; # vectorbt.returns.accessors.ReturnsAccessor.total\n&gt;&gt;&gt; ret_acc.total()\n0.0\n</code></pre> <p>The accessors extend vectorbt.generic.accessors.</p> <pre><code>&gt;&gt;&gt; # inherited from GenericAccessor\n&gt;&gt;&gt; ret_acc.max()\n0.09090909090909083\n</code></pre>","title":"accessors"},{"location":"api/returns/accessors/#defaults","text":"<p>ReturnsAccessor accepts <code>defaults</code> dictionary where you can pass defaults for arguments used throughout the accessor, such as</p> <ul> <li><code>start_value</code>: The starting value.</li> <li><code>window</code>: Window length.</li> <li><code>minp</code>: Minimum number of observations in a window required to have a value.</li> <li><code>ddof</code>: Delta Degrees of Freedom.</li> <li><code>risk_free</code>: Constant risk-free return throughout the period.</li> <li><code>levy_alpha</code>: Scaling relation (Levy stability exponent).</li> <li><code>required_return</code>: Minimum acceptance return of the investor.</li> <li><code>cutoff</code>: Decimal representing the percentage cutoff for the bottom percentile of returns.</li> </ul>","title":"Defaults"},{"location":"api/returns/accessors/#stats","text":"<p>Hint</p> <p>See StatsBuilderMixin.stats() and ReturnsAccessor.metrics.</p>  <pre><code>&gt;&gt;&gt; ret_acc.stats()\nUserWarning: Metric 'benchmark_return' requires benchmark_rets to be set\nUserWarning: Metric 'alpha' requires benchmark_rets to be set\nUserWarning: Metric 'beta' requires benchmark_rets to be set\n\nStart                                      0\nEnd                                        4\nDuration                     5 days 00:00:00\nTotal Return [%]                           0\nAnnualized Return [%]                      0\nAnnualized Volatility [%]            184.643\nSharpe Ratio                        0.691185\nCalmar Ratio                               0\nMax Drawdown [%]                     15.3846\nOmega Ratio                          1.08727\nSortino Ratio                        1.17805\nSkew                              0.00151002\nKurtosis                            -5.94737\nTail Ratio                           1.08985\nCommon Sense Ratio                   1.08985\nValue at Risk                     -0.0823718\ndtype: object\n</code></pre> <p>The missing <code>benchmark_rets</code> can be either passed to the contrustor of the accessor or as a setting to StatsBuilderMixin.stats():</p> <pre><code>&gt;&gt;&gt; benchmark = pd.Series([1.05, 1.1, 1.15, 1.1, 1.05])\n&gt;&gt;&gt; benchmark_rets = benchmark.vbt.to_returns()\n\n&gt;&gt;&gt; ret_acc.stats(settings=dict(benchmark_rets=benchmark_rets))\nStart                                      0\nEnd                                        4\nDuration                     5 days 00:00:00\nTotal Return [%]                           0\nBenchmark Return [%]                       0\nAnnualized Return [%]                      0\nAnnualized Volatility [%]            184.643\nSharpe Ratio                        0.691185\nCalmar Ratio                               0\nMax Drawdown [%]                     15.3846\nOmega Ratio                          1.08727\nSortino Ratio                        1.17805\nSkew                              0.00151002\nKurtosis                            -5.94737\nTail Ratio                           1.08985\nCommon Sense Ratio                   1.08985\nValue at Risk                     -0.0823718\nAlpha                                0.78789\nBeta                                 1.83864\ndtype: object\n</code></pre>  <p>Note</p> <p>StatsBuilderMixin.stats() does not support grouping.</p>","title":"Stats"},{"location":"api/returns/accessors/#plots","text":"<p>Hint</p> <p>See PlotsBuilderMixin.plots() and ReturnsAccessor.subplots.</p>  <p>This class inherits subplots from GenericAccessor.</p>","title":"Plots"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor","text":"<pre><code>ReturnsAccessor(\n    obj,\n    benchmark_rets=None,\n    year_freq=None,\n    defaults=None,\n    **kwargs\n)\n</code></pre> <p>Accessor on top of return series. For both, Series and DataFrames.</p> <p>Accessible through <code>pd.Series.vbt.returns</code> and <code>pd.DataFrame.vbt.returns</code>.</p> <p>Args</p>  <code>obj</code> :\u2002<code>pd.Series</code> or <code>pd.DataFrame</code> Pandas object representing returns. <code>benchmark_rets</code> :\u2002<code>array_like</code> Pandas object representing benchmark returns. <code>year_freq</code> :\u2002<code>any</code> Year frequency for annualization purposes. <code>defaults</code> :\u2002<code>dict</code> Defaults that override <code>returns.defaults</code> in settings. <code>**kwargs</code> Keyword arguments that are passed down to GenericAccessor.  <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>BaseAccessor</li> <li>Configured</li> <li>Documented</li> <li>GenericAccessor</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>BaseAccessor.align_to()</li> <li>BaseAccessor.apply()</li> <li>BaseAccessor.apply_and_concat()</li> <li>BaseAccessor.apply_on_index()</li> <li>BaseAccessor.broadcast()</li> <li>BaseAccessor.broadcast_to()</li> <li>BaseAccessor.combine()</li> <li>BaseAccessor.concat()</li> <li>BaseAccessor.drop_duplicate_levels()</li> <li>BaseAccessor.drop_levels()</li> <li>BaseAccessor.drop_redundant_levels()</li> <li>BaseAccessor.empty()</li> <li>BaseAccessor.empty_like()</li> <li>BaseAccessor.make_symmetric()</li> <li>BaseAccessor.rename_levels()</li> <li>BaseAccessor.repeat()</li> <li>BaseAccessor.select_levels()</li> <li>BaseAccessor.stack_index()</li> <li>BaseAccessor.tile()</li> <li>BaseAccessor.to_1d_array()</li> <li>BaseAccessor.to_2d_array()</li> <li>BaseAccessor.to_dict()</li> <li>BaseAccessor.unstack_to_array()</li> <li>BaseAccessor.unstack_to_df()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>GenericAccessor.apply_along_axis()</li> <li>GenericAccessor.apply_and_reduce()</li> <li>GenericAccessor.apply_mapping()</li> <li>GenericAccessor.applymap()</li> <li>GenericAccessor.barplot()</li> <li>GenericAccessor.bfill()</li> <li>GenericAccessor.binarize()</li> <li>GenericAccessor.boxplot()</li> <li>GenericAccessor.bshift()</li> <li>GenericAccessor.config</li> <li>GenericAccessor.count()</li> <li>GenericAccessor.crossed_above()</li> <li>GenericAccessor.crossed_below()</li> <li>GenericAccessor.cumprod()</li> <li>GenericAccessor.cumsum()</li> <li>GenericAccessor.describe()</li> <li>GenericAccessor.df_accessor_cls</li> <li>GenericAccessor.diff()</li> <li>GenericAccessor.ewm_mean()</li> <li>GenericAccessor.ewm_std()</li> <li>GenericAccessor.expanding_apply()</li> <li>GenericAccessor.expanding_max()</li> <li>GenericAccessor.expanding_mean()</li> <li>GenericAccessor.expanding_min()</li> <li>GenericAccessor.expanding_split()</li> <li>GenericAccessor.expanding_std()</li> <li>GenericAccessor.ffill()</li> <li>GenericAccessor.fillna()</li> <li>GenericAccessor.filter()</li> <li>GenericAccessor.fshift()</li> <li>GenericAccessor.get_ranges()</li> <li>GenericAccessor.groupby_apply()</li> <li>GenericAccessor.histplot()</li> <li>GenericAccessor.idxmax()</li> <li>GenericAccessor.idxmin()</li> <li>GenericAccessor.iloc</li> <li>GenericAccessor.indexing_kwargs</li> <li>GenericAccessor.lineplot()</li> <li>GenericAccessor.loc</li> <li>GenericAccessor.mapping</li> <li>GenericAccessor.max()</li> <li>GenericAccessor.maxabs_scale()</li> <li>GenericAccessor.mean()</li> <li>GenericAccessor.median()</li> <li>GenericAccessor.min()</li> <li>GenericAccessor.minmax_scale()</li> <li>GenericAccessor.normalize()</li> <li>GenericAccessor.obj</li> <li>GenericAccessor.pct_change()</li> <li>GenericAccessor.plot()</li> <li>GenericAccessor.power_transform()</li> <li>GenericAccessor.product()</li> <li>GenericAccessor.quantile_transform()</li> <li>GenericAccessor.range_split()</li> <li>GenericAccessor.ranges</li> <li>GenericAccessor.rebase()</li> <li>GenericAccessor.reduce()</li> <li>GenericAccessor.resample_apply()</li> <li>GenericAccessor.robust_scale()</li> <li>GenericAccessor.rolling_apply()</li> <li>GenericAccessor.rolling_max()</li> <li>GenericAccessor.rolling_mean()</li> <li>GenericAccessor.rolling_min()</li> <li>GenericAccessor.rolling_split()</li> <li>GenericAccessor.rolling_std()</li> <li>GenericAccessor.scale()</li> <li>GenericAccessor.scatterplot()</li> <li>GenericAccessor.self_aliases</li> <li>GenericAccessor.shuffle()</li> <li>GenericAccessor.split()</li> <li>GenericAccessor.sr_accessor_cls</li> <li>GenericAccessor.std()</li> <li>GenericAccessor.sum()</li> <li>GenericAccessor.to_mapped()</li> <li>GenericAccessor.to_returns()</li> <li>GenericAccessor.transform()</li> <li>GenericAccessor.value_counts()</li> <li>GenericAccessor.wrapper</li> <li>GenericAccessor.writeable_attrs</li> <li>GenericAccessor.zscore()</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li>ReturnsDFAccessor</li> <li>ReturnsSRAccessor</li> </ul>","title":"ReturnsAccessor class"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.metrics","text":"<p>Metrics supported by ReturnsAccessor.</p> <pre><code>Config({\n    \"start\": {\n        \"title\": \"Start\",\n        \"calc_func\": \"&lt;function ReturnsAccessor.&lt;lambda&gt; at 0x7ff521587598&gt;\",\n        \"agg_func\": null,\n        \"check_is_not_grouped\": false,\n        \"tags\": \"wrapper\"\n    },\n    \"end\": {\n        \"title\": \"End\",\n        \"calc_func\": \"&lt;function ReturnsAccessor.&lt;lambda&gt; at 0x7ff521587620&gt;\",\n        \"agg_func\": null,\n        \"check_is_not_grouped\": false,\n        \"tags\": \"wrapper\"\n    },\n    \"period\": {\n        \"title\": \"Period\",\n        \"calc_func\": \"&lt;function ReturnsAccessor.&lt;lambda&gt; at 0x7ff5215876a8&gt;\",\n        \"apply_to_timedelta\": true,\n        \"agg_func\": null,\n        \"check_is_not_grouped\": false,\n        \"tags\": \"wrapper\"\n    },\n    \"total_return\": {\n        \"title\": \"Total Return [%]\",\n        \"calc_func\": \"total\",\n        \"post_calc_func\": \"&lt;function ReturnsAccessor.&lt;lambda&gt; at 0x7ff521587730&gt;\",\n        \"tags\": \"returns\"\n    },\n    \"benchmark_return\": {\n        \"title\": \"Benchmark Return [%]\",\n        \"calc_func\": \"benchmark_rets.vbt.returns.total\",\n        \"post_calc_func\": \"&lt;function ReturnsAccessor.&lt;lambda&gt; at 0x7ff5215877b8&gt;\",\n        \"check_has_benchmark_rets\": true,\n        \"tags\": \"returns\"\n    },\n    \"ann_return\": {\n        \"title\": \"Annualized Return [%]\",\n        \"calc_func\": \"annualized\",\n        \"post_calc_func\": \"&lt;function ReturnsAccessor.&lt;lambda&gt; at 0x7ff521587840&gt;\",\n        \"check_has_freq\": true,\n        \"check_has_year_freq\": true,\n        \"tags\": \"returns\"\n    },\n    \"ann_volatility\": {\n        \"title\": \"Annualized Volatility [%]\",\n        \"calc_func\": \"annualized_volatility\",\n        \"post_calc_func\": \"&lt;function ReturnsAccessor.&lt;lambda&gt; at 0x7ff5215878c8&gt;\",\n        \"check_has_freq\": true,\n        \"check_has_year_freq\": true,\n        \"tags\": \"returns\"\n    },\n    \"max_dd\": {\n        \"title\": \"Max Drawdown [%]\",\n        \"calc_func\": \"drawdowns.max_drawdown\",\n        \"post_calc_func\": \"&lt;function ReturnsAccessor.&lt;lambda&gt; at 0x7ff521587950&gt;\",\n        \"tags\": [\n            \"returns\",\n            \"drawdowns\"\n        ]\n    },\n    \"max_dd_duration\": {\n        \"title\": \"Max Drawdown Duration\",\n        \"calc_func\": \"drawdowns.max_duration\",\n        \"fill_wrap_kwargs\": true,\n        \"tags\": [\n            \"returns\",\n            \"drawdowns\",\n            \"duration\"\n        ]\n    },\n    \"sharpe_ratio\": {\n        \"title\": \"Sharpe Ratio\",\n        \"calc_func\": \"sharpe_ratio\",\n        \"check_has_freq\": true,\n        \"check_has_year_freq\": true,\n        \"tags\": \"returns\"\n    },\n    \"calmar_ratio\": {\n        \"title\": \"Calmar Ratio\",\n        \"calc_func\": \"calmar_ratio\",\n        \"check_has_freq\": true,\n        \"check_has_year_freq\": true,\n        \"tags\": \"returns\"\n    },\n    \"omega_ratio\": {\n        \"title\": \"Omega Ratio\",\n        \"calc_func\": \"omega_ratio\",\n        \"check_has_freq\": true,\n        \"check_has_year_freq\": true,\n        \"tags\": \"returns\"\n    },\n    \"sortino_ratio\": {\n        \"title\": \"Sortino Ratio\",\n        \"calc_func\": \"sortino_ratio\",\n        \"check_has_freq\": true,\n        \"check_has_year_freq\": true,\n        \"tags\": \"returns\"\n    },\n    \"skew\": {\n        \"title\": \"Skew\",\n        \"calc_func\": \"obj.skew\",\n        \"tags\": \"returns\"\n    },\n    \"kurtosis\": {\n        \"title\": \"Kurtosis\",\n        \"calc_func\": \"obj.kurtosis\",\n        \"tags\": \"returns\"\n    },\n    \"tail_ratio\": {\n        \"title\": \"Tail Ratio\",\n        \"calc_func\": \"tail_ratio\",\n        \"tags\": \"returns\"\n    },\n    \"common_sense_ratio\": {\n        \"title\": \"Common Sense Ratio\",\n        \"calc_func\": \"common_sense_ratio\",\n        \"check_has_freq\": true,\n        \"check_has_year_freq\": true,\n        \"tags\": \"returns\"\n    },\n    \"value_at_risk\": {\n        \"title\": \"Value at Risk\",\n        \"calc_func\": \"value_at_risk\",\n        \"tags\": \"returns\"\n    },\n    \"alpha\": {\n        \"title\": \"Alpha\",\n        \"calc_func\": \"alpha\",\n        \"check_has_freq\": true,\n        \"check_has_year_freq\": true,\n        \"check_has_benchmark_rets\": true,\n        \"tags\": \"returns\"\n    },\n    \"beta\": {\n        \"title\": \"Beta\",\n        \"calc_func\": \"beta\",\n        \"check_has_benchmark_rets\": true,\n        \"tags\": \"returns\"\n    }\n})\n</code></pre> <p>Returns <code>ReturnsAccessor._metrics</code>, which gets (deep) copied upon creation of each instance. Thus, changing this config won't affect the class.</p> <p>To change metrics, you can either change the config in-place, override this property, or overwrite the instance variable <code>ReturnsAccessor._metrics</code>.</p>","title":"metrics class variable"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.subplots","text":"<p>Subplots supported by ReturnsAccessor.</p> <pre><code>Config({\n    \"plot\": {\n        \"check_is_not_grouped\": true,\n        \"plot_func\": \"plot\",\n        \"pass_trace_names\": false,\n        \"tags\": \"generic\"\n    }\n})\n</code></pre> <p>Returns <code>ReturnsAccessor._subplots</code>, which gets (deep) copied upon creation of each instance. Thus, changing this config won't affect the class.</p> <p>To change subplots, you can either change the config in-place, override this property, or overwrite the instance variable <code>ReturnsAccessor._subplots</code>.</p>","title":"subplots class variable"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.from_value","text":"<pre><code>ReturnsAccessor.from_value(\n    value,\n    init_value=nan,\n    broadcast_kwargs=None,\n    wrap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Returns a new ReturnsAccessor instance with returns calculated from <code>value</code>.</p>","title":"from_value class method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.ann_factor","text":"<p>Get annualization factor.</p>","title":"ann_factor property"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.benchmark_rets","text":"<p>Benchmark returns.</p>","title":"benchmark_rets property"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.defaults","text":"<p>Defaults for ReturnsAccessor.</p> <p>Merges <code>returns.defaults</code> from settings with <code>defaults</code> from ReturnsAccessor.</p>","title":"defaults property"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.drawdowns","text":"<p>ReturnsAccessor.get_drawdowns() with default arguments.</p>","title":"drawdowns property"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.plots_defaults","text":"<p>Defaults for PlotsBuilderMixin.plots().</p> <p>Merges GenericAccessor.plots_defaults, defaults from ReturnsAccessor.defaults (acting as <code>settings</code>), and <code>returns.plots</code> from settings</p>","title":"plots_defaults property"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.qs","text":"<p>Quantstats adapter.</p>","title":"qs property"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.stats_defaults","text":"<p>Defaults for StatsBuilderMixin.stats().</p> <p>Merges GenericAccessor.stats_defaults, defaults from ReturnsAccessor.defaults (acting as <code>settings</code>), and <code>returns.stats</code> from settings</p>","title":"stats_defaults property"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.year_freq","text":"<p>Year frequency for annualization purposes.</p>","title":"year_freq property"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.alpha","text":"<pre><code>ReturnsAccessor.alpha(\n    benchmark_rets=None,\n    risk_free=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>See alpha_nb().</p>","title":"alpha method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.annual","text":"<pre><code>ReturnsAccessor.annual(\n    **kwargs\n)\n</code></pre> <p>Annual returns.</p>","title":"annual method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.annualized","text":"<pre><code>ReturnsAccessor.annualized(\n    wrap_kwargs=None\n)\n</code></pre> <p>See annualized_return_nb().</p>","title":"annualized method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.annualized_volatility","text":"<pre><code>ReturnsAccessor.annualized_volatility(\n    levy_alpha=None,\n    ddof=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>See annualized_volatility_nb().</p>","title":"annualized_volatility method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.beta","text":"<pre><code>ReturnsAccessor.beta(\n    benchmark_rets=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>See beta_nb().</p>","title":"beta method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.calmar_ratio","text":"<pre><code>ReturnsAccessor.calmar_ratio(\n    wrap_kwargs=None\n)\n</code></pre> <p>See calmar_ratio_nb().</p>","title":"calmar_ratio method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.capture","text":"<pre><code>ReturnsAccessor.capture(\n    benchmark_rets=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>See capture_nb().</p>","title":"capture method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.common_sense_ratio","text":"<pre><code>ReturnsAccessor.common_sense_ratio(\n    wrap_kwargs=None\n)\n</code></pre> <p>Common Sense Ratio.</p>","title":"common_sense_ratio method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.cond_value_at_risk","text":"<pre><code>ReturnsAccessor.cond_value_at_risk(\n    cutoff=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>See cond_value_at_risk_nb().</p>","title":"cond_value_at_risk method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.cumulative","text":"<pre><code>ReturnsAccessor.cumulative(\n    start_value=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>See cum_returns_nb().</p>","title":"cumulative method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.daily","text":"<pre><code>ReturnsAccessor.daily(\n    **kwargs\n)\n</code></pre> <p>Daily returns.</p>","title":"daily method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.deflated_sharpe_ratio","text":"<pre><code>ReturnsAccessor.deflated_sharpe_ratio(\n    risk_free=None,\n    ddof=None,\n    var_sharpe=None,\n    nb_trials=None,\n    bias=True,\n    wrap_kwargs=None\n)\n</code></pre> <p>Deflated Sharpe Ratio (DSR).</p> <p>Expresses the chance that the advertised strategy has a positive Sharpe ratio.</p> <p>If <code>var_sharpe</code> is None, is calculated based on all columns. If <code>nb_trials</code> is None, is set to the number of columns.</p>","title":"deflated_sharpe_ratio method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.down_capture","text":"<pre><code>ReturnsAccessor.down_capture(\n    benchmark_rets=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>See down_capture_nb().</p>","title":"down_capture method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.downside_risk","text":"<pre><code>ReturnsAccessor.downside_risk(\n    required_return=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>See downside_risk_nb().</p>","title":"downside_risk method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.drawdown","text":"<pre><code>ReturnsAccessor.drawdown(\n    wrap_kwargs=None\n)\n</code></pre> <p>Relative decline from a peak.</p>","title":"drawdown method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.get_drawdowns","text":"<pre><code>ReturnsAccessor.get_drawdowns(\n    wrapper_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Generate drawdown records of cumulative returns.</p> <p>See Drawdowns.</p>","title":"get_drawdowns method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.indexing_func","text":"<pre><code>ReturnsAccessor.indexing_func(\n    pd_indexing_func,\n    **kwargs\n)\n</code></pre> <p>Perform indexing on ReturnsAccessor.</p>","title":"indexing_func method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.information_ratio","text":"<pre><code>ReturnsAccessor.information_ratio(\n    benchmark_rets=None,\n    ddof=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>See information_ratio_nb().</p>","title":"information_ratio method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.max_drawdown","text":"<pre><code>ReturnsAccessor.max_drawdown(\n    wrap_kwargs=None\n)\n</code></pre> <p>See max_drawdown_nb().</p> <p>Yields the same result as <code>max_drawdown</code> of ReturnsAccessor.drawdowns.</p>","title":"max_drawdown method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.omega_ratio","text":"<pre><code>ReturnsAccessor.omega_ratio(\n    risk_free=None,\n    required_return=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>See omega_ratio_nb().</p>","title":"omega_ratio method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.resolve_self","text":"<pre><code>ReturnsAccessor.resolve_self(\n    cond_kwargs=None,\n    custom_arg_names=None,\n    impacts_caching=True,\n    silence_warnings=False\n)\n</code></pre> <p>Resolve self.</p> <p>See Wrapping.resolve_self().</p> <p>Creates a copy of this instance <code>year_freq</code> is different in <code>cond_kwargs</code>.</p>","title":"resolve_self method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.rolling_alpha","text":"<pre><code>ReturnsAccessor.rolling_alpha(\n    benchmark_rets=None,\n    window=None,\n    minp=None,\n    risk_free=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Rolling version of ReturnsAccessor.alpha().</p>","title":"rolling_alpha method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.rolling_annualized","text":"<pre><code>ReturnsAccessor.rolling_annualized(\n    window=None,\n    minp=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Rolling version of ReturnsAccessor.annualized().</p>","title":"rolling_annualized method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.rolling_annualized_volatility","text":"<pre><code>ReturnsAccessor.rolling_annualized_volatility(\n    window=None,\n    minp=None,\n    levy_alpha=None,\n    ddof=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Rolling version of ReturnsAccessor.annualized_volatility().</p>","title":"rolling_annualized_volatility method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.rolling_beta","text":"<pre><code>ReturnsAccessor.rolling_beta(\n    benchmark_rets=None,\n    window=None,\n    minp=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Rolling version of ReturnsAccessor.beta().</p>","title":"rolling_beta method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.rolling_calmar_ratio","text":"<pre><code>ReturnsAccessor.rolling_calmar_ratio(\n    window=None,\n    minp=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Rolling version of ReturnsAccessor.calmar_ratio().</p>","title":"rolling_calmar_ratio method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.rolling_capture","text":"<pre><code>ReturnsAccessor.rolling_capture(\n    benchmark_rets=None,\n    window=None,\n    minp=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Rolling version of ReturnsAccessor.capture().</p>","title":"rolling_capture method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.rolling_common_sense_ratio","text":"<pre><code>ReturnsAccessor.rolling_common_sense_ratio(\n    window=None,\n    minp=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Rolling version of ReturnsAccessor.common_sense_ratio().</p>","title":"rolling_common_sense_ratio method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.rolling_cond_value_at_risk","text":"<pre><code>ReturnsAccessor.rolling_cond_value_at_risk(\n    window=None,\n    minp=None,\n    cutoff=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Rolling version of ReturnsAccessor.cond_value_at_risk().</p>","title":"rolling_cond_value_at_risk method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.rolling_down_capture","text":"<pre><code>ReturnsAccessor.rolling_down_capture(\n    benchmark_rets=None,\n    window=None,\n    minp=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Rolling version of ReturnsAccessor.down_capture().</p>","title":"rolling_down_capture method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.rolling_downside_risk","text":"<pre><code>ReturnsAccessor.rolling_downside_risk(\n    window=None,\n    minp=None,\n    required_return=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Rolling version of ReturnsAccessor.downside_risk().</p>","title":"rolling_downside_risk method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.rolling_information_ratio","text":"<pre><code>ReturnsAccessor.rolling_information_ratio(\n    benchmark_rets=None,\n    window=None,\n    minp=None,\n    ddof=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Rolling version of ReturnsAccessor.information_ratio().</p>","title":"rolling_information_ratio method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.rolling_max_drawdown","text":"<pre><code>ReturnsAccessor.rolling_max_drawdown(\n    window=None,\n    minp=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Rolling version of ReturnsAccessor.max_drawdown().</p>","title":"rolling_max_drawdown method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.rolling_omega_ratio","text":"<pre><code>ReturnsAccessor.rolling_omega_ratio(\n    window=None,\n    minp=None,\n    risk_free=None,\n    required_return=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Rolling version of ReturnsAccessor.omega_ratio().</p>","title":"rolling_omega_ratio method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.rolling_sharpe_ratio","text":"<pre><code>ReturnsAccessor.rolling_sharpe_ratio(\n    window=None,\n    minp=None,\n    risk_free=None,\n    ddof=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Rolling version of ReturnsAccessor.sharpe_ratio().</p>","title":"rolling_sharpe_ratio method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.rolling_sortino_ratio","text":"<pre><code>ReturnsAccessor.rolling_sortino_ratio(\n    window=None,\n    minp=None,\n    required_return=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Rolling version of ReturnsAccessor.sortino_ratio().</p>","title":"rolling_sortino_ratio method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.rolling_tail_ratio","text":"<pre><code>ReturnsAccessor.rolling_tail_ratio(\n    window=None,\n    minp=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Rolling version of ReturnsAccessor.tail_ratio().</p>","title":"rolling_tail_ratio method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.rolling_total","text":"<pre><code>ReturnsAccessor.rolling_total(\n    window=None,\n    minp=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Rolling version of ReturnsAccessor.total().</p>","title":"rolling_total method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.rolling_up_capture","text":"<pre><code>ReturnsAccessor.rolling_up_capture(\n    benchmark_rets=None,\n    window=None,\n    minp=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Rolling version of ReturnsAccessor.up_capture().</p>","title":"rolling_up_capture method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.rolling_value_at_risk","text":"<pre><code>ReturnsAccessor.rolling_value_at_risk(\n    window=None,\n    minp=None,\n    cutoff=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Rolling version of ReturnsAccessor.value_at_risk().</p>","title":"rolling_value_at_risk method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.sharpe_ratio","text":"<pre><code>ReturnsAccessor.sharpe_ratio(\n    risk_free=None,\n    ddof=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>See sharpe_ratio_nb().</p>","title":"sharpe_ratio method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.sortino_ratio","text":"<pre><code>ReturnsAccessor.sortino_ratio(\n    required_return=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>See sortino_ratio_nb().</p>","title":"sortino_ratio method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.tail_ratio","text":"<pre><code>ReturnsAccessor.tail_ratio(\n    wrap_kwargs=None\n)\n</code></pre> <p>See tail_ratio_nb().</p>","title":"tail_ratio method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.total","text":"<pre><code>ReturnsAccessor.total(\n    wrap_kwargs=None\n)\n</code></pre> <p>See cum_returns_final_nb().</p>","title":"total method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.up_capture","text":"<pre><code>ReturnsAccessor.up_capture(\n    benchmark_rets=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>See up_capture_nb().</p>","title":"up_capture method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsAccessor.value_at_risk","text":"<pre><code>ReturnsAccessor.value_at_risk(\n    cutoff=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>See value_at_risk_nb().</p>","title":"value_at_risk method"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsDFAccessor","text":"<pre><code>ReturnsDFAccessor(\n    obj,\n    benchmark_rets=None,\n    year_freq=None,\n    defaults=None,\n    **kwargs\n)\n</code></pre> <p>Accessor on top of return series. For DataFrames only.</p> <p>Accessible through <code>pd.DataFrame.vbt.returns</code>.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>BaseAccessor</li> <li>BaseDFAccessor</li> <li>Configured</li> <li>Documented</li> <li>GenericAccessor</li> <li>GenericDFAccessor</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>ReturnsAccessor</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>BaseAccessor.align_to()</li> <li>BaseAccessor.apply()</li> <li>BaseAccessor.apply_and_concat()</li> <li>BaseAccessor.apply_on_index()</li> <li>BaseAccessor.broadcast()</li> <li>BaseAccessor.broadcast_to()</li> <li>BaseAccessor.combine()</li> <li>BaseAccessor.concat()</li> <li>BaseAccessor.drop_duplicate_levels()</li> <li>BaseAccessor.drop_levels()</li> <li>BaseAccessor.drop_redundant_levels()</li> <li>BaseAccessor.empty()</li> <li>BaseAccessor.empty_like()</li> <li>BaseAccessor.make_symmetric()</li> <li>BaseAccessor.rename_levels()</li> <li>BaseAccessor.repeat()</li> <li>BaseAccessor.select_levels()</li> <li>BaseAccessor.stack_index()</li> <li>BaseAccessor.tile()</li> <li>BaseAccessor.to_1d_array()</li> <li>BaseAccessor.to_2d_array()</li> <li>BaseAccessor.to_dict()</li> <li>BaseAccessor.unstack_to_array()</li> <li>BaseAccessor.unstack_to_df()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>GenericAccessor.apply_along_axis()</li> <li>GenericAccessor.apply_and_reduce()</li> <li>GenericAccessor.apply_mapping()</li> <li>GenericAccessor.applymap()</li> <li>GenericAccessor.barplot()</li> <li>GenericAccessor.bfill()</li> <li>GenericAccessor.binarize()</li> <li>GenericAccessor.boxplot()</li> <li>GenericAccessor.bshift()</li> <li>GenericAccessor.count()</li> <li>GenericAccessor.crossed_above()</li> <li>GenericAccessor.crossed_below()</li> <li>GenericAccessor.cumprod()</li> <li>GenericAccessor.cumsum()</li> <li>GenericAccessor.describe()</li> <li>GenericAccessor.diff()</li> <li>GenericAccessor.ewm_mean()</li> <li>GenericAccessor.ewm_std()</li> <li>GenericAccessor.expanding_apply()</li> <li>GenericAccessor.expanding_max()</li> <li>GenericAccessor.expanding_mean()</li> <li>GenericAccessor.expanding_min()</li> <li>GenericAccessor.expanding_split()</li> <li>GenericAccessor.expanding_std()</li> <li>GenericAccessor.ffill()</li> <li>GenericAccessor.fillna()</li> <li>GenericAccessor.filter()</li> <li>GenericAccessor.fshift()</li> <li>GenericAccessor.get_ranges()</li> <li>GenericAccessor.groupby_apply()</li> <li>GenericAccessor.histplot()</li> <li>GenericAccessor.idxmax()</li> <li>GenericAccessor.idxmin()</li> <li>GenericAccessor.lineplot()</li> <li>GenericAccessor.max()</li> <li>GenericAccessor.maxabs_scale()</li> <li>GenericAccessor.mean()</li> <li>GenericAccessor.median()</li> <li>GenericAccessor.min()</li> <li>GenericAccessor.minmax_scale()</li> <li>GenericAccessor.normalize()</li> <li>GenericAccessor.pct_change()</li> <li>GenericAccessor.plot()</li> <li>GenericAccessor.power_transform()</li> <li>GenericAccessor.product()</li> <li>GenericAccessor.quantile_transform()</li> <li>GenericAccessor.range_split()</li> <li>GenericAccessor.rebase()</li> <li>GenericAccessor.reduce()</li> <li>GenericAccessor.resample_apply()</li> <li>GenericAccessor.robust_scale()</li> <li>GenericAccessor.rolling_apply()</li> <li>GenericAccessor.rolling_max()</li> <li>GenericAccessor.rolling_mean()</li> <li>GenericAccessor.rolling_min()</li> <li>GenericAccessor.rolling_split()</li> <li>GenericAccessor.rolling_std()</li> <li>GenericAccessor.scale()</li> <li>GenericAccessor.scatterplot()</li> <li>GenericAccessor.shuffle()</li> <li>GenericAccessor.split()</li> <li>GenericAccessor.std()</li> <li>GenericAccessor.sum()</li> <li>GenericAccessor.to_mapped()</li> <li>GenericAccessor.to_returns()</li> <li>GenericAccessor.transform()</li> <li>GenericAccessor.value_counts()</li> <li>GenericAccessor.zscore()</li> <li>GenericDFAccessor.flatten_grouped()</li> <li>GenericDFAccessor.heatmap()</li> <li>GenericDFAccessor.squeeze_grouped()</li> <li>GenericDFAccessor.ts_heatmap()</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>ReturnsAccessor.alpha()</li> <li>ReturnsAccessor.ann_factor</li> <li>ReturnsAccessor.annual()</li> <li>ReturnsAccessor.annualized()</li> <li>ReturnsAccessor.annualized_volatility()</li> <li>ReturnsAccessor.benchmark_rets</li> <li>ReturnsAccessor.beta()</li> <li>ReturnsAccessor.calmar_ratio()</li> <li>ReturnsAccessor.capture()</li> <li>ReturnsAccessor.common_sense_ratio()</li> <li>ReturnsAccessor.cond_value_at_risk()</li> <li>ReturnsAccessor.config</li> <li>ReturnsAccessor.cumulative()</li> <li>ReturnsAccessor.daily()</li> <li>ReturnsAccessor.defaults</li> <li>ReturnsAccessor.deflated_sharpe_ratio()</li> <li>ReturnsAccessor.df_accessor_cls</li> <li>ReturnsAccessor.down_capture()</li> <li>ReturnsAccessor.downside_risk()</li> <li>ReturnsAccessor.drawdown()</li> <li>ReturnsAccessor.drawdowns</li> <li>ReturnsAccessor.from_value()</li> <li>ReturnsAccessor.get_drawdowns()</li> <li>ReturnsAccessor.iloc</li> <li>ReturnsAccessor.indexing_func()</li> <li>ReturnsAccessor.indexing_kwargs</li> <li>ReturnsAccessor.information_ratio()</li> <li>ReturnsAccessor.loc</li> <li>ReturnsAccessor.mapping</li> <li>ReturnsAccessor.max_drawdown()</li> <li>ReturnsAccessor.obj</li> <li>ReturnsAccessor.omega_ratio()</li> <li>ReturnsAccessor.plots_defaults</li> <li>ReturnsAccessor.qs</li> <li>ReturnsAccessor.ranges</li> <li>ReturnsAccessor.resolve_self()</li> <li>ReturnsAccessor.rolling_alpha()</li> <li>ReturnsAccessor.rolling_annualized()</li> <li>ReturnsAccessor.rolling_annualized_volatility()</li> <li>ReturnsAccessor.rolling_beta()</li> <li>ReturnsAccessor.rolling_calmar_ratio()</li> <li>ReturnsAccessor.rolling_capture()</li> <li>ReturnsAccessor.rolling_common_sense_ratio()</li> <li>ReturnsAccessor.rolling_cond_value_at_risk()</li> <li>ReturnsAccessor.rolling_down_capture()</li> <li>ReturnsAccessor.rolling_downside_risk()</li> <li>ReturnsAccessor.rolling_information_ratio()</li> <li>ReturnsAccessor.rolling_max_drawdown()</li> <li>ReturnsAccessor.rolling_omega_ratio()</li> <li>ReturnsAccessor.rolling_sharpe_ratio()</li> <li>ReturnsAccessor.rolling_sortino_ratio()</li> <li>ReturnsAccessor.rolling_tail_ratio()</li> <li>ReturnsAccessor.rolling_total()</li> <li>ReturnsAccessor.rolling_up_capture()</li> <li>ReturnsAccessor.rolling_value_at_risk()</li> <li>ReturnsAccessor.self_aliases</li> <li>ReturnsAccessor.sharpe_ratio()</li> <li>ReturnsAccessor.sortino_ratio()</li> <li>ReturnsAccessor.sr_accessor_cls</li> <li>ReturnsAccessor.stats_defaults</li> <li>ReturnsAccessor.tail_ratio()</li> <li>ReturnsAccessor.total()</li> <li>ReturnsAccessor.up_capture()</li> <li>ReturnsAccessor.value_at_risk()</li> <li>ReturnsAccessor.wrapper</li> <li>ReturnsAccessor.writeable_attrs</li> <li>ReturnsAccessor.year_freq</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul>","title":"ReturnsDFAccessor class"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsSRAccessor","text":"<pre><code>ReturnsSRAccessor(\n    obj,\n    benchmark_rets=None,\n    year_freq=None,\n    defaults=None,\n    **kwargs\n)\n</code></pre> <p>Accessor on top of return series. For Series only.</p> <p>Accessible through <code>pd.Series.vbt.returns</code>.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>BaseAccessor</li> <li>BaseSRAccessor</li> <li>Configured</li> <li>Documented</li> <li>GenericAccessor</li> <li>GenericSRAccessor</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>ReturnsAccessor</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>BaseAccessor.align_to()</li> <li>BaseAccessor.apply()</li> <li>BaseAccessor.apply_and_concat()</li> <li>BaseAccessor.apply_on_index()</li> <li>BaseAccessor.broadcast()</li> <li>BaseAccessor.broadcast_to()</li> <li>BaseAccessor.combine()</li> <li>BaseAccessor.concat()</li> <li>BaseAccessor.drop_duplicate_levels()</li> <li>BaseAccessor.drop_levels()</li> <li>BaseAccessor.drop_redundant_levels()</li> <li>BaseAccessor.empty()</li> <li>BaseAccessor.empty_like()</li> <li>BaseAccessor.make_symmetric()</li> <li>BaseAccessor.rename_levels()</li> <li>BaseAccessor.repeat()</li> <li>BaseAccessor.select_levels()</li> <li>BaseAccessor.stack_index()</li> <li>BaseAccessor.tile()</li> <li>BaseAccessor.to_1d_array()</li> <li>BaseAccessor.to_2d_array()</li> <li>BaseAccessor.to_dict()</li> <li>BaseAccessor.unstack_to_array()</li> <li>BaseAccessor.unstack_to_df()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>GenericAccessor.apply_along_axis()</li> <li>GenericAccessor.apply_and_reduce()</li> <li>GenericAccessor.apply_mapping()</li> <li>GenericAccessor.applymap()</li> <li>GenericAccessor.barplot()</li> <li>GenericAccessor.bfill()</li> <li>GenericAccessor.binarize()</li> <li>GenericAccessor.boxplot()</li> <li>GenericAccessor.bshift()</li> <li>GenericAccessor.count()</li> <li>GenericAccessor.crossed_above()</li> <li>GenericAccessor.crossed_below()</li> <li>GenericAccessor.cumprod()</li> <li>GenericAccessor.cumsum()</li> <li>GenericAccessor.describe()</li> <li>GenericAccessor.diff()</li> <li>GenericAccessor.ewm_mean()</li> <li>GenericAccessor.ewm_std()</li> <li>GenericAccessor.expanding_apply()</li> <li>GenericAccessor.expanding_max()</li> <li>GenericAccessor.expanding_mean()</li> <li>GenericAccessor.expanding_min()</li> <li>GenericAccessor.expanding_split()</li> <li>GenericAccessor.expanding_std()</li> <li>GenericAccessor.ffill()</li> <li>GenericAccessor.fillna()</li> <li>GenericAccessor.filter()</li> <li>GenericAccessor.fshift()</li> <li>GenericAccessor.get_ranges()</li> <li>GenericAccessor.groupby_apply()</li> <li>GenericAccessor.histplot()</li> <li>GenericAccessor.idxmax()</li> <li>GenericAccessor.idxmin()</li> <li>GenericAccessor.lineplot()</li> <li>GenericAccessor.max()</li> <li>GenericAccessor.maxabs_scale()</li> <li>GenericAccessor.mean()</li> <li>GenericAccessor.median()</li> <li>GenericAccessor.min()</li> <li>GenericAccessor.minmax_scale()</li> <li>GenericAccessor.normalize()</li> <li>GenericAccessor.pct_change()</li> <li>GenericAccessor.plot()</li> <li>GenericAccessor.power_transform()</li> <li>GenericAccessor.product()</li> <li>GenericAccessor.quantile_transform()</li> <li>GenericAccessor.range_split()</li> <li>GenericAccessor.rebase()</li> <li>GenericAccessor.reduce()</li> <li>GenericAccessor.resample_apply()</li> <li>GenericAccessor.robust_scale()</li> <li>GenericAccessor.rolling_apply()</li> <li>GenericAccessor.rolling_max()</li> <li>GenericAccessor.rolling_mean()</li> <li>GenericAccessor.rolling_min()</li> <li>GenericAccessor.rolling_split()</li> <li>GenericAccessor.rolling_std()</li> <li>GenericAccessor.scale()</li> <li>GenericAccessor.scatterplot()</li> <li>GenericAccessor.shuffle()</li> <li>GenericAccessor.split()</li> <li>GenericAccessor.std()</li> <li>GenericAccessor.sum()</li> <li>GenericAccessor.to_mapped()</li> <li>GenericAccessor.to_returns()</li> <li>GenericAccessor.transform()</li> <li>GenericAccessor.value_counts()</li> <li>GenericAccessor.zscore()</li> <li>GenericSRAccessor.flatten_grouped()</li> <li>GenericSRAccessor.heatmap()</li> <li>GenericSRAccessor.overlay_with_heatmap()</li> <li>GenericSRAccessor.plot_against()</li> <li>GenericSRAccessor.qqplot()</li> <li>GenericSRAccessor.squeeze_grouped()</li> <li>GenericSRAccessor.ts_heatmap()</li> <li>GenericSRAccessor.volume()</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>ReturnsAccessor.alpha()</li> <li>ReturnsAccessor.ann_factor</li> <li>ReturnsAccessor.annual()</li> <li>ReturnsAccessor.annualized()</li> <li>ReturnsAccessor.annualized_volatility()</li> <li>ReturnsAccessor.benchmark_rets</li> <li>ReturnsAccessor.beta()</li> <li>ReturnsAccessor.calmar_ratio()</li> <li>ReturnsAccessor.capture()</li> <li>ReturnsAccessor.common_sense_ratio()</li> <li>ReturnsAccessor.cond_value_at_risk()</li> <li>ReturnsAccessor.config</li> <li>ReturnsAccessor.cumulative()</li> <li>ReturnsAccessor.daily()</li> <li>ReturnsAccessor.defaults</li> <li>ReturnsAccessor.deflated_sharpe_ratio()</li> <li>ReturnsAccessor.df_accessor_cls</li> <li>ReturnsAccessor.down_capture()</li> <li>ReturnsAccessor.downside_risk()</li> <li>ReturnsAccessor.drawdown()</li> <li>ReturnsAccessor.drawdowns</li> <li>ReturnsAccessor.from_value()</li> <li>ReturnsAccessor.get_drawdowns()</li> <li>ReturnsAccessor.iloc</li> <li>ReturnsAccessor.indexing_func()</li> <li>ReturnsAccessor.indexing_kwargs</li> <li>ReturnsAccessor.information_ratio()</li> <li>ReturnsAccessor.loc</li> <li>ReturnsAccessor.mapping</li> <li>ReturnsAccessor.max_drawdown()</li> <li>ReturnsAccessor.obj</li> <li>ReturnsAccessor.omega_ratio()</li> <li>ReturnsAccessor.plots_defaults</li> <li>ReturnsAccessor.qs</li> <li>ReturnsAccessor.ranges</li> <li>ReturnsAccessor.resolve_self()</li> <li>ReturnsAccessor.rolling_alpha()</li> <li>ReturnsAccessor.rolling_annualized()</li> <li>ReturnsAccessor.rolling_annualized_volatility()</li> <li>ReturnsAccessor.rolling_beta()</li> <li>ReturnsAccessor.rolling_calmar_ratio()</li> <li>ReturnsAccessor.rolling_capture()</li> <li>ReturnsAccessor.rolling_common_sense_ratio()</li> <li>ReturnsAccessor.rolling_cond_value_at_risk()</li> <li>ReturnsAccessor.rolling_down_capture()</li> <li>ReturnsAccessor.rolling_downside_risk()</li> <li>ReturnsAccessor.rolling_information_ratio()</li> <li>ReturnsAccessor.rolling_max_drawdown()</li> <li>ReturnsAccessor.rolling_omega_ratio()</li> <li>ReturnsAccessor.rolling_sharpe_ratio()</li> <li>ReturnsAccessor.rolling_sortino_ratio()</li> <li>ReturnsAccessor.rolling_tail_ratio()</li> <li>ReturnsAccessor.rolling_total()</li> <li>ReturnsAccessor.rolling_up_capture()</li> <li>ReturnsAccessor.rolling_value_at_risk()</li> <li>ReturnsAccessor.self_aliases</li> <li>ReturnsAccessor.sharpe_ratio()</li> <li>ReturnsAccessor.sortino_ratio()</li> <li>ReturnsAccessor.sr_accessor_cls</li> <li>ReturnsAccessor.stats_defaults</li> <li>ReturnsAccessor.tail_ratio()</li> <li>ReturnsAccessor.total()</li> <li>ReturnsAccessor.up_capture()</li> <li>ReturnsAccessor.value_at_risk()</li> <li>ReturnsAccessor.wrapper</li> <li>ReturnsAccessor.writeable_attrs</li> <li>ReturnsAccessor.year_freq</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul>","title":"ReturnsSRAccessor class"},{"location":"api/returns/accessors/#vectorbt.returns.accessors.ReturnsSRAccessor.plot_cumulative","text":"<pre><code>ReturnsSRAccessor.plot_cumulative(\n    benchmark_rets=None,\n    start_value=1,\n    fill_to_benchmark=False,\n    main_kwargs=None,\n    benchmark_kwargs=None,\n    hline_shape_kwargs=None,\n    add_trace_kwargs=None,\n    xref='x',\n    yref='y',\n    fig=None,\n    **layout_kwargs\n)\n</code></pre> <p>Plot cumulative returns.</p> <p>Args</p>  <code>benchmark_rets</code> :\u2002<code>array_like</code> Benchmark return to compare returns against. Will broadcast per element. <code>start_value</code> :\u2002<code>float</code> The starting returns. <code>fill_to_benchmark</code> :\u2002<code>bool</code> Whether to fill between main and benchmark, or between main and <code>start_value</code>. <code>main_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to GenericAccessor.plot() for main. <code>benchmark_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to GenericAccessor.plot() for benchmark. <code>hline_shape_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for <code>start_value</code> line. <code>add_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>add_trace</code>. <code>xref</code> :\u2002<code>str</code> X coordinate axis. <code>yref</code> :\u2002<code>str</code> Y coordinate axis. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**layout_kwargs</code> Keyword arguments for layout.  <p>Usage</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import numpy as np\n\n&gt;&gt;&gt; np.random.seed(0)\n&gt;&gt;&gt; rets = pd.Series(np.random.uniform(-0.05, 0.05, size=100))\n&gt;&gt;&gt; benchmark_rets = pd.Series(np.random.uniform(-0.05, 0.05, size=100))\n&gt;&gt;&gt; rets.vbt.returns.plot_cumulative(benchmark_rets=benchmark_rets)\n</code></pre> <p></p>","title":"plot_cumulative method"},{"location":"api/returns/metrics/","text":"<p>Other metrics that are not compiled with Numba.</p>","title":"metrics"},{"location":"api/returns/metrics/#vectorbt.returns.metrics.approx_exp_max_sharpe","text":"<pre><code>approx_exp_max_sharpe(\n    mean_sharpe,\n    var_sharpe,\n    nb_trials\n)\n</code></pre> <p>Expected Maximum Sharpe Ratio.</p>","title":"approx_exp_max_sharpe function"},{"location":"api/returns/metrics/#vectorbt.returns.metrics.deflated_sharpe_ratio","text":"<pre><code>deflated_sharpe_ratio(\n    *,\n    est_sharpe,\n    var_sharpe,\n    nb_trials,\n    backtest_horizon,\n    skew,\n    kurtosis\n)\n</code></pre> <p>Deflated Sharpe Ratio (DSR).</p> <p>See Deflated Sharpe Ratio.</p>","title":"deflated_sharpe_ratio function"},{"location":"api/returns/nb/","text":"<p>Numba-compiled functions.</p> <p>Provides an arsenal of Numba-compiled functions that are used by accessors and for measuring portfolio performance. These only accept NumPy arrays and other Numba-compatible types.</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; price = np.array([1.1, 1.2, 1.3, 1.2, 1.1])\n&gt;&gt;&gt; returns = vbt.generic.nb.pct_change_1d_nb(price)\n\n&gt;&gt;&gt; # vectorbt.returns.nb.cum_returns_1d_nb\n&gt;&gt;&gt; vbt.returns.nb.cum_returns_1d_nb(returns, 0)\narray([0., 0.09090909, 0.18181818, 0.09090909, 0.])\n</code></pre>  <p>Note</p> <p>vectorbt treats matrices as first-class citizens and expects input arrays to be 2-dim, unless function has suffix <code>_1d</code> or is meant to be input to another function. Data is processed along index (axis 0).</p> <p>All functions passed as argument should be Numba-compiled.</p>","title":"nb"},{"location":"api/returns/nb/#vectorbt.returns.nb.alpha_1d_nb","text":"<pre><code>alpha_1d_nb(\n    returns,\n    benchmark_rets,\n    ann_factor,\n    risk_free=0.0\n)\n</code></pre> <p>Annualized alpha.</p>","title":"alpha_1d_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.alpha_nb","text":"<pre><code>alpha_nb(\n    returns,\n    benchmark_rets,\n    ann_factor,\n    risk_free=0.0\n)\n</code></pre> <p>2-dim version of alpha_1d_nb().</p>","title":"alpha_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.annualized_return_1d_nb","text":"<pre><code>annualized_return_1d_nb(\n    returns,\n    ann_factor\n)\n</code></pre> <p>Mean annual growth rate of returns.</p> <p>This is equivalent to the compound annual growth rate.</p>","title":"annualized_return_1d_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.annualized_return_nb","text":"<pre><code>annualized_return_nb(\n    returns,\n    ann_factor\n)\n</code></pre> <p>2-dim version of annualized_return_1d_nb().</p>","title":"annualized_return_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.annualized_volatility_1d_nb","text":"<pre><code>annualized_volatility_1d_nb(\n    returns,\n    ann_factor,\n    levy_alpha=2.0,\n    ddof=1\n)\n</code></pre> <p>Annualized volatility of a strategy.</p>","title":"annualized_volatility_1d_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.annualized_volatility_nb","text":"<pre><code>annualized_volatility_nb(\n    returns,\n    ann_factor,\n    levy_alpha=2.0,\n    ddof=1\n)\n</code></pre> <p>2-dim version of annualized_volatility_1d_nb().</p>","title":"annualized_volatility_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.beta_1d_nb","text":"<pre><code>beta_1d_nb(\n    returns,\n    benchmark_rets\n)\n</code></pre> <p>Beta.</p>","title":"beta_1d_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.beta_nb","text":"<pre><code>beta_nb(\n    returns,\n    benchmark_rets\n)\n</code></pre> <p>2-dim version of beta_1d_nb().</p>","title":"beta_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.calmar_ratio_1d_nb","text":"<pre><code>calmar_ratio_1d_nb(\n    returns,\n    ann_factor\n)\n</code></pre> <p>Calmar ratio, or drawdown ratio, of a strategy.</p>","title":"calmar_ratio_1d_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.calmar_ratio_nb","text":"<pre><code>calmar_ratio_nb(\n    returns,\n    ann_factor\n)\n</code></pre> <p>2-dim version of calmar_ratio_1d_nb().</p>","title":"calmar_ratio_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.capture_1d_nb","text":"<pre><code>capture_1d_nb(\n    returns,\n    benchmark_rets,\n    ann_factor\n)\n</code></pre> <p>Capture ratio.</p>","title":"capture_1d_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.capture_nb","text":"<pre><code>capture_nb(\n    returns,\n    benchmark_rets,\n    ann_factor\n)\n</code></pre> <p>2-dim version of capture_1d_nb().</p>","title":"capture_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.cond_value_at_risk_1d_nb","text":"<pre><code>cond_value_at_risk_1d_nb(\n    returns,\n    cutoff=0.05\n)\n</code></pre> <p>Conditional value at risk (CVaR) of a returns stream.</p>","title":"cond_value_at_risk_1d_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.cond_value_at_risk_nb","text":"<pre><code>cond_value_at_risk_nb(\n    returns,\n    cutoff=0.05\n)\n</code></pre> <p>2-dim version of cond_value_at_risk_1d_nb().</p>","title":"cond_value_at_risk_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.cum_returns_1d_nb","text":"<pre><code>cum_returns_1d_nb(\n    returns,\n    start_value\n)\n</code></pre> <p>Cumulative returns.</p>","title":"cum_returns_1d_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.cum_returns_final_1d_nb","text":"<pre><code>cum_returns_final_1d_nb(\n    returns,\n    start_value=0.0\n)\n</code></pre> <p>Total return.</p>","title":"cum_returns_final_1d_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.cum_returns_final_nb","text":"<pre><code>cum_returns_final_nb(\n    returns,\n    start_value=0.0\n)\n</code></pre> <p>2-dim version of cum_returns_final_1d_nb().</p>","title":"cum_returns_final_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.cum_returns_nb","text":"<pre><code>cum_returns_nb(\n    returns,\n    start_value\n)\n</code></pre> <p>2-dim version of cum_returns_1d_nb().</p>","title":"cum_returns_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.down_capture_1d_nb","text":"<pre><code>down_capture_1d_nb(\n    returns,\n    benchmark_rets,\n    ann_factor\n)\n</code></pre> <p>Capture ratio for periods when the benchmark return is negative.</p>","title":"down_capture_1d_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.down_capture_nb","text":"<pre><code>down_capture_nb(\n    returns,\n    benchmark_rets,\n    ann_factor\n)\n</code></pre> <p>2-dim version of down_capture_1d_nb().</p>","title":"down_capture_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.downside_risk_1d_nb","text":"<pre><code>downside_risk_1d_nb(\n    returns,\n    ann_factor,\n    required_return=0.0\n)\n</code></pre> <p>Downside deviation below a threshold.</p>","title":"downside_risk_1d_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.downside_risk_nb","text":"<pre><code>downside_risk_nb(\n    returns,\n    ann_factor,\n    required_return=0.0\n)\n</code></pre> <p>2-dim version of downside_risk_1d_nb().</p>","title":"downside_risk_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.drawdown_1d_nb","text":"<pre><code>drawdown_1d_nb(\n    returns\n)\n</code></pre> <p>Drawdown of cumulative returns.</p>","title":"drawdown_1d_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.drawdown_nb","text":"<pre><code>drawdown_nb(\n    returns\n)\n</code></pre> <p>2-dim version of drawdown_1d_nb().</p>","title":"drawdown_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.get_return_nb","text":"<pre><code>get_return_nb(\n    input_value,\n    output_value\n)\n</code></pre> <p>Calculate return from input and output value.</p>","title":"get_return_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.information_ratio_1d_nb","text":"<pre><code>information_ratio_1d_nb(\n    returns,\n    benchmark_rets,\n    ddof=1\n)\n</code></pre> <p>Information ratio of a strategy.</p>","title":"information_ratio_1d_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.information_ratio_nb","text":"<pre><code>information_ratio_nb(\n    returns,\n    benchmark_rets,\n    ddof=1\n)\n</code></pre> <p>2-dim version of information_ratio_1d_nb().</p>","title":"information_ratio_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.max_drawdown_1d_nb","text":"<pre><code>max_drawdown_1d_nb(\n    returns\n)\n</code></pre> <p>Total maximum drawdown (MDD).</p>","title":"max_drawdown_1d_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.max_drawdown_nb","text":"<pre><code>max_drawdown_nb(\n    returns\n)\n</code></pre> <p>2-dim version of max_drawdown_1d_nb().</p>","title":"max_drawdown_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.omega_ratio_1d_nb","text":"<pre><code>omega_ratio_1d_nb(\n    returns,\n    ann_factor,\n    risk_free=0.0,\n    required_return=0.0\n)\n</code></pre> <p>Omega ratio of a strategy..</p>","title":"omega_ratio_1d_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.omega_ratio_nb","text":"<pre><code>omega_ratio_nb(\n    returns,\n    ann_factor,\n    risk_free=0.0,\n    required_return=0.0\n)\n</code></pre> <p>2-dim version of omega_ratio_1d_nb().</p>","title":"omega_ratio_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.returns_1d_nb","text":"<pre><code>returns_1d_nb(\n    value,\n    init_value\n)\n</code></pre> <p>Calculate returns from value.</p>","title":"returns_1d_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.returns_nb","text":"<pre><code>returns_nb(\n    value,\n    init_value\n)\n</code></pre> <p>2-dim version of returns_1d_nb().</p>","title":"returns_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.rolling_alpha_nb","text":"<pre><code>rolling_alpha_nb(\n    returns,\n    window,\n    minp,\n    benchmark_rets,\n    ann_factor,\n    risk_free=0.0\n)\n</code></pre> <p>Rolling version of alpha_nb().</p>","title":"rolling_alpha_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.rolling_annualized_return_nb","text":"<pre><code>rolling_annualized_return_nb(\n    returns,\n    window,\n    minp,\n    ann_factor\n)\n</code></pre> <p>Rolling version of annualized_return_nb().</p>","title":"rolling_annualized_return_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.rolling_annualized_volatility_nb","text":"<pre><code>rolling_annualized_volatility_nb(\n    returns,\n    window,\n    minp,\n    ann_factor,\n    levy_alpha=2.0,\n    ddof=1\n)\n</code></pre> <p>Rolling version of annualized_volatility_nb().</p>","title":"rolling_annualized_volatility_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.rolling_beta_nb","text":"<pre><code>rolling_beta_nb(\n    returns,\n    window,\n    minp,\n    benchmark_rets\n)\n</code></pre> <p>Rolling version of beta_nb().</p>","title":"rolling_beta_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.rolling_calmar_ratio_nb","text":"<pre><code>rolling_calmar_ratio_nb(\n    returns,\n    window,\n    minp,\n    ann_factor\n)\n</code></pre> <p>Rolling version of calmar_ratio_nb().</p>","title":"rolling_calmar_ratio_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.rolling_capture_nb","text":"<pre><code>rolling_capture_nb(\n    returns,\n    window,\n    minp,\n    benchmark_rets,\n    ann_factor\n)\n</code></pre> <p>Rolling version of capture_nb().</p>","title":"rolling_capture_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.rolling_cond_value_at_risk_nb","text":"<pre><code>rolling_cond_value_at_risk_nb(\n    returns,\n    window,\n    minp,\n    cutoff=0.05\n)\n</code></pre> <p>Rolling version of cond_value_at_risk_nb().</p>","title":"rolling_cond_value_at_risk_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.rolling_cum_returns_final_nb","text":"<pre><code>rolling_cum_returns_final_nb(\n    returns,\n    window,\n    minp,\n    start_value=0.0\n)\n</code></pre> <p>Rolling version of cum_returns_final_nb().</p>","title":"rolling_cum_returns_final_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.rolling_down_capture_nb","text":"<pre><code>rolling_down_capture_nb(\n    returns,\n    window,\n    minp,\n    benchmark_rets,\n    ann_factor\n)\n</code></pre> <p>Rolling version of down_capture_nb().</p>","title":"rolling_down_capture_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.rolling_downside_risk_nb","text":"<pre><code>rolling_downside_risk_nb(\n    returns,\n    window,\n    minp,\n    ann_factor,\n    required_return=0.0\n)\n</code></pre> <p>Rolling version of downside_risk_nb().</p>","title":"rolling_downside_risk_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.rolling_information_ratio_nb","text":"<pre><code>rolling_information_ratio_nb(\n    returns,\n    window,\n    minp,\n    benchmark_rets,\n    ddof=1\n)\n</code></pre> <p>Rolling version of information_ratio_nb().</p>","title":"rolling_information_ratio_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.rolling_max_drawdown_nb","text":"<pre><code>rolling_max_drawdown_nb(\n    returns,\n    window,\n    minp\n)\n</code></pre> <p>Rolling version of max_drawdown_nb().</p>","title":"rolling_max_drawdown_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.rolling_omega_ratio_nb","text":"<pre><code>rolling_omega_ratio_nb(\n    returns,\n    window,\n    minp,\n    ann_factor,\n    risk_free=0.0,\n    required_return=0.0\n)\n</code></pre> <p>Rolling version of omega_ratio_nb().</p>","title":"rolling_omega_ratio_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.rolling_sharpe_ratio_nb","text":"<pre><code>rolling_sharpe_ratio_nb(\n    returns,\n    window,\n    minp,\n    ann_factor,\n    risk_free=0.0,\n    ddof=1\n)\n</code></pre> <p>Rolling version of sharpe_ratio_nb().</p>","title":"rolling_sharpe_ratio_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.rolling_sortino_ratio_nb","text":"<pre><code>rolling_sortino_ratio_nb(\n    returns,\n    window,\n    minp,\n    ann_factor,\n    required_return=0.0\n)\n</code></pre> <p>Rolling version of sortino_ratio_nb().</p>","title":"rolling_sortino_ratio_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.rolling_tail_ratio_nb","text":"<pre><code>rolling_tail_ratio_nb(\n    returns,\n    window,\n    minp\n)\n</code></pre> <p>Rolling version of tail_ratio_nb().</p>","title":"rolling_tail_ratio_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.rolling_up_capture_nb","text":"<pre><code>rolling_up_capture_nb(\n    returns,\n    window,\n    minp,\n    benchmark_rets,\n    ann_factor\n)\n</code></pre> <p>Rolling version of up_capture_nb().</p>","title":"rolling_up_capture_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.rolling_value_at_risk_nb","text":"<pre><code>rolling_value_at_risk_nb(\n    returns,\n    window,\n    minp,\n    cutoff=0.05\n)\n</code></pre> <p>Rolling version of value_at_risk_nb().</p>","title":"rolling_value_at_risk_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.sharpe_ratio_1d_nb","text":"<pre><code>sharpe_ratio_1d_nb(\n    returns,\n    ann_factor,\n    risk_free=0.0,\n    ddof=1\n)\n</code></pre> <p>Sharpe ratio of a strategy.</p>","title":"sharpe_ratio_1d_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.sharpe_ratio_nb","text":"<pre><code>sharpe_ratio_nb(\n    returns,\n    ann_factor,\n    risk_free=0.0,\n    ddof=1\n)\n</code></pre> <p>2-dim version of sharpe_ratio_1d_nb().</p>","title":"sharpe_ratio_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.sortino_ratio_1d_nb","text":"<pre><code>sortino_ratio_1d_nb(\n    returns,\n    ann_factor,\n    required_return=0.0\n)\n</code></pre> <p>Sortino ratio of a strategy.</p>","title":"sortino_ratio_1d_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.sortino_ratio_nb","text":"<pre><code>sortino_ratio_nb(\n    returns,\n    ann_factor,\n    required_return=0.0\n)\n</code></pre> <p>2-dim version of sortino_ratio_1d_nb().</p>","title":"sortino_ratio_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.tail_ratio_1d_nb","text":"<pre><code>tail_ratio_1d_nb(\n    returns\n)\n</code></pre> <p>Ratio between the right (95%) and left tail (5%).</p>","title":"tail_ratio_1d_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.tail_ratio_nb","text":"<pre><code>tail_ratio_nb(\n    returns\n)\n</code></pre> <p>2-dim version of tail_ratio_1d_nb().</p>","title":"tail_ratio_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.total_return_apply_nb","text":"<pre><code>total_return_apply_nb(\n    idxs,\n    col,\n    returns\n)\n</code></pre> <p>Calculate total return from returns.</p>","title":"total_return_apply_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.up_capture_1d_nb","text":"<pre><code>up_capture_1d_nb(\n    returns,\n    benchmark_rets,\n    ann_factor\n)\n</code></pre> <p>Capture ratio for periods when the benchmark return is positive.</p>","title":"up_capture_1d_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.up_capture_nb","text":"<pre><code>up_capture_nb(\n    returns,\n    benchmark_rets,\n    ann_factor\n)\n</code></pre> <p>2-dim version of up_capture_1d_nb().</p>","title":"up_capture_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.value_at_risk_1d_nb","text":"<pre><code>value_at_risk_1d_nb(\n    returns,\n    cutoff=0.05\n)\n</code></pre> <p>Value at risk (VaR) of a returns stream.</p>","title":"value_at_risk_1d_nb function"},{"location":"api/returns/nb/#vectorbt.returns.nb.value_at_risk_nb","text":"<pre><code>value_at_risk_nb(\n    returns,\n    cutoff=0.05\n)\n</code></pre> <p>2-dim version of value_at_risk_1d_nb().</p>","title":"value_at_risk_nb function"},{"location":"api/returns/qs_adapter/","text":"<p>Adapter class for quantstats.</p>  <p>Note</p> <p>Accessors do not utilize caching.</p>  <p>We can access the adapter from <code>ReturnsAccessor</code>:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import vectorbt as vbt\n&gt;&gt;&gt; import quantstats as qs\n\n&gt;&gt;&gt; np.random.seed(42)\n&gt;&gt;&gt; rets = pd.Series(np.random.uniform(-0.1, 0.1, size=(100,)))\n&gt;&gt;&gt; benchmark_rets = pd.Series(np.random.uniform(-0.1, 0.1, size=(100,)))\n\n&gt;&gt;&gt; rets.vbt.returns.qs.r_squared(benchmark=benchmark_rets)\n0.0011582111228735541\n</code></pre> <p>Which is the same as:</p> <pre><code>&gt;&gt;&gt; qs.stats.r_squared(rets, benchmark_rets)\n</code></pre> <p>So why not just using <code>qs.stats</code>?</p> <p>First, we can define all parameters such as benchmark returns once and avoid passing them repeatedly to every function. Second, vectorbt automatically translates parameters passed to <code>ReturnsAccessor</code> for the use in quantstats.</p> <pre><code>&gt;&gt;&gt; # Defaults that vectorbt understands\n&gt;&gt;&gt; ret_acc = rets.vbt.returns(\n...     benchmark_rets=benchmark_rets,\n...     freq='d',\n...     year_freq='365d',\n...     defaults=dict(risk_free=0.001)\n... )\n\n&gt;&gt;&gt; ret_acc.qs.r_squared()\n0.0011582111228735541\n\n&gt;&gt;&gt; ret_acc.qs.sharpe()\n-1.9158923252075455\n\n&gt;&gt;&gt; # Defaults that only quantstats understands\n&gt;&gt;&gt; qs_defaults = dict(\n...     benchmark=benchmark_rets,\n...     periods=365,\n...     periods_per_year=365,\n...     rf=0.001\n... )\n&gt;&gt;&gt; ret_acc_qs = rets.vbt.returns.qs(defaults=qs_defaults)\n\n&gt;&gt;&gt; ret_acc_qs.r_squared()\n0.0011582111228735541\n\n&gt;&gt;&gt; ret_acc_qs.sharpe()\n-1.9158923252075455\n</code></pre> <p>The adapter automatically passes the returns to the particular function. It also merges the defaults defined in the settings, the defaults passed to <code>ReturnsAccessor</code>, and the defaults passed to QSAdapter itself, and matches them with the argument names listed in the function's signature.</p> <p>For example, the <code>periods</code> and <code>periods_per_year</code> arguments default to the annualization factor <code>ReturnsAccessor.ann_factor</code>, which itself is based on the <code>freq</code> argument. This makes the results produced by quantstats and vectorbt at least somewhat similar.</p> <pre><code>&gt;&gt;&gt; vbt.settings.array_wrapper['freq'] = 'h'\n&gt;&gt;&gt; vbt.settings.returns['year_freq'] = '365d'\n\n&gt;&gt;&gt; rets.vbt.returns.sharpe_ratio()  # ReturnsAccessor\n-9.38160953971508\n\n&gt;&gt;&gt; rets.vbt.returns.qs.sharpe()  # quantstats via QSAdapter\n-9.38160953971508\n</code></pre> <p>We can still override any argument by overriding its default or by passing it directly to the function:</p> <pre><code>&gt;&gt;&gt; rets.vbt.returns.qs(defaults=dict(periods=252)).sharpe()\n-1.5912029345745982\n\n&gt;&gt;&gt; rets.vbt.returns.qs.sharpe(periods=252)\n-1.5912029345745982\n\n&gt;&gt;&gt; qs.stats.sharpe(rets)\n-1.5912029345745982\n</code></pre>","title":"qs_adapter"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.attach_qs_methods","text":"<pre><code>attach_qs_methods(\n    cls,\n    replace_signature=True\n)\n</code></pre> <p>Class decorator to attach quantstats methods.</p>","title":"attach_qs_methods function"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter","text":"<pre><code>QSAdapter(\n    returns_accessor,\n    defaults=None,\n    **kwargs\n)\n</code></pre> <p>Adapter class for quantstats.</p> <p>Superclasses</p> <ul> <li>Configured</li> <li>Documented</li> <li>Pickleable</li> </ul> <p>Inherited members</p> <ul> <li>Configured.config</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>Configured.writeable_attrs</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> </ul>","title":"QSAdapter class"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.defaults","text":"<p>Defaults for QSAdapter.</p> <p>Merges <code>qs_adapter.defaults</code> from settings, <code>returns_accessor.defaults</code> (with adapted naming), and <code>defaults</code> from QSAdapter.</p>","title":"defaults property"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.defaults_mapping","text":"<p>Common argument names in quantstats mapped to <code>ReturnsAccessor.defaults</code>.</p>","title":"defaults_mapping property"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.returns_accessor","text":"<p>Returns accessor.</p>","title":"returns_accessor property"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.adjusted_sortino","text":"<pre><code>QSAdapter.adjusted_sortino(\n    *,\n    rf=0,\n    periods=252,\n    annualize=True,\n    smart=False\n)\n</code></pre> <p>See <code>quantstats.stats.adjusted_sortino</code>.</p>","title":"adjusted_sortino method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.aggregate_returns","text":"<pre><code>QSAdapter.aggregate_returns(\n    *,\n    period=None,\n    compounded=True\n)\n</code></pre> <p>See <code>quantstats.utils.aggregate_returns</code>.</p>","title":"aggregate_returns method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.autocorr_penalty","text":"<pre><code>QSAdapter.autocorr_penalty(\n    *,\n    prepare_returns=False\n)\n</code></pre> <p>See <code>quantstats.stats.autocorr_penalty</code>.</p>","title":"autocorr_penalty method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.avg_loss","text":"<pre><code>QSAdapter.avg_loss(\n    *,\n    aggregate=None,\n    compounded=True,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.avg_loss</code>.</p>","title":"avg_loss method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.avg_return","text":"<pre><code>QSAdapter.avg_return(\n    *,\n    aggregate=None,\n    compounded=True,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.avg_return</code>.</p>","title":"avg_return method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.avg_win","text":"<pre><code>QSAdapter.avg_win(\n    *,\n    aggregate=None,\n    compounded=True,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.avg_win</code>.</p>","title":"avg_win method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.basic_report","text":"<pre><code>QSAdapter.basic_report(\n    *,\n    benchmark=None,\n    rf=0.0,\n    grayscale=False,\n    figsize=(8, 5),\n    display=True,\n    compounded=True,\n    periods_per_year=252,\n    match_dates=False\n)\n</code></pre> <p>See <code>quantstats.reports.basic</code>.</p>","title":"basic_report method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.best","text":"<pre><code>QSAdapter.best(\n    *,\n    aggregate=None,\n    compounded=True,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.best</code>.</p>","title":"best method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.cagr","text":"<pre><code>QSAdapter.cagr(\n    *,\n    rf=0.0,\n    compounded=True\n)\n</code></pre> <p>See <code>quantstats.stats.cagr</code>.</p>","title":"cagr method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.calmar","text":"<pre><code>QSAdapter.calmar(\n    *,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.calmar</code>.</p>","title":"calmar method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.common_sense_ratio","text":"<pre><code>QSAdapter.common_sense_ratio(\n    *,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.common_sense_ratio</code>.</p>","title":"common_sense_ratio method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.comp","text":"<pre><code>QSAdapter.comp()\n</code></pre> <p>See <code>quantstats.stats.comp</code>.</p>","title":"comp method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.compare","text":"<pre><code>QSAdapter.compare(\n    *,\n    benchmark,\n    aggregate=None,\n    compounded=True,\n    round_vals=None,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.compare</code>.</p>","title":"compare method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.compsum","text":"<pre><code>QSAdapter.compsum()\n</code></pre> <p>See <code>quantstats.stats.compsum</code>.</p>","title":"compsum method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.conditional_value_at_risk","text":"<pre><code>QSAdapter.conditional_value_at_risk(\n    *,\n    sigma=1,\n    confidence=0.95,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.conditional_value_at_risk</code>.</p>","title":"conditional_value_at_risk method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.consecutive_losses","text":"<pre><code>QSAdapter.consecutive_losses(\n    *,\n    aggregate=None,\n    compounded=True,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.consecutive_losses</code>.</p>","title":"consecutive_losses method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.consecutive_wins","text":"<pre><code>QSAdapter.consecutive_wins(\n    *,\n    aggregate=None,\n    compounded=True,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.consecutive_wins</code>.</p>","title":"consecutive_wins method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.cpc_index","text":"<pre><code>QSAdapter.cpc_index(\n    *,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.cpc_index</code>.</p>","title":"cpc_index method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.cvar","text":"<pre><code>QSAdapter.cvar(\n    *,\n    sigma=1,\n    confidence=0.95,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.cvar</code>.</p>","title":"cvar method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.distribution","text":"<pre><code>QSAdapter.distribution(\n    *,\n    compounded=True,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.distribution</code>.</p>","title":"distribution method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.expected_return","text":"<pre><code>QSAdapter.expected_return(\n    *,\n    aggregate=None,\n    compounded=True,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.expected_return</code>.</p>","title":"expected_return method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.expected_shortfall","text":"<pre><code>QSAdapter.expected_shortfall(\n    *,\n    sigma=1,\n    confidence=0.95\n)\n</code></pre> <p>See <code>quantstats.stats.expected_shortfall</code>.</p>","title":"expected_shortfall method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.exponential_stdev","text":"<pre><code>QSAdapter.exponential_stdev(\n    *,\n    window=30,\n    is_halflife=False\n)\n</code></pre> <p>See <code>quantstats.utils.exponential_stdev</code>.</p>","title":"exponential_stdev method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.exposure","text":"<pre><code>QSAdapter.exposure(\n    *,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.exposure</code>.</p>","title":"exposure method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.full_report","text":"<pre><code>QSAdapter.full_report(\n    *,\n    benchmark=None,\n    rf=0.0,\n    grayscale=False,\n    figsize=(8, 5),\n    display=True,\n    compounded=True,\n    periods_per_year=252,\n    match_dates=False\n)\n</code></pre> <p>See <code>quantstats.reports.full</code>.</p>","title":"full_report method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.gain_to_pain_ratio","text":"<pre><code>QSAdapter.gain_to_pain_ratio(\n    *,\n    rf=0,\n    resolution='D'\n)\n</code></pre> <p>See <code>quantstats.stats.gain_to_pain_ratio</code>.</p>","title":"gain_to_pain_ratio method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.greeks","text":"<pre><code>QSAdapter.greeks(\n    *,\n    benchmark,\n    periods=252.0,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.greeks</code>.</p>","title":"greeks method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.group_returns","text":"<pre><code>QSAdapter.group_returns(\n    *,\n    groupby,\n    compounded=False\n)\n</code></pre> <p>See <code>quantstats.utils.group_returns</code>.</p>","title":"group_returns method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.html_report","text":"<pre><code>QSAdapter.html_report(\n    *,\n    benchmark=None,\n    rf=0.0,\n    grayscale=False,\n    title='Strategy Tearsheet',\n    output=None,\n    compounded=True,\n    periods_per_year=252,\n    download_filename='quantstats-tearsheet.html',\n    figfmt='svg',\n    template_path=None,\n    match_dates=False\n)\n</code></pre> <p>See <code>quantstats.reports.html</code>.</p>","title":"html_report method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.implied_volatility","text":"<pre><code>QSAdapter.implied_volatility(\n    *,\n    periods=252,\n    annualize=True\n)\n</code></pre> <p>See <code>quantstats.stats.implied_volatility</code>.</p>","title":"implied_volatility method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.information_ratio","text":"<pre><code>QSAdapter.information_ratio(\n    *,\n    benchmark,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.information_ratio</code>.</p>","title":"information_ratio method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.kelly_criterion","text":"<pre><code>QSAdapter.kelly_criterion(\n    *,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.kelly_criterion</code>.</p>","title":"kelly_criterion method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.kurtosis","text":"<pre><code>QSAdapter.kurtosis(\n    *,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.kurtosis</code>.</p>","title":"kurtosis method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.log_returns","text":"<pre><code>QSAdapter.log_returns(\n    *,\n    rf=0.0,\n    nperiods=None\n)\n</code></pre> <p>See <code>quantstats.utils.log_returns</code>.</p>","title":"log_returns method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.make_index","text":"<pre><code>QSAdapter.make_index(\n    *,\n    rebalance='1M',\n    period='max',\n    returns=None,\n    match_dates=False\n)\n</code></pre> <p>See <code>quantstats.utils.make_index</code>.</p>","title":"make_index method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.make_portfolio","text":"<pre><code>QSAdapter.make_portfolio(\n    *,\n    start_balance=100000.0,\n    mode='comp',\n    round_to=None\n)\n</code></pre> <p>See <code>quantstats.utils.make_portfolio</code>.</p>","title":"make_portfolio method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.metrics_report","text":"<pre><code>QSAdapter.metrics_report(\n    *,\n    benchmark=None,\n    rf=0.0,\n    display=True,\n    mode='basic',\n    sep=False,\n    compounded=True,\n    periods_per_year=252,\n    prepare_returns=True,\n    match_dates=False,\n    **kwargs\n)\n</code></pre> <p>See <code>quantstats.reports.metrics</code>.</p>","title":"metrics_report method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.monthly_returns","text":"<pre><code>QSAdapter.monthly_returns(\n    *,\n    eoy=True,\n    compounded=True,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.monthly_returns</code>.</p>","title":"monthly_returns method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.omega","text":"<pre><code>QSAdapter.omega(\n    *,\n    rf=0.0,\n    required_return=0.0,\n    periods=252\n)\n</code></pre> <p>See <code>quantstats.stats.omega</code>.</p>","title":"omega method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.outlier_loss_ratio","text":"<pre><code>QSAdapter.outlier_loss_ratio(\n    *,\n    quantile=0.01,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.outlier_loss_ratio</code>.</p>","title":"outlier_loss_ratio method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.outlier_win_ratio","text":"<pre><code>QSAdapter.outlier_win_ratio(\n    *,\n    quantile=0.99,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.outlier_win_ratio</code>.</p>","title":"outlier_win_ratio method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.outliers","text":"<pre><code>QSAdapter.outliers(\n    *,\n    quantile=0.95\n)\n</code></pre> <p>See <code>quantstats.stats.outliers</code>.</p>","title":"outliers method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.payoff_ratio","text":"<pre><code>QSAdapter.payoff_ratio(\n    *,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.payoff_ratio</code>.</p>","title":"payoff_ratio method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.plot_daily_returns","text":"<pre><code>QSAdapter.plot_daily_returns(\n    *,\n    grayscale=False,\n    figsize=(10, 4),\n    fontname='Arial',\n    lw=0.5,\n    log_scale=False,\n    ylabel='Returns',\n    subtitle=True,\n    savefig=None,\n    show=True,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.plots.daily_returns</code>.</p>","title":"plot_daily_returns method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.plot_distribution","text":"<pre><code>QSAdapter.plot_distribution(\n    *,\n    fontname='Arial',\n    grayscale=False,\n    ylabel=True,\n    figsize=(10, 6),\n    subtitle=True,\n    compounded=True,\n    savefig=None,\n    show=True,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.plots.distribution</code>.</p>","title":"plot_distribution method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.plot_drawdown","text":"<pre><code>QSAdapter.plot_drawdown(\n    *,\n    grayscale=False,\n    figsize=(10, 5),\n    fontname='Arial',\n    lw=1,\n    log_scale=False,\n    match_volatility=False,\n    compound=False,\n    ylabel='Drawdown',\n    resample=None,\n    subtitle=True,\n    savefig=None,\n    show=True\n)\n</code></pre> <p>See <code>quantstats.plots.drawdown</code>.</p>","title":"plot_drawdown method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.plot_drawdowns_periods","text":"<pre><code>QSAdapter.plot_drawdowns_periods(\n    *,\n    periods=5,\n    lw=1.5,\n    log_scale=False,\n    fontname='Arial',\n    grayscale=False,\n    figsize=(10, 5),\n    ylabel=True,\n    subtitle=True,\n    compounded=True,\n    savefig=None,\n    show=True,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.plots.drawdowns_periods</code>.</p>","title":"plot_drawdowns_periods method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.plot_earnings","text":"<pre><code>QSAdapter.plot_earnings(\n    *,\n    start_balance=100000.0,\n    mode='comp',\n    grayscale=False,\n    figsize=(10, 6),\n    title='Portfolio Earnings',\n    fontname='Arial',\n    lw=1.5,\n    subtitle=True,\n    savefig=None,\n    show=True\n)\n</code></pre> <p>See <code>quantstats.plots.earnings</code>.</p>","title":"plot_earnings method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.plot_histogram","text":"<pre><code>QSAdapter.plot_histogram(\n    *,\n    resample='M',\n    fontname='Arial',\n    grayscale=False,\n    figsize=(10, 5),\n    ylabel=True,\n    subtitle=True,\n    compounded=True,\n    savefig=None,\n    show=True,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.plots.histogram</code>.</p>","title":"plot_histogram method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.plot_log_returns","text":"<pre><code>QSAdapter.plot_log_returns(\n    *,\n    benchmark=None,\n    grayscale=False,\n    figsize=(10, 5),\n    fontname='Arial',\n    lw=1.5,\n    match_volatility=False,\n    compound=True,\n    cumulative=True,\n    resample=None,\n    ylabel='Cumulative Returns',\n    subtitle=True,\n    savefig=None,\n    show=True,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.plots.log_returns</code>.</p>","title":"plot_log_returns method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.plot_monthly_heatmap","text":"<pre><code>QSAdapter.plot_monthly_heatmap(\n    *,\n    annot_size=10,\n    figsize=(10, 5),\n    cbar=True,\n    square=False,\n    compounded=True,\n    eoy=False,\n    grayscale=False,\n    fontname='Arial',\n    ylabel=True,\n    savefig=None,\n    show=True\n)\n</code></pre> <p>See <code>quantstats.plots.monthly_heatmap</code>.</p>","title":"plot_monthly_heatmap method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.plot_monthly_returns","text":"<pre><code>QSAdapter.plot_monthly_returns(\n    *,\n    annot_size=10,\n    figsize=(10, 5),\n    cbar=True,\n    square=False,\n    compounded=True,\n    eoy=False,\n    grayscale=False,\n    fontname='Arial',\n    ylabel=True,\n    savefig=None,\n    show=True\n)\n</code></pre> <p>See <code>quantstats.plots.monthly_returns</code>.</p>","title":"plot_monthly_returns method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.plot_returns","text":"<pre><code>QSAdapter.plot_returns(\n    *,\n    benchmark=None,\n    grayscale=False,\n    figsize=(10, 6),\n    fontname='Arial',\n    lw=1.5,\n    match_volatility=False,\n    compound=True,\n    cumulative=True,\n    resample=None,\n    ylabel='Cumulative Returns',\n    subtitle=True,\n    savefig=None,\n    show=True,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.plots.returns</code>.</p>","title":"plot_returns method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.plot_rolling_beta","text":"<pre><code>QSAdapter.plot_rolling_beta(\n    *,\n    benchmark,\n    window1=126,\n    window1_label='6-Months',\n    window2=252,\n    window2_label='12-Months',\n    lw=1.5,\n    fontname='Arial',\n    grayscale=False,\n    figsize=(10, 3),\n    ylabel=True,\n    subtitle=True,\n    savefig=None,\n    show=True,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.plots.rolling_beta</code>.</p>","title":"plot_rolling_beta method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.plot_rolling_sharpe","text":"<pre><code>QSAdapter.plot_rolling_sharpe(\n    *,\n    benchmark=None,\n    rf=0.0,\n    period=126,\n    period_label='6-Months',\n    periods_per_year=252,\n    lw=1.25,\n    fontname='Arial',\n    grayscale=False,\n    figsize=(10, 3),\n    ylabel='Sharpe',\n    subtitle=True,\n    savefig=None,\n    show=True\n)\n</code></pre> <p>See <code>quantstats.plots.rolling_sharpe</code>.</p>","title":"plot_rolling_sharpe method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.plot_rolling_sortino","text":"<pre><code>QSAdapter.plot_rolling_sortino(\n    *,\n    benchmark=None,\n    rf=0.0,\n    period=126,\n    period_label='6-Months',\n    periods_per_year=252,\n    lw=1.25,\n    fontname='Arial',\n    grayscale=False,\n    figsize=(10, 3),\n    ylabel='Sortino',\n    subtitle=True,\n    savefig=None,\n    show=True\n)\n</code></pre> <p>See <code>quantstats.plots.rolling_sortino</code>.</p>","title":"plot_rolling_sortino method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.plot_rolling_volatility","text":"<pre><code>QSAdapter.plot_rolling_volatility(\n    *,\n    benchmark=None,\n    period=126,\n    period_label='6-Months',\n    periods_per_year=252,\n    lw=1.5,\n    fontname='Arial',\n    grayscale=False,\n    figsize=(10, 3),\n    ylabel='Volatility',\n    subtitle=True,\n    savefig=None,\n    show=True\n)\n</code></pre> <p>See <code>quantstats.plots.rolling_volatility</code>.</p>","title":"plot_rolling_volatility method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.plot_snapshot","text":"<pre><code>QSAdapter.plot_snapshot(\n    *,\n    grayscale=False,\n    figsize=(10, 8),\n    title='Portfolio Summary',\n    fontname='Arial',\n    lw=1.5,\n    mode='comp',\n    subtitle=True,\n    savefig=None,\n    show=True,\n    log_scale=False\n)\n</code></pre> <p>See <code>quantstats.plots.snapshot</code>.</p>","title":"plot_snapshot method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.plot_yearly_returns","text":"<pre><code>QSAdapter.plot_yearly_returns(\n    *,\n    benchmark=None,\n    fontname='Arial',\n    grayscale=False,\n    hlw=1.5,\n    hlcolor='red',\n    hllabel='',\n    match_volatility=False,\n    log_scale=False,\n    figsize=(10, 5),\n    ylabel=True,\n    subtitle=True,\n    compounded=True,\n    savefig=None,\n    show=True,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.plots.yearly_returns</code>.</p>","title":"plot_yearly_returns method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.plots_report","text":"<pre><code>QSAdapter.plots_report(\n    *,\n    benchmark=None,\n    grayscale=False,\n    figsize=(8, 5),\n    mode='basic',\n    compounded=True,\n    periods_per_year=252,\n    prepare_returns=True,\n    match_dates=False\n)\n</code></pre> <p>See <code>quantstats.reports.plots</code>.</p>","title":"plots_report method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.profit_factor","text":"<pre><code>QSAdapter.profit_factor(\n    *,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.profit_factor</code>.</p>","title":"profit_factor method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.profit_ratio","text":"<pre><code>QSAdapter.profit_ratio(\n    *,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.profit_ratio</code>.</p>","title":"profit_ratio method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.r2","text":"<pre><code>QSAdapter.r2(\n    *,\n    benchmark\n)\n</code></pre> <p>See <code>quantstats.stats.r2</code>.</p>","title":"r2 method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.r_squared","text":"<pre><code>QSAdapter.r_squared(\n    *,\n    benchmark,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.r_squared</code>.</p>","title":"r_squared method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.rar","text":"<pre><code>QSAdapter.rar(\n    *,\n    rf=0.0\n)\n</code></pre> <p>See <code>quantstats.stats.rar</code>.</p>","title":"rar method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.recovery_factor","text":"<pre><code>QSAdapter.recovery_factor(\n    *,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.recovery_factor</code>.</p>","title":"recovery_factor method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.remove_outliers","text":"<pre><code>QSAdapter.remove_outliers(\n    *,\n    quantile=0.95\n)\n</code></pre> <p>See <code>quantstats.stats.remove_outliers</code>.</p>","title":"remove_outliers method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.risk_of_ruin","text":"<pre><code>QSAdapter.risk_of_ruin(\n    *,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.risk_of_ruin</code>.</p>","title":"risk_of_ruin method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.risk_return_ratio","text":"<pre><code>QSAdapter.risk_return_ratio(\n    *,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.risk_return_ratio</code>.</p>","title":"risk_return_ratio method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.rolling_greeks","text":"<pre><code>QSAdapter.rolling_greeks(\n    *,\n    benchmark,\n    periods=252,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.rolling_greeks</code>.</p>","title":"rolling_greeks method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.rolling_sharpe","text":"<pre><code>QSAdapter.rolling_sharpe(\n    *,\n    rf=0.0,\n    rolling_period=126,\n    annualize=True,\n    periods_per_year=252,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.rolling_sharpe</code>.</p>","title":"rolling_sharpe method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.rolling_sortino","text":"<pre><code>QSAdapter.rolling_sortino(\n    *,\n    rf=0,\n    rolling_period=126,\n    annualize=True,\n    periods_per_year=252,\n    **kwargs\n)\n</code></pre> <p>See <code>quantstats.stats.rolling_sortino</code>.</p>","title":"rolling_sortino method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.rolling_volatility","text":"<pre><code>QSAdapter.rolling_volatility(\n    *,\n    rolling_period=126,\n    periods_per_year=252,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.rolling_volatility</code>.</p>","title":"rolling_volatility method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.ror","text":"<pre><code>QSAdapter.ror()\n</code></pre> <p>See <code>quantstats.stats.ror</code>.</p>","title":"ror method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.serenity_index","text":"<pre><code>QSAdapter.serenity_index(\n    *,\n    rf=0\n)\n</code></pre> <p>See <code>quantstats.stats.serenity_index</code>.</p>","title":"serenity_index method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.sharpe","text":"<pre><code>QSAdapter.sharpe(\n    *,\n    rf=0.0,\n    periods=252,\n    annualize=True,\n    smart=False\n)\n</code></pre> <p>See <code>quantstats.stats.sharpe</code>.</p>","title":"sharpe method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.skew","text":"<pre><code>QSAdapter.skew(\n    *,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.skew</code>.</p>","title":"skew method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.smart_sharpe","text":"<pre><code>QSAdapter.smart_sharpe(\n    *,\n    rf=0.0,\n    periods=252,\n    annualize=True\n)\n</code></pre> <p>See <code>quantstats.stats.smart_sharpe</code>.</p>","title":"smart_sharpe method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.smart_sortino","text":"<pre><code>QSAdapter.smart_sortino(\n    *,\n    rf=0,\n    periods=252,\n    annualize=True\n)\n</code></pre> <p>See <code>quantstats.stats.smart_sortino</code>.</p>","title":"smart_sortino method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.sortino","text":"<pre><code>QSAdapter.sortino(\n    *,\n    rf=0,\n    periods=252,\n    annualize=True,\n    smart=False\n)\n</code></pre> <p>See <code>quantstats.stats.sortino</code>.</p>","title":"sortino method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.tail_ratio","text":"<pre><code>QSAdapter.tail_ratio(\n    *,\n    cutoff=0.95,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.tail_ratio</code>.</p>","title":"tail_ratio method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.to_drawdown_series","text":"<pre><code>QSAdapter.to_drawdown_series()\n</code></pre> <p>See <code>quantstats.stats.to_drawdown_series</code>.</p>","title":"to_drawdown_series method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.to_excess_returns","text":"<pre><code>QSAdapter.to_excess_returns(\n    *,\n    rf,\n    nperiods=None\n)\n</code></pre> <p>See <code>quantstats.utils.to_excess_returns</code>.</p>","title":"to_excess_returns method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.to_log_returns","text":"<pre><code>QSAdapter.to_log_returns(\n    *,\n    rf=0.0,\n    nperiods=None\n)\n</code></pre> <p>See <code>quantstats.utils.to_log_returns</code>.</p>","title":"to_log_returns method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.to_prices","text":"<pre><code>QSAdapter.to_prices(\n    *,\n    base=100000.0\n)\n</code></pre> <p>See <code>quantstats.utils.to_prices</code>.</p>","title":"to_prices method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.ulcer_index","text":"<pre><code>QSAdapter.ulcer_index()\n</code></pre> <p>See <code>quantstats.stats.ulcer_index</code>.</p>","title":"ulcer_index method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.ulcer_performance_index","text":"<pre><code>QSAdapter.ulcer_performance_index(\n    *,\n    rf=0\n)\n</code></pre> <p>See <code>quantstats.stats.ulcer_performance_index</code>.</p>","title":"ulcer_performance_index method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.upi","text":"<pre><code>QSAdapter.upi(\n    *,\n    rf=0\n)\n</code></pre> <p>See <code>quantstats.stats.upi</code>.</p>","title":"upi method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.value_at_risk","text":"<pre><code>QSAdapter.value_at_risk(\n    *,\n    sigma=1,\n    confidence=0.95,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.value_at_risk</code>.</p>","title":"value_at_risk method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.var","text":"<pre><code>QSAdapter.var(\n    *,\n    sigma=1,\n    confidence=0.95,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.var</code>.</p>","title":"var method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.volatility","text":"<pre><code>QSAdapter.volatility(\n    *,\n    periods=252,\n    annualize=True,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.volatility</code>.</p>","title":"volatility method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.win_loss_ratio","text":"<pre><code>QSAdapter.win_loss_ratio(\n    *,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.win_loss_ratio</code>.</p>","title":"win_loss_ratio method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.win_rate","text":"<pre><code>QSAdapter.win_rate(\n    *,\n    aggregate=None,\n    compounded=True,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.win_rate</code>.</p>","title":"win_rate method"},{"location":"api/returns/qs_adapter/#vectorbt.returns.qs_adapter.QSAdapter.worst","text":"<pre><code>QSAdapter.worst(\n    *,\n    aggregate=None,\n    compounded=True,\n    prepare_returns=True\n)\n</code></pre> <p>See <code>quantstats.stats.worst</code>.</p>","title":"worst method"},{"location":"api/signals/","text":"<p>Modules for working with signals, such as entry and exit signals.</p>","title":"signals"},{"location":"api/signals/#sub-modules","text":"<ul> <li>vectorbt.signals.accessors</li> <li>vectorbt.signals.enums</li> <li>vectorbt.signals.factory</li> <li>vectorbt.signals.generators</li> <li>vectorbt.signals.nb</li> </ul>","title":"Sub-modules"},{"location":"api/signals/accessors/","text":"<p>Custom pandas accessors for signals data.</p> <p>Methods can be accessed as follows:</p> <ul> <li>SignalsSRAccessor -&gt; <code>pd.Series.vbt.signals.*</code></li> <li>SignalsDFAccessor -&gt; <code>pd.DataFrame.vbt.signals.*</code></li> </ul> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; # vectorbt.signals.accessors.SignalsAccessor.pos_rank\n&gt;&gt;&gt; pd.Series([False, True, True, True, False]).vbt.signals.pos_rank()\n0    0\n1    1\n2    2\n3    3\n4    0\ndtype: int64\n</code></pre> <p>The accessors extend vectorbt.generic.accessors.</p>  <p>Note</p> <p>The underlying Series/DataFrame should already be a signal series.</p> <p>Input arrays should be <code>np.bool_</code>.</p> <p>Grouping is only supported by the methods that accept the <code>group_by</code> argument.</p> <p>Accessors do not utilize caching.</p>  <p>Run for the examples below</p> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from numba import njit\n&gt;&gt;&gt; from datetime import datetime\n\n&gt;&gt;&gt; mask = pd.DataFrame({\n...     'a': [True, False, False, False, False],\n...     'b': [True, False, True, False, True],\n...     'c': [True, True, True, False, False]\n... }, index=pd.Index([\n...     datetime(2020, 1, 1),\n...     datetime(2020, 1, 2),\n...     datetime(2020, 1, 3),\n...     datetime(2020, 1, 4),\n...     datetime(2020, 1, 5)\n... ]))\n&gt;&gt;&gt; mask\n                a      b      c\n2020-01-01   True   True   True\n2020-01-02  False  False   True\n2020-01-03  False   True   True\n2020-01-04  False  False  False\n2020-01-05  False   True  False\n</code></pre>","title":"accessors"},{"location":"api/signals/accessors/#stats","text":"<p>Hint</p> <p>See StatsBuilderMixin.stats() and SignalsAccessor.metrics.</p>  <pre><code>&gt;&gt;&gt; mask.vbt.signals.stats(column='a')\nStart                       2020-01-01 00:00:00\nEnd                         2020-01-05 00:00:00\nPeriod                          5 days 00:00:00\nTotal                                         1\nRate [%]                                     20\nFirst Index                 2020-01-01 00:00:00\nLast Index                  2020-01-01 00:00:00\nNorm Avg Index [-1, 1]                       -1\nDistance: Min                               NaT\nDistance: Max                               NaT\nDistance: Mean                              NaT\nDistance: Std                               NaT\nTotal Partitions                              1\nPartition Rate [%]                          100\nPartition Length: Min           1 days 00:00:00\nPartition Length: Max           1 days 00:00:00\nPartition Length: Mean          1 days 00:00:00\nPartition Length: Std                       NaT\nPartition Distance: Min                     NaT\nPartition Distance: Max                     NaT\nPartition Distance: Mean                    NaT\nPartition Distance: Std                     NaT\nName: a, dtype: object\n</code></pre> <p>We can pass another signal array to compare this array with:</p> <pre><code>&gt;&gt;&gt; mask.vbt.signals.stats(column='a', settings=dict(other=mask['b']))\nStart                       2020-01-01 00:00:00\nEnd                         2020-01-05 00:00:00\nPeriod                          5 days 00:00:00\nTotal                                         1\nRate [%]                                     20\nTotal Overlapping                             1\nOverlapping Rate [%]                    33.3333\nFirst Index                 2020-01-01 00:00:00\nLast Index                  2020-01-01 00:00:00\nNorm Avg Index [-1, 1]                       -1\nDistance -&gt; Other: Min          0 days 00:00:00\nDistance -&gt; Other: Max          0 days 00:00:00\nDistance -&gt; Other: Mean         0 days 00:00:00\nDistance -&gt; Other: Std                      NaT\nTotal Partitions                              1\nPartition Rate [%]                          100\nPartition Length: Min           1 days 00:00:00\nPartition Length: Max           1 days 00:00:00\nPartition Length: Mean          1 days 00:00:00\nPartition Length: Std                       NaT\nPartition Distance: Min                     NaT\nPartition Distance: Max                     NaT\nPartition Distance: Mean                    NaT\nPartition Distance: Std                     NaT\nName: a, dtype: object\n</code></pre> <p>We can also return duration as a floating number rather than a timedelta:</p> <pre><code>&gt;&gt;&gt; mask.vbt.signals.stats(column='a', settings=dict(to_timedelta=False))\nStart                       2020-01-01 00:00:00\nEnd                         2020-01-05 00:00:00\nPeriod                                        5\nTotal                                         1\nRate [%]                                     20\nFirst Index                 2020-01-01 00:00:00\nLast Index                  2020-01-01 00:00:00\nNorm Avg Index [-1, 1]                       -1\nDistance: Min                               NaN\nDistance: Max                               NaN\nDistance: Mean                              NaN\nDistance: Std                               NaN\nTotal Partitions                              1\nPartition Rate [%]                          100\nPartition Length: Min                         1\nPartition Length: Max                         1\nPartition Length: Mean                        1\nPartition Length: Std                       NaN\nPartition Distance: Min                     NaN\nPartition Distance: Max                     NaN\nPartition Distance: Mean                    NaN\nPartition Distance: Std                     NaN\nName: a, dtype: object\n</code></pre> <p>StatsBuilderMixin.stats() also supports (re-)grouping:</p> <pre><code>&gt;&gt;&gt; mask.vbt.signals.stats(column=0, group_by=[0, 0, 1])\nStart                       2020-01-01 00:00:00\nEnd                         2020-01-05 00:00:00\nPeriod                          5 days 00:00:00\nTotal                                         4\nRate [%]                                     40\nFirst Index                 2020-01-01 00:00:00\nLast Index                  2020-01-05 00:00:00\nNorm Avg Index [-1, 1]                    -0.25\nDistance: Min                   2 days 00:00:00\nDistance: Max                   2 days 00:00:00\nDistance: Mean                  2 days 00:00:00\nDistance: Std                   0 days 00:00:00\nTotal Partitions                              4\nPartition Rate [%]                          100\nPartition Length: Min           1 days 00:00:00\nPartition Length: Max           1 days 00:00:00\nPartition Length: Mean          1 days 00:00:00\nPartition Length: Std           0 days 00:00:00\nPartition Distance: Min         2 days 00:00:00\nPartition Distance: Max         2 days 00:00:00\nPartition Distance: Mean        2 days 00:00:00\nPartition Distance: Std         0 days 00:00:00\nName: 0, dtype: object\n</code></pre>","title":"Stats"},{"location":"api/signals/accessors/#plots","text":"<p>Hint</p> <p>See PlotsBuilderMixin.plots() and SignalsAccessor.subplots.</p>  <p>This class inherits subplots from GenericAccessor.</p>","title":"Plots"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor","text":"<pre><code>SignalsAccessor(\n    obj,\n    **kwargs\n)\n</code></pre> <p>Accessor on top of signal series. For both, Series and DataFrames.</p> <p>Accessible through <code>pd.Series.vbt.signals</code> and <code>pd.DataFrame.vbt.signals</code>.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>BaseAccessor</li> <li>Configured</li> <li>Documented</li> <li>GenericAccessor</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>BaseAccessor.align_to()</li> <li>BaseAccessor.apply()</li> <li>BaseAccessor.apply_and_concat()</li> <li>BaseAccessor.apply_on_index()</li> <li>BaseAccessor.broadcast()</li> <li>BaseAccessor.broadcast_to()</li> <li>BaseAccessor.combine()</li> <li>BaseAccessor.concat()</li> <li>BaseAccessor.drop_duplicate_levels()</li> <li>BaseAccessor.drop_levels()</li> <li>BaseAccessor.drop_redundant_levels()</li> <li>BaseAccessor.indexing_func()</li> <li>BaseAccessor.make_symmetric()</li> <li>BaseAccessor.rename_levels()</li> <li>BaseAccessor.repeat()</li> <li>BaseAccessor.select_levels()</li> <li>BaseAccessor.stack_index()</li> <li>BaseAccessor.tile()</li> <li>BaseAccessor.to_1d_array()</li> <li>BaseAccessor.to_2d_array()</li> <li>BaseAccessor.to_dict()</li> <li>BaseAccessor.unstack_to_array()</li> <li>BaseAccessor.unstack_to_df()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>GenericAccessor.apply_along_axis()</li> <li>GenericAccessor.apply_and_reduce()</li> <li>GenericAccessor.apply_mapping()</li> <li>GenericAccessor.applymap()</li> <li>GenericAccessor.barplot()</li> <li>GenericAccessor.bfill()</li> <li>GenericAccessor.binarize()</li> <li>GenericAccessor.boxplot()</li> <li>GenericAccessor.config</li> <li>GenericAccessor.count()</li> <li>GenericAccessor.crossed_above()</li> <li>GenericAccessor.crossed_below()</li> <li>GenericAccessor.cumprod()</li> <li>GenericAccessor.cumsum()</li> <li>GenericAccessor.describe()</li> <li>GenericAccessor.df_accessor_cls</li> <li>GenericAccessor.diff()</li> <li>GenericAccessor.drawdown()</li> <li>GenericAccessor.drawdowns</li> <li>GenericAccessor.ewm_mean()</li> <li>GenericAccessor.ewm_std()</li> <li>GenericAccessor.expanding_apply()</li> <li>GenericAccessor.expanding_max()</li> <li>GenericAccessor.expanding_mean()</li> <li>GenericAccessor.expanding_min()</li> <li>GenericAccessor.expanding_split()</li> <li>GenericAccessor.expanding_std()</li> <li>GenericAccessor.ffill()</li> <li>GenericAccessor.fillna()</li> <li>GenericAccessor.filter()</li> <li>GenericAccessor.get_drawdowns()</li> <li>GenericAccessor.get_ranges()</li> <li>GenericAccessor.groupby_apply()</li> <li>GenericAccessor.histplot()</li> <li>GenericAccessor.idxmax()</li> <li>GenericAccessor.idxmin()</li> <li>GenericAccessor.iloc</li> <li>GenericAccessor.indexing_kwargs</li> <li>GenericAccessor.lineplot()</li> <li>GenericAccessor.loc</li> <li>GenericAccessor.mapping</li> <li>GenericAccessor.max()</li> <li>GenericAccessor.maxabs_scale()</li> <li>GenericAccessor.mean()</li> <li>GenericAccessor.median()</li> <li>GenericAccessor.min()</li> <li>GenericAccessor.minmax_scale()</li> <li>GenericAccessor.normalize()</li> <li>GenericAccessor.obj</li> <li>GenericAccessor.pct_change()</li> <li>GenericAccessor.power_transform()</li> <li>GenericAccessor.product()</li> <li>GenericAccessor.quantile_transform()</li> <li>GenericAccessor.range_split()</li> <li>GenericAccessor.ranges</li> <li>GenericAccessor.rebase()</li> <li>GenericAccessor.reduce()</li> <li>GenericAccessor.resample_apply()</li> <li>GenericAccessor.resolve_self()</li> <li>GenericAccessor.robust_scale()</li> <li>GenericAccessor.rolling_apply()</li> <li>GenericAccessor.rolling_max()</li> <li>GenericAccessor.rolling_mean()</li> <li>GenericAccessor.rolling_min()</li> <li>GenericAccessor.rolling_split()</li> <li>GenericAccessor.rolling_std()</li> <li>GenericAccessor.scale()</li> <li>GenericAccessor.scatterplot()</li> <li>GenericAccessor.self_aliases</li> <li>GenericAccessor.shuffle()</li> <li>GenericAccessor.split()</li> <li>GenericAccessor.sr_accessor_cls</li> <li>GenericAccessor.std()</li> <li>GenericAccessor.sum()</li> <li>GenericAccessor.to_mapped()</li> <li>GenericAccessor.to_returns()</li> <li>GenericAccessor.transform()</li> <li>GenericAccessor.value_counts()</li> <li>GenericAccessor.wrapper</li> <li>GenericAccessor.writeable_attrs</li> <li>GenericAccessor.zscore()</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li>SignalsDFAccessor</li> <li>SignalsSRAccessor</li> </ul>","title":"SignalsAccessor class"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.metrics","text":"<p>Metrics supported by SignalsAccessor.</p> <pre><code>Config({\n    \"start\": {\n        \"title\": \"Start\",\n        \"calc_func\": \"&lt;function SignalsAccessor.&lt;lambda&gt; at 0x7ff521597840&gt;\",\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"end\": {\n        \"title\": \"End\",\n        \"calc_func\": \"&lt;function SignalsAccessor.&lt;lambda&gt; at 0x7ff5215978c8&gt;\",\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"period\": {\n        \"title\": \"Period\",\n        \"calc_func\": \"&lt;function SignalsAccessor.&lt;lambda&gt; at 0x7ff521597950&gt;\",\n        \"apply_to_timedelta\": true,\n        \"agg_func\": null,\n        \"tags\": \"wrapper\"\n    },\n    \"total\": {\n        \"title\": \"Total\",\n        \"calc_func\": \"total\",\n        \"tags\": \"signals\"\n    },\n    \"rate\": {\n        \"title\": \"Rate [%]\",\n        \"calc_func\": \"rate\",\n        \"post_calc_func\": \"&lt;function SignalsAccessor.&lt;lambda&gt; at 0x7ff5215979d8&gt;\",\n        \"tags\": \"signals\"\n    },\n    \"total_overlapping\": {\n        \"title\": \"Total Overlapping\",\n        \"calc_func\": \"&lt;function SignalsAccessor.&lt;lambda&gt; at 0x7ff521597a60&gt;\",\n        \"check_silent_has_other\": true,\n        \"tags\": [\n            \"signals\",\n            \"other\"\n        ]\n    },\n    \"overlapping_rate\": {\n        \"title\": \"Overlapping Rate [%]\",\n        \"calc_func\": \"&lt;function SignalsAccessor.&lt;lambda&gt; at 0x7ff521597ae8&gt;\",\n        \"post_calc_func\": \"&lt;function SignalsAccessor.&lt;lambda&gt; at 0x7ff521597b70&gt;\",\n        \"check_silent_has_other\": true,\n        \"tags\": [\n            \"signals\",\n            \"other\"\n        ]\n    },\n    \"first_index\": {\n        \"title\": \"First Index\",\n        \"calc_func\": \"nth_index\",\n        \"n\": 0,\n        \"return_labels\": true,\n        \"tags\": [\n            \"signals\",\n            \"index\"\n        ]\n    },\n    \"last_index\": {\n        \"title\": \"Last Index\",\n        \"calc_func\": \"nth_index\",\n        \"n\": -1,\n        \"return_labels\": true,\n        \"tags\": [\n            \"signals\",\n            \"index\"\n        ]\n    },\n    \"norm_avg_index\": {\n        \"title\": \"Norm Avg Index [-1, 1]\",\n        \"calc_func\": \"norm_avg_index\",\n        \"tags\": [\n            \"signals\",\n            \"index\"\n        ]\n    },\n    \"distance\": {\n        \"title\": \"RepEval(expression=\\\"f'Distance {\\\"&lt;-\\\" if from_other else \\\"-&gt;\\\"} {other_name}' if other is not None else 'Distance'\\\", mapping={})\",\n        \"calc_func\": \"between_ranges.duration\",\n        \"post_calc_func\": \"&lt;function SignalsAccessor.&lt;lambda&gt; at 0x7ff521597bf8&gt;\",\n        \"apply_to_timedelta\": true,\n        \"tags\": \"RepEval(expression=\\\"['signals', 'distance', 'other'] if other is not None else ['signals', 'distance']\\\", mapping={})\"\n    },\n    \"total_partitions\": {\n        \"title\": \"Total Partitions\",\n        \"calc_func\": \"total_partitions\",\n        \"tags\": [\n            \"signals\",\n            \"partitions\"\n        ]\n    },\n    \"partition_rate\": {\n        \"title\": \"Partition Rate [%]\",\n        \"calc_func\": \"partition_rate\",\n        \"post_calc_func\": \"&lt;function SignalsAccessor.&lt;lambda&gt; at 0x7ff521597c80&gt;\",\n        \"tags\": [\n            \"signals\",\n            \"partitions\"\n        ]\n    },\n    \"partition_len\": {\n        \"title\": \"Partition Length\",\n        \"calc_func\": \"partition_ranges.duration\",\n        \"post_calc_func\": \"&lt;function SignalsAccessor.&lt;lambda&gt; at 0x7ff521597d08&gt;\",\n        \"apply_to_timedelta\": true,\n        \"tags\": [\n            \"signals\",\n            \"partitions\",\n            \"distance\"\n        ]\n    },\n    \"partition_distance\": {\n        \"title\": \"Partition Distance\",\n        \"calc_func\": \"between_partition_ranges.duration\",\n        \"post_calc_func\": \"&lt;function SignalsAccessor.&lt;lambda&gt; at 0x7ff521597d90&gt;\",\n        \"apply_to_timedelta\": true,\n        \"tags\": [\n            \"signals\",\n            \"partitions\",\n            \"distance\"\n        ]\n    }\n})\n</code></pre> <p>Returns <code>SignalsAccessor._metrics</code>, which gets (deep) copied upon creation of each instance. Thus, changing this config won't affect the class.</p> <p>To change metrics, you can either change the config in-place, override this property, or overwrite the instance variable <code>SignalsAccessor._metrics</code>.</p>","title":"metrics class variable"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.subplots","text":"<p>Subplots supported by SignalsAccessor.</p> <pre><code>Config({\n    \"plot\": {\n        \"check_is_not_grouped\": true,\n        \"plot_func\": \"plot\",\n        \"pass_trace_names\": false,\n        \"tags\": \"generic\"\n    }\n})\n</code></pre> <p>Returns <code>SignalsAccessor._subplots</code>, which gets (deep) copied upon creation of each instance. Thus, changing this config won't affect the class.</p> <p>To change subplots, you can either change the config in-place, override this property, or overwrite the instance variable <code>SignalsAccessor._subplots</code>.</p>","title":"subplots class variable"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.clean","text":"<pre><code>SignalsAccessor.clean(\n    *args,\n    entry_first=True,\n    broadcast_kwargs=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Clean signals.</p> <p>If one array passed, see SignalsAccessor.first(). If two arrays passed, entries and exits, see clean_enex_nb().</p>","title":"clean class method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.empty","text":"<pre><code>SignalsAccessor.empty(\n    *args,\n    fill_value=False,\n    **kwargs\n)\n</code></pre> <p>BaseAccessor.empty() with <code>fill_value=False</code>.</p>","title":"empty class method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.empty_like","text":"<pre><code>SignalsAccessor.empty_like(\n    *args,\n    fill_value=False,\n    **kwargs\n)\n</code></pre> <p>BaseAccessor.empty_like() with <code>fill_value=False</code>.</p>","title":"empty_like class method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.generate","text":"<pre><code>SignalsAccessor.generate(\n    shape,\n    choice_func_nb,\n    *args,\n    pick_first=False,\n    **kwargs\n)\n</code></pre> <p>See generate_nb().</p> <p><code>**kwargs</code> will be passed to pandas constructor.</p> <p>Usage</p> <ul> <li>Generate random signals manually:</li> </ul> <pre><code>&gt;&gt;&gt; @njit\n... def choice_func_nb(from_i, to_i, col):\n...     return col + from_i\n\n&gt;&gt;&gt; pd.DataFrame.vbt.signals.generate((5, 3),\n...     choice_func_nb, index=mask.index, columns=mask.columns)\n                a      b      c\n2020-01-01   True  False  False\n2020-01-02  False   True  False\n2020-01-03  False  False   True\n2020-01-04  False  False  False\n2020-01-05  False  False  False\n</code></pre>","title":"generate class method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.generate_both","text":"<pre><code>SignalsAccessor.generate_both(\n    shape,\n    entry_choice_func_nb=None,\n    entry_args=None,\n    exit_choice_func_nb=None,\n    exit_args=None,\n    entry_wait=1,\n    exit_wait=1,\n    entry_pick_first=True,\n    exit_pick_first=True,\n    **kwargs\n)\n</code></pre> <p>See generate_enex_nb().</p> <p><code>**kwargs</code> will be passed to pandas constructor.</p> <p>Usage</p> <ul> <li>Generate entry and exit signals one after another. Each column increment the number of ticks to wait before placing the exit signal.</li> </ul> <pre><code>&gt;&gt;&gt; @njit\n... def entry_choice_func_nb(from_i, to_i, col, temp_idx_arr):\n...     temp_idx_arr[0] = from_i\n...     return temp_idx_arr[:1]  # array with one signal\n\n&gt;&gt;&gt; @njit\n... def exit_choice_func_nb(from_i, to_i, col, temp_idx_arr):\n...     wait = col\n...     temp_idx_arr[0] = from_i + wait\n...     if temp_idx_arr[0] &lt; to_i:\n...         return temp_idx_arr[:1]  # array with one signal\n...     return temp_idx_arr[:0]  # empty array\n\n&gt;&gt;&gt; temp_idx_arr = np.empty((1,), dtype=np.int_)  # reuse memory\n&gt;&gt;&gt; en, ex = pd.DataFrame.vbt.signals.generate_both(\n...     (5, 3),\n...     entry_choice_func_nb, (temp_idx_arr,),\n...     exit_choice_func_nb, (temp_idx_arr,),\n...     index=mask.index, columns=mask.columns)\n&gt;&gt;&gt; en\n                a      b      c\n2020-01-01   True   True   True\n2020-01-02  False  False  False\n2020-01-03   True  False  False\n2020-01-04  False   True  False\n2020-01-05   True  False   True\n&gt;&gt;&gt; ex\n                a      b      c\n2020-01-01  False  False  False\n2020-01-02   True  False  False\n2020-01-03  False   True  False\n2020-01-04   True  False   True\n2020-01-05  False  False  False\n</code></pre>","title":"generate_both class method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.generate_random","text":"<pre><code>SignalsAccessor.generate_random(\n    shape,\n    n=None,\n    prob=None,\n    pick_first=False,\n    seed=None,\n    **kwargs\n)\n</code></pre> <p>Generate signals randomly.</p> <p>If <code>n</code> is set, see generate_rand_nb(). If <code>prob</code> is set, see generate_rand_by_prob_nb().</p> <p><code>n</code> should be either a scalar or an array that will broadcast to the number of columns. <code>prob</code> should be either a single number or an array that will broadcast to match <code>shape</code>. <code>**kwargs</code> will be passed to pandas constructor.</p> <p>Usage</p> <ul> <li>For each column, generate a variable number of signals:</li> </ul> <pre><code>&gt;&gt;&gt; pd.DataFrame.vbt.signals.generate_random((5, 3), n=[0, 1, 2],\n...     seed=42, index=mask.index, columns=mask.columns)\n                a      b      c\n2020-01-01  False  False   True\n2020-01-02  False  False   True\n2020-01-03  False  False  False\n2020-01-04  False   True  False\n2020-01-05  False  False  False\n</code></pre> <ul> <li>For each column and time step, pick a signal with 50% probability:</li> </ul> <pre><code>&gt;&gt;&gt; pd.DataFrame.vbt.signals.generate_random((5, 3), prob=0.5,\n...     seed=42, index=mask.index, columns=mask.columns)\n                a      b      c\n2020-01-01   True   True   True\n2020-01-02  False   True  False\n2020-01-03  False  False  False\n2020-01-04  False  False   True\n2020-01-05   True  False   True\n</code></pre>","title":"generate_random class method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.generate_random_both","text":"<pre><code>SignalsAccessor.generate_random_both(\n    shape,\n    n=None,\n    entry_prob=None,\n    exit_prob=None,\n    seed=None,\n    entry_wait=1,\n    exit_wait=1,\n    entry_pick_first=True,\n    exit_pick_first=True,\n    **kwargs\n)\n</code></pre> <p>Generate chain of entry and exit signals randomly.</p> <p>If <code>n</code> is set, see generate_rand_enex_nb(). If <code>entry_prob</code> and <code>exit_prob</code> are set, see generate_rand_enex_by_prob_nb().</p> <p>For arguments, see SignalsAccessor.generate_random().</p> <p>Usage</p> <ul> <li>For each column, generate two entries and exits randomly:</li> </ul> <pre><code>&gt;&gt;&gt; en, ex = pd.DataFrame.vbt.signals.generate_random_both(\n...     (5, 3), n=2, seed=42, index=mask.index, columns=mask.columns)\n&gt;&gt;&gt; en\n                a      b      c\n2020-01-01   True   True   True\n2020-01-02  False  False  False\n2020-01-03   True   True  False\n2020-01-04  False  False   True\n2020-01-05  False  False  False\n&gt;&gt;&gt; ex\n                a      b      c\n2020-01-01  False  False  False\n2020-01-02   True   True   True\n2020-01-03  False  False  False\n2020-01-04  False   True  False\n2020-01-05   True  False   True\n</code></pre> <ul> <li>For each column and time step, pick entry with 50% probability and exit right after:</li> </ul> <pre><code>&gt;&gt;&gt; en, ex = pd.DataFrame.vbt.signals.generate_random_both(\n...     (5, 3), entry_prob=0.5, exit_prob=1.,\n...     seed=42, index=mask.index, columns=mask.columns)\n&gt;&gt;&gt; en\n                a      b      c\n2020-01-01   True   True   True\n2020-01-02  False  False  False\n2020-01-03  False  False  False\n2020-01-04  False  False   True\n2020-01-05   True  False  False\n&gt;&gt;&gt; ex\n                a      b      c\n2020-01-01  False  False  False\n2020-01-02   True   True  False\n2020-01-03  False  False   True\n2020-01-04  False   True  False\n2020-01-05   True  False   True\n</code></pre>","title":"generate_random_both class method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.plots_defaults","text":"<p>Defaults for PlotsBuilderMixin.plots().</p> <p>Merges GenericAccessor.plots_defaults and <code>signals.plots</code> from settings.</p>","title":"plots_defaults property"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.stats_defaults","text":"<p>Defaults for StatsBuilderMixin.stats().</p> <p>Merges GenericAccessor.stats_defaults and <code>signals.stats</code> from settings.</p>","title":"stats_defaults property"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.AND","text":"<pre><code>SignalsAccessor.AND(\n    other,\n    **kwargs\n)\n</code></pre> <p>Combine with <code>other</code> using logical AND.</p> <p>See BaseAccessor.combine().</p>","title":"AND method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.OR","text":"<pre><code>SignalsAccessor.OR(\n    other,\n    **kwargs\n)\n</code></pre> <p>Combine with <code>other</code> using logical OR.</p> <p>See BaseAccessor.combine().</p> <p>Usage</p> <ul> <li>Perform two OR operations and concatenate them:</li> </ul> <pre><code>&gt;&gt;&gt; ts = pd.Series([1, 2, 3, 2, 1])\n&gt;&gt;&gt; mask.vbt.signals.OR([ts &gt; 1, ts &gt; 2], concat=True, keys=['&gt;1', '&gt;2'])\n                            &gt;1                   &gt;2\n                a     b      c      a      b      c\n2020-01-01   True  True   True   True   True   True\n2020-01-02   True  True   True  False  False   True\n2020-01-03   True  True   True   True   True   True\n2020-01-04   True  True   True  False  False  False\n2020-01-05  False  True  False  False   True  False\n</code></pre>","title":"OR method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.XOR","text":"<pre><code>SignalsAccessor.XOR(\n    other,\n    **kwargs\n)\n</code></pre> <p>Combine with <code>other</code> using logical XOR.</p> <p>See BaseAccessor.combine().</p>","title":"XOR method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.between_partition_ranges","text":"<pre><code>SignalsAccessor.between_partition_ranges(\n    group_by=None,\n    attach_ts=True,\n    **kwargs\n)\n</code></pre> <p>Wrap the result of between_partition_ranges_nb() with Ranges.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; mask_sr = pd.Series([True, False, False, True, False, True, True])\n&gt;&gt;&gt; mask_sr.vbt.signals.between_partition_ranges().records_readable\n   Range Id  Column  Start Timestamp  End Timestamp  Status\n0         0       0                0              3  Closed\n1         1       0                3              5  Closed\n</code></pre>","title":"between_partition_ranges method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.between_ranges","text":"<pre><code>SignalsAccessor.between_ranges(\n    other=None,\n    from_other=False,\n    broadcast_kwargs=None,\n    group_by=None,\n    attach_ts=True,\n    attach_other=False,\n    **kwargs\n)\n</code></pre> <p>Wrap the result of between_ranges_nb() with Ranges.</p> <p>If <code>other</code> specified, see between_two_ranges_nb(). Both will broadcast using broadcast() and <code>broadcast_kwargs</code>.</p> <p>Usage</p> <ul> <li>One array:</li> </ul> <pre><code>&gt;&gt;&gt; mask_sr = pd.Series([True, False, False, True, False, True, True])\n&gt;&gt;&gt; ranges = mask_sr.vbt.signals.between_ranges()\n&gt;&gt;&gt; ranges\n&lt;vectorbt.generic.ranges.Ranges at 0x7ff29ea7c7b8&gt;\n\n&gt;&gt;&gt; ranges.records_readable\n   Range Id  Column  Start Timestamp  End Timestamp  Status\n0         0       0                0              3  Closed\n1         1       0                3              5  Closed\n2         2       0                5              6  Closed\n\n&gt;&gt;&gt; ranges.duration.values\narray([3, 2, 1])\n</code></pre> <ul> <li>Two arrays, traversing the signals of the first array:</li> </ul> <pre><code>&gt;&gt;&gt; mask_sr = pd.Series([True, True, True, False, False])\n&gt;&gt;&gt; mask_sr2 = pd.Series([False, False, True, False, True])\n&gt;&gt;&gt; ranges = mask_sr.vbt.signals.between_ranges(other=mask_sr2)\n&gt;&gt;&gt; ranges\n&lt;vectorbt.generic.ranges.Ranges at 0x7ff29e3b80f0&gt;\n\n&gt;&gt;&gt; ranges.records_readable\n   Range Id  Column  Start Timestamp  End Timestamp  Status\n0         0       0                0              2  Closed\n1         1       0                1              2  Closed\n2         2       0                2              2  Closed\n\n&gt;&gt;&gt; ranges.duration.values\narray([2, 1, 0])\n</code></pre> <ul> <li>Two arrays, traversing the signals of the second array:</li> </ul> <pre><code>&gt;&gt;&gt; ranges = mask_sr.vbt.signals.between_ranges(other=mask_sr2, from_other=True)\n&gt;&gt;&gt; ranges\n&lt;vectorbt.generic.ranges.Ranges at 0x7ff29eccbd68&gt;\n\n&gt;&gt;&gt; ranges.records_readable\n   Range Id  Column  Start Timestamp  End Timestamp  Status\n0         0       0                2              2  Closed\n1         1       0                2              4  Closed\n\n&gt;&gt;&gt; ranges.duration.values\narray([0, 2])\n</code></pre>","title":"between_ranges method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.bshift","text":"<pre><code>SignalsAccessor.bshift(\n    *args,\n    fill_value=False,\n    **kwargs\n)\n</code></pre> <p>GenericAccessor.bshift() with <code>fill_value=False</code>.</p>","title":"bshift method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.first","text":"<pre><code>SignalsAccessor.first(\n    wrap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Select signals that satisfy the condition <code>pos_rank == 0</code>.</p>","title":"first method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.from_nth","text":"<pre><code>SignalsAccessor.from_nth(\n    n,\n    wrap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Select signals that satisfy the condition <code>pos_rank &gt;= n</code>.</p>","title":"from_nth method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.fshift","text":"<pre><code>SignalsAccessor.fshift(\n    *args,\n    fill_value=False,\n    **kwargs\n)\n</code></pre> <p>GenericAccessor.fshift() with <code>fill_value=False</code>.</p>","title":"fshift method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.generate_exits","text":"<pre><code>SignalsAccessor.generate_exits(\n    exit_choice_func_nb,\n    *args,\n    wait=1,\n    until_next=True,\n    skip_until_exit=False,\n    pick_first=False,\n    wrap_kwargs=None\n)\n</code></pre> <p>See generate_ex_nb().</p> <p>Usage</p> <ul> <li>Fill all space after signals in <code>mask</code>:</li> </ul> <pre><code>&gt;&gt;&gt; @njit\n... def exit_choice_func_nb(from_i, to_i, col, temp_range):\n...     return temp_range[from_i:to_i]\n\n&gt;&gt;&gt; temp_range = np.arange(mask.shape[0])  # reuse memory\n&gt;&gt;&gt; mask.vbt.signals.generate_exits(exit_choice_func_nb, temp_range)\n                a      b      c\n2020-01-01  False  False  False\n2020-01-02   True   True  False\n2020-01-03   True  False  False\n2020-01-04   True   True   True\n2020-01-05   True  False   True\n</code></pre>","title":"generate_exits method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.generate_ohlc_stop_exits","text":"<pre><code>SignalsAccessor.generate_ohlc_stop_exits(\n    open,\n    high=None,\n    low=None,\n    close=None,\n    is_open_safe=True,\n    out_dict=None,\n    sl_stop=nan,\n    sl_trail=False,\n    tp_stop=nan,\n    reverse=False,\n    entry_wait=1,\n    exit_wait=1,\n    until_next=True,\n    skip_until_exit=False,\n    pick_first=True,\n    chain=False,\n    broadcast_kwargs=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Generate exits based on when the price hits (trailing) stop loss or take profit.</p>  <p>Hint</p> <p>This function is meant for signal analysis. For backtesting, consider using the stop logic integrated into Portfolio.from_signals().</p>  <p>If any of <code>high</code>, <code>low</code> or <code>close</code> is None, it will be set to <code>open</code>.</p> <p>Use <code>out_dict</code> as a dict to pass <code>stop_price</code> and <code>stop_type</code> arrays. You can also set <code>out_dict</code> to {} to produce these arrays automatically and still have access to them.</p> <p>For arguments, see ohlc_stop_choice_nb(). If <code>chain</code> is True, see generate_ohlc_stop_enex_nb(). Otherwise, see generate_ohlc_stop_ex_nb().</p> <p>All array-like arguments including stops and <code>out_dict</code> will broadcast using broadcast() and <code>broadcast_kwargs</code>.</p> <p>For arguments, see ohlc_stop_choice_nb().</p>  <p>Note</p> <p><code>open</code> isn't necessarily open price, but can be any entry price (even previous close). Stop price is calculated based solely on the entry price.</p>   <p>Hint</p> <p>Default arguments will generate an exit signal strictly between two entry signals. If both entry signals are too close to each other, no exit will be generated.</p> <p>To ignore all entries that come between an entry and its exit, set <code>until_next</code> to False and <code>skip_until_exit</code> to True.</p> <p>To remove all entries that come between an entry and its exit, set <code>chain</code> to True. This will return two arrays: new entries and exits.</p>  <p>Usage</p> <ul> <li>The same example as under generate_ohlc_stop_ex_nb():</li> </ul> <pre><code>&gt;&gt;&gt; from vectorbt.signals.enums import StopType\n\n&gt;&gt;&gt; price = pd.DataFrame({\n...     'open': [10, 11, 12, 11, 10],\n...     'high': [11, 12, 13, 12, 11],\n...     'low': [9, 10, 11, 10, 9],\n...     'close': [10, 11, 12, 11, 10]\n... })\n&gt;&gt;&gt; out_dict = {}\n&gt;&gt;&gt; exits = mask.vbt.signals.generate_ohlc_stop_exits(\n...     price['open'], price['high'], price['low'], price['close'],\n...     sl_stop=0.1, sl_trail=True, tp_stop=0.1, out_dict=out_dict)\n&gt;&gt;&gt; exits\n                a      b      c\n2020-01-01  False  False  False\n2020-01-02   True   True  False\n2020-01-03  False  False  False\n2020-01-04  False   True   True\n2020-01-05  False  False  False\n\n&gt;&gt;&gt; out_dict['stop_price']\n               a     b     c\n2020-01-01   NaN   NaN   NaN\n2020-01-02  11.0  11.0   NaN\n2020-01-03   NaN   NaN   NaN\n2020-01-04   NaN  10.8  10.8\n2020-01-05   NaN   NaN   NaN\n\n&gt;&gt;&gt; out_dict['stop_type'].vbt(mapping=StopType).apply_mapping()\n                     a           b          c\n2020-01-01        None        None       None\n2020-01-02  TakeProfit  TakeProfit       None\n2020-01-03        None        None       None\n2020-01-04        None   TrailStop  TrailStop\n2020-01-05        None        None       None\n</code></pre> <p>Notice how the first two entry signals in the third column have no exit signal - there is no room between them for an exit signal.</p> <ul> <li>To find an exit for the first entry and ignore all entries that are in-between them, we can pass <code>until_next=False</code> and <code>skip_until_exit=True</code>:</li> </ul> <pre><code>&gt;&gt;&gt; out_dict = {}\n&gt;&gt;&gt; exits = mask.vbt.signals.generate_ohlc_stop_exits(\n...     price['open'], price['high'], price['low'], price['close'],\n...     sl_stop=0.1, sl_trail=True, tp_stop=0.1, out_dict=out_dict,\n...     until_next=False, skip_until_exit=True)\n&gt;&gt;&gt; exits\n                a      b      c\n2020-01-01  False  False  False\n2020-01-02   True   True   True\n2020-01-03  False  False  False\n2020-01-04  False   True   True\n2020-01-05  False  False  False\n\n&gt;&gt;&gt; out_dict['stop_price']\n2020-01-01   NaN   NaN   NaN\n2020-01-02  11.0  11.0  11.0\n2020-01-03   NaN   NaN   NaN\n2020-01-04   NaN  10.8  10.8\n2020-01-05   NaN   NaN   NaN\n\n&gt;&gt;&gt; out_dict['stop_type'].vbt(mapping=StopType).apply_mapping()\n                     a           b           c\n2020-01-01        None        None        None\n2020-01-02  TakeProfit  TakeProfit  TakeProfit\n2020-01-03        None        None        None\n2020-01-04        None   TrailStop   TrailStop\n2020-01-05        None        None        None\n</code></pre> <p>Now, the first signal in the third column gets executed regardless of the entries that come next, which is very similar to the logic that is implemented in Portfolio.from_signals().</p> <ul> <li>To automatically remove all ignored entry signals, pass <code>chain=True</code>. This will return a new entries array:</li> </ul> <pre><code>&gt;&gt;&gt; out_dict = {}\n&gt;&gt;&gt; new_entries, exits = mask.vbt.signals.generate_ohlc_stop_exits(\n...     price['open'], price['high'], price['low'], price['close'],\n...     sl_stop=0.1, sl_trail=True, tp_stop=0.1, out_dict=out_dict,\n...     chain=True)\n&gt;&gt;&gt; new_entries\n                a      b      c\n2020-01-01   True   True   True\n2020-01-02  False  False  False  &lt;&lt; removed entry in the third column\n2020-01-03  False   True   True\n2020-01-04  False  False  False\n2020-01-05  False   True  False\n&gt;&gt;&gt; exits\n                a      b      c\n2020-01-01  False  False  False\n2020-01-02   True   True   True\n2020-01-03  False  False  False\n2020-01-04  False   True   True\n2020-01-05  False  False  False\n</code></pre>  <p>Warning</p> <p>The last two examples above make entries dependent upon exits - this makes only sense if you have no other exit arrays to combine this stop exit array with.</p>","title":"generate_ohlc_stop_exits method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.generate_random_exits","text":"<pre><code>SignalsAccessor.generate_random_exits(\n    prob=None,\n    seed=None,\n    wait=1,\n    until_next=True,\n    skip_until_exit=False,\n    wrap_kwargs=None\n)\n</code></pre> <p>Generate exit signals randomly.</p> <p>If <code>prob</code> is None, see generate_rand_ex_nb(). Otherwise, see generate_rand_ex_by_prob_nb().</p> <p>Usage</p> <ul> <li>After each entry in <code>mask</code>, generate exactly one exit:</li> </ul> <pre><code>&gt;&gt;&gt; mask.vbt.signals.generate_random_exits(seed=42)\n                a      b      c\n2020-01-01  False  False  False\n2020-01-02  False   True  False\n2020-01-03   True  False  False\n2020-01-04  False   True  False\n2020-01-05  False  False   True\n</code></pre> <ul> <li>After each entry in <code>mask</code> and at each time step, generate exit with 50% probability:</li> </ul> <pre><code>&gt;&gt;&gt; mask.vbt.signals.generate_random_exits(prob=0.5, seed=42)\n                a      b      c\n2020-01-01  False  False  False\n2020-01-02   True  False  False\n2020-01-03  False  False  False\n2020-01-04  False  False  False\n2020-01-05  False  False   True\n</code></pre>","title":"generate_random_exits method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.generate_stop_exits","text":"<pre><code>SignalsAccessor.generate_stop_exits(\n    ts,\n    stop,\n    trailing=False,\n    entry_wait=1,\n    exit_wait=1,\n    until_next=True,\n    skip_until_exit=False,\n    pick_first=True,\n    chain=False,\n    broadcast_kwargs=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>Generate exits based on when <code>ts</code> hits the stop.</p> <p>For arguments, see stop_choice_nb(). If <code>chain</code> is True, see generate_stop_enex_nb(). Otherwise, see generate_stop_ex_nb().</p> <p>Arguments <code>entries</code>, <code>ts</code> and <code>stop</code> will broadcast using broadcast() and <code>broadcast_kwargs</code>.</p> <p>For arguments, see stop_choice_nb().</p>  <p>Hint</p> <p>Default arguments will generate an exit signal strictly between two entry signals. If both entry signals are too close to each other, no exit will be generated.</p> <p>To ignore all entries that come between an entry and its exit, set <code>until_next</code> to False and <code>skip_until_exit</code> to True.</p> <p>To remove all entries that come between an entry and its exit, set <code>chain</code> to True. This will return two arrays: new entries and exits.</p>  <p>Usage</p> <pre><code>&gt;&gt;&gt; ts = pd.Series([1, 2, 3, 2, 1])\n\n&gt;&gt;&gt; # stop loss\n&gt;&gt;&gt; mask.vbt.signals.generate_stop_exits(ts, -0.1)\n                a      b      c\n2020-01-01  False  False  False\n2020-01-02  False  False  False\n2020-01-03  False  False  False\n2020-01-04  False   True   True\n2020-01-05  False  False  False\n\n&gt;&gt;&gt; # trailing stop loss\n&gt;&gt;&gt; mask.vbt.signals.generate_stop_exits(ts, -0.1, trailing=True)\n                a      b      c\n2020-01-01  False  False  False\n2020-01-02  False  False  False\n2020-01-03  False  False  False\n2020-01-04   True   True   True\n2020-01-05  False  False  False\n</code></pre>","title":"generate_stop_exits method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.index_mapped","text":"<pre><code>SignalsAccessor.index_mapped(\n    group_by=None,\n    **kwargs\n)\n</code></pre> <p>Get a mapped array of indices.</p> <p>See GenericAccessor.to_mapped().</p> <p>Only True values will be considered.</p>","title":"index_mapped method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.norm_avg_index","text":"<pre><code>SignalsAccessor.norm_avg_index(\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>See norm_avg_index_nb().</p> <p>Normalized average index measures the average signal location relative to the middle of the column. This way, we can quickly see where the majority of signals are located.</p> <p>Common values are:</p> <ul> <li>-1.0: only the first signal is set</li> <li>1.0: only the last signal is set</li> <li>0.0: symmetric distribution around the middle</li> <li>[-1.0, 0.0): average signal is on the left</li> <li>(0.0, 1.0]: average signal is on the right</li> </ul> <p>Usage</p> <pre><code>&gt;&gt;&gt; pd.Series([True, False, False, False]).vbt.signals.norm_avg_index()\n-1.0\n\n&gt;&gt;&gt; pd.Series([False, False, False, True]).vbt.signals.norm_avg_index()\n1.0\n\n&gt;&gt;&gt; pd.Series([True, False, False, True]).vbt.signals.norm_avg_index()\n0.0\n</code></pre>","title":"norm_avg_index method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.nth","text":"<pre><code>SignalsAccessor.nth(\n    n,\n    wrap_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Select signals that satisfy the condition <code>pos_rank == n</code>.</p>","title":"nth method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.nth_index","text":"<pre><code>SignalsAccessor.nth_index(\n    n,\n    return_labels=True,\n    group_by=None,\n    wrap_kwargs=None\n)\n</code></pre> <p>See nth_index_nb().</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; mask.vbt.signals.nth_index(0)\na   2020-01-01\nb   2020-01-01\nc   2020-01-01\nName: nth_index, dtype: datetime64[ns]\n\n&gt;&gt;&gt; mask.vbt.signals.nth_index(2)\na          NaT\nb   2020-01-05\nc   2020-01-03\nName: nth_index, dtype: datetime64[ns]\n\n&gt;&gt;&gt; mask.vbt.signals.nth_index(-1)\na   2020-01-01\nb   2020-01-05\nc   2020-01-03\nName: nth_index, dtype: datetime64[ns]\n\n&gt;&gt;&gt; mask.vbt.signals.nth_index(-1, group_by=True)\nTimestamp('2020-01-05 00:00:00')\n</code></pre>","title":"nth_index method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.partition_pos_rank","text":"<pre><code>SignalsAccessor.partition_pos_rank(\n    **kwargs\n)\n</code></pre> <p>Get partition position ranks.</p> <p>Uses SignalsAccessor.rank() with part_pos_rank_nb().</p> <p>Usage</p> <ul> <li>Rank each partition of True values in <code>mask</code>:</li> </ul> <pre><code>&gt;&gt;&gt; mask.vbt.signals.partition_pos_rank()\n            a  b  c\n2020-01-01  0  0  0\n2020-01-02 -1 -1  0\n2020-01-03 -1  1  0\n2020-01-04 -1 -1 -1\n2020-01-05 -1  2 -1\n\n&gt;&gt;&gt; mask.vbt.signals.partition_pos_rank(after_false=True)\n            a  b  c\n2020-01-01 -1 -1 -1\n2020-01-02 -1 -1 -1\n2020-01-03 -1  0 -1\n2020-01-04 -1 -1 -1\n2020-01-05 -1  1 -1\n\n&gt;&gt;&gt; mask.vbt.signals.partition_pos_rank(reset_by=mask)\n            a  b  c\n2020-01-01  0  0  0\n2020-01-02 -1 -1  0\n2020-01-03 -1  0  0\n2020-01-04 -1 -1 -1\n2020-01-05 -1  0 -1\n</code></pre>","title":"partition_pos_rank method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.partition_pos_rank_mapped","text":"<pre><code>SignalsAccessor.partition_pos_rank_mapped(\n    group_by=None,\n    **kwargs\n)\n</code></pre> <p>Get a mapped array of partition position ranks.</p> <p>See SignalsAccessor.partition_pos_rank().</p>","title":"partition_pos_rank_mapped method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.partition_ranges","text":"<pre><code>SignalsAccessor.partition_ranges(\n    group_by=None,\n    attach_ts=True,\n    **kwargs\n)\n</code></pre> <p>Wrap the result of partition_ranges_nb() with Ranges.</p> <p>If <code>use_end_idxs</code> is True, uses the index of the last signal in each partition as <code>idx_arr</code>. Otherwise, uses the index of the first signal.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; mask_sr = pd.Series([True, True, True, False, True, True])\n&gt;&gt;&gt; mask_sr.vbt.signals.partition_ranges().records_readable\n   Range Id  Column  Start Timestamp  End Timestamp  Status\n0         0       0                0              3  Closed\n1         1       0                4              5    Open\n</code></pre>","title":"partition_ranges method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.partition_rate","text":"<pre><code>SignalsAccessor.partition_rate(\n    wrap_kwargs=None,\n    group_by=None,\n    **kwargs\n)\n</code></pre> <p>SignalsAccessor.total_partitions() divided by SignalsAccessor.total() in each column/group.</p>","title":"partition_rate method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.plot","text":"<pre><code>SignalsAccessor.plot(\n    yref='y',\n    **kwargs\n)\n</code></pre> <p>Plot signals.</p> <p>Args</p>  <code>yref</code> :\u2002<code>str</code> Y coordinate axis. <code>**kwargs</code> Keyword arguments passed to GenericAccessor.lineplot().  <p>Usage</p> <pre><code>&gt;&gt;&gt; mask[['a', 'c']].vbt.signals.plot()\n</code></pre> <p></p>","title":"plot method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.pos_rank","text":"<pre><code>SignalsAccessor.pos_rank(\n    allow_gaps=False,\n    **kwargs\n)\n</code></pre> <p>Get signal position ranks.</p> <p>Uses SignalsAccessor.rank() with sig_pos_rank_nb().</p> <p>Usage</p> <ul> <li>Rank each True value in each partition in <code>mask</code>:</li> </ul> <pre><code>&gt;&gt;&gt; mask.vbt.signals.pos_rank()\n            a  b  c\n2020-01-01  0  0  0\n2020-01-02 -1 -1  1\n2020-01-03 -1  0  2\n2020-01-04 -1 -1 -1\n2020-01-05 -1  0 -1\n\n&gt;&gt;&gt; mask.vbt.signals.pos_rank(after_false=True)\n            a  b  c\n2020-01-01 -1 -1 -1\n2020-01-02 -1 -1 -1\n2020-01-03 -1  0 -1\n2020-01-04 -1 -1 -1\n2020-01-05 -1  0 -1\n\n&gt;&gt;&gt; mask.vbt.signals.pos_rank(allow_gaps=True)\n            a  b  c\n2020-01-01  0  0  0\n2020-01-02 -1 -1  1\n2020-01-03 -1  1  2\n2020-01-04 -1 -1 -1\n2020-01-05 -1  2 -1\n\n&gt;&gt;&gt; mask.vbt.signals.pos_rank(reset_by=~mask, allow_gaps=True)\n            a  b  c\n2020-01-01  0  0  0\n2020-01-02 -1 -1  1\n2020-01-03 -1  0  2\n2020-01-04 -1 -1 -1\n2020-01-05 -1  0 -1\n</code></pre>","title":"pos_rank method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.pos_rank_mapped","text":"<pre><code>SignalsAccessor.pos_rank_mapped(\n    group_by=None,\n    **kwargs\n)\n</code></pre> <p>Get a mapped array of signal position ranks.</p> <p>See SignalsAccessor.pos_rank().</p>","title":"pos_rank_mapped method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.rank","text":"<pre><code>SignalsAccessor.rank(\n    rank_func_nb,\n    *args,\n    prepare_func=None,\n    reset_by=None,\n    after_false=False,\n    broadcast_kwargs=None,\n    wrap_kwargs=None,\n    as_mapped=False,\n    **kwargs\n)\n</code></pre> <p>See rank_nb().</p> <p>Will broadcast with <code>reset_by</code> using broadcast() and <code>broadcast_kwargs</code>.</p> <p>Use <code>prepare_func</code> to prepare further arguments to be passed before <code>*args</code>, such as temporary arrays. It should take both broadcasted arrays (<code>reset_by</code> can be None) and return a tuple.</p> <p>Set <code>as_mapped</code> to True to return an instance of MappedArray.</p>","title":"rank method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.rate","text":"<pre><code>SignalsAccessor.rate(\n    wrap_kwargs=None,\n    group_by=None,\n    **kwargs\n)\n</code></pre> <p>SignalsAccessor.total() divided by the total index length in each column/group.</p>","title":"rate method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.total","text":"<pre><code>SignalsAccessor.total(\n    wrap_kwargs=None,\n    group_by=None\n)\n</code></pre> <p>Total number of True values in each column/group.</p>","title":"total method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsAccessor.total_partitions","text":"<pre><code>SignalsAccessor.total_partitions(\n    wrap_kwargs=None,\n    group_by=None,\n    **kwargs\n)\n</code></pre> <p>Total number of partitions of True values in each column/group.</p>","title":"total_partitions method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsDFAccessor","text":"<pre><code>SignalsDFAccessor(\n    obj,\n    **kwargs\n)\n</code></pre> <p>Accessor on top of signal series. For DataFrames only.</p> <p>Accessible through <code>pd.DataFrame.vbt.signals</code>.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>BaseAccessor</li> <li>BaseDFAccessor</li> <li>Configured</li> <li>Documented</li> <li>GenericAccessor</li> <li>GenericDFAccessor</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>SignalsAccessor</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>BaseAccessor.align_to()</li> <li>BaseAccessor.apply()</li> <li>BaseAccessor.apply_and_concat()</li> <li>BaseAccessor.apply_on_index()</li> <li>BaseAccessor.broadcast()</li> <li>BaseAccessor.broadcast_to()</li> <li>BaseAccessor.combine()</li> <li>BaseAccessor.concat()</li> <li>BaseAccessor.drop_duplicate_levels()</li> <li>BaseAccessor.drop_levels()</li> <li>BaseAccessor.drop_redundant_levels()</li> <li>BaseAccessor.indexing_func()</li> <li>BaseAccessor.make_symmetric()</li> <li>BaseAccessor.rename_levels()</li> <li>BaseAccessor.repeat()</li> <li>BaseAccessor.select_levels()</li> <li>BaseAccessor.stack_index()</li> <li>BaseAccessor.tile()</li> <li>BaseAccessor.to_1d_array()</li> <li>BaseAccessor.to_2d_array()</li> <li>BaseAccessor.to_dict()</li> <li>BaseAccessor.unstack_to_array()</li> <li>BaseAccessor.unstack_to_df()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>GenericAccessor.apply_along_axis()</li> <li>GenericAccessor.apply_and_reduce()</li> <li>GenericAccessor.apply_mapping()</li> <li>GenericAccessor.applymap()</li> <li>GenericAccessor.barplot()</li> <li>GenericAccessor.bfill()</li> <li>GenericAccessor.binarize()</li> <li>GenericAccessor.boxplot()</li> <li>GenericAccessor.count()</li> <li>GenericAccessor.crossed_above()</li> <li>GenericAccessor.crossed_below()</li> <li>GenericAccessor.cumprod()</li> <li>GenericAccessor.cumsum()</li> <li>GenericAccessor.describe()</li> <li>GenericAccessor.diff()</li> <li>GenericAccessor.drawdown()</li> <li>GenericAccessor.ewm_mean()</li> <li>GenericAccessor.ewm_std()</li> <li>GenericAccessor.expanding_apply()</li> <li>GenericAccessor.expanding_max()</li> <li>GenericAccessor.expanding_mean()</li> <li>GenericAccessor.expanding_min()</li> <li>GenericAccessor.expanding_split()</li> <li>GenericAccessor.expanding_std()</li> <li>GenericAccessor.ffill()</li> <li>GenericAccessor.fillna()</li> <li>GenericAccessor.filter()</li> <li>GenericAccessor.get_drawdowns()</li> <li>GenericAccessor.get_ranges()</li> <li>GenericAccessor.groupby_apply()</li> <li>GenericAccessor.histplot()</li> <li>GenericAccessor.idxmax()</li> <li>GenericAccessor.idxmin()</li> <li>GenericAccessor.lineplot()</li> <li>GenericAccessor.max()</li> <li>GenericAccessor.maxabs_scale()</li> <li>GenericAccessor.mean()</li> <li>GenericAccessor.median()</li> <li>GenericAccessor.min()</li> <li>GenericAccessor.minmax_scale()</li> <li>GenericAccessor.normalize()</li> <li>GenericAccessor.pct_change()</li> <li>GenericAccessor.power_transform()</li> <li>GenericAccessor.product()</li> <li>GenericAccessor.quantile_transform()</li> <li>GenericAccessor.range_split()</li> <li>GenericAccessor.rebase()</li> <li>GenericAccessor.reduce()</li> <li>GenericAccessor.resample_apply()</li> <li>GenericAccessor.resolve_self()</li> <li>GenericAccessor.robust_scale()</li> <li>GenericAccessor.rolling_apply()</li> <li>GenericAccessor.rolling_max()</li> <li>GenericAccessor.rolling_mean()</li> <li>GenericAccessor.rolling_min()</li> <li>GenericAccessor.rolling_split()</li> <li>GenericAccessor.rolling_std()</li> <li>GenericAccessor.scale()</li> <li>GenericAccessor.scatterplot()</li> <li>GenericAccessor.shuffle()</li> <li>GenericAccessor.split()</li> <li>GenericAccessor.std()</li> <li>GenericAccessor.sum()</li> <li>GenericAccessor.to_mapped()</li> <li>GenericAccessor.to_returns()</li> <li>GenericAccessor.transform()</li> <li>GenericAccessor.value_counts()</li> <li>GenericAccessor.zscore()</li> <li>GenericDFAccessor.flatten_grouped()</li> <li>GenericDFAccessor.heatmap()</li> <li>GenericDFAccessor.squeeze_grouped()</li> <li>GenericDFAccessor.ts_heatmap()</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>SignalsAccessor.AND()</li> <li>SignalsAccessor.OR()</li> <li>SignalsAccessor.XOR()</li> <li>SignalsAccessor.between_partition_ranges()</li> <li>SignalsAccessor.between_ranges()</li> <li>SignalsAccessor.bshift()</li> <li>SignalsAccessor.clean()</li> <li>SignalsAccessor.config</li> <li>SignalsAccessor.df_accessor_cls</li> <li>SignalsAccessor.drawdowns</li> <li>SignalsAccessor.empty()</li> <li>SignalsAccessor.empty_like()</li> <li>SignalsAccessor.first()</li> <li>SignalsAccessor.from_nth()</li> <li>SignalsAccessor.fshift()</li> <li>SignalsAccessor.generate()</li> <li>SignalsAccessor.generate_both()</li> <li>SignalsAccessor.generate_exits()</li> <li>SignalsAccessor.generate_ohlc_stop_exits()</li> <li>SignalsAccessor.generate_random()</li> <li>SignalsAccessor.generate_random_both()</li> <li>SignalsAccessor.generate_random_exits()</li> <li>SignalsAccessor.generate_stop_exits()</li> <li>SignalsAccessor.iloc</li> <li>SignalsAccessor.index_mapped()</li> <li>SignalsAccessor.indexing_kwargs</li> <li>SignalsAccessor.loc</li> <li>SignalsAccessor.mapping</li> <li>SignalsAccessor.norm_avg_index()</li> <li>SignalsAccessor.nth()</li> <li>SignalsAccessor.nth_index()</li> <li>SignalsAccessor.obj</li> <li>SignalsAccessor.partition_pos_rank()</li> <li>SignalsAccessor.partition_pos_rank_mapped()</li> <li>SignalsAccessor.partition_ranges()</li> <li>SignalsAccessor.partition_rate()</li> <li>SignalsAccessor.plot()</li> <li>SignalsAccessor.plots_defaults</li> <li>SignalsAccessor.pos_rank()</li> <li>SignalsAccessor.pos_rank_mapped()</li> <li>SignalsAccessor.ranges</li> <li>SignalsAccessor.rank()</li> <li>SignalsAccessor.rate()</li> <li>SignalsAccessor.self_aliases</li> <li>SignalsAccessor.sr_accessor_cls</li> <li>SignalsAccessor.stats_defaults</li> <li>SignalsAccessor.total()</li> <li>SignalsAccessor.total_partitions()</li> <li>SignalsAccessor.wrapper</li> <li>SignalsAccessor.writeable_attrs</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul>","title":"SignalsDFAccessor class"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsSRAccessor","text":"<pre><code>SignalsSRAccessor(\n    obj,\n    **kwargs\n)\n</code></pre> <p>Accessor on top of signal series. For Series only.</p> <p>Accessible through <code>pd.Series.vbt.signals</code>.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>BaseAccessor</li> <li>BaseSRAccessor</li> <li>Configured</li> <li>Documented</li> <li>GenericAccessor</li> <li>GenericSRAccessor</li> <li>IndexingBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>SignalsAccessor</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>BaseAccessor.align_to()</li> <li>BaseAccessor.apply()</li> <li>BaseAccessor.apply_and_concat()</li> <li>BaseAccessor.apply_on_index()</li> <li>BaseAccessor.broadcast()</li> <li>BaseAccessor.broadcast_to()</li> <li>BaseAccessor.combine()</li> <li>BaseAccessor.concat()</li> <li>BaseAccessor.drop_duplicate_levels()</li> <li>BaseAccessor.drop_levels()</li> <li>BaseAccessor.drop_redundant_levels()</li> <li>BaseAccessor.indexing_func()</li> <li>BaseAccessor.make_symmetric()</li> <li>BaseAccessor.rename_levels()</li> <li>BaseAccessor.repeat()</li> <li>BaseAccessor.select_levels()</li> <li>BaseAccessor.stack_index()</li> <li>BaseAccessor.tile()</li> <li>BaseAccessor.to_1d_array()</li> <li>BaseAccessor.to_2d_array()</li> <li>BaseAccessor.to_dict()</li> <li>BaseAccessor.unstack_to_array()</li> <li>BaseAccessor.unstack_to_df()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>GenericAccessor.apply_along_axis()</li> <li>GenericAccessor.apply_and_reduce()</li> <li>GenericAccessor.apply_mapping()</li> <li>GenericAccessor.applymap()</li> <li>GenericAccessor.barplot()</li> <li>GenericAccessor.bfill()</li> <li>GenericAccessor.binarize()</li> <li>GenericAccessor.boxplot()</li> <li>GenericAccessor.count()</li> <li>GenericAccessor.crossed_above()</li> <li>GenericAccessor.crossed_below()</li> <li>GenericAccessor.cumprod()</li> <li>GenericAccessor.cumsum()</li> <li>GenericAccessor.describe()</li> <li>GenericAccessor.diff()</li> <li>GenericAccessor.drawdown()</li> <li>GenericAccessor.ewm_mean()</li> <li>GenericAccessor.ewm_std()</li> <li>GenericAccessor.expanding_apply()</li> <li>GenericAccessor.expanding_max()</li> <li>GenericAccessor.expanding_mean()</li> <li>GenericAccessor.expanding_min()</li> <li>GenericAccessor.expanding_split()</li> <li>GenericAccessor.expanding_std()</li> <li>GenericAccessor.ffill()</li> <li>GenericAccessor.fillna()</li> <li>GenericAccessor.filter()</li> <li>GenericAccessor.get_drawdowns()</li> <li>GenericAccessor.get_ranges()</li> <li>GenericAccessor.groupby_apply()</li> <li>GenericAccessor.histplot()</li> <li>GenericAccessor.idxmax()</li> <li>GenericAccessor.idxmin()</li> <li>GenericAccessor.lineplot()</li> <li>GenericAccessor.max()</li> <li>GenericAccessor.maxabs_scale()</li> <li>GenericAccessor.mean()</li> <li>GenericAccessor.median()</li> <li>GenericAccessor.min()</li> <li>GenericAccessor.minmax_scale()</li> <li>GenericAccessor.normalize()</li> <li>GenericAccessor.pct_change()</li> <li>GenericAccessor.power_transform()</li> <li>GenericAccessor.product()</li> <li>GenericAccessor.quantile_transform()</li> <li>GenericAccessor.range_split()</li> <li>GenericAccessor.rebase()</li> <li>GenericAccessor.reduce()</li> <li>GenericAccessor.resample_apply()</li> <li>GenericAccessor.resolve_self()</li> <li>GenericAccessor.robust_scale()</li> <li>GenericAccessor.rolling_apply()</li> <li>GenericAccessor.rolling_max()</li> <li>GenericAccessor.rolling_mean()</li> <li>GenericAccessor.rolling_min()</li> <li>GenericAccessor.rolling_split()</li> <li>GenericAccessor.rolling_std()</li> <li>GenericAccessor.scale()</li> <li>GenericAccessor.scatterplot()</li> <li>GenericAccessor.shuffle()</li> <li>GenericAccessor.split()</li> <li>GenericAccessor.std()</li> <li>GenericAccessor.sum()</li> <li>GenericAccessor.to_mapped()</li> <li>GenericAccessor.to_returns()</li> <li>GenericAccessor.transform()</li> <li>GenericAccessor.value_counts()</li> <li>GenericAccessor.zscore()</li> <li>GenericSRAccessor.flatten_grouped()</li> <li>GenericSRAccessor.heatmap()</li> <li>GenericSRAccessor.overlay_with_heatmap()</li> <li>GenericSRAccessor.plot_against()</li> <li>GenericSRAccessor.qqplot()</li> <li>GenericSRAccessor.squeeze_grouped()</li> <li>GenericSRAccessor.ts_heatmap()</li> <li>GenericSRAccessor.volume()</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>SignalsAccessor.AND()</li> <li>SignalsAccessor.OR()</li> <li>SignalsAccessor.XOR()</li> <li>SignalsAccessor.between_partition_ranges()</li> <li>SignalsAccessor.between_ranges()</li> <li>SignalsAccessor.bshift()</li> <li>SignalsAccessor.clean()</li> <li>SignalsAccessor.config</li> <li>SignalsAccessor.df_accessor_cls</li> <li>SignalsAccessor.drawdowns</li> <li>SignalsAccessor.empty()</li> <li>SignalsAccessor.empty_like()</li> <li>SignalsAccessor.first()</li> <li>SignalsAccessor.from_nth()</li> <li>SignalsAccessor.fshift()</li> <li>SignalsAccessor.generate()</li> <li>SignalsAccessor.generate_both()</li> <li>SignalsAccessor.generate_exits()</li> <li>SignalsAccessor.generate_ohlc_stop_exits()</li> <li>SignalsAccessor.generate_random()</li> <li>SignalsAccessor.generate_random_both()</li> <li>SignalsAccessor.generate_random_exits()</li> <li>SignalsAccessor.generate_stop_exits()</li> <li>SignalsAccessor.iloc</li> <li>SignalsAccessor.index_mapped()</li> <li>SignalsAccessor.indexing_kwargs</li> <li>SignalsAccessor.loc</li> <li>SignalsAccessor.mapping</li> <li>SignalsAccessor.norm_avg_index()</li> <li>SignalsAccessor.nth()</li> <li>SignalsAccessor.nth_index()</li> <li>SignalsAccessor.obj</li> <li>SignalsAccessor.partition_pos_rank()</li> <li>SignalsAccessor.partition_pos_rank_mapped()</li> <li>SignalsAccessor.partition_ranges()</li> <li>SignalsAccessor.partition_rate()</li> <li>SignalsAccessor.plot()</li> <li>SignalsAccessor.plots_defaults</li> <li>SignalsAccessor.pos_rank()</li> <li>SignalsAccessor.pos_rank_mapped()</li> <li>SignalsAccessor.ranges</li> <li>SignalsAccessor.rank()</li> <li>SignalsAccessor.rate()</li> <li>SignalsAccessor.self_aliases</li> <li>SignalsAccessor.sr_accessor_cls</li> <li>SignalsAccessor.stats_defaults</li> <li>SignalsAccessor.total()</li> <li>SignalsAccessor.total_partitions()</li> <li>SignalsAccessor.wrapper</li> <li>SignalsAccessor.writeable_attrs</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul>","title":"SignalsSRAccessor class"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsSRAccessor.plot_as_entry_markers","text":"<pre><code>SignalsSRAccessor.plot_as_entry_markers(\n    y=None,\n    **kwargs\n)\n</code></pre> <p>Plot signals as entry markers.</p> <p>See SignalsSRAccessor.plot_as_markers().</p>","title":"plot_as_entry_markers method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsSRAccessor.plot_as_exit_markers","text":"<pre><code>SignalsSRAccessor.plot_as_exit_markers(\n    y=None,\n    **kwargs\n)\n</code></pre> <p>Plot signals as exit markers.</p> <p>See SignalsSRAccessor.plot_as_markers().</p>","title":"plot_as_exit_markers method"},{"location":"api/signals/accessors/#vectorbt.signals.accessors.SignalsSRAccessor.plot_as_markers","text":"<pre><code>SignalsSRAccessor.plot_as_markers(\n    y=None,\n    **kwargs\n)\n</code></pre> <p>Plot Series as markers.</p> <p>Args</p>  <code>y</code> :\u2002<code>array_like</code> Y-axis values to plot markers on. <code>**kwargs</code> Keyword arguments passed to GenericAccessor.scatterplot().  <p>Usage</p> <pre><code>&gt;&gt;&gt; ts = pd.Series([1, 2, 3, 2, 1], index=mask.index)\n&gt;&gt;&gt; fig = ts.vbt.lineplot()\n&gt;&gt;&gt; mask['b'].vbt.signals.plot_as_entry_markers(y=ts, fig=fig)\n&gt;&gt;&gt; (~mask['b']).vbt.signals.plot_as_exit_markers(y=ts, fig=fig)\n</code></pre> <p></p>","title":"plot_as_markers method"},{"location":"api/signals/enums/","text":"<p>Named tuples and enumerated types.</p> <p>Defines enums and other schemas for vectorbt.signals.</p>","title":"enums"},{"location":"api/signals/enums/#vectorbt.signals.enums.FactoryMode","text":"<p>Factory mode.</p> <pre><code>{\n    \"Entries\": 0,\n    \"Exits\": 1,\n    \"Both\": 2,\n    \"Chain\": 3\n}\n</code></pre> <p>Attributes</p>  <code>Entries</code>  <p>Generate entries only using <code>generate_func</code>.</p> <p>Takes no input signal arrays. Produces one output signal array - <code>entries</code>.</p> <p>Such generators often have no suffix.</p>  <code>Exits</code>  <p>Generate exits only using <code>generate_ex_func</code>.</p> <p>Takes one input signal array - <code>entries</code>. Produces one output signal array - <code>exits</code>.</p> <p>Such generators often have suffix 'X'.</p>  <code>Both</code>  <p>Generate both entries and exits using <code>generate_enex_func</code>.</p> <p>Takes no input signal arrays. Produces two output signal arrays - <code>entries</code> and <code>exits</code>.</p> <p>Such generators often have suffix 'NX'.</p>  <code>Chain</code>  <p>Generate chain of entries and exits using <code>generate_enex_func</code>.</p> <p>Takes one input signal array - <code>entries</code>. Produces two output signal arrays - <code>new_entries</code> and <code>exits</code>.</p> <p>Such generators often have suffix 'CX'.</p>","title":"FactoryMode variable"},{"location":"api/signals/enums/#vectorbt.signals.enums.StopType","text":"<p>Stop type.</p> <pre><code>{\n    \"StopLoss\": 0,\n    \"TrailStop\": 1,\n    \"TakeProfit\": 2\n}\n</code></pre>","title":"StopType variable"},{"location":"api/signals/factory/","text":"<p>A factory for building new signal generators with ease.</p> <p>The signal factory class SignalFactory extends IndicatorFactory to offer a convenient way to create signal generators of any complexity. By providing it with information such as entry and exit functions and the names of inputs, parameters, and outputs, it will create a stand-alone class capable of generating signals for an arbitrary combination of inputs and parameters.</p>","title":"factory"},{"location":"api/signals/factory/#vectorbt.signals.factory.SignalFactory","text":"<pre><code>SignalFactory(\n    *args,\n    mode=2,\n    input_names=None,\n    attr_settings=None,\n    **kwargs\n)\n</code></pre> <p>A factory for building signal generators.</p> <p>Extends IndicatorFactory with choice functions.</p> <p>Generates a fixed number of outputs (depending upon <code>mode</code>). If you need to generate other outputs, use in-place outputs (via <code>in_output_names</code>).</p> <p>See FactoryMode for supported generation modes.</p> <p>Other arguments are passed to IndicatorFactory. <pre><code>A factory for creating new indicators.\n\nInitialize `IndicatorFactory` to create a skeleton and then use a class method\nsuch as `IndicatorFactory.from_custom_func` to bind a calculation function to the skeleton.\n\n__Args__\n\n**```class_name```** :&amp;ensp;`str`\n:   Name for the created indicator class.\n\n**```class_docstring```** :&amp;ensp;`str`\n:   Docstring for the created indicator class.\n\n**```module_name```** :&amp;ensp;`str`\n:   Specify the module the class originates from.\n\n**```short_name```** :&amp;ensp;`str`\n:   A short name of the indicator.\n\n    Defaults to lower-case `class_name`.\n\n**```prepend_name```** :&amp;ensp;`bool`\n:   Whether to prepend `short_name` to each parameter level.\n\n**```input_names```** :&amp;ensp;`list` of `str`\n:   A list of names of input arrays.\n\n**```param_names```** :&amp;ensp;`list` of `str`\n:   A list of names of parameters.\n\n**```in_output_names```** :&amp;ensp;`list` of `str`\n:   A list of names of in-place output arrays.\n\n    An in-place output is an output that is not returned but modified in-place.\n    Some advantages of such outputs include:\n\n    1) they don't need to be returned,\n    2) they can be passed between functions as easily as inputs,\n    3) they can be provided with already allocated data to safe memory,\n    4) if data or default value are not provided, they are created empty to not occupy memory.\n\n**```output_names```** :&amp;ensp;`list` of `str`\n:   A list of names of output arrays.\n\n**```output_flags```** :&amp;ensp;`dict`\n:   A dictionary of in-place and regular output flags.\n\n**```custom_output_props```** :&amp;ensp;`dict`\n:   A dictionary with user-defined functions that will be\n    bound to the indicator class and wrapped with `@cached_property`.\n\n**```attr_settings```** :&amp;ensp;`dict`\n:   A dictionary of settings by attribute name.\n\n    Attributes can be `input_names`, `in_output_names`, `output_names` and `custom_output_props`.\n\n    Following keys are accepted:\n\n    * `dtype`: Data type used to determine which methods to generate around this attribute.\n        Set to None to disable. Default is `np.float_`. Can be set to instance of\n        `collections.namedtuple` acting as enumerated type, or any other mapping;\n        It will then create a property with suffix `readable` that contains data in a string format.\n\n**```metrics```** :&amp;ensp;`dict`\n:   Metrics supported by [StatsBuilderMixin.stats()](/api/generic/stats_builder/#vectorbt.generic.stats_builder.StatsBuilderMixin.stats \"vectorbt.generic.stats_builder.StatsBuilderMixin.stats\").\n\n    If dict, will be converted to [Config](/api/utils/config/#vectorbt.utils.config.Config \"vectorbt.utils.config.Config\").\n\n**```stats_defaults```** :&amp;ensp;`callable` or `dict`\n:   Defaults for [StatsBuilderMixin.stats()](/api/generic/stats_builder/#vectorbt.generic.stats_builder.StatsBuilderMixin.stats \"vectorbt.generic.stats_builder.StatsBuilderMixin.stats\").\n\n    If dict, will be converted into a property.\n\n**```subplots```** :&amp;ensp;`dict`\n:   Subplots supported by [PlotsBuilderMixin.plots()](/api/generic/plots_builder/#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots \"vectorbt.generic.plots_builder.PlotsBuilderMixin.plots\").\n\n    If dict, will be converted to [Config](/api/utils/config/#vectorbt.utils.config.Config \"vectorbt.utils.config.Config\").\n\n**```plots_defaults```** :&amp;ensp;`callable` or `dict`\n:   Defaults for [PlotsBuilderMixin.plots()](/api/generic/plots_builder/#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots \"vectorbt.generic.plots_builder.PlotsBuilderMixin.plots\").\n\n    If dict, will be converted into a property.\n\n!!! note\n    The `__init__` method is not used for running the indicator, for this use `run`.\n    The reason for this is indexing, which requires a clean `__init__` method for creating \n    a new indicator object with newly indexed attributes.\n\n__Superclasses__\n\n* [IndicatorFactory](/api/indicators/factory/#vectorbt.indicators.factory.IndicatorFactory \"vectorbt.indicators.factory.IndicatorFactory\")\n\n__Inherited members__\n\n* [IndicatorFactory.find_ta_indicator()](/api/indicators/factory/#vectorbt.indicators.factory.IndicatorFactory.find_ta_indicator \"vectorbt.indicators.factory.IndicatorFactory.find_ta_indicator\")\n* [IndicatorFactory.from_apply_func()](/api/indicators/factory/#vectorbt.indicators.factory.IndicatorFactory.from_apply_func \"vectorbt.indicators.factory.IndicatorFactory.from_apply_func\")\n* [IndicatorFactory.from_custom_func()](/api/indicators/factory/#vectorbt.indicators.factory.IndicatorFactory.from_custom_func \"vectorbt.indicators.factory.IndicatorFactory.from_custom_func\")\n* [IndicatorFactory.from_pandas_ta()](/api/indicators/factory/#vectorbt.indicators.factory.IndicatorFactory.from_pandas_ta \"vectorbt.indicators.factory.IndicatorFactory.from_pandas_ta\")\n* [IndicatorFactory.from_ta()](/api/indicators/factory/#vectorbt.indicators.factory.IndicatorFactory.from_ta \"vectorbt.indicators.factory.IndicatorFactory.from_ta\")\n* [IndicatorFactory.from_talib()](/api/indicators/factory/#vectorbt.indicators.factory.IndicatorFactory.from_talib \"vectorbt.indicators.factory.IndicatorFactory.from_talib\")\n* [IndicatorFactory.get_pandas_ta_indicators()](/api/indicators/factory/#vectorbt.indicators.factory.IndicatorFactory.get_pandas_ta_indicators \"vectorbt.indicators.factory.IndicatorFactory.get_pandas_ta_indicators\")\n* [IndicatorFactory.get_ta_indicators()](/api/indicators/factory/#vectorbt.indicators.factory.IndicatorFactory.get_ta_indicators \"vectorbt.indicators.factory.IndicatorFactory.get_ta_indicators\")\n* [IndicatorFactory.get_talib_indicators()](/api/indicators/factory/#vectorbt.indicators.factory.IndicatorFactory.get_talib_indicators \"vectorbt.indicators.factory.IndicatorFactory.get_talib_indicators\")\n* [IndicatorFactory.parse_pandas_ta_config()](/api/indicators/factory/#vectorbt.indicators.factory.IndicatorFactory.parse_pandas_ta_config \"vectorbt.indicators.factory.IndicatorFactory.parse_pandas_ta_config\")\n* [IndicatorFactory.parse_ta_config()](/api/indicators/factory/#vectorbt.indicators.factory.IndicatorFactory.parse_ta_config \"vectorbt.indicators.factory.IndicatorFactory.parse_ta_config\")\n\n---\n\n### from_choice_func &lt;span class=\"dobjtype\"&gt;method&lt;/span&gt;&lt;a class=\"githublink\" href=\"https://github.com/polakowo/vectorbt/blob/a8ac2de36c1c8c733703854d97d84c28500e7bb4/vectorbt/signals/factory.py#L165-L950\" title=\"Jump to source\"&gt;:material-github:&lt;/a&gt; { #vectorbt.signals.factory.SignalFactory.from_choice_func data-toc-label='from_choice_func()' }\n\n```python\nSignalFactory.from_choice_func(\n    entry_choice_func=None,\n    exit_choice_func=None,\n    generate_func=generate_nb,\n    generate_ex_func=generate_ex_nb,\n    generate_enex_func=generate_enex_nb,\n    cache_func=None,\n    entry_settings=None,\n    exit_settings=None,\n    cache_settings=None,\n    numba_loop=False,\n    **kwargs\n)\n</code></pre></p> <p>Build signal generator class around entry and exit choice functions.</p> <p>A choice function is simply a function that returns indices of signals. There are two types of it: entry choice function and exit choice function. Each choice function takes broadcast time series, broadcast in-place output time series, broadcast parameter arrays, and other arguments, and returns an array of indices corresponding to chosen signals. See generate_nb().</p> <p>Args</p>  <code>entry_choice_func</code> :\u2002<code>callable</code>  <p><code>choice_func_nb</code> that returns indices of entries.</p> <p>Defaults to first_choice_nb() for <code>FactoryMode.Chain</code>.</p>  <code>exit_choice_func</code> :\u2002<code>callable</code> <code>choice_func_nb</code> that returns indices of exits. <code>generate_func</code> :\u2002<code>callable</code>  <p>Entry generation function.</p> <p>Defaults to generate_nb().</p>  <code>generate_ex_func</code> :\u2002<code>callable</code>  <p>Exit generation function.</p> <p>Defaults to generate_ex_nb().</p>  <code>generate_enex_func</code> :\u2002<code>callable</code>  <p>Entry and exit generation function.</p> <p>Defaults to generate_enex_nb().</p>  <code>cache_func</code> :\u2002<code>callable</code>  <p>A caching function to preprocess data beforehand.</p> <p>All returned objects will be passed as last arguments to choice functions.</p>  <code>entry_settings</code> :\u2002<code>dict</code> Settings dict for <code>entry_choice_func</code>. <code>exit_settings</code> :\u2002<code>dict</code> Settings dict for <code>exit_choice_func</code>. <code>cache_settings</code> :\u2002<code>dict</code> Settings dict for <code>cache_func</code>. <code>numba_loop</code> :\u2002<code>bool</code>  <p>Whether to loop using Numba.</p> <p>Set to True when iterating large number of times over small input.</p>  <code>**kwargs</code> Keyword arguments passed to <code>IndicatorFactory.from_custom_func</code>.   <p>Note</p> <p>Choice functions should be Numba-compiled.</p> <p>Which inputs, parameters and arguments to pass to each function should be explicitly indicated in the function's settings dict. By default, nothing is passed.</p> <p>Passing keyword arguments directly to the choice functions is not supported. Use <code>pass_kwargs</code> in a settings dict to pass keyword arguments as positional.</p>  <p>Settings dict of each function can have the following keys:</p> <p>Attributes</p>  <code>pass_inputs</code> :\u2002<code>list</code> of <code>str</code>  <p>Input names to pass to the choice function.</p> <p>Defaults to []. Order matters. Each name must be in <code>input_names</code>.</p>  <code>pass_in_outputs</code> :\u2002<code>list</code> of <code>str</code>  <p>In-place output names to pass to the choice function.</p> <p>Defaults to []. Order matters. Each name must be in <code>in_output_names</code>.</p>  <code>pass_params</code> :\u2002<code>list</code> of <code>str</code>  <p>Parameter names to pass to the choice function.</p> <p>Defaults to []. Order matters. Each name must be in <code>param_names</code>.</p>  <code>pass_kwargs</code> :\u2002<code>dict</code>, <code>list</code> of <code>str</code> or <code>list</code> of <code>tuple</code>  <p>Keyword arguments from <code>kwargs</code> dict to pass as positional arguments to the choice function.</p> <p>Defaults to []. Order matters.</p> <p>If any element is a tuple, should contain the name and the default value. If any element is a string, the default value is None.</p> <p>Built-in keys include:</p> <ul> <li><code>input_shape</code>: Input shape if no input time series passed.     Default is provided by the pipeline if <code>pass_input_shape</code> is True.</li> <li><code>wait</code>: Number of ticks to wait before placing signals.     Default is 1.</li> <li> <p><code>until_next</code>: Whether to place signals up to the next entry signal.     Default is True.</p> <p>Applied in <code>generate_ex_func</code> only.     * <code>skip_until_exit</code>: Whether to skip processing entry signals until the next exit. Default is False.</p> <p>Applied in <code>generate_ex_func</code> only.     * <code>pick_first</code>: Whether to stop as soon as the first exit signal is found. Default is False with <code>FactoryMode.Entries</code>, otherwise is True.     * <code>temp_idx_arr</code>: Empty integer array used to temporarily store indices. Default is an automatically generated array of shape <code>input_shape[0]</code>.</p> <p>You can also pass <code>temp_idx_arr1</code>, <code>temp_idx_arr2</code>, etc. to generate multiple.     * <code>flex_2d</code>: See flex_select_auto_nb(). Default is provided by the pipeline if <code>pass_flex_2d</code> is True.</p> </li> </ul>  <code>pass_cache</code> :\u2002<code>bool</code>  <p>Whether to pass cache from <code>cache_func</code> to the choice function.</p> <p>Defaults to False. Cache is passed unpacked.</p>   <p>The following arguments can be passed to <code>run</code> and <code>run_combs</code> methods:</p> <p>Args</p>  <code>*args</code> Should be used instead of <code>entry_args</code> with <code>FactoryMode.Entries</code> and instead of <code>exit_args</code> with <code>FactoryMode.Exits</code> and <code>FactoryMode.Chain</code> with default <code>entry_choice_func</code>. <code>entry_args</code> :\u2002<code>tuple</code> Arguments passed to the entry choice function. <code>exit_args</code> :\u2002<code>tuple</code> Arguments passed to the exit choice function. <code>cache_args</code> :\u2002<code>tuple</code> Arguments passed to the cache function. <code>entry_kwargs</code> :\u2002<code>tuple</code> Settings for the entry choice function. Also contains arguments passed as positional if in <code>pass_kwargs</code>. <code>exit_kwargs</code> :\u2002<code>tuple</code> Settings for the exit choice function. Also contains arguments passed as positional if in <code>pass_kwargs</code>. <code>cache_kwargs</code> :\u2002<code>tuple</code> Settings for the cache function. Also contains arguments passed as positional if in <code>pass_kwargs</code>. <code>return_cache</code> :\u2002<code>bool</code> Whether to return only cache. <code>use_cache</code> :\u2002<code>any</code> Cache to use. <code>**kwargs</code> Should be used instead of <code>entry_kwargs</code> with <code>FactoryMode.Entries</code> and instead of <code>exit_kwargs</code> with <code>FactoryMode.Exits</code> and <code>FactoryMode.Chain</code> with default <code>entry_choice_func</code>.  <p>For more arguments, see run_pipeline().</p> <p>Usage</p> <ul> <li>The simplest signal indicator that places True at the very first index:</li> </ul> <pre><code>&gt;&gt;&gt; from numba import njit\n&gt;&gt;&gt; import vectorbt as vbt\n&gt;&gt;&gt; import numpy as np\n\n&gt;&gt;&gt; @njit\n... def entry_choice_func(from_i, to_i, col):\n...     return np.array([from_i])\n\n&gt;&gt;&gt; @njit\n... def exit_choice_func(from_i, to_i, col):\n...     return np.array([from_i])\n\n&gt;&gt;&gt; MySignals = vbt.SignalFactory().from_choice_func(\n...     entry_choice_func=entry_choice_func,\n...     exit_choice_func=exit_choice_func,\n...     entry_kwargs=dict(wait=1),\n...     exit_kwargs=dict(wait=1)\n... )\n\n&gt;&gt;&gt; my_sig = MySignals.run(input_shape=(3, 3))\n&gt;&gt;&gt; my_sig.entries\n       0      1      2\n0   True   True   True\n1  False  False  False\n2   True   True   True\n&gt;&gt;&gt; my_sig.exits\n       0      1      2\n0  False  False  False\n1   True   True   True\n2  False  False  False\n</code></pre> <ul> <li>Take the first entry and place an exit after waiting <code>n</code> ticks. Find the next entry and repeat. Test three different <code>n</code> values.</li> </ul> <pre><code>&gt;&gt;&gt; from numba import njit\n&gt;&gt;&gt; from vectorbt.signals.factory import SignalFactory\n\n&gt;&gt;&gt; @njit\n... def wait_choice_nb(from_i, to_i, col, n, temp_idx_arr):\n...     temp_idx_arr[0] = from_i + n  # index of next exit\n...     if temp_idx_arr[0] &lt; to_i:\n...         return temp_idx_arr[:1]\n...     return temp_idx_arr[:0]  # must return array anyway\n\n&gt;&gt;&gt; # Build signal generator\n&gt;&gt;&gt; MySignals = SignalFactory(\n...     mode='chain',\n...     param_names=['n']\n... ).from_choice_func(\n...     exit_choice_func=wait_choice_nb,\n...     exit_settings=dict(\n...         pass_params=['n'],\n...         pass_kwargs=['temp_idx_arr']  # built-in kwarg\n...     )\n... )\n\n&gt;&gt;&gt; # Run signal generator\n&gt;&gt;&gt; entries = [True, True, True, True, True]\n&gt;&gt;&gt; my_sig = MySignals.run(entries, [0, 1, 2])\n\n&gt;&gt;&gt; my_sig.entries  # input entries\ncustom_n     0     1     2\n0         True  True  True\n1         True  True  True\n2         True  True  True\n3         True  True  True\n4         True  True  True\n\n&gt;&gt;&gt; my_sig.new_entries  # output entries\ncustom_n      0      1      2\n0          True   True   True\n1         False  False  False\n2          True  False  False\n3         False   True  False\n4          True  False   True\n\n&gt;&gt;&gt; my_sig.exits  # output exits\ncustom_n      0      1      2\n0         False  False  False\n1          True  False  False\n2         False   True  False\n3          True  False   True\n4         False  False  False\n</code></pre> <ul> <li>To combine multiple iterative signals, you would need to create a custom choice function. Here is an example of combining two random generators using \"OR\" rule (the first signal wins):</li> </ul> <pre><code>&gt;&gt;&gt; from numba import njit\n&gt;&gt;&gt; from collections import namedtuple\n&gt;&gt;&gt; from vectorbt.indicators.configs import flex_elem_param_config\n&gt;&gt;&gt; from vectorbt.signals.factory import SignalFactory\n&gt;&gt;&gt; from vectorbt.signals.nb import rand_by_prob_choice_nb\n\n&gt;&gt;&gt; # Enum to distinguish random generators\n&gt;&gt;&gt; RandType = namedtuple('RandType', ['R1', 'R2'])(0, 1)\n\n&gt;&gt;&gt; # Define exit choice function\n&gt;&gt;&gt; @njit\n... def rand_exit_choice_nb(from_i, to_i, col, rand_type, prob1,\n...                         prob2, temp_idx_arr1, temp_idx_arr2, flex_2d):\n...     idxs1 = rand_by_prob_choice_nb(from_i, to_i, col, prob1, True, temp_idx_arr1, flex_2d)\n...     if len(idxs1) &gt; 0:\n...         to_i = idxs1[0]  # no need to go beyond first the first found signal\n...     idxs2 = rand_by_prob_choice_nb(from_i, to_i, col, prob2, True, temp_idx_arr2, flex_2d)\n...     if len(idxs2) &gt; 0:\n...         rand_type[idxs2[0], col] = RandType.R2\n...         return idxs2\n...     if len(idxs1) &gt; 0:\n...         rand_type[idxs1[0], col] = RandType.R1\n...         return idxs1\n...     return temp_idx_arr1[:0]\n\n&gt;&gt;&gt; # Build signal generator\n&gt;&gt;&gt; MySignals = SignalFactory(\n...     mode='chain',\n...     in_output_names=['rand_type'],\n...     param_names=['prob1', 'prob2'],\n...     attr_settings=dict(\n...         rand_type=dict(dtype=RandType)  # creates rand_type_readable\n...     )\n... ).from_choice_func(\n...     exit_choice_func=rand_exit_choice_nb,\n...     exit_settings=dict(\n...         pass_in_outputs=['rand_type'],\n...         pass_params=['prob1', 'prob2'],\n...         pass_kwargs=['temp_idx_arr1', 'temp_idx_arr2', 'flex_2d']\n...     ),\n...     param_settings=dict(\n...         prob1=flex_elem_param_config,  # param per frame/row/col/element\n...         prob2=flex_elem_param_config\n...     ),\n...     pass_flex_2d=True,\n...     rand_type=-1  # fill with this value\n... )\n\n&gt;&gt;&gt; # Run signal generator\n&gt;&gt;&gt; entries = [True, True, True, True, True]\n&gt;&gt;&gt; my_sig = MySignals.run(entries, [0., 1.], [0., 1.], param_product=True)\n\n&gt;&gt;&gt; my_sig.new_entries\ncustom_prob1           0.0           1.0\ncustom_prob2    0.0    1.0    0.0    1.0\n0              True   True   True   True\n1             False  False  False  False\n2             False   True   True   True\n3             False  False  False  False\n4             False   True   True   True\n\n&gt;&gt;&gt; my_sig.exits\ncustom_prob1           0.0           1.0\ncustom_prob2    0.0    1.0    0.0    1.0\n0             False  False  False  False\n1             False   True   True   True\n2             False  False  False  False\n3             False   True   True   True\n4             False  False  False  False\n\n&gt;&gt;&gt; my_sig.rand_type_readable\ncustom_prob1     0.0     1.0\ncustom_prob2 0.0 1.0 0.0 1.0\n0\n1                 R2  R1  R1\n2\n3                 R2  R1  R1\n4\n</code></pre>","title":"SignalFactory class"},{"location":"api/signals/generators/","text":"<p>Signal generators built with SignalFactory.</p>","title":"generators"},{"location":"api/signals/generators/#vectorbt.signals.generators.ohlcstx_config","text":"<p>Factory config for OHLCSTX.</p>","title":"ohlcstx_config variable"},{"location":"api/signals/generators/#vectorbt.signals.generators.ohlcstx_func_config","text":"<p>Exit function config for OHLCSTX.</p>","title":"ohlcstx_func_config variable"},{"location":"api/signals/generators/#vectorbt.signals.generators.rprobx_config","text":"<p>Factory config for RPROBX.</p>","title":"rprobx_config variable"},{"location":"api/signals/generators/#vectorbt.signals.generators.rprobx_func_config","text":"<p>Exit function config for RPROBX.</p>","title":"rprobx_func_config variable"},{"location":"api/signals/generators/#vectorbt.signals.generators.stx_config","text":"<p>Factory config for STX.</p>","title":"stx_config variable"},{"location":"api/signals/generators/#vectorbt.signals.generators.stx_func_config","text":"<p>Exit function config for STX.</p>","title":"stx_func_config variable"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX","text":"<pre><code>OHLCSTCX(\n    wrapper,\n    input_list,\n    input_mapper,\n    in_output_list,\n    output_list,\n    param_list,\n    mapper_list,\n    short_name,\n    level_names\n)\n</code></pre> <p>Exit signal generator based on OHLC and stop values.</p> <p>Generates chain of <code>new_entries</code> and <code>exits</code> based on <code>entries</code> and ohlc_stop_choice_nb().</p> <p>See OHLCSTX for notes on parameters.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>IndicatorBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> <li><code>vectorbt.signals.generators.ParamIndexer</code></li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>IndicatorBase.config</li> <li>IndicatorBase.iloc</li> <li>IndicatorBase.in_output_names</li> <li>IndicatorBase.indexing_func()</li> <li>IndicatorBase.indexing_kwargs</li> <li>IndicatorBase.input_names</li> <li>IndicatorBase.level_names</li> <li>IndicatorBase.loc</li> <li>IndicatorBase.output_flags</li> <li>IndicatorBase.output_names</li> <li>IndicatorBase.param_names</li> <li>IndicatorBase.plots_defaults</li> <li>IndicatorBase.self_aliases</li> <li>IndicatorBase.short_name</li> <li>IndicatorBase.stats_defaults</li> <li>IndicatorBase.wrapper</li> <li>IndicatorBase.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li><code>vectorbt.signals.generators._OHLCSTCX</code></li> </ul>","title":"OHLCSTCX class"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.run","text":"<pre><code>OHLCSTCX.run(\n    entries,\n    open,\n    high,\n    low,\n    close,\n    sl_stop=Default(nan),\n    sl_trail=Default(False),\n    tp_stop=Default(nan),\n    reverse=Default(False),\n    stop_price=nan,\n    stop_type=-1,\n    short_name='ohlcstcx',\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Run OHLCSTCX indicator.</p> <ul> <li>Inputs: <code>entries</code>, <code>open</code>, <code>high</code>, <code>low</code>, <code>close</code></li> <li>In-place outputs: <code>stop_price</code>, <code>stop_type</code></li> <li>Parameters: <code>sl_stop</code>, <code>sl_trail</code>, <code>tp_stop</code>, <code>reverse</code></li> <li>Outputs: <code>new_entries</code>, <code>exits</code></li> </ul> <p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels. Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p> <p>Other keyword arguments are passed to run_pipeline().</p>","title":"run class method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.run_combs","text":"<pre><code>OHLCSTCX.run_combs(\n    entries,\n    open,\n    high,\n    low,\n    close,\n    sl_stop=Default(nan),\n    sl_trail=Default(False),\n    tp_stop=Default(nan),\n    reverse=Default(False),\n    stop_price=nan,\n    stop_type=-1,\n    r=2,\n    param_product=False,\n    comb_func=itertools.combinations,\n    run_unique=True,\n    short_names=None,\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Create a combination of multiple OHLCSTCX indicators using function <code>comb_func</code>.</p> <ul> <li>Inputs: <code>entries</code>, <code>open</code>, <code>high</code>, <code>low</code>, <code>close</code></li> <li>In-place outputs: <code>stop_price</code>, <code>stop_type</code></li> <li>Parameters: <code>sl_stop</code>, <code>sl_trail</code>, <code>tp_stop</code>, <code>reverse</code></li> <li>Outputs: <code>new_entries</code>, <code>exits</code></li> </ul> <p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.  Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>. Pass <code>r</code> to specify how many indicators to run.  Pass <code>short_names</code> to specify the short name for each indicator.  Set <code>run_unique</code> to True to first compute raw outputs for all parameters,  and then use them to build each indicator (faster).</p> <p>Other keyword arguments are passed to OHLCSTCX.run().</p>","title":"run_combs class method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.close","text":"<p>Input array.</p>","title":"close variable"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.entries","text":"<p>Input array.</p>","title":"entries variable"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.exits","text":"<p>Output array.</p>","title":"exits property"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.high","text":"<p>Input array.</p>","title":"high variable"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.low","text":"<p>Input array.</p>","title":"low variable"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.new_entries","text":"<p>Output array.</p>","title":"new_entries property"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.open","text":"<p>Input array.</p>","title":"open variable"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.reverse_list","text":"<p>List of <code>reverse</code> values.</p>","title":"reverse_list property"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.sl_stop_list","text":"<p>List of <code>sl_stop</code> values.</p>","title":"sl_stop_list property"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.sl_trail_list","text":"<p>List of <code>sl_trail</code> values.</p>","title":"sl_trail_list property"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.stop_price","text":"<p>In-place output array.</p>","title":"stop_price property"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.stop_type","text":"<p>In-place output array.</p>","title":"stop_type property"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.stop_type_readable","text":"<p><code>stop_type</code> in readable format based on the following mapping: </p> <pre><code>{\n    \"0\": \"StopLoss\",\n    \"1\": \"TrailStop\",\n    \"2\": \"TakeProfit\",\n    \"-1\": null\n}\n</code></pre>","title":"stop_type_readable property"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.tp_stop_list","text":"<p>List of <code>tp_stop</code> values.</p>","title":"tp_stop_list property"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.close_above","text":"<pre><code>OHLCSTCX.close_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_above method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.close_below","text":"<pre><code>OHLCSTCX.close_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_below method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.close_crossed_above","text":"<pre><code>OHLCSTCX.close_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_above method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.close_crossed_below","text":"<pre><code>OHLCSTCX.close_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_below method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.close_equal","text":"<pre><code>OHLCSTCX.close_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_equal method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.close_stats","text":"<pre><code>OHLCSTCX.close_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>close</code> as generic.</p>","title":"close_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.entries_and","text":"<pre><code>OHLCSTCX.entries_and(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries AND other</code>. </p> <p>See combine_objs().</p>","title":"entries_and method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.entries_or","text":"<pre><code>OHLCSTCX.entries_or(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries OR other</code>. </p> <p>See combine_objs().</p>","title":"entries_or method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.entries_stats","text":"<pre><code>OHLCSTCX.entries_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>entries</code> as signals.</p>","title":"entries_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.entries_xor","text":"<pre><code>OHLCSTCX.entries_xor(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries XOR other</code>. </p> <p>See combine_objs().</p>","title":"entries_xor method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.exits_and","text":"<pre><code>OHLCSTCX.exits_and(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>exits AND other</code>. </p> <p>See combine_objs().</p>","title":"exits_and method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.exits_or","text":"<pre><code>OHLCSTCX.exits_or(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>exits OR other</code>. </p> <p>See combine_objs().</p>","title":"exits_or method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.exits_stats","text":"<pre><code>OHLCSTCX.exits_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>exits</code> as signals.</p>","title":"exits_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.exits_xor","text":"<pre><code>OHLCSTCX.exits_xor(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>exits XOR other</code>. </p> <p>See combine_objs().</p>","title":"exits_xor method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.high_above","text":"<pre><code>OHLCSTCX.high_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>high</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"high_above method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.high_below","text":"<pre><code>OHLCSTCX.high_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>high</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"high_below method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.high_crossed_above","text":"<pre><code>OHLCSTCX.high_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>high</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"high_crossed_above method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.high_crossed_below","text":"<pre><code>OHLCSTCX.high_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>high</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"high_crossed_below method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.high_equal","text":"<pre><code>OHLCSTCX.high_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>high</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"high_equal method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.high_stats","text":"<pre><code>OHLCSTCX.high_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>high</code> as generic.</p>","title":"high_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.low_above","text":"<pre><code>OHLCSTCX.low_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>low</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"low_above method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.low_below","text":"<pre><code>OHLCSTCX.low_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>low</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"low_below method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.low_crossed_above","text":"<pre><code>OHLCSTCX.low_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>low</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"low_crossed_above method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.low_crossed_below","text":"<pre><code>OHLCSTCX.low_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>low</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"low_crossed_below method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.low_equal","text":"<pre><code>OHLCSTCX.low_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>low</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"low_equal method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.low_stats","text":"<pre><code>OHLCSTCX.low_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>low</code> as generic.</p>","title":"low_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.new_entries_and","text":"<pre><code>OHLCSTCX.new_entries_and(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>new_entries AND other</code>. </p> <p>See combine_objs().</p>","title":"new_entries_and method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.new_entries_or","text":"<pre><code>OHLCSTCX.new_entries_or(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>new_entries OR other</code>. </p> <p>See combine_objs().</p>","title":"new_entries_or method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.new_entries_stats","text":"<pre><code>OHLCSTCX.new_entries_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>new_entries</code> as signals.</p>","title":"new_entries_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.new_entries_xor","text":"<pre><code>OHLCSTCX.new_entries_xor(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>new_entries XOR other</code>. </p> <p>See combine_objs().</p>","title":"new_entries_xor method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.open_above","text":"<pre><code>OHLCSTCX.open_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>open</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"open_above method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.open_below","text":"<pre><code>OHLCSTCX.open_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>open</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"open_below method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.open_crossed_above","text":"<pre><code>OHLCSTCX.open_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>open</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"open_crossed_above method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.open_crossed_below","text":"<pre><code>OHLCSTCX.open_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>open</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"open_crossed_below method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.open_equal","text":"<pre><code>OHLCSTCX.open_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>open</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"open_equal method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.open_stats","text":"<pre><code>OHLCSTCX.open_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>open</code> as generic.</p>","title":"open_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.stop_price_above","text":"<pre><code>OHLCSTCX.stop_price_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>stop_price</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"stop_price_above method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.stop_price_below","text":"<pre><code>OHLCSTCX.stop_price_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>stop_price</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"stop_price_below method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.stop_price_crossed_above","text":"<pre><code>OHLCSTCX.stop_price_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>stop_price</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"stop_price_crossed_above method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.stop_price_crossed_below","text":"<pre><code>OHLCSTCX.stop_price_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>stop_price</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"stop_price_crossed_below method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.stop_price_equal","text":"<pre><code>OHLCSTCX.stop_price_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>stop_price</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"stop_price_equal method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.stop_price_stats","text":"<pre><code>OHLCSTCX.stop_price_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>stop_price</code> as generic.</p>","title":"stop_price_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.stop_type_stats","text":"<pre><code>OHLCSTCX.stop_type_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>stop_type</code> based on the following mapping: </p> <pre><code>{\n    \"0\": \"StopLoss\",\n    \"1\": \"TrailStop\",\n    \"2\": \"TakeProfit\",\n    \"-1\": null\n}\n</code></pre>","title":"stop_type_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.custom_func","text":"<pre><code>SignalFactory.from_choice_func.&lt;locals&gt;.custom_func(\n    input_list,\n    in_output_list,\n    param_list,\n    *args,\n    input_shape=None,\n    flex_2d=None,\n    entry_args=None,\n    exit_args=None,\n    cache_args=None,\n    entry_kwargs=None,\n    exit_kwargs=None,\n    cache_kwargs=None,\n    return_cache=False,\n    use_cache=None,\n    **_kwargs\n)\n</code></pre>","title":"custom_func method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTCX.plot","text":"<pre><code>_bind_ohlcstx_plot.&lt;locals&gt;.plot(\n    plot_type=None,\n    ohlc_kwargs=None,\n    entry_trace_kwargs=None,\n    exit_trace_kwargs=None,\n    add_trace_kwargs=None,\n    fig=None,\n    **layout_kwargs\n)\n</code></pre> <p>Plot OHLC, OHLCSTCX.new_entries and OHLCSTCX.exits.</p> <p>Args</p>  <code>plot_type</code> Either 'OHLC', 'Candlestick' or Plotly trace. <code>ohlc_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plot_type</code>. <code>entry_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to         SignalsSRAccessor.plot_as_entry_markers() for OHLCSTCX.new_entries. <code>exit_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to         SignalsSRAccessor.plot_as_exit_markers() for OHLCSTCX.exits. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**layout_kwargs</code> Keyword arguments for layout.","title":"plot method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX","text":"<pre><code>OHLCSTX(\n    wrapper,\n    input_list,\n    input_mapper,\n    in_output_list,\n    output_list,\n    param_list,\n    mapper_list,\n    short_name,\n    level_names\n)\n</code></pre> <p>Exit signal generator based on OHLC and stop values.</p> <p>Generates <code>exits</code> based on <code>entries</code> and ohlc_stop_choice_nb().</p>  <p>Hint</p> <p>All parameters can be either a single value (per frame) or a NumPy array (per row, column, or element). To generate multiple combinations, pass them as lists.</p>  <p>Usage</p> <ul> <li>Test each stop type:</li> </ul> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import numpy as np\n\n&gt;&gt;&gt; entries = pd.Series([True, False, False, False, False, False])\n&gt;&gt;&gt; price = pd.DataFrame({\n...     'open': [10, 11, 12, 11, 10, 9],\n...     'high': [11, 12, 13, 12, 11, 10],\n...     'low': [9, 10, 11, 10, 9, 8],\n...     'close': [10, 11, 12, 11, 10, 9]\n... })\n&gt;&gt;&gt; ohlcstx = vbt.OHLCSTX.run(\n...     entries,\n...     price['open'], price['high'], price['low'], price['close'],\n...     sl_stop=[0.1, 0.1, np.nan],\n...     sl_trail=[False, True, False],\n...     tp_stop=[np.nan, np.nan, 0.1])\n\n&gt;&gt;&gt; ohlcstx.entries\nohlcstx_sl_stop     0.1    0.1    NaN\nohlcstx_sl_trail  False   True  False\nohlcstx_tp_stop     NaN    NaN    0.1\n0                  True   True   True\n1                 False  False  False\n2                 False  False  False\n3                 False  False  False\n4                 False  False  False\n5                 False  False  False\n\n&gt;&gt;&gt; ohlcstx.exits\nohlcstx_sl_stop     0.1    0.1    NaN\nohlcstx_sl_trail  False   True  False\nohlcstx_tp_stop     NaN    NaN    0.1\n0                 False  False  False\n1                 False  False   True\n2                 False  False  False\n3                 False   True  False\n4                  True  False  False\n5                 False  False  False\n\n&gt;&gt;&gt; ohlcstx.stop_price\nohlcstx_sl_stop     0.1    0.1    NaN\nohlcstx_sl_trail  False   True  False\nohlcstx_tp_stop     NaN    NaN    0.1\n0                   NaN    NaN    NaN\n1                   NaN    NaN   11.0\n2                   NaN    NaN    NaN\n3                   NaN   11.7    NaN\n4                   9.0    NaN    NaN\n5                   NaN    NaN    NaN\n\n&gt;&gt;&gt; ohlcstx.stop_type_readable\nohlcstx_sl_stop        0.1        0.1         NaN\nohlcstx_sl_trail     False       True       False\nohlcstx_tp_stop        NaN        NaN         0.1\n0                     None       None        None\n1                     None       None  TakeProfit\n2                     None       None        None\n3                     None  TrailStop        None\n4                 StopLoss       None        None\n5                     None       None        None\n</code></pre> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>IndicatorBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> <li><code>vectorbt.signals.generators.ParamIndexer</code></li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>IndicatorBase.config</li> <li>IndicatorBase.iloc</li> <li>IndicatorBase.in_output_names</li> <li>IndicatorBase.indexing_func()</li> <li>IndicatorBase.indexing_kwargs</li> <li>IndicatorBase.input_names</li> <li>IndicatorBase.level_names</li> <li>IndicatorBase.loc</li> <li>IndicatorBase.output_flags</li> <li>IndicatorBase.output_names</li> <li>IndicatorBase.param_names</li> <li>IndicatorBase.plots_defaults</li> <li>IndicatorBase.self_aliases</li> <li>IndicatorBase.short_name</li> <li>IndicatorBase.stats_defaults</li> <li>IndicatorBase.wrapper</li> <li>IndicatorBase.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li><code>vectorbt.signals.generators._OHLCSTX</code></li> </ul>","title":"OHLCSTX class"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.run","text":"<pre><code>OHLCSTX.run(\n    entries,\n    open,\n    high,\n    low,\n    close,\n    sl_stop=Default(nan),\n    sl_trail=Default(False),\n    tp_stop=Default(nan),\n    reverse=Default(False),\n    stop_price=nan,\n    stop_type=-1,\n    short_name='ohlcstx',\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Run OHLCSTX indicator.</p> <ul> <li>Inputs: <code>entries</code>, <code>open</code>, <code>high</code>, <code>low</code>, <code>close</code></li> <li>In-place outputs: <code>stop_price</code>, <code>stop_type</code></li> <li>Parameters: <code>sl_stop</code>, <code>sl_trail</code>, <code>tp_stop</code>, <code>reverse</code></li> <li>Outputs: <code>exits</code></li> </ul> <p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels. Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p> <p>Other keyword arguments are passed to run_pipeline().</p>","title":"run class method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.run_combs","text":"<pre><code>OHLCSTX.run_combs(\n    entries,\n    open,\n    high,\n    low,\n    close,\n    sl_stop=Default(nan),\n    sl_trail=Default(False),\n    tp_stop=Default(nan),\n    reverse=Default(False),\n    stop_price=nan,\n    stop_type=-1,\n    r=2,\n    param_product=False,\n    comb_func=itertools.combinations,\n    run_unique=True,\n    short_names=None,\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Create a combination of multiple OHLCSTX indicators using function <code>comb_func</code>.</p> <ul> <li>Inputs: <code>entries</code>, <code>open</code>, <code>high</code>, <code>low</code>, <code>close</code></li> <li>In-place outputs: <code>stop_price</code>, <code>stop_type</code></li> <li>Parameters: <code>sl_stop</code>, <code>sl_trail</code>, <code>tp_stop</code>, <code>reverse</code></li> <li>Outputs: <code>exits</code></li> </ul> <p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.  Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>. Pass <code>r</code> to specify how many indicators to run.  Pass <code>short_names</code> to specify the short name for each indicator.  Set <code>run_unique</code> to True to first compute raw outputs for all parameters,  and then use them to build each indicator (faster).</p> <p>Other keyword arguments are passed to OHLCSTX.run().</p>","title":"run_combs class method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.close","text":"<p>Input array.</p>","title":"close variable"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.entries","text":"<p>Input array.</p>","title":"entries variable"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.exits","text":"<p>Output array.</p>","title":"exits property"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.high","text":"<p>Input array.</p>","title":"high variable"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.low","text":"<p>Input array.</p>","title":"low variable"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.open","text":"<p>Input array.</p>","title":"open variable"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.reverse_list","text":"<p>List of <code>reverse</code> values.</p>","title":"reverse_list property"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.sl_stop_list","text":"<p>List of <code>sl_stop</code> values.</p>","title":"sl_stop_list property"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.sl_trail_list","text":"<p>List of <code>sl_trail</code> values.</p>","title":"sl_trail_list property"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.stop_price","text":"<p>In-place output array.</p>","title":"stop_price property"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.stop_type","text":"<p>In-place output array.</p>","title":"stop_type property"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.stop_type_readable","text":"<p><code>stop_type</code> in readable format based on the following mapping: </p> <pre><code>{\n    \"0\": \"StopLoss\",\n    \"1\": \"TrailStop\",\n    \"2\": \"TakeProfit\",\n    \"-1\": null\n}\n</code></pre>","title":"stop_type_readable property"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.tp_stop_list","text":"<p>List of <code>tp_stop</code> values.</p>","title":"tp_stop_list property"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.close_above","text":"<pre><code>OHLCSTX.close_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_above method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.close_below","text":"<pre><code>OHLCSTX.close_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_below method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.close_crossed_above","text":"<pre><code>OHLCSTX.close_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_above method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.close_crossed_below","text":"<pre><code>OHLCSTX.close_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_crossed_below method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.close_equal","text":"<pre><code>OHLCSTX.close_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>close</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"close_equal method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.close_stats","text":"<pre><code>OHLCSTX.close_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>close</code> as generic.</p>","title":"close_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.entries_and","text":"<pre><code>OHLCSTX.entries_and(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries AND other</code>. </p> <p>See combine_objs().</p>","title":"entries_and method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.entries_or","text":"<pre><code>OHLCSTX.entries_or(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries OR other</code>. </p> <p>See combine_objs().</p>","title":"entries_or method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.entries_stats","text":"<pre><code>OHLCSTX.entries_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>entries</code> as signals.</p>","title":"entries_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.entries_xor","text":"<pre><code>OHLCSTX.entries_xor(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries XOR other</code>. </p> <p>See combine_objs().</p>","title":"entries_xor method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.exits_and","text":"<pre><code>OHLCSTX.exits_and(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>exits AND other</code>. </p> <p>See combine_objs().</p>","title":"exits_and method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.exits_or","text":"<pre><code>OHLCSTX.exits_or(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>exits OR other</code>. </p> <p>See combine_objs().</p>","title":"exits_or method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.exits_stats","text":"<pre><code>OHLCSTX.exits_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>exits</code> as signals.</p>","title":"exits_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.exits_xor","text":"<pre><code>OHLCSTX.exits_xor(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>exits XOR other</code>. </p> <p>See combine_objs().</p>","title":"exits_xor method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.high_above","text":"<pre><code>OHLCSTX.high_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>high</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"high_above method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.high_below","text":"<pre><code>OHLCSTX.high_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>high</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"high_below method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.high_crossed_above","text":"<pre><code>OHLCSTX.high_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>high</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"high_crossed_above method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.high_crossed_below","text":"<pre><code>OHLCSTX.high_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>high</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"high_crossed_below method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.high_equal","text":"<pre><code>OHLCSTX.high_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>high</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"high_equal method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.high_stats","text":"<pre><code>OHLCSTX.high_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>high</code> as generic.</p>","title":"high_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.low_above","text":"<pre><code>OHLCSTX.low_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>low</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"low_above method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.low_below","text":"<pre><code>OHLCSTX.low_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>low</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"low_below method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.low_crossed_above","text":"<pre><code>OHLCSTX.low_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>low</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"low_crossed_above method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.low_crossed_below","text":"<pre><code>OHLCSTX.low_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>low</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"low_crossed_below method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.low_equal","text":"<pre><code>OHLCSTX.low_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>low</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"low_equal method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.low_stats","text":"<pre><code>OHLCSTX.low_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>low</code> as generic.</p>","title":"low_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.open_above","text":"<pre><code>OHLCSTX.open_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>open</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"open_above method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.open_below","text":"<pre><code>OHLCSTX.open_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>open</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"open_below method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.open_crossed_above","text":"<pre><code>OHLCSTX.open_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>open</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"open_crossed_above method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.open_crossed_below","text":"<pre><code>OHLCSTX.open_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>open</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"open_crossed_below method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.open_equal","text":"<pre><code>OHLCSTX.open_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>open</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"open_equal method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.open_stats","text":"<pre><code>OHLCSTX.open_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>open</code> as generic.</p>","title":"open_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.stop_price_above","text":"<pre><code>OHLCSTX.stop_price_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>stop_price</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"stop_price_above method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.stop_price_below","text":"<pre><code>OHLCSTX.stop_price_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>stop_price</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"stop_price_below method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.stop_price_crossed_above","text":"<pre><code>OHLCSTX.stop_price_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>stop_price</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"stop_price_crossed_above method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.stop_price_crossed_below","text":"<pre><code>OHLCSTX.stop_price_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>stop_price</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"stop_price_crossed_below method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.stop_price_equal","text":"<pre><code>OHLCSTX.stop_price_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>stop_price</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"stop_price_equal method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.stop_price_stats","text":"<pre><code>OHLCSTX.stop_price_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>stop_price</code> as generic.</p>","title":"stop_price_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.stop_type_stats","text":"<pre><code>OHLCSTX.stop_type_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>stop_type</code> based on the following mapping: </p> <pre><code>{\n    \"0\": \"StopLoss\",\n    \"1\": \"TrailStop\",\n    \"2\": \"TakeProfit\",\n    \"-1\": null\n}\n</code></pre>","title":"stop_type_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.custom_func","text":"<pre><code>SignalFactory.from_choice_func.&lt;locals&gt;.custom_func(\n    input_list,\n    in_output_list,\n    param_list,\n    *args,\n    input_shape=None,\n    flex_2d=None,\n    entry_args=None,\n    exit_args=None,\n    cache_args=None,\n    entry_kwargs=None,\n    exit_kwargs=None,\n    cache_kwargs=None,\n    return_cache=False,\n    use_cache=None,\n    **_kwargs\n)\n</code></pre>","title":"custom_func method"},{"location":"api/signals/generators/#vectorbt.signals.generators.OHLCSTX.plot","text":"<pre><code>_bind_ohlcstx_plot.&lt;locals&gt;.plot(\n    plot_type=None,\n    ohlc_kwargs=None,\n    entry_trace_kwargs=None,\n    exit_trace_kwargs=None,\n    add_trace_kwargs=None,\n    fig=None,\n    **layout_kwargs\n)\n</code></pre> <p>Plot OHLC, OHLCSTX.entries and OHLCSTX.exits.</p> <p>Args</p>  <code>plot_type</code> Either 'OHLC', 'Candlestick' or Plotly trace. <code>ohlc_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plot_type</code>. <code>entry_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to         SignalsSRAccessor.plot_as_entry_markers() for OHLCSTX.entries. <code>exit_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to         SignalsSRAccessor.plot_as_exit_markers() for OHLCSTX.exits. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**layout_kwargs</code> Keyword arguments for layout.  <p>Usage</p> <pre><code>&gt;&gt;&gt; ohlcstx.iloc[:, 0].plot()\n</code></pre> <p></p>","title":"plot method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RAND","text":"<pre><code>RAND(\n    wrapper,\n    input_list,\n    input_mapper,\n    in_output_list,\n    output_list,\n    param_list,\n    mapper_list,\n    short_name,\n    level_names\n)\n</code></pre> <p>Random entry signal generator based on the number of signals.</p> <p>Generates <code>entries</code> based on rand_choice_nb().</p>  <p>Hint</p> <p>Parameter <code>n</code> can be either a single value (per frame) or a NumPy array (per column). To generate multiple combinations, pass it as a list.</p>  <p>Usage</p> <ul> <li>Test three different entry counts values:</li> </ul> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; rand = vbt.RAND.run(input_shape=(6,), n=[1, 2, 3], seed=42)\n\n&gt;&gt;&gt; rand.entries\nrand_n      1      2      3\n0        True   True   True\n1       False  False   True\n2       False  False  False\n3       False   True  False\n4       False  False   True\n5       False  False  False\n</code></pre> <ul> <li>Entry count can also be set per column:</li> </ul> <pre><code>&gt;&gt;&gt; import numpy as np\n\n&gt;&gt;&gt; rand = vbt.RAND.run(input_shape=(8, 2), n=[np.array([1, 2]), 3], seed=42)\n\n&gt;&gt;&gt; rand.entries\nrand_n      1      2      3      3\n            0      1      0      1\n0       False  False   True  False\n1        True  False  False  False\n2       False  False  False   True\n3       False   True   True  False\n4       False  False  False  False\n5       False  False  False   True\n6       False  False   True  False\n7       False   True  False   True\n</code></pre> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>IndicatorBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> <li><code>vectorbt.signals.generators.ParamIndexer</code></li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>IndicatorBase.config</li> <li>IndicatorBase.iloc</li> <li>IndicatorBase.in_output_names</li> <li>IndicatorBase.indexing_func()</li> <li>IndicatorBase.indexing_kwargs</li> <li>IndicatorBase.input_names</li> <li>IndicatorBase.level_names</li> <li>IndicatorBase.loc</li> <li>IndicatorBase.output_flags</li> <li>IndicatorBase.output_names</li> <li>IndicatorBase.param_names</li> <li>IndicatorBase.plots_defaults</li> <li>IndicatorBase.self_aliases</li> <li>IndicatorBase.short_name</li> <li>IndicatorBase.stats_defaults</li> <li>IndicatorBase.wrapper</li> <li>IndicatorBase.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li><code>vectorbt.signals.generators._RAND</code></li> </ul>","title":"RAND class"},{"location":"api/signals/generators/#vectorbt.signals.generators.RAND.run","text":"<pre><code>RAND.run(\n    input_shape,\n    n,\n    short_name='rand',\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Run RAND indicator.</p> <ul> <li>Parameters: <code>n</code></li> <li>Outputs: <code>entries</code></li> </ul> <p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels. Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p> <p>Other keyword arguments are passed to run_pipeline().</p>","title":"run class method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RAND.run_combs","text":"<pre><code>RAND.run_combs(\n    input_shape,\n    n,\n    r=2,\n    param_product=False,\n    comb_func=itertools.combinations,\n    run_unique=True,\n    short_names=None,\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Create a combination of multiple RAND indicators using function <code>comb_func</code>.</p> <ul> <li>Parameters: <code>n</code></li> <li>Outputs: <code>entries</code></li> </ul> <p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.  Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>. Pass <code>r</code> to specify how many indicators to run.  Pass <code>short_names</code> to specify the short name for each indicator.  Set <code>run_unique</code> to True to first compute raw outputs for all parameters,  and then use them to build each indicator (faster).</p> <p>Other keyword arguments are passed to RAND.run().</p>","title":"run_combs class method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RAND.entries","text":"<p>Output array.</p>","title":"entries property"},{"location":"api/signals/generators/#vectorbt.signals.generators.RAND.n_list","text":"<p>List of <code>n</code> values.</p>","title":"n_list property"},{"location":"api/signals/generators/#vectorbt.signals.generators.RAND.entries_and","text":"<pre><code>RAND.entries_and(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries AND other</code>. </p> <p>See combine_objs().</p>","title":"entries_and method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RAND.entries_or","text":"<pre><code>RAND.entries_or(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries OR other</code>. </p> <p>See combine_objs().</p>","title":"entries_or method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RAND.entries_stats","text":"<pre><code>RAND.entries_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>entries</code> as signals.</p>","title":"entries_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RAND.entries_xor","text":"<pre><code>RAND.entries_xor(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries XOR other</code>. </p> <p>See combine_objs().</p>","title":"entries_xor method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RAND.plot","text":"<pre><code>SignalFactory.__init__.&lt;locals&gt;.plot(\n    _self,\n    entry_y=None,\n    exit_y=None,\n    entry_types=None,\n    exit_types=None,\n    entry_trace_kwargs=None,\n    exit_trace_kwargs=None,\n    fig=None,\n    **kwargs\n)\n</code></pre> <p>Plot RAND.entries and <code>RAND.exits</code>.</p> <p>Args</p>  <code>entry_y</code> :\u2002<code>array_like</code> Y-axis values to plot entry markers on. <code>exit_y</code> :\u2002<code>array_like</code> Y-axis values to plot exit markers on. <code>entry_types</code> :\u2002<code>array_like</code> Entry types in string format. <code>exit_types</code> :\u2002<code>array_like</code> Exit types in string format. <code>entry_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to             SignalsSRAccessor.plot_as_entry_markers() for RAND.entries. <code>exit_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to             SignalsSRAccessor.plot_as_exit_markers() for <code>RAND.exits</code>. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**kwargs</code> Keyword arguments passed to SignalsSRAccessor.plot_as_markers().","title":"plot method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RAND.custom_func","text":"<pre><code>SignalFactory.from_choice_func.&lt;locals&gt;.custom_func(\n    input_list,\n    in_output_list,\n    param_list,\n    *args,\n    input_shape=None,\n    flex_2d=None,\n    entry_args=None,\n    exit_args=None,\n    cache_args=None,\n    entry_kwargs=None,\n    exit_kwargs=None,\n    cache_kwargs=None,\n    return_cache=False,\n    use_cache=None,\n    **_kwargs\n)\n</code></pre>","title":"custom_func method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RANDNX","text":"<pre><code>RANDNX(\n    wrapper,\n    input_list,\n    input_mapper,\n    in_output_list,\n    output_list,\n    param_list,\n    mapper_list,\n    short_name,\n    level_names\n)\n</code></pre> <p>Random entry and exit signal generator based on the number of signals.</p> <p>Generates <code>entries</code> and <code>exits</code> based on rand_enex_apply_nb().</p> <p>See RAND for notes on parameters.</p> <p>Usage</p> <ul> <li>Test three different entry and exit counts:</li> </ul> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; randnx = vbt.RANDNX.run(\n...     input_shape=(6,),\n...     n=[1, 2, 3],\n...     seed=42)\n\n&gt;&gt;&gt; randnx.entries\nrandnx_n      1      2      3\n0          True   True   True\n1         False  False  False\n2         False   True   True\n3         False  False  False\n4         False  False   True\n5         False  False  False\n\n&gt;&gt;&gt; randnx.exits\nrandnx_n      1      2      3\n0         False  False  False\n1          True   True   True\n2         False  False  False\n3         False   True   True\n4         False  False  False\n5         False  False   True\n</code></pre> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>IndicatorBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> <li><code>vectorbt.signals.generators.ParamIndexer</code></li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>IndicatorBase.config</li> <li>IndicatorBase.iloc</li> <li>IndicatorBase.in_output_names</li> <li>IndicatorBase.indexing_func()</li> <li>IndicatorBase.indexing_kwargs</li> <li>IndicatorBase.input_names</li> <li>IndicatorBase.level_names</li> <li>IndicatorBase.loc</li> <li>IndicatorBase.output_flags</li> <li>IndicatorBase.output_names</li> <li>IndicatorBase.param_names</li> <li>IndicatorBase.plots_defaults</li> <li>IndicatorBase.self_aliases</li> <li>IndicatorBase.short_name</li> <li>IndicatorBase.stats_defaults</li> <li>IndicatorBase.wrapper</li> <li>IndicatorBase.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li><code>vectorbt.signals.generators._RANDNX</code></li> </ul>","title":"RANDNX class"},{"location":"api/signals/generators/#vectorbt.signals.generators.RANDNX.run","text":"<pre><code>RANDNX.run(\n    input_shape,\n    n,\n    short_name='randnx',\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Run RANDNX indicator.</p> <ul> <li>Parameters: <code>n</code></li> <li>Outputs: <code>entries</code>, <code>exits</code></li> </ul> <p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels. Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p> <p>Other keyword arguments are passed to run_pipeline().</p>","title":"run class method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RANDNX.run_combs","text":"<pre><code>RANDNX.run_combs(\n    input_shape,\n    n,\n    r=2,\n    param_product=False,\n    comb_func=itertools.combinations,\n    run_unique=True,\n    short_names=None,\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Create a combination of multiple RANDNX indicators using function <code>comb_func</code>.</p> <ul> <li>Parameters: <code>n</code></li> <li>Outputs: <code>entries</code>, <code>exits</code></li> </ul> <p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.  Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>. Pass <code>r</code> to specify how many indicators to run.  Pass <code>short_names</code> to specify the short name for each indicator.  Set <code>run_unique</code> to True to first compute raw outputs for all parameters,  and then use them to build each indicator (faster).</p> <p>Other keyword arguments are passed to RANDNX.run().</p>","title":"run_combs class method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RANDNX.entries","text":"<p>Output array.</p>","title":"entries property"},{"location":"api/signals/generators/#vectorbt.signals.generators.RANDNX.exits","text":"<p>Output array.</p>","title":"exits property"},{"location":"api/signals/generators/#vectorbt.signals.generators.RANDNX.n_list","text":"<p>List of <code>n</code> values.</p>","title":"n_list property"},{"location":"api/signals/generators/#vectorbt.signals.generators.RANDNX.custom_func","text":"<pre><code>IndicatorFactory.from_apply_func.&lt;locals&gt;.custom_func(\n    input_list,\n    in_output_list,\n    param_list,\n    *args,\n    input_shape=None,\n    col=None,\n    flex_2d=None,\n    return_cache=False,\n    use_cache=None,\n    use_ray=False,\n    **_kwargs\n)\n</code></pre> <p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p>","title":"custom_func method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RANDNX.apply_func","text":"<pre><code>RANDNX.apply_func(\n    input_shape,\n    n,\n    entry_wait,\n    exit_wait\n)\n</code></pre> <p><code>apply_func_nb</code> that calls <code>generate_rand_enex_nb</code>.</p>","title":"apply_func method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RANDNX.entries_and","text":"<pre><code>RANDNX.entries_and(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries AND other</code>. </p> <p>See combine_objs().</p>","title":"entries_and method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RANDNX.entries_or","text":"<pre><code>RANDNX.entries_or(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries OR other</code>. </p> <p>See combine_objs().</p>","title":"entries_or method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RANDNX.entries_stats","text":"<pre><code>RANDNX.entries_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>entries</code> as signals.</p>","title":"entries_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RANDNX.entries_xor","text":"<pre><code>RANDNX.entries_xor(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries XOR other</code>. </p> <p>See combine_objs().</p>","title":"entries_xor method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RANDNX.exits_and","text":"<pre><code>RANDNX.exits_and(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>exits AND other</code>. </p> <p>See combine_objs().</p>","title":"exits_and method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RANDNX.exits_or","text":"<pre><code>RANDNX.exits_or(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>exits OR other</code>. </p> <p>See combine_objs().</p>","title":"exits_or method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RANDNX.exits_stats","text":"<pre><code>RANDNX.exits_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>exits</code> as signals.</p>","title":"exits_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RANDNX.exits_xor","text":"<pre><code>RANDNX.exits_xor(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>exits XOR other</code>. </p> <p>See combine_objs().</p>","title":"exits_xor method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RANDNX.plot","text":"<pre><code>SignalFactory.__init__.&lt;locals&gt;.plot(\n    _self,\n    entry_y=None,\n    exit_y=None,\n    entry_types=None,\n    exit_types=None,\n    entry_trace_kwargs=None,\n    exit_trace_kwargs=None,\n    fig=None,\n    **kwargs\n)\n</code></pre> <p>Plot RANDNX.entries and RANDNX.exits.</p> <p>Args</p>  <code>entry_y</code> :\u2002<code>array_like</code> Y-axis values to plot entry markers on. <code>exit_y</code> :\u2002<code>array_like</code> Y-axis values to plot exit markers on. <code>entry_types</code> :\u2002<code>array_like</code> Entry types in string format. <code>exit_types</code> :\u2002<code>array_like</code> Exit types in string format. <code>entry_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to             SignalsSRAccessor.plot_as_entry_markers() for RANDNX.entries. <code>exit_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to             SignalsSRAccessor.plot_as_exit_markers() for RANDNX.exits. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**kwargs</code> Keyword arguments passed to SignalsSRAccessor.plot_as_markers().","title":"plot method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RANDX","text":"<pre><code>RANDX(\n    wrapper,\n    input_list,\n    input_mapper,\n    in_output_list,\n    output_list,\n    param_list,\n    mapper_list,\n    short_name,\n    level_names\n)\n</code></pre> <p>Random exit signal generator based on the number of signals.</p> <p>Generates <code>exits</code> based on <code>entries</code> and rand_choice_nb().</p> <p>See RAND for notes on parameters.</p> <p>Usage</p> <ul> <li>Generate an exit for each entry:</li> </ul> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n&gt;&gt;&gt; import pandas as pd\n\n&gt;&gt;&gt; entries = pd.Series([True, False, False, True, False, False])\n&gt;&gt;&gt; randx = vbt.RANDX.run(entries, seed=42)\n\n&gt;&gt;&gt; randx.exits\n0    False\n1    False\n2     True\n3    False\n4     True\n5    False\ndtype: bool\n</code></pre> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>IndicatorBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> <li><code>vectorbt.signals.generators.ParamIndexer</code></li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>IndicatorBase.config</li> <li>IndicatorBase.iloc</li> <li>IndicatorBase.in_output_names</li> <li>IndicatorBase.indexing_func()</li> <li>IndicatorBase.indexing_kwargs</li> <li>IndicatorBase.input_names</li> <li>IndicatorBase.level_names</li> <li>IndicatorBase.loc</li> <li>IndicatorBase.output_flags</li> <li>IndicatorBase.output_names</li> <li>IndicatorBase.param_names</li> <li>IndicatorBase.plots_defaults</li> <li>IndicatorBase.run_combs()</li> <li>IndicatorBase.self_aliases</li> <li>IndicatorBase.short_name</li> <li>IndicatorBase.stats_defaults</li> <li>IndicatorBase.wrapper</li> <li>IndicatorBase.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li><code>vectorbt.signals.generators._RANDX</code></li> </ul>","title":"RANDX class"},{"location":"api/signals/generators/#vectorbt.signals.generators.RANDX.run","text":"<pre><code>RANDX.run(\n    entries,\n    short_name='randx',\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Run RANDX indicator.</p> <ul> <li>Inputs: <code>entries</code></li> <li>Outputs: <code>exits</code></li> </ul> <p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels. Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p> <p>Other keyword arguments are passed to run_pipeline().</p>","title":"run class method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RANDX.entries","text":"<p>Input array.</p>","title":"entries variable"},{"location":"api/signals/generators/#vectorbt.signals.generators.RANDX.exits","text":"<p>Output array.</p>","title":"exits property"},{"location":"api/signals/generators/#vectorbt.signals.generators.RANDX.entries_and","text":"<pre><code>RANDX.entries_and(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries AND other</code>. </p> <p>See combine_objs().</p>","title":"entries_and method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RANDX.entries_or","text":"<pre><code>RANDX.entries_or(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries OR other</code>. </p> <p>See combine_objs().</p>","title":"entries_or method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RANDX.entries_stats","text":"<pre><code>RANDX.entries_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>entries</code> as signals.</p>","title":"entries_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RANDX.entries_xor","text":"<pre><code>RANDX.entries_xor(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries XOR other</code>. </p> <p>See combine_objs().</p>","title":"entries_xor method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RANDX.exits_and","text":"<pre><code>RANDX.exits_and(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>exits AND other</code>. </p> <p>See combine_objs().</p>","title":"exits_and method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RANDX.exits_or","text":"<pre><code>RANDX.exits_or(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>exits OR other</code>. </p> <p>See combine_objs().</p>","title":"exits_or method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RANDX.exits_stats","text":"<pre><code>RANDX.exits_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>exits</code> as signals.</p>","title":"exits_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RANDX.exits_xor","text":"<pre><code>RANDX.exits_xor(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>exits XOR other</code>. </p> <p>See combine_objs().</p>","title":"exits_xor method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RANDX.plot","text":"<pre><code>SignalFactory.__init__.&lt;locals&gt;.plot(\n    _self,\n    entry_y=None,\n    exit_y=None,\n    entry_types=None,\n    exit_types=None,\n    entry_trace_kwargs=None,\n    exit_trace_kwargs=None,\n    fig=None,\n    **kwargs\n)\n</code></pre> <p>Plot RANDX.entries and RANDX.exits.</p> <p>Args</p>  <code>entry_y</code> :\u2002<code>array_like</code> Y-axis values to plot entry markers on. <code>exit_y</code> :\u2002<code>array_like</code> Y-axis values to plot exit markers on. <code>entry_types</code> :\u2002<code>array_like</code> Entry types in string format. <code>exit_types</code> :\u2002<code>array_like</code> Exit types in string format. <code>entry_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to             SignalsSRAccessor.plot_as_entry_markers() for RANDX.entries. <code>exit_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to             SignalsSRAccessor.plot_as_exit_markers() for RANDX.exits. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**kwargs</code> Keyword arguments passed to SignalsSRAccessor.plot_as_markers().","title":"plot method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RANDX.custom_func","text":"<pre><code>SignalFactory.from_choice_func.&lt;locals&gt;.custom_func(\n    input_list,\n    in_output_list,\n    param_list,\n    *args,\n    input_shape=None,\n    flex_2d=None,\n    entry_args=None,\n    exit_args=None,\n    cache_args=None,\n    entry_kwargs=None,\n    exit_kwargs=None,\n    cache_kwargs=None,\n    return_cache=False,\n    use_cache=None,\n    **_kwargs\n)\n</code></pre>","title":"custom_func method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROB","text":"<pre><code>RPROB(\n    wrapper,\n    input_list,\n    input_mapper,\n    in_output_list,\n    output_list,\n    param_list,\n    mapper_list,\n    short_name,\n    level_names\n)\n</code></pre> <p>Random entry signal generator based on probabilities.</p> <p>Generates <code>entries</code> based on rand_by_prob_choice_nb().</p>  <p>Hint</p> <p>All parameters can be either a single value (per frame) or a NumPy array (per row, column, or element). To generate multiple combinations, pass them as lists.</p>  <p>Usage</p> <ul> <li>Generate three columns with different entry probabilities:</li> </ul> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; rprob = vbt.RPROB.run(input_shape=(5,), prob=[0., 0.5, 1.], seed=42)\n\n&gt;&gt;&gt; rprob.entries\nrprob_prob    0.0    0.5   1.0\n0           False   True  True\n1           False   True  True\n2           False  False  True\n3           False  False  True\n4           False  False  True\n</code></pre> <ul> <li>Probability can also be set per row, column, or element:</li> </ul> <pre><code>&gt;&gt;&gt; import numpy as np\n\n&gt;&gt;&gt; rprob = vbt.RPROB.run(input_shape=(5,), prob=np.array([0., 0., 1., 1., 1.]), seed=42)\n\n&gt;&gt;&gt; rprob.entries\n0    False\n1    False\n2     True\n3     True\n4     True\nName: array_0, dtype: bool\n</code></pre> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>IndicatorBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> <li><code>vectorbt.signals.generators.ParamIndexer</code></li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>IndicatorBase.config</li> <li>IndicatorBase.iloc</li> <li>IndicatorBase.in_output_names</li> <li>IndicatorBase.indexing_func()</li> <li>IndicatorBase.indexing_kwargs</li> <li>IndicatorBase.input_names</li> <li>IndicatorBase.level_names</li> <li>IndicatorBase.loc</li> <li>IndicatorBase.output_flags</li> <li>IndicatorBase.output_names</li> <li>IndicatorBase.param_names</li> <li>IndicatorBase.plots_defaults</li> <li>IndicatorBase.self_aliases</li> <li>IndicatorBase.short_name</li> <li>IndicatorBase.stats_defaults</li> <li>IndicatorBase.wrapper</li> <li>IndicatorBase.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li><code>vectorbt.signals.generators._RPROB</code></li> </ul>","title":"RPROB class"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROB.run","text":"<pre><code>RPROB.run(\n    input_shape,\n    prob,\n    short_name='rprob',\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Run RPROB indicator.</p> <ul> <li>Parameters: <code>prob</code></li> <li>Outputs: <code>entries</code></li> </ul> <p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels. Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p> <p>Other keyword arguments are passed to run_pipeline().</p>","title":"run class method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROB.run_combs","text":"<pre><code>RPROB.run_combs(\n    input_shape,\n    prob,\n    r=2,\n    param_product=False,\n    comb_func=itertools.combinations,\n    run_unique=True,\n    short_names=None,\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Create a combination of multiple RPROB indicators using function <code>comb_func</code>.</p> <ul> <li>Parameters: <code>prob</code></li> <li>Outputs: <code>entries</code></li> </ul> <p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.  Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>. Pass <code>r</code> to specify how many indicators to run.  Pass <code>short_names</code> to specify the short name for each indicator.  Set <code>run_unique</code> to True to first compute raw outputs for all parameters,  and then use them to build each indicator (faster).</p> <p>Other keyword arguments are passed to RPROB.run().</p>","title":"run_combs class method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROB.entries","text":"<p>Output array.</p>","title":"entries property"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROB.prob_list","text":"<p>List of <code>prob</code> values.</p>","title":"prob_list property"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROB.entries_and","text":"<pre><code>RPROB.entries_and(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries AND other</code>. </p> <p>See combine_objs().</p>","title":"entries_and method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROB.entries_or","text":"<pre><code>RPROB.entries_or(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries OR other</code>. </p> <p>See combine_objs().</p>","title":"entries_or method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROB.entries_stats","text":"<pre><code>RPROB.entries_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>entries</code> as signals.</p>","title":"entries_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROB.entries_xor","text":"<pre><code>RPROB.entries_xor(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries XOR other</code>. </p> <p>See combine_objs().</p>","title":"entries_xor method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROB.plot","text":"<pre><code>SignalFactory.__init__.&lt;locals&gt;.plot(\n    _self,\n    entry_y=None,\n    exit_y=None,\n    entry_types=None,\n    exit_types=None,\n    entry_trace_kwargs=None,\n    exit_trace_kwargs=None,\n    fig=None,\n    **kwargs\n)\n</code></pre> <p>Plot RPROB.entries and <code>RPROB.exits</code>.</p> <p>Args</p>  <code>entry_y</code> :\u2002<code>array_like</code> Y-axis values to plot entry markers on. <code>exit_y</code> :\u2002<code>array_like</code> Y-axis values to plot exit markers on. <code>entry_types</code> :\u2002<code>array_like</code> Entry types in string format. <code>exit_types</code> :\u2002<code>array_like</code> Exit types in string format. <code>entry_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to             SignalsSRAccessor.plot_as_entry_markers() for RPROB.entries. <code>exit_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to             SignalsSRAccessor.plot_as_exit_markers() for <code>RPROB.exits</code>. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**kwargs</code> Keyword arguments passed to SignalsSRAccessor.plot_as_markers().","title":"plot method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROB.custom_func","text":"<pre><code>SignalFactory.from_choice_func.&lt;locals&gt;.custom_func(\n    input_list,\n    in_output_list,\n    param_list,\n    *args,\n    input_shape=None,\n    flex_2d=None,\n    entry_args=None,\n    exit_args=None,\n    cache_args=None,\n    entry_kwargs=None,\n    exit_kwargs=None,\n    cache_kwargs=None,\n    return_cache=False,\n    use_cache=None,\n    **_kwargs\n)\n</code></pre>","title":"custom_func method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBCX","text":"<pre><code>RPROBCX(\n    wrapper,\n    input_list,\n    input_mapper,\n    in_output_list,\n    output_list,\n    param_list,\n    mapper_list,\n    short_name,\n    level_names\n)\n</code></pre> <p>Random exit signal generator based on probabilities.</p> <p>Generates chain of <code>new_entries</code> and <code>exits</code> based on <code>entries</code> and rand_by_prob_choice_nb().</p> <p>See RPROB for notes on parameters.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>IndicatorBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> <li><code>vectorbt.signals.generators.ParamIndexer</code></li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>IndicatorBase.config</li> <li>IndicatorBase.iloc</li> <li>IndicatorBase.in_output_names</li> <li>IndicatorBase.indexing_func()</li> <li>IndicatorBase.indexing_kwargs</li> <li>IndicatorBase.input_names</li> <li>IndicatorBase.level_names</li> <li>IndicatorBase.loc</li> <li>IndicatorBase.output_flags</li> <li>IndicatorBase.output_names</li> <li>IndicatorBase.param_names</li> <li>IndicatorBase.plots_defaults</li> <li>IndicatorBase.self_aliases</li> <li>IndicatorBase.short_name</li> <li>IndicatorBase.stats_defaults</li> <li>IndicatorBase.wrapper</li> <li>IndicatorBase.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li><code>vectorbt.signals.generators._RPROBCX</code></li> </ul>","title":"RPROBCX class"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBCX.run","text":"<pre><code>RPROBCX.run(\n    entries,\n    prob,\n    short_name='rprobcx',\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Run RPROBCX indicator.</p> <ul> <li>Inputs: <code>entries</code></li> <li>Parameters: <code>prob</code></li> <li>Outputs: <code>new_entries</code>, <code>exits</code></li> </ul> <p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels. Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p> <p>Other keyword arguments are passed to run_pipeline().</p>","title":"run class method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBCX.run_combs","text":"<pre><code>RPROBCX.run_combs(\n    entries,\n    prob,\n    r=2,\n    param_product=False,\n    comb_func=itertools.combinations,\n    run_unique=True,\n    short_names=None,\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Create a combination of multiple RPROBCX indicators using function <code>comb_func</code>.</p> <ul> <li>Inputs: <code>entries</code></li> <li>Parameters: <code>prob</code></li> <li>Outputs: <code>new_entries</code>, <code>exits</code></li> </ul> <p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.  Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>. Pass <code>r</code> to specify how many indicators to run.  Pass <code>short_names</code> to specify the short name for each indicator.  Set <code>run_unique</code> to True to first compute raw outputs for all parameters,  and then use them to build each indicator (faster).</p> <p>Other keyword arguments are passed to RPROBCX.run().</p>","title":"run_combs class method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBCX.entries","text":"<p>Input array.</p>","title":"entries variable"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBCX.exits","text":"<p>Output array.</p>","title":"exits property"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBCX.new_entries","text":"<p>Output array.</p>","title":"new_entries property"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBCX.prob_list","text":"<p>List of <code>prob</code> values.</p>","title":"prob_list property"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBCX.entries_and","text":"<pre><code>RPROBCX.entries_and(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries AND other</code>. </p> <p>See combine_objs().</p>","title":"entries_and method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBCX.entries_or","text":"<pre><code>RPROBCX.entries_or(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries OR other</code>. </p> <p>See combine_objs().</p>","title":"entries_or method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBCX.entries_stats","text":"<pre><code>RPROBCX.entries_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>entries</code> as signals.</p>","title":"entries_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBCX.entries_xor","text":"<pre><code>RPROBCX.entries_xor(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries XOR other</code>. </p> <p>See combine_objs().</p>","title":"entries_xor method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBCX.exits_and","text":"<pre><code>RPROBCX.exits_and(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>exits AND other</code>. </p> <p>See combine_objs().</p>","title":"exits_and method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBCX.exits_or","text":"<pre><code>RPROBCX.exits_or(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>exits OR other</code>. </p> <p>See combine_objs().</p>","title":"exits_or method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBCX.exits_stats","text":"<pre><code>RPROBCX.exits_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>exits</code> as signals.</p>","title":"exits_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBCX.exits_xor","text":"<pre><code>RPROBCX.exits_xor(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>exits XOR other</code>. </p> <p>See combine_objs().</p>","title":"exits_xor method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBCX.new_entries_and","text":"<pre><code>RPROBCX.new_entries_and(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>new_entries AND other</code>. </p> <p>See combine_objs().</p>","title":"new_entries_and method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBCX.new_entries_or","text":"<pre><code>RPROBCX.new_entries_or(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>new_entries OR other</code>. </p> <p>See combine_objs().</p>","title":"new_entries_or method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBCX.new_entries_stats","text":"<pre><code>RPROBCX.new_entries_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>new_entries</code> as signals.</p>","title":"new_entries_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBCX.new_entries_xor","text":"<pre><code>RPROBCX.new_entries_xor(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>new_entries XOR other</code>. </p> <p>See combine_objs().</p>","title":"new_entries_xor method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBCX.plot","text":"<pre><code>SignalFactory.__init__.&lt;locals&gt;.plot(\n    _self,\n    entry_y=None,\n    exit_y=None,\n    entry_types=None,\n    exit_types=None,\n    entry_trace_kwargs=None,\n    exit_trace_kwargs=None,\n    fig=None,\n    **kwargs\n)\n</code></pre> <p>Plot RPROBCX.new_entries and RPROBCX.exits.</p> <p>Args</p>  <code>entry_y</code> :\u2002<code>array_like</code> Y-axis values to plot entry markers on. <code>exit_y</code> :\u2002<code>array_like</code> Y-axis values to plot exit markers on. <code>entry_types</code> :\u2002<code>array_like</code> Entry types in string format. <code>exit_types</code> :\u2002<code>array_like</code> Exit types in string format. <code>entry_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to             SignalsSRAccessor.plot_as_entry_markers() for RPROBCX.new_entries. <code>exit_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to             SignalsSRAccessor.plot_as_exit_markers() for RPROBCX.exits. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**kwargs</code> Keyword arguments passed to SignalsSRAccessor.plot_as_markers().","title":"plot method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBCX.custom_func","text":"<pre><code>SignalFactory.from_choice_func.&lt;locals&gt;.custom_func(\n    input_list,\n    in_output_list,\n    param_list,\n    *args,\n    input_shape=None,\n    flex_2d=None,\n    entry_args=None,\n    exit_args=None,\n    cache_args=None,\n    entry_kwargs=None,\n    exit_kwargs=None,\n    cache_kwargs=None,\n    return_cache=False,\n    use_cache=None,\n    **_kwargs\n)\n</code></pre>","title":"custom_func method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBNX","text":"<pre><code>RPROBNX(\n    wrapper,\n    input_list,\n    input_mapper,\n    in_output_list,\n    output_list,\n    param_list,\n    mapper_list,\n    short_name,\n    level_names\n)\n</code></pre> <p>Random entry and exit signal generator based on probabilities.</p> <p>Generates <code>entries</code> and <code>exits</code> based on rand_by_prob_choice_nb().</p> <p>See RPROB for notes on parameters.</p> <p>Usage</p> <ul> <li>Test all probability combinations:</li> </ul> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; rprobnx = vbt.RPROBNX.run(\n...     input_shape=(5,),\n...     entry_prob=[0.5, 1.],\n...     exit_prob=[0.5, 1.],\n...     param_product=True,\n...     seed=42)\n\n&gt;&gt;&gt; rprobnx.entries\nrprobnx_entry_prob    0.5    0.5    1.0    0.5\nrprobnx_exit_prob     0.5    1.0    0.5    1.0\n0                    True   True   True   True\n1                   False  False  False  False\n2                   False  False  False   True\n3                   False  False  False  False\n4                   False  False   True   True\n\n&gt;&gt;&gt; rprobnx.exits\nrprobnx_entry_prob    0.5    0.5    1.0    1.0\nrprobnx_exit_prob     0.5    1.0    0.5    1.0\n0                   False  False  False  False\n1                   False   True  False   True\n2                   False  False  False  False\n3                   False  False   True   True\n4                    True  False  False  False\n</code></pre> <ul> <li>Probabilities can also be set per row, column, or element:</li> </ul> <pre><code>&gt;&gt;&gt; import numpy as np\n\n&gt;&gt;&gt; entry_prob1 = np.asarray([1., 0., 1., 0., 1.])\n&gt;&gt;&gt; entry_prob2 = np.asarray([0., 1., 0., 1., 0.])\n&gt;&gt;&gt; rprobnx = vbt.RPROBNX.run(\n...     input_shape=(5,),\n...     entry_prob=[entry_prob1, entry_prob2],\n...     exit_prob=1.,\n...     seed=42)\n\n&gt;&gt;&gt; rprobnx.entries\nrprobnx_entry_prob array_0 array_1\nrprobnx_exit_prob      1.0     1.0\n0                     True   False\n1                    False    True\n2                     True   False\n3                    False    True\n4                     True   False\n\n&gt;&gt;&gt; rprobnx.exits\nrprobnx_entry_prob array_0 array_1\nrprobnx_exit_prob      1.0     1.0\n0                    False   False\n1                     True   False\n2                    False    True\n3                     True   False\n4                    False    True\n</code></pre> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>IndicatorBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> <li><code>vectorbt.signals.generators.ParamIndexer</code></li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>IndicatorBase.config</li> <li>IndicatorBase.iloc</li> <li>IndicatorBase.in_output_names</li> <li>IndicatorBase.indexing_func()</li> <li>IndicatorBase.indexing_kwargs</li> <li>IndicatorBase.input_names</li> <li>IndicatorBase.level_names</li> <li>IndicatorBase.loc</li> <li>IndicatorBase.output_flags</li> <li>IndicatorBase.output_names</li> <li>IndicatorBase.param_names</li> <li>IndicatorBase.plots_defaults</li> <li>IndicatorBase.self_aliases</li> <li>IndicatorBase.short_name</li> <li>IndicatorBase.stats_defaults</li> <li>IndicatorBase.wrapper</li> <li>IndicatorBase.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li><code>vectorbt.signals.generators._RPROBNX</code></li> </ul>","title":"RPROBNX class"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBNX.run","text":"<pre><code>RPROBNX.run(\n    input_shape,\n    entry_prob,\n    exit_prob,\n    short_name='rprobnx',\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Run RPROBNX indicator.</p> <ul> <li>Parameters: <code>entry_prob</code>, <code>exit_prob</code></li> <li>Outputs: <code>entries</code>, <code>exits</code></li> </ul> <p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels. Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p> <p>Other keyword arguments are passed to run_pipeline().</p>","title":"run class method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBNX.run_combs","text":"<pre><code>RPROBNX.run_combs(\n    input_shape,\n    entry_prob,\n    exit_prob,\n    r=2,\n    param_product=False,\n    comb_func=itertools.combinations,\n    run_unique=True,\n    short_names=None,\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Create a combination of multiple RPROBNX indicators using function <code>comb_func</code>.</p> <ul> <li>Parameters: <code>entry_prob</code>, <code>exit_prob</code></li> <li>Outputs: <code>entries</code>, <code>exits</code></li> </ul> <p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.  Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>. Pass <code>r</code> to specify how many indicators to run.  Pass <code>short_names</code> to specify the short name for each indicator.  Set <code>run_unique</code> to True to first compute raw outputs for all parameters,  and then use them to build each indicator (faster).</p> <p>Other keyword arguments are passed to RPROBNX.run().</p>","title":"run_combs class method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBNX.entries","text":"<p>Output array.</p>","title":"entries property"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBNX.entry_prob_list","text":"<p>List of <code>entry_prob</code> values.</p>","title":"entry_prob_list property"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBNX.exit_prob_list","text":"<p>List of <code>exit_prob</code> values.</p>","title":"exit_prob_list property"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBNX.exits","text":"<p>Output array.</p>","title":"exits property"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBNX.entries_and","text":"<pre><code>RPROBNX.entries_and(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries AND other</code>. </p> <p>See combine_objs().</p>","title":"entries_and method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBNX.entries_or","text":"<pre><code>RPROBNX.entries_or(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries OR other</code>. </p> <p>See combine_objs().</p>","title":"entries_or method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBNX.entries_stats","text":"<pre><code>RPROBNX.entries_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>entries</code> as signals.</p>","title":"entries_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBNX.entries_xor","text":"<pre><code>RPROBNX.entries_xor(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries XOR other</code>. </p> <p>See combine_objs().</p>","title":"entries_xor method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBNX.exits_and","text":"<pre><code>RPROBNX.exits_and(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>exits AND other</code>. </p> <p>See combine_objs().</p>","title":"exits_and method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBNX.exits_or","text":"<pre><code>RPROBNX.exits_or(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>exits OR other</code>. </p> <p>See combine_objs().</p>","title":"exits_or method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBNX.exits_stats","text":"<pre><code>RPROBNX.exits_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>exits</code> as signals.</p>","title":"exits_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBNX.exits_xor","text":"<pre><code>RPROBNX.exits_xor(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>exits XOR other</code>. </p> <p>See combine_objs().</p>","title":"exits_xor method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBNX.plot","text":"<pre><code>SignalFactory.__init__.&lt;locals&gt;.plot(\n    _self,\n    entry_y=None,\n    exit_y=None,\n    entry_types=None,\n    exit_types=None,\n    entry_trace_kwargs=None,\n    exit_trace_kwargs=None,\n    fig=None,\n    **kwargs\n)\n</code></pre> <p>Plot RPROBNX.entries and RPROBNX.exits.</p> <p>Args</p>  <code>entry_y</code> :\u2002<code>array_like</code> Y-axis values to plot entry markers on. <code>exit_y</code> :\u2002<code>array_like</code> Y-axis values to plot exit markers on. <code>entry_types</code> :\u2002<code>array_like</code> Entry types in string format. <code>exit_types</code> :\u2002<code>array_like</code> Exit types in string format. <code>entry_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to             SignalsSRAccessor.plot_as_entry_markers() for RPROBNX.entries. <code>exit_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to             SignalsSRAccessor.plot_as_exit_markers() for RPROBNX.exits. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**kwargs</code> Keyword arguments passed to SignalsSRAccessor.plot_as_markers().","title":"plot method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBNX.custom_func","text":"<pre><code>SignalFactory.from_choice_func.&lt;locals&gt;.custom_func(\n    input_list,\n    in_output_list,\n    param_list,\n    *args,\n    input_shape=None,\n    flex_2d=None,\n    entry_args=None,\n    exit_args=None,\n    cache_args=None,\n    entry_kwargs=None,\n    exit_kwargs=None,\n    cache_kwargs=None,\n    return_cache=False,\n    use_cache=None,\n    **_kwargs\n)\n</code></pre>","title":"custom_func method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBX","text":"<pre><code>RPROBX(\n    wrapper,\n    input_list,\n    input_mapper,\n    in_output_list,\n    output_list,\n    param_list,\n    mapper_list,\n    short_name,\n    level_names\n)\n</code></pre> <p>Random exit signal generator based on probabilities.</p> <p>Generates <code>exits</code> based on <code>entries</code> and rand_by_prob_choice_nb().</p> <p>See RPROB for notes on parameters.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>IndicatorBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> <li><code>vectorbt.signals.generators.ParamIndexer</code></li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>IndicatorBase.config</li> <li>IndicatorBase.iloc</li> <li>IndicatorBase.in_output_names</li> <li>IndicatorBase.indexing_func()</li> <li>IndicatorBase.indexing_kwargs</li> <li>IndicatorBase.input_names</li> <li>IndicatorBase.level_names</li> <li>IndicatorBase.loc</li> <li>IndicatorBase.output_flags</li> <li>IndicatorBase.output_names</li> <li>IndicatorBase.param_names</li> <li>IndicatorBase.plots_defaults</li> <li>IndicatorBase.self_aliases</li> <li>IndicatorBase.short_name</li> <li>IndicatorBase.stats_defaults</li> <li>IndicatorBase.wrapper</li> <li>IndicatorBase.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li><code>vectorbt.signals.generators._RPROBX</code></li> </ul>","title":"RPROBX class"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBX.run","text":"<pre><code>RPROBX.run(\n    entries,\n    prob,\n    short_name='rprobx',\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Run RPROBX indicator.</p> <ul> <li>Inputs: <code>entries</code></li> <li>Parameters: <code>prob</code></li> <li>Outputs: <code>exits</code></li> </ul> <p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels. Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p> <p>Other keyword arguments are passed to run_pipeline().</p>","title":"run class method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBX.run_combs","text":"<pre><code>RPROBX.run_combs(\n    entries,\n    prob,\n    r=2,\n    param_product=False,\n    comb_func=itertools.combinations,\n    run_unique=True,\n    short_names=None,\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Create a combination of multiple RPROBX indicators using function <code>comb_func</code>.</p> <ul> <li>Inputs: <code>entries</code></li> <li>Parameters: <code>prob</code></li> <li>Outputs: <code>exits</code></li> </ul> <p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.  Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>. Pass <code>r</code> to specify how many indicators to run.  Pass <code>short_names</code> to specify the short name for each indicator.  Set <code>run_unique</code> to True to first compute raw outputs for all parameters,  and then use them to build each indicator (faster).</p> <p>Other keyword arguments are passed to RPROBX.run().</p>","title":"run_combs class method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBX.entries","text":"<p>Input array.</p>","title":"entries variable"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBX.exits","text":"<p>Output array.</p>","title":"exits property"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBX.prob_list","text":"<p>List of <code>prob</code> values.</p>","title":"prob_list property"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBX.entries_and","text":"<pre><code>RPROBX.entries_and(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries AND other</code>. </p> <p>See combine_objs().</p>","title":"entries_and method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBX.entries_or","text":"<pre><code>RPROBX.entries_or(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries OR other</code>. </p> <p>See combine_objs().</p>","title":"entries_or method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBX.entries_stats","text":"<pre><code>RPROBX.entries_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>entries</code> as signals.</p>","title":"entries_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBX.entries_xor","text":"<pre><code>RPROBX.entries_xor(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries XOR other</code>. </p> <p>See combine_objs().</p>","title":"entries_xor method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBX.exits_and","text":"<pre><code>RPROBX.exits_and(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>exits AND other</code>. </p> <p>See combine_objs().</p>","title":"exits_and method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBX.exits_or","text":"<pre><code>RPROBX.exits_or(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>exits OR other</code>. </p> <p>See combine_objs().</p>","title":"exits_or method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBX.exits_stats","text":"<pre><code>RPROBX.exits_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>exits</code> as signals.</p>","title":"exits_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBX.exits_xor","text":"<pre><code>RPROBX.exits_xor(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>exits XOR other</code>. </p> <p>See combine_objs().</p>","title":"exits_xor method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBX.plot","text":"<pre><code>SignalFactory.__init__.&lt;locals&gt;.plot(\n    _self,\n    entry_y=None,\n    exit_y=None,\n    entry_types=None,\n    exit_types=None,\n    entry_trace_kwargs=None,\n    exit_trace_kwargs=None,\n    fig=None,\n    **kwargs\n)\n</code></pre> <p>Plot RPROBX.entries and RPROBX.exits.</p> <p>Args</p>  <code>entry_y</code> :\u2002<code>array_like</code> Y-axis values to plot entry markers on. <code>exit_y</code> :\u2002<code>array_like</code> Y-axis values to plot exit markers on. <code>entry_types</code> :\u2002<code>array_like</code> Entry types in string format. <code>exit_types</code> :\u2002<code>array_like</code> Exit types in string format. <code>entry_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to             SignalsSRAccessor.plot_as_entry_markers() for RPROBX.entries. <code>exit_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to             SignalsSRAccessor.plot_as_exit_markers() for RPROBX.exits. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**kwargs</code> Keyword arguments passed to SignalsSRAccessor.plot_as_markers().","title":"plot method"},{"location":"api/signals/generators/#vectorbt.signals.generators.RPROBX.custom_func","text":"<pre><code>SignalFactory.from_choice_func.&lt;locals&gt;.custom_func(\n    input_list,\n    in_output_list,\n    param_list,\n    *args,\n    input_shape=None,\n    flex_2d=None,\n    entry_args=None,\n    exit_args=None,\n    cache_args=None,\n    entry_kwargs=None,\n    exit_kwargs=None,\n    cache_kwargs=None,\n    return_cache=False,\n    use_cache=None,\n    **_kwargs\n)\n</code></pre>","title":"custom_func method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STCX","text":"<pre><code>STCX(\n    wrapper,\n    input_list,\n    input_mapper,\n    in_output_list,\n    output_list,\n    param_list,\n    mapper_list,\n    short_name,\n    level_names\n)\n</code></pre> <p>Exit signal generator based on stop values.</p> <p>Generates chain of <code>new_entries</code> and <code>exits</code> based on <code>entries</code> and stop_choice_nb().</p> <p>See STX for notes on parameters.</p> <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>IndicatorBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> <li><code>vectorbt.signals.generators.ParamIndexer</code></li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>IndicatorBase.config</li> <li>IndicatorBase.iloc</li> <li>IndicatorBase.in_output_names</li> <li>IndicatorBase.indexing_func()</li> <li>IndicatorBase.indexing_kwargs</li> <li>IndicatorBase.input_names</li> <li>IndicatorBase.level_names</li> <li>IndicatorBase.loc</li> <li>IndicatorBase.output_flags</li> <li>IndicatorBase.output_names</li> <li>IndicatorBase.param_names</li> <li>IndicatorBase.plots_defaults</li> <li>IndicatorBase.self_aliases</li> <li>IndicatorBase.short_name</li> <li>IndicatorBase.stats_defaults</li> <li>IndicatorBase.wrapper</li> <li>IndicatorBase.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li><code>vectorbt.signals.generators._STCX</code></li> </ul>","title":"STCX class"},{"location":"api/signals/generators/#vectorbt.signals.generators.STCX.run","text":"<pre><code>STCX.run(\n    entries,\n    ts,\n    stop,\n    trailing=Default(False),\n    short_name='stcx',\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Run STCX indicator.</p> <ul> <li>Inputs: <code>entries</code>, <code>ts</code></li> <li>Parameters: <code>stop</code>, <code>trailing</code></li> <li>Outputs: <code>new_entries</code>, <code>exits</code></li> </ul> <p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels. Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p> <p>Other keyword arguments are passed to run_pipeline().</p>","title":"run class method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STCX.run_combs","text":"<pre><code>STCX.run_combs(\n    entries,\n    ts,\n    stop,\n    trailing=Default(False),\n    r=2,\n    param_product=False,\n    comb_func=itertools.combinations,\n    run_unique=True,\n    short_names=None,\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Create a combination of multiple STCX indicators using function <code>comb_func</code>.</p> <ul> <li>Inputs: <code>entries</code>, <code>ts</code></li> <li>Parameters: <code>stop</code>, <code>trailing</code></li> <li>Outputs: <code>new_entries</code>, <code>exits</code></li> </ul> <p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.  Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>. Pass <code>r</code> to specify how many indicators to run.  Pass <code>short_names</code> to specify the short name for each indicator.  Set <code>run_unique</code> to True to first compute raw outputs for all parameters,  and then use them to build each indicator (faster).</p> <p>Other keyword arguments are passed to STCX.run().</p>","title":"run_combs class method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STCX.entries","text":"<p>Input array.</p>","title":"entries variable"},{"location":"api/signals/generators/#vectorbt.signals.generators.STCX.exits","text":"<p>Output array.</p>","title":"exits property"},{"location":"api/signals/generators/#vectorbt.signals.generators.STCX.new_entries","text":"<p>Output array.</p>","title":"new_entries property"},{"location":"api/signals/generators/#vectorbt.signals.generators.STCX.stop_list","text":"<p>List of <code>stop</code> values.</p>","title":"stop_list property"},{"location":"api/signals/generators/#vectorbt.signals.generators.STCX.trailing_list","text":"<p>List of <code>trailing</code> values.</p>","title":"trailing_list property"},{"location":"api/signals/generators/#vectorbt.signals.generators.STCX.ts","text":"<p>Input array.</p>","title":"ts variable"},{"location":"api/signals/generators/#vectorbt.signals.generators.STCX.entries_and","text":"<pre><code>STCX.entries_and(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries AND other</code>. </p> <p>See combine_objs().</p>","title":"entries_and method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STCX.entries_or","text":"<pre><code>STCX.entries_or(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries OR other</code>. </p> <p>See combine_objs().</p>","title":"entries_or method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STCX.entries_stats","text":"<pre><code>STCX.entries_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>entries</code> as signals.</p>","title":"entries_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STCX.entries_xor","text":"<pre><code>STCX.entries_xor(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries XOR other</code>. </p> <p>See combine_objs().</p>","title":"entries_xor method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STCX.exits_and","text":"<pre><code>STCX.exits_and(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>exits AND other</code>. </p> <p>See combine_objs().</p>","title":"exits_and method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STCX.exits_or","text":"<pre><code>STCX.exits_or(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>exits OR other</code>. </p> <p>See combine_objs().</p>","title":"exits_or method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STCX.exits_stats","text":"<pre><code>STCX.exits_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>exits</code> as signals.</p>","title":"exits_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STCX.exits_xor","text":"<pre><code>STCX.exits_xor(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>exits XOR other</code>. </p> <p>See combine_objs().</p>","title":"exits_xor method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STCX.new_entries_and","text":"<pre><code>STCX.new_entries_and(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>new_entries AND other</code>. </p> <p>See combine_objs().</p>","title":"new_entries_and method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STCX.new_entries_or","text":"<pre><code>STCX.new_entries_or(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>new_entries OR other</code>. </p> <p>See combine_objs().</p>","title":"new_entries_or method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STCX.new_entries_stats","text":"<pre><code>STCX.new_entries_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>new_entries</code> as signals.</p>","title":"new_entries_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STCX.new_entries_xor","text":"<pre><code>STCX.new_entries_xor(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>new_entries XOR other</code>. </p> <p>See combine_objs().</p>","title":"new_entries_xor method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STCX.ts_above","text":"<pre><code>STCX.ts_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>ts</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"ts_above method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STCX.ts_below","text":"<pre><code>STCX.ts_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>ts</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"ts_below method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STCX.ts_crossed_above","text":"<pre><code>STCX.ts_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>ts</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"ts_crossed_above method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STCX.ts_crossed_below","text":"<pre><code>STCX.ts_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>ts</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"ts_crossed_below method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STCX.ts_equal","text":"<pre><code>STCX.ts_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>ts</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"ts_equal method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STCX.ts_stats","text":"<pre><code>STCX.ts_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>ts</code> as generic.</p>","title":"ts_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STCX.plot","text":"<pre><code>SignalFactory.__init__.&lt;locals&gt;.plot(\n    _self,\n    entry_y=None,\n    exit_y=None,\n    entry_types=None,\n    exit_types=None,\n    entry_trace_kwargs=None,\n    exit_trace_kwargs=None,\n    fig=None,\n    **kwargs\n)\n</code></pre> <p>Plot STCX.new_entries and STCX.exits.</p> <p>Args</p>  <code>entry_y</code> :\u2002<code>array_like</code> Y-axis values to plot entry markers on. <code>exit_y</code> :\u2002<code>array_like</code> Y-axis values to plot exit markers on. <code>entry_types</code> :\u2002<code>array_like</code> Entry types in string format. <code>exit_types</code> :\u2002<code>array_like</code> Exit types in string format. <code>entry_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to             SignalsSRAccessor.plot_as_entry_markers() for STCX.new_entries. <code>exit_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to             SignalsSRAccessor.plot_as_exit_markers() for STCX.exits. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**kwargs</code> Keyword arguments passed to SignalsSRAccessor.plot_as_markers().","title":"plot method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STCX.custom_func","text":"<pre><code>SignalFactory.from_choice_func.&lt;locals&gt;.custom_func(\n    input_list,\n    in_output_list,\n    param_list,\n    *args,\n    input_shape=None,\n    flex_2d=None,\n    entry_args=None,\n    exit_args=None,\n    cache_args=None,\n    entry_kwargs=None,\n    exit_kwargs=None,\n    cache_kwargs=None,\n    return_cache=False,\n    use_cache=None,\n    **_kwargs\n)\n</code></pre>","title":"custom_func method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STX","text":"<pre><code>STX(\n    wrapper,\n    input_list,\n    input_mapper,\n    in_output_list,\n    output_list,\n    param_list,\n    mapper_list,\n    short_name,\n    level_names\n)\n</code></pre> <p>Exit signal generator based on stop values.</p> <p>Generates <code>exits</code> based on <code>entries</code> and stop_choice_nb().</p>  <p>Hint</p> <p>All parameters can be either a single value (per frame) or a NumPy array (per row, column, or element). To generate multiple combinations, pass them as lists.</p>  <p>Superclasses</p> <ul> <li>AttrResolver</li> <li>Configured</li> <li>Documented</li> <li>IndexingBase</li> <li>IndicatorBase</li> <li>PandasIndexer</li> <li>Pickleable</li> <li>PlotsBuilderMixin</li> <li>StatsBuilderMixin</li> <li>Wrapping</li> <li><code>vectorbt.signals.generators.ParamIndexer</code></li> </ul> <p>Inherited members</p> <ul> <li>AttrResolver.deep_getattr()</li> <li>AttrResolver.post_resolve_attr()</li> <li>AttrResolver.pre_resolve_attr()</li> <li>AttrResolver.resolve_attr()</li> <li>Configured.copy()</li> <li>Configured.dumps()</li> <li>Configured.loads()</li> <li>Configured.replace()</li> <li>Configured.to_doc()</li> <li>Configured.update_config()</li> <li>IndicatorBase.config</li> <li>IndicatorBase.iloc</li> <li>IndicatorBase.in_output_names</li> <li>IndicatorBase.indexing_func()</li> <li>IndicatorBase.indexing_kwargs</li> <li>IndicatorBase.input_names</li> <li>IndicatorBase.level_names</li> <li>IndicatorBase.loc</li> <li>IndicatorBase.output_flags</li> <li>IndicatorBase.output_names</li> <li>IndicatorBase.param_names</li> <li>IndicatorBase.plots_defaults</li> <li>IndicatorBase.self_aliases</li> <li>IndicatorBase.short_name</li> <li>IndicatorBase.stats_defaults</li> <li>IndicatorBase.wrapper</li> <li>IndicatorBase.writeable_attrs</li> <li>PandasIndexer.xs()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PlotsBuilderMixin.build_subplots_doc()</li> <li>PlotsBuilderMixin.override_subplots_doc()</li> <li>PlotsBuilderMixin.plots()</li> <li>StatsBuilderMixin.build_metrics_doc()</li> <li>StatsBuilderMixin.override_metrics_doc()</li> <li>StatsBuilderMixin.stats()</li> <li>Wrapping.regroup()</li> <li>Wrapping.resolve_self()</li> <li>Wrapping.select_one()</li> <li>Wrapping.select_one_from_obj()</li> </ul> <p>Subclasses</p> <ul> <li><code>vectorbt.signals.generators._STX</code></li> </ul>","title":"STX class"},{"location":"api/signals/generators/#vectorbt.signals.generators.STX.run","text":"<pre><code>STX.run(\n    entries,\n    ts,\n    stop,\n    trailing=Default(False),\n    short_name='stx',\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Run STX indicator.</p> <ul> <li>Inputs: <code>entries</code>, <code>ts</code></li> <li>Parameters: <code>stop</code>, <code>trailing</code></li> <li>Outputs: <code>exits</code></li> </ul> <p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels. Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p> <p>Other keyword arguments are passed to run_pipeline().</p>","title":"run class method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STX.run_combs","text":"<pre><code>STX.run_combs(\n    entries,\n    ts,\n    stop,\n    trailing=Default(False),\n    r=2,\n    param_product=False,\n    comb_func=itertools.combinations,\n    run_unique=True,\n    short_names=None,\n    hide_params=None,\n    hide_default=True,\n    **kwargs\n)\n</code></pre> <p>Create a combination of multiple STX indicators using function <code>comb_func</code>.</p> <ul> <li>Inputs: <code>entries</code>, <code>ts</code></li> <li>Parameters: <code>stop</code>, <code>trailing</code></li> <li>Outputs: <code>exits</code></li> </ul> <p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.  Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>. Pass <code>r</code> to specify how many indicators to run.  Pass <code>short_names</code> to specify the short name for each indicator.  Set <code>run_unique</code> to True to first compute raw outputs for all parameters,  and then use them to build each indicator (faster).</p> <p>Other keyword arguments are passed to STX.run().</p>","title":"run_combs class method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STX.entries","text":"<p>Input array.</p>","title":"entries variable"},{"location":"api/signals/generators/#vectorbt.signals.generators.STX.exits","text":"<p>Output array.</p>","title":"exits property"},{"location":"api/signals/generators/#vectorbt.signals.generators.STX.stop_list","text":"<p>List of <code>stop</code> values.</p>","title":"stop_list property"},{"location":"api/signals/generators/#vectorbt.signals.generators.STX.trailing_list","text":"<p>List of <code>trailing</code> values.</p>","title":"trailing_list property"},{"location":"api/signals/generators/#vectorbt.signals.generators.STX.ts","text":"<p>Input array.</p>","title":"ts variable"},{"location":"api/signals/generators/#vectorbt.signals.generators.STX.entries_and","text":"<pre><code>STX.entries_and(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries AND other</code>. </p> <p>See combine_objs().</p>","title":"entries_and method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STX.entries_or","text":"<pre><code>STX.entries_or(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries OR other</code>. </p> <p>See combine_objs().</p>","title":"entries_or method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STX.entries_stats","text":"<pre><code>STX.entries_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>entries</code> as signals.</p>","title":"entries_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STX.entries_xor","text":"<pre><code>STX.entries_xor(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>entries XOR other</code>. </p> <p>See combine_objs().</p>","title":"entries_xor method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STX.exits_and","text":"<pre><code>STX.exits_and(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>exits AND other</code>. </p> <p>See combine_objs().</p>","title":"exits_and method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STX.exits_or","text":"<pre><code>STX.exits_or(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>exits OR other</code>. </p> <p>See combine_objs().</p>","title":"exits_or method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STX.exits_stats","text":"<pre><code>STX.exits_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>exits</code> as signals.</p>","title":"exits_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STX.exits_xor","text":"<pre><code>STX.exits_xor(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return <code>exits XOR other</code>. </p> <p>See combine_objs().</p>","title":"exits_xor method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STX.ts_above","text":"<pre><code>STX.ts_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>ts</code> is above <code>other</code>. </p> <p>See combine_objs().</p>","title":"ts_above method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STX.ts_below","text":"<pre><code>STX.ts_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>ts</code> is below <code>other</code>. </p> <p>See combine_objs().</p>","title":"ts_below method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STX.ts_crossed_above","text":"<pre><code>STX.ts_crossed_above(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>ts</code> is crossed_above <code>other</code>. </p> <p>See combine_objs().</p>","title":"ts_crossed_above method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STX.ts_crossed_below","text":"<pre><code>STX.ts_crossed_below(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>ts</code> is crossed_below <code>other</code>. </p> <p>See combine_objs().</p>","title":"ts_crossed_below method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STX.ts_equal","text":"<pre><code>STX.ts_equal(\n    other,\n    level_name=None,\n    allow_multiple=True,\n    **kwargs\n)\n</code></pre> <p>Return True for each element where <code>ts</code> is equal <code>other</code>. </p> <p>See combine_objs().</p>","title":"ts_equal method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STX.ts_stats","text":"<pre><code>STX.ts_stats(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Stats of <code>ts</code> as generic.</p>","title":"ts_stats method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STX.plot","text":"<pre><code>SignalFactory.__init__.&lt;locals&gt;.plot(\n    _self,\n    entry_y=None,\n    exit_y=None,\n    entry_types=None,\n    exit_types=None,\n    entry_trace_kwargs=None,\n    exit_trace_kwargs=None,\n    fig=None,\n    **kwargs\n)\n</code></pre> <p>Plot STX.entries and STX.exits.</p> <p>Args</p>  <code>entry_y</code> :\u2002<code>array_like</code> Y-axis values to plot entry markers on. <code>exit_y</code> :\u2002<code>array_like</code> Y-axis values to plot exit markers on. <code>entry_types</code> :\u2002<code>array_like</code> Entry types in string format. <code>exit_types</code> :\u2002<code>array_like</code> Exit types in string format. <code>entry_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to             SignalsSRAccessor.plot_as_entry_markers() for STX.entries. <code>exit_trace_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to             SignalsSRAccessor.plot_as_exit_markers() for STX.exits. <code>fig</code> :\u2002<code>Figure</code> or <code>FigureWidget</code> Figure to add traces to. <code>**kwargs</code> Keyword arguments passed to SignalsSRAccessor.plot_as_markers().","title":"plot method"},{"location":"api/signals/generators/#vectorbt.signals.generators.STX.custom_func","text":"<pre><code>SignalFactory.from_choice_func.&lt;locals&gt;.custom_func(\n    input_list,\n    in_output_list,\n    param_list,\n    *args,\n    input_shape=None,\n    flex_2d=None,\n    entry_args=None,\n    exit_args=None,\n    cache_args=None,\n    entry_kwargs=None,\n    exit_kwargs=None,\n    cache_kwargs=None,\n    return_cache=False,\n    use_cache=None,\n    **_kwargs\n)\n</code></pre>","title":"custom_func method"},{"location":"api/signals/nb/","text":"<p>Numba-compiled functions.</p> <p>Provides an arsenal of Numba-compiled functions that are used by accessors and in many other parts of the backtesting pipeline, such as technical indicators. These only accept NumPy arrays and other Numba-compatible types.</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; # vectorbt.signals.nb.pos_rank_nb\n&gt;&gt;&gt; vbt.signals.nb.pos_rank_nb(np.array([False, True, True, True, False])[:, None])[:, 0]\n[-1  0  1  2 -1]\n</code></pre>  <p>Note</p> <p>vectorbt treats matrices as first-class citizens and expects input arrays to be 2-dim, unless function has suffix <code>_1d</code> or is meant to be input to another function.  Data is processed along index (axis 0).</p> <p>All functions passed as argument should be Numba-compiled.</p> <p>Returned indices should be absolute.</p>","title":"nb"},{"location":"api/signals/nb/#vectorbt.signals.nb.between_partition_ranges_nb","text":"<pre><code>between_partition_ranges_nb(\n    a\n)\n</code></pre> <p>Create a record of type range_dt for each range between two partitions in <code>a</code>.</p>","title":"between_partition_ranges_nb function"},{"location":"api/signals/nb/#vectorbt.signals.nb.between_ranges_nb","text":"<pre><code>between_ranges_nb(\n    a\n)\n</code></pre> <p>Create a record of type range_dt for each range between two signals in <code>a</code>.</p>","title":"between_ranges_nb function"},{"location":"api/signals/nb/#vectorbt.signals.nb.between_two_ranges_nb","text":"<pre><code>between_two_ranges_nb(\n    a,\n    b,\n    from_other=False\n)\n</code></pre> <p>Create a record of type range_dt for each range between two signals in <code>a</code> and <code>b</code>.</p> <p>If <code>from_other</code> is False, returns ranges from each in <code>a</code> to the succeeding in <code>b</code>. Otherwise, returns ranges from each in <code>b</code> to the preceding in <code>a</code>.</p> <p>When <code>a</code> and <code>b</code> overlap (two signals at the same time), the distance between overlapping signals is still considered and <code>from_i</code> would match <code>to_i</code>.</p>","title":"between_two_ranges_nb function"},{"location":"api/signals/nb/#vectorbt.signals.nb.clean_enex_1d_nb","text":"<pre><code>clean_enex_1d_nb(\n    entries,\n    exits,\n    entry_first\n)\n</code></pre> <p>Clean entry and exit arrays by picking the first signal out of each.</p> <p>Entry signal must be picked first. If both signals are present, selects none.</p>","title":"clean_enex_1d_nb function"},{"location":"api/signals/nb/#vectorbt.signals.nb.clean_enex_nb","text":"<pre><code>clean_enex_nb(\n    entries,\n    exits,\n    entry_first\n)\n</code></pre> <p>2-dim version of clean_enex_1d_nb().</p>","title":"clean_enex_nb function"},{"location":"api/signals/nb/#vectorbt.signals.nb.first_choice_nb","text":"<pre><code>first_choice_nb(\n    from_i,\n    to_i,\n    col,\n    a\n)\n</code></pre> <p><code>choice_func_nb</code> that returns the index of the first signal in <code>a</code>.</p>","title":"first_choice_nb function"},{"location":"api/signals/nb/#vectorbt.signals.nb.generate_enex_nb","text":"<pre><code>generate_enex_nb(\n    shape,\n    entry_wait,\n    exit_wait,\n    entry_pick_first,\n    exit_pick_first,\n    entry_choice_func_nb,\n    entry_args,\n    exit_choice_func_nb,\n    exit_args\n)\n</code></pre> <p>Pick entry signals using <code>entry_choice_func_nb</code> and exit signals using  <code>exit_choice_func_nb</code> one after another.</p> <p>Args</p>  <code>shape</code> :\u2002<code>array</code> Target shape. <code>entry_wait</code> :\u2002<code>int</code>  <p>Number of ticks to wait before placing entries.</p>  <p>Note</p> <p>Setting <code>entry_wait</code> to 0 or False assumes that both entry and exit can be processed within the same bar, and exit can be processed before entry.</p>   <code>exit_wait</code> :\u2002<code>int</code>  <p>Number of ticks to wait before placing exits.</p>  <p>Note</p> <p>Setting <code>exit_wait</code> to 0 or False assumes that both entry and exit can be processed within the same bar, and entry can be processed before exit.</p>   <code>entry_pick_first</code> :\u2002<code>bool</code> Whether to pick the first entry out of all returned by <code>entry_choice_func_nb</code>. <code>exit_pick_first</code> :\u2002<code>bool</code>  <p>Whether to pick the first exit out of all returned by <code>exit_choice_func_nb</code>.</p> <p>Setting it to False acts similarly to setting <code>skip_until_exit</code> to True in generate_ex_nb().</p>  <code>entry_choice_func_nb</code> :\u2002<code>callable</code>  <p>Entry choice function.</p> <p>See <code>choice_func_nb</code> in generate_nb().</p>  <code>entry_args</code> :\u2002<code>tuple</code> Arguments unpacked and passed to <code>entry_choice_func_nb</code>. <code>exit_choice_func_nb</code> :\u2002<code>callable</code>  <p>Exit choice function.</p> <p>See <code>choice_func_nb</code> in generate_nb().</p>  <code>exit_args</code> :\u2002<code>tuple</code> Arguments unpacked and passed to <code>exit_choice_func_nb</code>.","title":"generate_enex_nb function"},{"location":"api/signals/nb/#vectorbt.signals.nb.generate_ex_nb","text":"<pre><code>generate_ex_nb(\n    entries,\n    wait,\n    until_next,\n    skip_until_exit,\n    pick_first,\n    exit_choice_func_nb,\n    *args\n)\n</code></pre> <p>Pick exit signals using <code>exit_choice_func_nb</code> after each signal in <code>entries</code>.</p> <p>Args</p>  <code>entries</code> :\u2002<code>array</code> Boolean array with entry signals. <code>wait</code> :\u2002<code>int</code>  <p>Number of ticks to wait before placing exits.</p>  <p>Note</p> <p>Setting <code>wait</code> to 0 or False may result in two signals at one bar.</p>   <code>until_next</code> :\u2002<code>int</code>  <p>Whether to place signals up to the next entry signal.</p>  <p>Note</p> <p>Setting it to False makes it difficult to tell which exit belongs to which entry.</p>   <code>skip_until_exit</code> :\u2002<code>bool</code>  <p>Whether to skip processing entry signals until the next exit.</p> <p>Has only effect when <code>until_next</code> is disabled.</p>  <p>Note</p> <p>Setting it to True makes it difficult to tell which exit belongs to which entry.</p>   <code>pick_first</code> :\u2002<code>bool</code> Whether to pick the first signal out of all returned by <code>exit_choice_func_nb</code>. <code>exit_choice_func_nb</code> :\u2002<code>callable</code>  <p>Exit choice function.</p> <p>See <code>choice_func_nb</code> in generate_nb().</p>  <code>*args</code> :\u2002<code>callable</code> Arguments passed to <code>exit_choice_func_nb</code>.","title":"generate_ex_nb function"},{"location":"api/signals/nb/#vectorbt.signals.nb.generate_nb","text":"<pre><code>generate_nb(\n    shape,\n    pick_first,\n    choice_func_nb,\n    *args\n)\n</code></pre> <p>Create a boolean matrix of <code>shape</code> and pick signals using <code>choice_func_nb</code>.</p> <p>Args</p>  <code>shape</code> :\u2002<code>array</code> Target shape. <code>pick_first</code> :\u2002<code>bool</code> Whether to pick the first signal out of all returned by <code>choice_func_nb</code>. <code>choice_func_nb</code> :\u2002<code>callable</code>  <p>Choice function.</p> <p><code>choice_func_nb</code> should accept index of the start of the range <code>from_i</code>, index of the end of the range <code>to_i</code>, index of the column <code>col</code>, and <code>*args</code>. It should return an array of indices from <code>[from_i, to_i)</code> (can be empty).</p>  <code>*args</code> Arguments passed to <code>choice_func_nb</code>.  <p>Usage</p> <pre><code>&gt;&gt;&gt; from numba import njit\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from vectorbt.signals.nb import generate_nb\n\n&gt;&gt;&gt; @njit\n... def choice_func_nb(from_i, to_i, col):\n...     return np.array([from_i + col])\n\n&gt;&gt;&gt; generate_nb((5, 3), choice_func_nb)\n[[ True False False]\n [False  True False]\n [False False  True]\n [False False False]\n [False False False]]\n</code></pre>","title":"generate_nb function"},{"location":"api/signals/nb/#vectorbt.signals.nb.generate_ohlc_stop_enex_nb","text":"<pre><code>generate_ohlc_stop_enex_nb(\n    entries,\n    open,\n    high,\n    low,\n    close,\n    stop_price_out,\n    stop_type_out,\n    sl_stop,\n    sl_trail,\n    tp_stop,\n    reverse,\n    is_open_safe,\n    entry_wait,\n    exit_wait,\n    pick_first,\n    flex_2d\n)\n</code></pre> <p>Generate one after another using generate_enex_nb() and ohlc_stop_choice_nb().</p> <p>Returns two arrays: new entries and exits.</p>  <p>Note</p> <p>Has the same logic as calling generate_ohlc_stop_ex_nb() with <code>skip_until_exit=True</code>, but removes all entries that come before the next exit.</p>","title":"generate_ohlc_stop_enex_nb function"},{"location":"api/signals/nb/#vectorbt.signals.nb.generate_ohlc_stop_ex_nb","text":"<pre><code>generate_ohlc_stop_ex_nb(\n    entries,\n    open,\n    high,\n    low,\n    close,\n    stop_price_out,\n    stop_type_out,\n    sl_stop,\n    sl_trail,\n    tp_stop,\n    reverse,\n    is_open_safe,\n    wait,\n    until_next,\n    skip_until_exit,\n    pick_first,\n    flex_2d\n)\n</code></pre> <p>Generate using generate_ex_nb() and ohlc_stop_choice_nb().</p> <p>Usage</p> <ul> <li>Generate trailing stop loss and take profit signals for 10%. Illustrates how exit signal can be generated within the same bar as entry.</li> </ul> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from vectorbt.signals.nb import generate_ohlc_stop_ex_nb\n\n&gt;&gt;&gt; entries = np.asarray([True, False, True, False, False])[:, None]\n&gt;&gt;&gt; entry_price = np.asarray([10, 11, 12, 11, 10])[:, None]\n&gt;&gt;&gt; high_price = entry_price + 1\n&gt;&gt;&gt; low_price = entry_price - 1\n&gt;&gt;&gt; close_price = entry_price\n&gt;&gt;&gt; stop_price_out = np.full_like(entries, np.nan, dtype=np.float_)\n&gt;&gt;&gt; stop_type_out = np.full_like(entries, -1, dtype=np.int_)\n\n&gt;&gt;&gt; generate_ohlc_stop_ex_nb(\n...     entries=entries,\n...     open=entry_price,\n...     high=high_price,\n...     low=low_price,\n...     close=close_price,\n...     stop_price_out=stop_price_out,\n...     stop_type_out=stop_type_out,\n...     sl_stop=0.1,\n...     sl_trail=True,\n...     tp_stop=0.1,\n...     reverse=False,\n...     is_open_safe=True,\n...     wait=1,\n...     until_next=True,\n...     skip_until_exit=False,\n...     pick_first=True,\n...     flex_2d=True\n... )\narray([[ True],\n       [False],\n       [False],\n       [ True],\n       [False]])\n\n&gt;&gt;&gt; stop_price_out\narray([[ 9. ],  &lt;&lt; trailing SL from 10 (entry_price)\n       [ nan],\n       [ nan],\n       [11.7],  &lt;&lt; trailing SL from 13 (high_price)\n       [ nan]])\n\n&gt;&gt;&gt; stop_type_out\narray([[ 1],\n       [-1],\n       [-1],\n       [ 1],\n       [-1]])\n</code></pre> <p>Note that if <code>is_open_safe</code> was False, the first exit would be executed at the second bar. This is because we don't know whether the entry price comes before the high and low price at the first bar, and so the trailing stop isn't triggered for the low price of 9.0.</p>","title":"generate_ohlc_stop_ex_nb function"},{"location":"api/signals/nb/#vectorbt.signals.nb.generate_rand_by_prob_nb","text":"<pre><code>generate_rand_by_prob_nb(\n    shape,\n    prob,\n    pick_first,\n    flex_2d,\n    seed=None\n)\n</code></pre> <p>Create a boolean matrix of <code>shape</code> and pick signals randomly by probability <code>prob</code>.</p> <p><code>prob</code> should be a 2-dim array of shape <code>shape</code>. Specify <code>seed</code> to make output deterministic.</p> <p>See rand_by_prob_choice_nb().</p>","title":"generate_rand_by_prob_nb function"},{"location":"api/signals/nb/#vectorbt.signals.nb.generate_rand_enex_by_prob_nb","text":"<pre><code>generate_rand_enex_by_prob_nb(\n    shape,\n    entry_prob,\n    exit_prob,\n    entry_wait,\n    exit_wait,\n    entry_pick_first,\n    exit_pick_first,\n    flex_2d,\n    seed=None\n)\n</code></pre> <p>Pick entries by probability <code>entry_prob</code> and exits by probability <code>exit_prob</code> one after another.</p> <p><code>entry_prob</code> and <code>exit_prob</code> should be 2-dim arrays of shape <code>shape</code>. Specify <code>seed</code> to make output deterministic.</p>","title":"generate_rand_enex_by_prob_nb function"},{"location":"api/signals/nb/#vectorbt.signals.nb.generate_rand_enex_nb","text":"<pre><code>generate_rand_enex_nb(\n    shape,\n    n,\n    entry_wait,\n    exit_wait,\n    seed=None\n)\n</code></pre> <p>Pick a number of entries and the same number of exits one after another.</p> <p>Respects <code>entry_wait</code> and <code>exit_wait</code> constraints through a number of tricks. Tries to mimic a uniform distribution as much as possible.</p> <p>The idea is the following: with constraints, there is some fixed amount of total space required between first entry and last exit. Upscale this space in a way that distribution of entries and exit is similar to a uniform distribution. This means randomizing the position of first entry, last exit, and all signals between them.</p> <p><code>n</code> uses flexible indexing. Specify <code>seed</code> to make output deterministic.</p>","title":"generate_rand_enex_nb function"},{"location":"api/signals/nb/#vectorbt.signals.nb.generate_rand_ex_by_prob_nb","text":"<pre><code>generate_rand_ex_by_prob_nb(\n    entries,\n    prob,\n    wait,\n    until_next,\n    skip_until_exit,\n    flex_2d,\n    seed=None\n)\n</code></pre> <p>Pick an exit after each entry in <code>entries</code> by probability <code>prob</code>.</p> <p><code>prob</code> should be a 2-dim array of shape <code>shape</code>. Specify <code>seed</code> to make output deterministic.</p>","title":"generate_rand_ex_by_prob_nb function"},{"location":"api/signals/nb/#vectorbt.signals.nb.generate_rand_ex_nb","text":"<pre><code>generate_rand_ex_nb(\n    entries,\n    wait,\n    until_next,\n    skip_until_exit,\n    seed=None\n)\n</code></pre> <p>Pick an exit after each entry in <code>entries</code>.</p> <p>Specify <code>seed</code> to make output deterministic.</p>","title":"generate_rand_ex_nb function"},{"location":"api/signals/nb/#vectorbt.signals.nb.generate_rand_nb","text":"<pre><code>generate_rand_nb(\n    shape,\n    n,\n    seed=None\n)\n</code></pre> <p>Create a boolean matrix of <code>shape</code> and pick a number of signals randomly.</p> <p>Specify <code>seed</code> to make output deterministic.</p> <p>See rand_choice_nb().</p>","title":"generate_rand_nb function"},{"location":"api/signals/nb/#vectorbt.signals.nb.generate_stop_enex_nb","text":"<pre><code>generate_stop_enex_nb(\n    entries,\n    ts,\n    stop,\n    trailing,\n    entry_wait,\n    exit_wait,\n    pick_first,\n    flex_2d\n)\n</code></pre> <p>Generate one after another using generate_enex_nb() and stop_choice_nb().</p> <p>Returns two arrays: new entries and exits.</p>  <p>Note</p> <p>Has the same logic as calling generate_stop_ex_nb() with <code>skip_until_exit=True</code>, but removes all entries that come before the next exit.</p>","title":"generate_stop_enex_nb function"},{"location":"api/signals/nb/#vectorbt.signals.nb.generate_stop_ex_nb","text":"<pre><code>generate_stop_ex_nb(\n    entries,\n    ts,\n    stop,\n    trailing,\n    wait,\n    until_next,\n    skip_until_exit,\n    pick_first,\n    flex_2d\n)\n</code></pre> <p>Generate using generate_ex_nb() and stop_choice_nb().</p> <p>Usage</p> <ul> <li>Generate trailing stop loss and take profit signals for 10%.</li> </ul> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from vectorbt.signals.nb import generate_stop_ex_nb\n\n&gt;&gt;&gt; entries = np.asarray([False, True, False, False, False])[:, None]\n&gt;&gt;&gt; ts = np.asarray([1, 2, 3, 2, 1])[:, None]\n\n&gt;&gt;&gt; generate_stop_ex_nb(entries, ts, -0.1, True, 1, True, True)\narray([[False],\n       [False],\n       [False],\n       [ True],\n       [False]])\n\n&gt;&gt;&gt; generate_stop_ex_nb(entries, ts, 0.1, False, 1, True, True)\narray([[False],\n       [False],\n       [ True],\n       [False],\n       [False]])\n</code></pre>","title":"generate_stop_ex_nb function"},{"location":"api/signals/nb/#vectorbt.signals.nb.norm_avg_index_1d_nb","text":"<pre><code>norm_avg_index_1d_nb(\n    a\n)\n</code></pre> <p>Get mean index normalized to (-1, 1).</p>","title":"norm_avg_index_1d_nb function"},{"location":"api/signals/nb/#vectorbt.signals.nb.norm_avg_index_nb","text":"<pre><code>norm_avg_index_nb(\n    a\n)\n</code></pre> <p>2-dim version of norm_avg_index_1d_nb().</p>","title":"norm_avg_index_nb function"},{"location":"api/signals/nb/#vectorbt.signals.nb.nth_index_1d_nb","text":"<pre><code>nth_index_1d_nb(\n    a,\n    n\n)\n</code></pre> <p>Get the index of the n-th True value.</p>  <p>Note</p> <p><code>n</code> starts with 0 and can be negative.</p>","title":"nth_index_1d_nb function"},{"location":"api/signals/nb/#vectorbt.signals.nb.nth_index_nb","text":"<pre><code>nth_index_nb(\n    a,\n    n\n)\n</code></pre> <p>2-dim version of nth_index_1d_nb().</p>","title":"nth_index_nb function"},{"location":"api/signals/nb/#vectorbt.signals.nb.ohlc_stop_choice_nb","text":"<pre><code>ohlc_stop_choice_nb(\n    from_i,\n    to_i,\n    col,\n    open,\n    high,\n    low,\n    close,\n    stop_price_out,\n    stop_type_out,\n    sl_stop,\n    sl_trail,\n    tp_stop,\n    reverse,\n    is_open_safe,\n    wait,\n    pick_first,\n    temp_idx_arr,\n    flex_2d\n)\n</code></pre> <p><code>choice_func_nb</code> that returns the indices of the stop price being hit within OHLC.</p> <p>Compared to stop_choice_nb(), takes into account the whole bar, can check for both (trailing) stop loss and take profit simultaneously, and tracks hit price and stop type.</p>  <p>Note</p> <p>We don't have intra-candle data. If there was a huge price fluctuation in both directions, we can't determine whether SL was triggered before TP and vice versa. So some assumptions need to be made: 1) trailing stop can only be based on previous close/high, and 2) we pessimistically assume that SL comes before TP.</p>  <p>Args</p>  <code>col</code> :\u2002<code>int</code> Current column. <code>from_i</code> :\u2002<code>int</code> Index to start generation from (inclusive). <code>to_i</code> :\u2002<code>int</code> Index to run generation to (exclusive). <code>open</code> :\u2002<code>array</code> of <code>float</code> Entry price such as open or previous close. <code>high</code> :\u2002<code>array</code> of <code>float</code> High price. <code>low</code> :\u2002<code>array</code> of <code>float</code> Low price. <code>close</code> :\u2002<code>array</code> of <code>float</code> Close price. <code>stop_price_out</code> :\u2002<code>array</code> of <code>float</code> Array where hit price of each exit will be stored. <code>stop_type_out</code> :\u2002<code>array</code> of <code>int</code>  <p>Array where stop type of each exit will be stored.</p> <p>0 for stop loss, 1 for take profit.</p>  <code>sl_stop</code> :\u2002<code>float</code> or <code>array_like</code>  <p>Percentage value for stop loss.</p> <p>Can be per frame, column, row, or element-wise. Set to <code>np.nan</code> to disable.</p>  <code>sl_trail</code> :\u2002<code>bool</code> or <code>array_like</code>  <p>Whether <code>sl_stop</code> is trailing.</p> <p>Can be per frame, column, row, or element-wise. Set to False to disable.</p>  <code>tp_stop</code> :\u2002<code>float</code> or <code>array_like</code>  <p>Percentage value for take profit.</p> <p>Can be per frame, column, row, or element-wise. Set to <code>np.nan</code> to disable.</p>  <code>reverse</code> :\u2002<code>bool</code> or <code>array_like</code> Whether to do the opposite, i.e.: prices are followed downwards. <code>is_open_safe</code> :\u2002<code>bool</code>  <p>Whether entry price comes right at or before open.</p> <p>If True and wait is 0, can use high/low at entry bar. Otherwise uses only close.</p>  <code>wait</code> :\u2002<code>int</code>  <p>Number of ticks to wait before placing exits.</p> <p>Setting False or 0 may result in entry and exit signal at one bar.</p>  <p>Note</p> <p>If <code>wait</code> is greater than 0, even with <code>is_open_safe</code> set to True, trailing stop won't update at bars that come before <code>from_i</code>.</p>   <code>pick_first</code> :\u2002<code>bool</code> Whether to stop as soon as the first exit signal is found. <code>temp_idx_arr</code> :\u2002<code>array</code> of <code>int</code> Empty integer array used to temporarily store indices. <code>flex_2d</code> :\u2002<code>bool</code> See flex_select_auto_nb().","title":"ohlc_stop_choice_nb function"},{"location":"api/signals/nb/#vectorbt.signals.nb.part_pos_rank_nb","text":"<pre><code>part_pos_rank_nb(\n    i,\n    col,\n    reset_i,\n    prev_part_end_i,\n    part_start_i,\n    part_pos_temp\n)\n</code></pre> <p><code>rank_func_nb</code> that returns the rank of each partition by its position in the series.</p>","title":"part_pos_rank_nb function"},{"location":"api/signals/nb/#vectorbt.signals.nb.partition_ranges_nb","text":"<pre><code>partition_ranges_nb(\n    a\n)\n</code></pre> <p>Create a record of type range_dt for each partition of signals in <code>a</code>.</p>","title":"partition_ranges_nb function"},{"location":"api/signals/nb/#vectorbt.signals.nb.rand_by_prob_choice_nb","text":"<pre><code>rand_by_prob_choice_nb(\n    from_i,\n    to_i,\n    col,\n    prob,\n    pick_first,\n    temp_idx_arr,\n    flex_2d\n)\n</code></pre> <p><code>choice_func_nb</code> to randomly pick values from range <code>[from_i, to_i)</code> with probability <code>prob</code>.</p> <p><code>prob</code> uses flexible indexing.</p>","title":"rand_by_prob_choice_nb function"},{"location":"api/signals/nb/#vectorbt.signals.nb.rand_choice_nb","text":"<pre><code>rand_choice_nb(\n    from_i,\n    to_i,\n    col,\n    n\n)\n</code></pre> <p><code>choice_func_nb</code> to randomly pick <code>n</code> values from range <code>[from_i, to_i)</code>.</p> <p><code>n</code> uses flexible indexing.</p>","title":"rand_choice_nb function"},{"location":"api/signals/nb/#vectorbt.signals.nb.rand_enex_apply_nb","text":"<pre><code>rand_enex_apply_nb(\n    input_shape,\n    n,\n    entry_wait,\n    exit_wait\n)\n</code></pre> <p><code>apply_func_nb</code> that calls generate_rand_enex_nb().</p>","title":"rand_enex_apply_nb function"},{"location":"api/signals/nb/#vectorbt.signals.nb.rank_nb","text":"<pre><code>rank_nb(\n    a,\n    reset_by,\n    after_false,\n    rank_func_nb,\n    *args\n)\n</code></pre> <p>Rank each signal using <code>rank_func_nb</code>.</p> <p>Applies <code>rank_func_nb</code> on each True value. Should accept index of the row,  index of the column, index of the last reset signal, index of the end of the previous partition, index of the start of the current partition, and <code>*args</code>. Should return -1 for no rank, otherwise 0 or greater.</p> <p>Setting <code>after_false</code> to True will disregard the first partition of True values if there is no False value before them.</p>","title":"rank_nb function"},{"location":"api/signals/nb/#vectorbt.signals.nb.sig_pos_rank_nb","text":"<pre><code>sig_pos_rank_nb(\n    i,\n    col,\n    reset_i,\n    prev_part_end_i,\n    part_start_i,\n    sig_pos_temp,\n    allow_gaps\n)\n</code></pre> <p><code>rank_func_nb</code> that returns the rank of each signal by its position in the partition.</p>","title":"sig_pos_rank_nb function"},{"location":"api/signals/nb/#vectorbt.signals.nb.stop_choice_nb","text":"<pre><code>stop_choice_nb(\n    from_i,\n    to_i,\n    col,\n    ts,\n    stop,\n    trailing,\n    wait,\n    pick_first,\n    temp_idx_arr,\n    flex_2d\n)\n</code></pre> <p><code>choice_func_nb</code> that returns the indices of the stop being hit.</p> <p>Args</p>  <code>from_i</code> :\u2002<code>int</code> Index to start generation from (inclusive). <code>to_i</code> :\u2002<code>int</code> Index to run generation to (exclusive). <code>col</code> :\u2002<code>int</code> Current column. <code>ts</code> :\u2002<code>array</code> of <code>float</code> 2-dim time series array such as price. <code>stop</code> :\u2002<code>float</code> or <code>array_like</code>  <p>Stop value for stop loss.</p> <p>Can be per frame, column, row, or element-wise. Set to <code>np.nan</code> to disable.</p>  <code>trailing</code> :\u2002<code>bool</code> or <code>array_like</code>  <p>Whether to use trailing stop.</p> <p>Can be per frame, column, row, or element-wise. Set to False to disable.</p>  <code>wait</code> :\u2002<code>int</code>  <p>Number of ticks to wait before placing exits.</p> <p>Setting False or 0 may result in two signals at one bar.</p>  <p>Note</p> <p>If <code>wait</code> is greater than 0, trailing stop won't update at bars that come before <code>from_i</code>.</p>   <code>pick_first</code> :\u2002<code>bool</code> Whether to stop as soon as the first exit signal is found. <code>temp_idx_arr</code> :\u2002<code>array</code> of <code>int</code> Empty integer array used to temporarily store indices. <code>flex_2d</code> :\u2002<code>bool</code> See flex_select_auto_nb().","title":"stop_choice_nb function"},{"location":"api/utils/","text":"<p>Modules with utilities that are used throughout vectorbt.</p>","title":"utils"},{"location":"api/utils/#sub-modules","text":"<ul> <li>vectorbt.utils.array_</li> <li>vectorbt.utils.attr_</li> <li>vectorbt.utils.checks</li> <li>vectorbt.utils.colors</li> <li>vectorbt.utils.config</li> <li>vectorbt.utils.datetime_</li> <li>vectorbt.utils.decorators</li> <li>vectorbt.utils.docs</li> <li>vectorbt.utils.enum_</li> <li>vectorbt.utils.figure</li> <li>vectorbt.utils.image_</li> <li>vectorbt.utils.mapping</li> <li>vectorbt.utils.math_</li> <li>vectorbt.utils.module_</li> <li>vectorbt.utils.params</li> <li>vectorbt.utils.random_</li> <li>vectorbt.utils.requests_</li> <li>vectorbt.utils.schedule_</li> <li>vectorbt.utils.tags</li> <li>vectorbt.utils.template</li> </ul>","title":"Sub-modules"},{"location":"api/utils/array_/","text":"<p>Utilities for working with arrays.</p>","title":"array_"},{"location":"api/utils/array_/#vectorbt.utils.array_.get_ranges_arr","text":"<pre><code>get_ranges_arr(\n    starts,\n    ends\n)\n</code></pre> <p>Build array from start and end indices.</p> <p>Based on https://stackoverflow.com/a/37626057</p>","title":"get_ranges_arr function"},{"location":"api/utils/array_/#vectorbt.utils.array_.insert_argsort_nb","text":"<pre><code>insert_argsort_nb(\n    A,\n    I\n)\n</code></pre> <p>Perform argsort using insertion sort.</p> <p>In-memory and without recursion -&gt; very fast for smaller arrays.</p>","title":"insert_argsort_nb function"},{"location":"api/utils/array_/#vectorbt.utils.array_.is_sorted","text":"<pre><code>is_sorted(\n    a\n)\n</code></pre> <p>Checks if array is sorted.</p>","title":"is_sorted function"},{"location":"api/utils/array_/#vectorbt.utils.array_.is_sorted_nb","text":"<pre><code>is_sorted_nb(\n    a\n)\n</code></pre> <p>Numba-compiled version of is_sorted().</p>","title":"is_sorted_nb function"},{"location":"api/utils/array_/#vectorbt.utils.array_.max_rel_rescale","text":"<pre><code>max_rel_rescale(\n    a,\n    to_range\n)\n</code></pre> <p>Rescale elements in <code>a</code> relatively to maximum.</p>","title":"max_rel_rescale function"},{"location":"api/utils/array_/#vectorbt.utils.array_.min_rel_rescale","text":"<pre><code>min_rel_rescale(\n    a,\n    to_range\n)\n</code></pre> <p>Rescale elements in <code>a</code> relatively to minimum.</p>","title":"min_rel_rescale function"},{"location":"api/utils/array_/#vectorbt.utils.array_.renormalize","text":"<pre><code>renormalize(\n    a,\n    from_range,\n    to_range\n)\n</code></pre> <p>Renormalize <code>a</code> from one range to another.</p>","title":"renormalize function"},{"location":"api/utils/array_/#vectorbt.utils.array_.renormalize_nb","text":"<pre><code>renormalize(\n    a,\n    from_range,\n    to_range\n)\n</code></pre> <p>Renormalize <code>a</code> from one range to another.</p>","title":"renormalize_nb function"},{"location":"api/utils/array_/#vectorbt.utils.array_.rescale_float_to_int_nb","text":"<pre><code>rescale_float_to_int_nb(\n    floats,\n    int_range,\n    total\n)\n</code></pre> <p>Rescale a float array into an int array.</p>","title":"rescale_float_to_int_nb function"},{"location":"api/utils/array_/#vectorbt.utils.array_.uniform_summing_to_one_nb","text":"<pre><code>uniform_summing_to_one_nb(\n    n\n)\n</code></pre> <p>Generate random floats summing to one.</p> <p>See # https://stackoverflow.com/a/2640067/8141780</p>","title":"uniform_summing_to_one_nb function"},{"location":"api/utils/attr_/","text":"<p>Utilities for working with class/instance attributes.</p>","title":"attr_"},{"location":"api/utils/attr_/#vectorbt.utils.attr_.deep_getattr","text":"<pre><code>deep_getattr(\n    obj,\n    attr_chain,\n    getattr_func=&lt;function default_getattr_func&gt;,\n    call_last_attr=True\n)\n</code></pre> <p>Retrieve attribute consecutively.</p> <p>The attribute chain <code>attr_chain</code> can be:</p> <ul> <li>string -&gt; get variable/property or method without arguments</li> <li>tuple of string -&gt; call method without arguments</li> <li>tuple of string and tuple -&gt; call method and pass positional arguments (unpacked)</li> <li>tuple of string, tuple, and dict -&gt; call method and pass positional and keyword arguments (unpacked)</li> <li>iterable of any of the above</li> </ul> <p>Use <code>getattr_func</code> to overwrite the default behavior of accessing an attribute (see default_getattr_func()).</p>  <p>Hint</p> <p>If your chain includes only attributes and functions without arguments, you can represent this chain as a single (but probably long) string.</p>","title":"deep_getattr function"},{"location":"api/utils/attr_/#vectorbt.utils.attr_.default_getattr_func","text":"<pre><code>default_getattr_func(\n    obj,\n    attr,\n    args=None,\n    kwargs=None,\n    call_attr=True\n)\n</code></pre> <p>Default <code>getattr_func</code>.</p>","title":"default_getattr_func function"},{"location":"api/utils/attr_/#vectorbt.utils.attr_.get_dict_attr","text":"<pre><code>get_dict_attr(\n    obj,\n    attr\n)\n</code></pre> <p>Get attribute without invoking the attribute lookup machinery.</p>","title":"get_dict_attr function"},{"location":"api/utils/attr_/#vectorbt.utils.attr_.AttrResolver","text":"<pre><code>AttrResolver()\n</code></pre> <p>Class that implements resolution of self and its attributes.</p> <p>Resolution is <code>getattr</code> that works for self, properties, and methods. It also utilizes built-in caching.</p> <p>Subclasses</p> <ul> <li>Wrapping</li> </ul>","title":"AttrResolver class"},{"location":"api/utils/attr_/#vectorbt.utils.attr_.AttrResolver.self_aliases","text":"<p>Names to associate with this object.</p>","title":"self_aliases property"},{"location":"api/utils/attr_/#vectorbt.utils.attr_.AttrResolver.deep_getattr","text":"<pre><code>AttrResolver.deep_getattr(\n    *args,\n    **kwargs\n)\n</code></pre> <p>See deep_getattr().</p>","title":"deep_getattr method"},{"location":"api/utils/attr_/#vectorbt.utils.attr_.AttrResolver.post_resolve_attr","text":"<pre><code>AttrResolver.post_resolve_attr(\n    attr,\n    out,\n    final_kwargs=None\n)\n</code></pre> <p>Post-process an object after resolution.</p> <p>Should return an object.</p>","title":"post_resolve_attr method"},{"location":"api/utils/attr_/#vectorbt.utils.attr_.AttrResolver.pre_resolve_attr","text":"<pre><code>AttrResolver.pre_resolve_attr(\n    attr,\n    final_kwargs=None\n)\n</code></pre> <p>Pre-process an attribute before resolution.</p> <p>Should return an attribute.</p>","title":"pre_resolve_attr method"},{"location":"api/utils/attr_/#vectorbt.utils.attr_.AttrResolver.resolve_attr","text":"<pre><code>AttrResolver.resolve_attr(\n    attr,\n    args=None,\n    cond_kwargs=None,\n    kwargs=None,\n    custom_arg_names=None,\n    cache_dct=None,\n    use_caching=True,\n    passed_kwargs_out=None\n)\n</code></pre> <p>Resolve an attribute using keyword arguments and built-in caching.</p> <ul> <li>If <code>attr</code> is a property, returns its value.</li> <li>If <code>attr</code> is a method, passes <code>*args</code>, <code>**kwargs</code>, and <code>**cond_kwargs</code> with keys found in the signature.</li> <li>If <code>attr</code> is a property and there is a <code>get_{arg}</code> method, calls the <code>get_{arg}</code> method.</li> </ul> <p>Won't cache if <code>use_caching</code> is False or any passed argument is in <code>custom_arg_names</code>.</p> <p>Use <code>passed_kwargs_out</code> to get keyword arguments that were passed.</p>","title":"resolve_attr method"},{"location":"api/utils/attr_/#vectorbt.utils.attr_.AttrResolver.resolve_self","text":"<pre><code>AttrResolver.resolve_self(\n    cond_kwargs=None,\n    custom_arg_names=None,\n    impacts_caching=True,\n    silence_warnings=False\n)\n</code></pre> <p>Resolve self.</p>  <p>Note</p> <p><code>cond_kwargs</code> can be modified in-place.</p>","title":"resolve_self method"},{"location":"api/utils/checks/","text":"<p>Utilities for validation during runtime.</p>","title":"checks"},{"location":"api/utils/checks/#vectorbt.utils.checks.assert_array_equal","text":"<pre><code>assert_array_equal(\n    arg1,\n    arg2\n)\n</code></pre> <p>Raise exception if the first argument and the second argument have different metadata or values.</p>","title":"assert_array_equal function"},{"location":"api/utils/checks/#vectorbt.utils.checks.assert_dict_sequence_valid","text":"<pre><code>assert_dict_sequence_valid(\n    arg,\n    lvl_keys\n)\n</code></pre> <p>Raise exception if a dict or any dict in a sequence of dicts has keys that are not in <code>lvl_keys</code>.</p>","title":"assert_dict_sequence_valid function"},{"location":"api/utils/checks/#vectorbt.utils.checks.assert_dict_valid","text":"<pre><code>assert_dict_valid(\n    arg,\n    lvl_keys\n)\n</code></pre> <p>Raise exception if dict the argument has keys that are not in <code>lvl_keys</code>.</p> <p><code>lvl_keys</code> should be a list of lists, each corresponding to a level in the dict.</p>","title":"assert_dict_valid function"},{"location":"api/utils/checks/#vectorbt.utils.checks.assert_dtype","text":"<pre><code>assert_dtype(\n    arg,\n    dtype\n)\n</code></pre> <p>Raise exception if the argument is not of data type <code>dtype</code>.</p>","title":"assert_dtype function"},{"location":"api/utils/checks/#vectorbt.utils.checks.assert_dtype_equal","text":"<pre><code>assert_dtype_equal(\n    arg1,\n    arg2\n)\n</code></pre> <p>Raise exception if the first argument and the second argument have different data types.</p>","title":"assert_dtype_equal function"},{"location":"api/utils/checks/#vectorbt.utils.checks.assert_equal","text":"<pre><code>assert_equal(\n    arg1,\n    arg2,\n    deep=False\n)\n</code></pre> <p>Raise exception if the first argument and the second argument are different.</p>","title":"assert_equal function"},{"location":"api/utils/checks/#vectorbt.utils.checks.assert_in","text":"<pre><code>assert_in(\n    arg1,\n    arg2\n)\n</code></pre> <p>Raise exception if the first argument is not in the second argument.</p>","title":"assert_in function"},{"location":"api/utils/checks/#vectorbt.utils.checks.assert_index_equal","text":"<pre><code>assert_index_equal(\n    arg1,\n    arg2,\n    **kwargs\n)\n</code></pre> <p>Raise exception if the first argument and the second argument have different index/columns.</p>","title":"assert_index_equal function"},{"location":"api/utils/checks/#vectorbt.utils.checks.assert_instance_of","text":"<pre><code>assert_instance_of(\n    arg,\n    types\n)\n</code></pre> <p>Raise exception if the argument is none of types <code>types</code>.</p>","title":"assert_instance_of function"},{"location":"api/utils/checks/#vectorbt.utils.checks.assert_iterable","text":"<pre><code>assert_iterable(\n    arg\n)\n</code></pre> <p>Raise exception if the argument is not an iterable.</p>","title":"assert_iterable function"},{"location":"api/utils/checks/#vectorbt.utils.checks.assert_len_equal","text":"<pre><code>assert_len_equal(\n    arg1,\n    arg2\n)\n</code></pre> <p>Raise exception if the first argument and the second argument have different length.</p> <p>Does not transform arguments to NumPy arrays.</p>","title":"assert_len_equal function"},{"location":"api/utils/checks/#vectorbt.utils.checks.assert_level_not_exists","text":"<pre><code>assert_level_not_exists(\n    arg,\n    level_name\n)\n</code></pre> <p>Raise exception if index the argument has level <code>level_name</code>.</p>","title":"assert_level_not_exists function"},{"location":"api/utils/checks/#vectorbt.utils.checks.assert_meta_equal","text":"<pre><code>assert_meta_equal(\n    arg1,\n    arg2\n)\n</code></pre> <p>Raise exception if the first argument and the second argument have different metadata.</p>","title":"assert_meta_equal function"},{"location":"api/utils/checks/#vectorbt.utils.checks.assert_ndim","text":"<pre><code>assert_ndim(\n    arg,\n    ndims\n)\n</code></pre> <p>Raise exception if the argument has a different number of dimensions than <code>ndims</code>.</p>","title":"assert_ndim function"},{"location":"api/utils/checks/#vectorbt.utils.checks.assert_not_none","text":"<pre><code>assert_not_none(\n    arg\n)\n</code></pre> <p>Raise exception if the argument is None.</p>","title":"assert_not_none function"},{"location":"api/utils/checks/#vectorbt.utils.checks.assert_numba_func","text":"<pre><code>assert_numba_func(\n    func\n)\n</code></pre> <p>Raise exception if <code>func</code> is not Numba-compiled.</p>","title":"assert_numba_func function"},{"location":"api/utils/checks/#vectorbt.utils.checks.assert_sequence","text":"<pre><code>assert_sequence(\n    arg\n)\n</code></pre> <p>Raise exception if the argument is not a sequence.</p>","title":"assert_sequence function"},{"location":"api/utils/checks/#vectorbt.utils.checks.assert_shape_equal","text":"<pre><code>assert_shape_equal(\n    arg1,\n    arg2,\n    axis=None\n)\n</code></pre> <p>Raise exception if the first argument and the second argument have different shapes along <code>axis</code>.</p>","title":"assert_shape_equal function"},{"location":"api/utils/checks/#vectorbt.utils.checks.assert_subclass_of","text":"<pre><code>assert_subclass_of(\n    arg,\n    classes\n)\n</code></pre> <p>Raise exception if the argument is not a subclass of classes <code>classes</code>.</p>","title":"assert_subclass_of function"},{"location":"api/utils/checks/#vectorbt.utils.checks.assert_subdtype","text":"<pre><code>assert_subdtype(\n    arg,\n    dtype\n)\n</code></pre> <p>Raise exception if the argument is not a sub data type of <code>dtype</code>.</p>","title":"assert_subdtype function"},{"location":"api/utils/checks/#vectorbt.utils.checks.assert_type_equal","text":"<pre><code>assert_type_equal(\n    arg1,\n    arg2\n)\n</code></pre> <p>Raise exception if the first argument and the second argument have different types.</p>","title":"assert_type_equal function"},{"location":"api/utils/checks/#vectorbt.utils.checks.iskeyword","text":"<pre><code>frozenset.__contains__(\n    ...\n)\n</code></pre> <p>x.contains(y) &lt;==&gt; y in x.</p>","title":"iskeyword function"},{"location":"api/utils/checks/#vectorbt.utils.checks.func_accepts_arg","text":"<pre><code>func_accepts_arg(\n    func,\n    arg_name,\n    arg_kind=None\n)\n</code></pre> <p>Check whether <code>func</code> accepts a positional or keyword argument with name <code>arg_name</code>.</p>","title":"func_accepts_arg function"},{"location":"api/utils/checks/#vectorbt.utils.checks.is_any_array","text":"<pre><code>is_any_array(\n    arg\n)\n</code></pre> <p>Check whether the argument is any of <code>np.ndarray</code>, <code>pd.Series</code> or <code>pd.DataFrame</code>.</p>","title":"is_any_array function"},{"location":"api/utils/checks/#vectorbt.utils.checks.is_deep_equal","text":"<pre><code>is_deep_equal(\n    arg1,\n    arg2,\n    check_exact=False,\n    **kwargs\n)\n</code></pre> <p>Check whether two objects are equal (deep check).</p>","title":"is_deep_equal function"},{"location":"api/utils/checks/#vectorbt.utils.checks.is_default_index","text":"<pre><code>is_default_index(\n    arg\n)\n</code></pre> <p>Check whether index is a basic range.</p>","title":"is_default_index function"},{"location":"api/utils/checks/#vectorbt.utils.checks.is_equal","text":"<pre><code>is_equal(\n    arg1,\n    arg2,\n    equality_func=&lt;function &lt;lambda&gt;&gt;\n)\n</code></pre> <p>Check whether two objects are equal.</p>","title":"is_equal function"},{"location":"api/utils/checks/#vectorbt.utils.checks.is_frame","text":"<pre><code>is_frame(\n    arg\n)\n</code></pre> <p>Check whether the argument is <code>pd.DataFrame</code>.</p>","title":"is_frame function"},{"location":"api/utils/checks/#vectorbt.utils.checks.is_hashable","text":"<pre><code>is_hashable(\n    arg\n)\n</code></pre> <p>Check whether the argument can be hashed.</p>","title":"is_hashable function"},{"location":"api/utils/checks/#vectorbt.utils.checks.is_index","text":"<pre><code>is_index(\n    arg\n)\n</code></pre> <p>Check whether the argument is <code>pd.Index</code>.</p>","title":"is_index function"},{"location":"api/utils/checks/#vectorbt.utils.checks.is_index_equal","text":"<pre><code>is_index_equal(\n    arg1,\n    arg2,\n    strict=True\n)\n</code></pre> <p>Check whether indexes are equal.</p> <p>Introduces naming tests on top of <code>pd.Index.equals</code>, but still doesn't check for types.</p>","title":"is_index_equal function"},{"location":"api/utils/checks/#vectorbt.utils.checks.is_instance_of","text":"<pre><code>is_instance_of(\n    arg,\n    types\n)\n</code></pre> <p>Check whether the argument is an instance of <code>types</code>.</p> <p><code>types</code> can be one or multiple types or strings.</p>","title":"is_instance_of function"},{"location":"api/utils/checks/#vectorbt.utils.checks.is_iterable","text":"<pre><code>is_iterable(\n    arg\n)\n</code></pre> <p>Check whether the argument is iterable.</p>","title":"is_iterable function"},{"location":"api/utils/checks/#vectorbt.utils.checks.is_mapping","text":"<pre><code>is_mapping(\n    arg\n)\n</code></pre> <p>Check whether the arguments is a mapping.</p>","title":"is_mapping function"},{"location":"api/utils/checks/#vectorbt.utils.checks.is_mapping_like","text":"<pre><code>is_mapping_like(\n    arg\n)\n</code></pre> <p>Check whether the arguments is a mapping-like object.</p>","title":"is_mapping_like function"},{"location":"api/utils/checks/#vectorbt.utils.checks.is_namedtuple","text":"<pre><code>is_namedtuple(\n    x\n)\n</code></pre> <p>Check whether object is an instance of namedtuple.</p>","title":"is_namedtuple function"},{"location":"api/utils/checks/#vectorbt.utils.checks.is_np_array","text":"<pre><code>is_np_array(\n    arg\n)\n</code></pre> <p>Check whether the argument is <code>np.ndarray</code>.</p>","title":"is_np_array function"},{"location":"api/utils/checks/#vectorbt.utils.checks.is_numba_func","text":"<pre><code>is_numba_func(\n    arg\n)\n</code></pre> <p>Check whether the argument is a Numba-compiled function.</p>","title":"is_numba_func function"},{"location":"api/utils/checks/#vectorbt.utils.checks.is_pandas","text":"<pre><code>is_pandas(\n    arg\n)\n</code></pre> <p>Check whether the argument is <code>pd.Series</code> or <code>pd.DataFrame</code>.</p>","title":"is_pandas function"},{"location":"api/utils/checks/#vectorbt.utils.checks.is_sequence","text":"<pre><code>is_sequence(\n    arg\n)\n</code></pre> <p>Check whether the argument is a sequence.</p>","title":"is_sequence function"},{"location":"api/utils/checks/#vectorbt.utils.checks.is_series","text":"<pre><code>is_series(\n    arg\n)\n</code></pre> <p>Check whether the argument is <code>pd.Series</code>.</p>","title":"is_series function"},{"location":"api/utils/checks/#vectorbt.utils.checks.is_subclass_of","text":"<pre><code>is_subclass_of(\n    arg,\n    types\n)\n</code></pre> <p>Check whether the argument is a subclass of <code>types</code>.</p> <p><code>types</code> can be one or multiple types or strings.</p>","title":"is_subclass_of function"},{"location":"api/utils/checks/#vectorbt.utils.checks.is_valid_variable_name","text":"<pre><code>is_valid_variable_name(\n    arg\n)\n</code></pre> <p>Check whether the argument is a valid variable name.</p>","title":"is_valid_variable_name function"},{"location":"api/utils/checks/#vectorbt.utils.checks.safe_assert","text":"<pre><code>safe_assert(\n    arg,\n    msg=None\n)\n</code></pre>","title":"safe_assert function"},{"location":"api/utils/colors/","text":"<p>Utilities for working with colors.</p>","title":"colors"},{"location":"api/utils/colors/#vectorbt.utils.colors.adjust_lightness","text":"<pre><code>adjust_lightness(\n    color,\n    amount=0.7\n)\n</code></pre> <p>Lightens the given color by multiplying (1-luminosity) by the given amount.</p> <p>Input can be matplotlib color string, hex string, or RGB tuple. Output will be an RGB string.</p>","title":"adjust_lightness function"},{"location":"api/utils/colors/#vectorbt.utils.colors.adjust_opacity","text":"<pre><code>adjust_opacity(\n    color,\n    opacity\n)\n</code></pre> <p>Adjust opacity of color.</p>","title":"adjust_opacity function"},{"location":"api/utils/colors/#vectorbt.utils.colors.rgb_from_cmap","text":"<pre><code>rgb_from_cmap(\n    cmap_name,\n    value,\n    value_range\n)\n</code></pre> <p>Map <code>value_range</code> to colormap with name <code>cmap_name</code> and get RGB of the <code>value</code> from that range.</p>","title":"rgb_from_cmap function"},{"location":"api/utils/config/","text":"<p>Utilities for configuration.</p>","title":"config"},{"location":"api/utils/config/#vectorbt.utils.config.convert_to_dict","text":"<pre><code>convert_to_dict(\n    dct,\n    nested=True\n)\n</code></pre> <p>Convert any dict (apart from atomic_dict) to <code>dict</code>.</p> <p>Set <code>nested</code> to True to convert all child dicts in recursive manner.</p>","title":"convert_to_dict function"},{"location":"api/utils/config/#vectorbt.utils.config.copy_dict","text":"<pre><code>copy_dict(\n    dct,\n    copy_mode='shallow',\n    nested=True\n)\n</code></pre> <p>Copy dict based on a copy mode.</p> <p>The following modes are supported:</p> <ul> <li>'shallow': Copies keys only.</li> <li>'hybrid': Copies keys and values using <code>copy.copy</code>.</li> <li>'deep': Copies the whole thing using <code>copy.deepcopy</code>.</li> </ul> <p>Set <code>nested</code> to True to copy all child dicts in recursive manner.</p>","title":"copy_dict function"},{"location":"api/utils/config/#vectorbt.utils.config.get_func_arg_names","text":"<pre><code>get_func_arg_names(\n    func,\n    arg_kind=None\n)\n</code></pre> <p>Get argument names of a function.</p>","title":"get_func_arg_names function"},{"location":"api/utils/config/#vectorbt.utils.config.get_func_kwargs","text":"<pre><code>get_func_kwargs(\n    func\n)\n</code></pre> <p>Get keyword arguments with defaults of a function.</p>","title":"get_func_kwargs function"},{"location":"api/utils/config/#vectorbt.utils.config.merge_dicts","text":"<pre><code>merge_dicts(\n    *dicts,\n    to_dict=True,\n    copy_mode='shallow',\n    nested=True,\n    same_keys=False\n)\n</code></pre> <p>Merge dicts.</p> <p>Args</p>  <code>*dicts</code> :\u2002<code>dict</code> Dicts. <code>to_dict</code> :\u2002<code>bool</code> Whether to call convert_to_dict() on each dict prior to copying. <code>copy_mode</code> :\u2002<code>str</code>  <p>Mode for copy_dict() to copy each dict prior to merging.</p> <p>Pass None to not copy.</p>  <code>nested</code> :\u2002<code>bool</code> Whether to merge all child dicts in recursive manner. <code>same_keys</code> :\u2002<code>bool</code> Whether to merge on the overlapping keys only.","title":"merge_dicts function"},{"location":"api/utils/config/#vectorbt.utils.config.resolve_dict","text":"<pre><code>resolve_dict(\n    dct,\n    i=None\n)\n</code></pre> <p>Select keyword arguments.</p>","title":"resolve_dict function"},{"location":"api/utils/config/#vectorbt.utils.config.set_dict_item","text":"<pre><code>set_dict_item(\n    dct,\n    k,\n    v,\n    force=False\n)\n</code></pre> <p>Set dict item.</p> <p>If the dict is of the type Config, also passes <code>force</code> keyword to override blocking flags.</p>","title":"set_dict_item function"},{"location":"api/utils/config/#vectorbt.utils.config.update_dict","text":"<pre><code>update_dict(\n    x,\n    y,\n    nested=True,\n    force=False,\n    same_keys=False\n)\n</code></pre> <p>Update dict with keys and values from other dict.</p> <p>Set <code>nested</code> to True to update all child dicts in recursive manner. For <code>force</code>, see set_dict_item().</p> <p>If you want to treat any dict as a single value, wrap it with atomic_dict.</p>  <p>Note</p> <p>If the child dict is not atomic, it will copy only its values, not its meta.</p>","title":"update_dict function"},{"location":"api/utils/config/#vectorbt.utils.config.AtomicConfig","text":"<pre><code>AtomicConfig(\n    dct=None,\n    copy_kwargs=None,\n    reset_dct=None,\n    reset_dct_copy_kwargs=None,\n    frozen_keys=None,\n    readonly=None,\n    nested=None,\n    convert_dicts=None,\n    as_attrs=None\n)\n</code></pre> <p>Config that behaves like a single value when merging.</p> <p>Superclasses</p> <ul> <li>Config</li> <li>Documented</li> <li>Pickleable</li> <li>PickleableDict</li> <li>atomic_dict</li> <li><code>builtins.dict</code></li> </ul> <p>Inherited members</p> <ul> <li>Config.as_attrs_</li> <li>Config.clear()</li> <li>Config.convert_dicts_</li> <li>Config.copy()</li> <li>Config.copy_kwargs_</li> <li>Config.dumps()</li> <li>Config.frozen_keys_</li> <li>Config.load_update()</li> <li>Config.loads()</li> <li>Config.make_checkpoint()</li> <li>Config.merge_with()</li> <li>Config.nested_</li> <li>Config.pop()</li> <li>Config.popitem()</li> <li>Config.readonly_</li> <li>Config.reset()</li> <li>Config.reset_dct_</li> <li>Config.reset_dct_copy_kwargs_</li> <li>Config.to_dict()</li> <li>Config.to_doc()</li> <li>Config.update()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> </ul>","title":"AtomicConfig class"},{"location":"api/utils/config/#vectorbt.utils.config.Config","text":"<pre><code>Config(\n    dct=None,\n    copy_kwargs=None,\n    reset_dct=None,\n    reset_dct_copy_kwargs=None,\n    frozen_keys=None,\n    readonly=None,\n    nested=None,\n    convert_dicts=None,\n    as_attrs=None\n)\n</code></pre> <p>Extends dict with config features such as nested updates, frozen keys/values, and pickling.</p> <p>Args</p>  <code>dct</code> :\u2002<code>dict</code> Dict to construct this config from. <code>copy_kwargs</code> :\u2002<code>dict</code>  <p>Keyword arguments passed to copy_dict() for copying <code>dct</code> and <code>reset_dct</code>.</p> <p>Copy mode defaults to 'shallow' if <code>readonly</code>, otherwise to 'hybrid'.</p>  <code>reset_dct</code> :\u2002<code>dict</code>  <p>Dict to fall back to in case of resetting.</p> <p>If None, copies <code>dct</code> using <code>reset_dct_copy_kwargs</code>.</p>  <code>reset_dct_copy_kwargs</code> :\u2002<code>dict</code> Keyword arguments that override <code>copy_kwargs</code> for <code>reset_dct</code>. <code>frozen_keys</code> :\u2002<code>bool</code>  <p>Whether to deny updates to the keys of the config.</p> <p>Defaults to False.</p>  <code>readonly</code> :\u2002<code>bool</code>  <p>Whether to deny updates to the keys and values of the config.</p> <p>Defaults to False.</p>  <code>nested</code> :\u2002<code>bool</code>  <p>Whether to do operations recursively on each child dict.</p> <p>Such operations include copy, update, and merge. Disable to treat each child dict as a single value. Defaults to True.</p>  <code>convert_dicts</code> :\u2002<code>bool</code> or <code>type</code>  <p>Whether to convert child dicts to configs with the same configuration.</p> <p>This will trigger a waterfall reaction across all child dicts. Won't convert dicts that are already configs. Apart from boolean, you can set it to any subclass of Config to use it for construction. Requires <code>nested</code> to be True. Defaults to False.</p>  <code>as_attrs</code> :\u2002<code>bool</code>  <p>Whether to enable accessing dict keys via the dot notation.</p> <p>Enables autocompletion (but only during runtime!). Raises error in case of naming conflicts. Defaults to True if <code>frozen</code> or <code>readonly</code>, otherwise False.</p>   <p>Defaults can be overridden with settings under <code>config</code> in settings.</p> <p>If another config is passed, its properties are copied over, but they can still be overridden with the arguments passed to the initializer.</p>  <p>Note</p> <p>All arguments are applied only once during initialization.</p>  <p>Superclasses</p> <ul> <li>Documented</li> <li>Pickleable</li> <li>PickleableDict</li> <li><code>builtins.dict</code></li> </ul> <p>Inherited members</p> <ul> <li>Documented.to_doc()</li> <li>Pickleable.load()</li> <li>Pickleable.save()</li> <li>PickleableDict.dumps()</li> <li>PickleableDict.loads()</li> </ul> <p>Subclasses</p> <ul> <li>AtomicConfig</li> <li>SettingsConfig</li> </ul>","title":"Config class"},{"location":"api/utils/config/#vectorbt.utils.config.Config.as_attrs_","text":"<p>Whether to enable accessing dict keys via dot notation.</p>","title":"as_attrs_ property"},{"location":"api/utils/config/#vectorbt.utils.config.Config.convert_dicts_","text":"<p>Whether to convert child dicts to configs with the same configuration.</p>","title":"convert_dicts_ property"},{"location":"api/utils/config/#vectorbt.utils.config.Config.copy_kwargs_","text":"<p>Parameters for copying <code>dct</code>.</p>","title":"copy_kwargs_ property"},{"location":"api/utils/config/#vectorbt.utils.config.Config.frozen_keys_","text":"<p>Whether to deny updates to the keys and values of the config.</p>","title":"frozen_keys_ property"},{"location":"api/utils/config/#vectorbt.utils.config.Config.nested_","text":"<p>Whether to do operations recursively on each child dict.</p>","title":"nested_ property"},{"location":"api/utils/config/#vectorbt.utils.config.Config.readonly_","text":"<p>Whether to deny any updates to the config.</p>","title":"readonly_ property"},{"location":"api/utils/config/#vectorbt.utils.config.Config.reset_dct_","text":"<p>Dict to fall back to in case of resetting.</p>","title":"reset_dct_ property"},{"location":"api/utils/config/#vectorbt.utils.config.Config.reset_dct_copy_kwargs_","text":"<p>Parameters for copying <code>reset_dct</code>.</p>","title":"reset_dct_copy_kwargs_ property"},{"location":"api/utils/config/#vectorbt.utils.config.Config.clear","text":"<pre><code>Config.clear(\n    force=False\n)\n</code></pre> <p>Remove all items.</p>","title":"clear method"},{"location":"api/utils/config/#vectorbt.utils.config.Config.copy","text":"<pre><code>Config.copy(\n    reset_dct_copy_kwargs=None,\n    **copy_kwargs\n)\n</code></pre> <p>Copy the instance in the same way it's done during initialization.</p> <p><code>copy_kwargs</code> override Config.copy_kwargs_ and Config.reset_dct_copy_kwargs_ via merging. <code>reset_dct_copy_kwargs</code> override merged Config.reset_dct_copy_kwargs_.</p>","title":"copy method"},{"location":"api/utils/config/#vectorbt.utils.config.Config.load_update","text":"<pre><code>Config.load_update(\n    fname,\n    **kwargs\n)\n</code></pre> <p>Load dumps from a file and update this instance.</p>  <p>Note</p> <p>Updates both the config properties and dictionary.</p>","title":"load_update method"},{"location":"api/utils/config/#vectorbt.utils.config.Config.make_checkpoint","text":"<pre><code>Config.make_checkpoint(\n    force=False,\n    **reset_dct_copy_kwargs\n)\n</code></pre> <p>Replace <code>reset_dct</code> by the current state.</p> <p><code>reset_dct_copy_kwargs</code> override Config.reset_dct_copy_kwargs_.</p>","title":"make_checkpoint method"},{"location":"api/utils/config/#vectorbt.utils.config.Config.merge_with","text":"<pre><code>Config.merge_with(\n    other,\n    nested=None,\n    **kwargs\n)\n</code></pre> <p>Merge with another dict into one single dict.</p> <p>See merge_dicts().</p>","title":"merge_with method"},{"location":"api/utils/config/#vectorbt.utils.config.Config.pop","text":"<pre><code>Config.pop(\n    k,\n    v=&lt;object object&gt;,\n    force=False\n)\n</code></pre> <p>Remove and return the pair by the key.</p>","title":"pop method"},{"location":"api/utils/config/#vectorbt.utils.config.Config.popitem","text":"<pre><code>Config.popitem(\n    force=False\n)\n</code></pre> <p>Remove and return some pair.</p>","title":"popitem method"},{"location":"api/utils/config/#vectorbt.utils.config.Config.reset","text":"<pre><code>Config.reset(\n    force=False,\n    **reset_dct_copy_kwargs\n)\n</code></pre> <p>Clears the config and updates it with the initial config.</p> <p><code>reset_dct_copy_kwargs</code> override Config.reset_dct_copy_kwargs_.</p>","title":"reset method"},{"location":"api/utils/config/#vectorbt.utils.config.Config.to_dict","text":"<pre><code>Config.to_dict(\n    nested=None\n)\n</code></pre> <p>Convert to dict.</p>","title":"to_dict method"},{"location":"api/utils/config/#vectorbt.utils.config.Config.update","text":"<pre><code>Config.update(\n    *args,\n    nested=None,\n    force=False,\n    **kwargs\n)\n</code></pre> <p>Update the config.</p> <p>See update_dict().</p>","title":"update method"},{"location":"api/utils/config/#vectorbt.utils.config.Configured","text":"<pre><code>Configured(\n    **config\n)\n</code></pre> <p>Class with an initialization config.</p> <p>All subclasses of Configured are initialized using Config, which makes it easier to pickle.</p> <p>Settings are defined under <code>configured</code> in settings.</p>  <p>Warning</p> <p>If any attribute has been overwritten that isn't listed in Configured.writeable_attrs, or if any Configured argument depends upon global defaults, their values won't be copied over. Make sure to pass them explicitly to make the saved &amp; loaded / copied instance resilient to changes in globals.</p>  <p>Superclasses</p> <ul> <li>Documented</li> <li>Pickleable</li> </ul> <p>Inherited members</p> <ul> <li>Documented.to_doc()</li> <li>Pickleable.dumps()</li> <li>Pickleable.load()</li> <li>Pickleable.loads()</li> <li>Pickleable.save()</li> </ul> <p>Subclasses</p> <ul> <li>ArrayWrapper</li> <li>Bar</li> <li>Box</li> <li>ColumnGrouper</li> <li>DataUpdater</li> <li>Gauge</li> <li>Heatmap</li> <li>Histogram</li> <li>QSAdapter</li> <li>Scatter</li> <li>TelegramBot</li> <li>Volume</li> <li>Wrapping</li> </ul>","title":"Configured class"},{"location":"api/utils/config/#vectorbt.utils.config.Configured.config","text":"<p>Initialization config.</p>","title":"config property"},{"location":"api/utils/config/#vectorbt.utils.config.Configured.writeable_attrs","text":"<p>Set of writeable attributes that will be saved/copied along with the config.</p>","title":"writeable_attrs property"},{"location":"api/utils/config/#vectorbt.utils.config.Configured.copy","text":"<pre><code>Configured.copy(\n    copy_mode='shallow',\n    nested=None,\n    cls=None\n)\n</code></pre> <p>Create a new instance by copying the config.</p> <p>See Configured.replace().</p>","title":"copy method"},{"location":"api/utils/config/#vectorbt.utils.config.Configured.replace","text":"<pre><code>Configured.replace(\n    copy_mode_='shallow',\n    nested_=None,\n    cls_=None,\n    **new_config\n)\n</code></pre> <p>Create a new instance by copying and (optionally) changing the config.</p>  <p>Warning</p> <p>This operation won't return a copy of the instance but a new instance initialized with the same config and writeable attributes (or their copy, depending on <code>copy_mode</code>).</p>","title":"replace method"},{"location":"api/utils/config/#vectorbt.utils.config.Configured.update_config","text":"<pre><code>Configured.update_config(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Force-update the config.</p>","title":"update_config method"},{"location":"api/utils/config/#vectorbt.utils.config.Default","text":"<pre><code>Default(\n    value\n)\n</code></pre> <p>Class for wrapping default values.</p>","title":"Default class"},{"location":"api/utils/config/#vectorbt.utils.config.DumpTuple","text":"<pre><code>DumpTuple(\n    cls,\n    dumps\n)\n</code></pre> <p>DumpTuple(cls, dumps)</p> <p>Superclasses</p> <ul> <li><code>builtins.tuple</code></li> </ul>","title":"DumpTuple class"},{"location":"api/utils/config/#vectorbt.utils.config.DumpTuple.cls","text":"<p>Alias for field number 0</p>","title":"cls property"},{"location":"api/utils/config/#vectorbt.utils.config.DumpTuple.dumps","text":"<p>Alias for field number 1</p>","title":"dumps property"},{"location":"api/utils/config/#vectorbt.utils.config.Pickleable","text":"<pre><code>Pickleable()\n</code></pre> <p>Superclass that defines abstract properties and methods for pickle-able classes.</p> <p>Subclasses</p> <ul> <li>Configured</li> <li>PickleableDict</li> </ul>","title":"Pickleable class"},{"location":"api/utils/config/#vectorbt.utils.config.Pickleable.load","text":"<pre><code>Pickleable.load(\n    fname,\n    **kwargs\n)\n</code></pre> <p>Load dumps from a file and create new instance.</p>","title":"load class method"},{"location":"api/utils/config/#vectorbt.utils.config.Pickleable.loads","text":"<pre><code>Pickleable.loads(\n    dumps,\n    **kwargs\n)\n</code></pre> <p>Unpickle from bytes.</p>","title":"loads class method"},{"location":"api/utils/config/#vectorbt.utils.config.Pickleable.dumps","text":"<pre><code>Pickleable.dumps(\n    **kwargs\n)\n</code></pre> <p>Pickle to bytes.</p>","title":"dumps method"},{"location":"api/utils/config/#vectorbt.utils.config.Pickleable.save","text":"<pre><code>Pickleable.save(\n    fname,\n    **kwargs\n)\n</code></pre> <p>Save dumps to a file.</p>","title":"save method"},{"location":"api/utils/config/#vectorbt.utils.config.PickleableDict","text":"<pre><code>PickleableDict(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Dict that may contain values of type Pickleable.</p> <p>Superclasses</p> <ul> <li>Pickleable</li> <li><code>builtins.dict</code></li> </ul> <p>Inherited members</p> <ul> <li>Pickleable.dumps()</li> <li>Pickleable.load()</li> <li>Pickleable.loads()</li> <li>Pickleable.save()</li> </ul> <p>Subclasses</p> <ul> <li>Config</li> </ul>","title":"PickleableDict class"},{"location":"api/utils/config/#vectorbt.utils.config.PickleableDict.load_update","text":"<pre><code>PickleableDict.load_update(\n    fname,\n    **kwargs\n)\n</code></pre> <p>Load dumps from a file and update this instance.</p>","title":"load_update method"},{"location":"api/utils/config/#vectorbt.utils.config.atomic_dict","text":"<pre><code>atomic_dict(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Dict that behaves like a single value when merging.</p> <p>Superclasses</p> <ul> <li><code>builtins.dict</code></li> </ul> <p>Subclasses</p> <ul> <li>AtomicConfig</li> </ul>","title":"atomic_dict class"},{"location":"api/utils/datetime_/","text":"<p>Utilities for working with dates and time.</p>","title":"datetime_"},{"location":"api/utils/datetime_/#vectorbt.utils.datetime_.convert_naive_time","text":"<pre><code>convert_naive_time(\n    t,\n    tz_out\n)\n</code></pre> <p>Return as naive time.</p> <p><code>datetime.time</code> should not have <code>tzinfo</code> set.</p>","title":"convert_naive_time function"},{"location":"api/utils/datetime_/#vectorbt.utils.datetime_.convert_tzaware_time","text":"<pre><code>convert_tzaware_time(\n    t,\n    tz_out\n)\n</code></pre> <p>Return as non-naive time.</p> <p><code>datetime.time</code> should have <code>tzinfo</code> set.</p>","title":"convert_tzaware_time function"},{"location":"api/utils/datetime_/#vectorbt.utils.datetime_.datetime_to_ms","text":"<pre><code>datetime_to_ms(\n    dt\n)\n</code></pre> <p>Convert a datetime to milliseconds.</p>","title":"datetime_to_ms function"},{"location":"api/utils/datetime_/#vectorbt.utils.datetime_.freq_to_timedelta","text":"<pre><code>freq_to_timedelta(\n    arg\n)\n</code></pre> <p><code>pd.to_timedelta</code> that uses unit abbreviation with number.</p>","title":"freq_to_timedelta function"},{"location":"api/utils/datetime_/#vectorbt.utils.datetime_.get_local_tz","text":"<pre><code>get_local_tz()\n</code></pre> <p>Get local timezone.</p>","title":"get_local_tz function"},{"location":"api/utils/datetime_/#vectorbt.utils.datetime_.get_utc_tz","text":"<pre><code>get_utc_tz()\n</code></pre> <p>Get UTC timezone.</p>","title":"get_utc_tz function"},{"location":"api/utils/datetime_/#vectorbt.utils.datetime_.interval_to_ms","text":"<pre><code>interval_to_ms(\n    interval\n)\n</code></pre> <p>Convert an interval string to milliseconds.</p>","title":"interval_to_ms function"},{"location":"api/utils/datetime_/#vectorbt.utils.datetime_.is_tz_aware","text":"<pre><code>is_tz_aware(\n    dt\n)\n</code></pre> <p>Whether datetime is timezone-aware.</p>","title":"is_tz_aware function"},{"location":"api/utils/datetime_/#vectorbt.utils.datetime_.naive_to_tzaware_time","text":"<pre><code>naive_to_tzaware_time(\n    t,\n    tz_out\n)\n</code></pre> <p>Return as non-naive time.</p> <p><code>datetime.time</code> should not have <code>tzinfo</code> set.</p>","title":"naive_to_tzaware_time function"},{"location":"api/utils/datetime_/#vectorbt.utils.datetime_.to_timezone","text":"<pre><code>to_timezone(\n    tz,\n    to_py_timezone=None,\n    **kwargs\n)\n</code></pre> <p>Parse the timezone.</p> <p>Strings are parsed by <code>pytz</code> and <code>dateparser</code>, while integers and floats are treated as hour offsets.</p> <p>If the timezone object can't be checked for equality based on its properties, it's automatically converted to <code>datetime.timezone</code>.</p> <p>If <code>to_py_timezone</code> is set to True, will convert to <code>datetime.timezone</code>.</p> <p><code>**kwargs</code> are passed to <code>dateparser.parse</code>.</p>","title":"to_timezone function"},{"location":"api/utils/datetime_/#vectorbt.utils.datetime_.to_tzaware_datetime","text":"<pre><code>to_tzaware_datetime(\n    dt_like,\n    naive_tz=None,\n    tz=None,\n    **kwargs\n)\n</code></pre> <p>Parse the datetime as a timezone-aware <code>datetime.datetime</code>.</p> <p>See dateparser docs for valid string formats and <code>**kwargs</code>.</p> <p>Raw timestamps are localized to UTC, while naive datetime is localized to <code>naive_tz</code>. Set <code>naive_tz</code> to None to use the default value defined under <code>datetime</code> settings in settings. To explicitly convert the datetime to a timezone, use <code>tz</code> (uses to_timezone()).</p>","title":"to_tzaware_datetime function"},{"location":"api/utils/datetime_/#vectorbt.utils.datetime_.tzaware_to_naive_time","text":"<pre><code>tzaware_to_naive_time(\n    t,\n    tz_out\n)\n</code></pre> <p>Return as naive time.</p> <p><code>datetime.time</code> should have <code>tzinfo</code> set.</p>","title":"tzaware_to_naive_time function"},{"location":"api/utils/decorators/","text":"<p>Class and function decorators.</p>","title":"decorators"},{"location":"api/utils/decorators/#vectorbt.utils.decorators.binary_magic_config","text":"<p>Config of binary magic methods to be added to a class.</p> <pre><code>Config({\n    \"__eq__\": {\n        \"func\": \"&lt;ufunc 'equal'&gt;\"\n    },\n    \"__ne__\": {\n        \"func\": \"&lt;ufunc 'not_equal'&gt;\"\n    },\n    \"__lt__\": {\n        \"func\": \"&lt;ufunc 'less'&gt;\"\n    },\n    \"__gt__\": {\n        \"func\": \"&lt;ufunc 'greater'&gt;\"\n    },\n    \"__le__\": {\n        \"func\": \"&lt;ufunc 'less_equal'&gt;\"\n    },\n    \"__ge__\": {\n        \"func\": \"&lt;ufunc 'greater_equal'&gt;\"\n    },\n    \"__add__\": {\n        \"func\": \"&lt;ufunc 'add'&gt;\"\n    },\n    \"__sub__\": {\n        \"func\": \"&lt;ufunc 'subtract'&gt;\"\n    },\n    \"__mul__\": {\n        \"func\": \"&lt;ufunc 'multiply'&gt;\"\n    },\n    \"__pow__\": {\n        \"func\": \"&lt;ufunc 'power'&gt;\"\n    },\n    \"__mod__\": {\n        \"func\": \"&lt;ufunc 'remainder'&gt;\"\n    },\n    \"__floordiv__\": {\n        \"func\": \"&lt;ufunc 'floor_divide'&gt;\"\n    },\n    \"__truediv__\": {\n        \"func\": \"&lt;ufunc 'true_divide'&gt;\"\n    },\n    \"__radd__\": {\n        \"func\": \"&lt;function &lt;lambda&gt; at 0x7ff53301ab70&gt;\"\n    },\n    \"__rsub__\": {\n        \"func\": \"&lt;function &lt;lambda&gt; at 0x7ff53301abf8&gt;\"\n    },\n    \"__rmul__\": {\n        \"func\": \"&lt;function &lt;lambda&gt; at 0x7ff53301ac80&gt;\"\n    },\n    \"__rpow__\": {\n        \"func\": \"&lt;function &lt;lambda&gt; at 0x7ff53301ad08&gt;\"\n    },\n    \"__rmod__\": {\n        \"func\": \"&lt;function &lt;lambda&gt; at 0x7ff53301ad90&gt;\"\n    },\n    \"__rfloordiv__\": {\n        \"func\": \"&lt;function &lt;lambda&gt; at 0x7ff53301ae18&gt;\"\n    },\n    \"__rtruediv__\": {\n        \"func\": \"&lt;function &lt;lambda&gt; at 0x7ff53301aea0&gt;\"\n    },\n    \"__and__\": {\n        \"func\": \"&lt;ufunc 'bitwise_and'&gt;\"\n    },\n    \"__or__\": {\n        \"func\": \"&lt;ufunc 'bitwise_or'&gt;\"\n    },\n    \"__xor__\": {\n        \"func\": \"&lt;ufunc 'bitwise_xor'&gt;\"\n    },\n    \"__rand__\": {\n        \"func\": \"&lt;function &lt;lambda&gt; at 0x7ff53301af28&gt;\"\n    },\n    \"__ror__\": {\n        \"func\": \"&lt;function &lt;lambda&gt; at 0x7ff53301f048&gt;\"\n    },\n    \"__rxor__\": {\n        \"func\": \"&lt;function &lt;lambda&gt; at 0x7ff53301f0d0&gt;\"\n    }\n})\n</code></pre>","title":"binary_magic_config variable"},{"location":"api/utils/decorators/#vectorbt.utils.decorators.unary_magic_config","text":"<p>Config of unary magic methods to be added to a class.</p> <pre><code>Config({\n    \"__neg__\": {\n        \"func\": \"&lt;ufunc 'negative'&gt;\"\n    },\n    \"__pos__\": {\n        \"func\": \"&lt;ufunc 'positive'&gt;\"\n    },\n    \"__abs__\": {\n        \"func\": \"&lt;ufunc 'absolute'&gt;\"\n    },\n    \"__invert__\": {\n        \"func\": \"&lt;ufunc 'invert'&gt;\"\n    }\n})\n</code></pre>","title":"unary_magic_config variable"},{"location":"api/utils/decorators/#vectorbt.utils.decorators.attach_binary_magic_methods","text":"<pre><code>attach_binary_magic_methods(\n    translate_func,\n    config=None\n)\n</code></pre> <p>Class decorator to add binary magic methods to a class.</p> <p><code>translate_func</code> should</p> <ul> <li>take <code>self</code>, <code>other</code>, and unary function,</li> <li>perform computation, and</li> <li>return the result.</li> </ul> <p><code>config</code> defaults to binary_magic_config and should contain target method names (keys) and dictionaries (values) with the following keys:</p> <ul> <li><code>func</code>: Function that combines two array-like objects.</li> </ul>","title":"attach_binary_magic_methods function"},{"location":"api/utils/decorators/#vectorbt.utils.decorators.attach_unary_magic_methods","text":"<pre><code>attach_unary_magic_methods(\n    translate_func,\n    config=None\n)\n</code></pre> <p>Class decorator to add unary magic methods to a class.</p> <p><code>translate_func</code> should</p> <ul> <li>take <code>self</code> and unary function,</li> <li>perform computation, and</li> <li>return the result.</li> </ul> <p><code>config</code> defaults to unary_magic_config and should contain target method names (keys) and dictionaries (values) with the following keys:</p> <ul> <li><code>func</code>: Function that transforms one array-like object.</li> </ul>","title":"attach_unary_magic_methods function"},{"location":"api/utils/decorators/#vectorbt.utils.decorators.cached_method","text":"<pre><code>cached_method(\n    *args,\n    maxsize=128,\n    typed=False,\n    **flags\n)\n</code></pre> <p>Extends custom_method() with caching.</p> <p>Internally uses <code>functools.lru_cache</code>.</p> <p>Disables caching if should_cache() yields False or a non-hashable object as argument has been passed.</p> <p>See notes on cached_property.</p>","title":"cached_method function"},{"location":"api/utils/decorators/#vectorbt.utils.decorators.custom_method","text":"<pre><code>custom_method(\n    *args,\n    **flags\n)\n</code></pre> <p>Custom extensible method that stores function and flags as attributes.</p> <p>Can be called both as <pre><code>&gt;&gt;&gt; @cached_method\n... def user_function(): pass\n</code></pre> and <pre><code>&gt;&gt;&gt; @cached_method(maxsize=128, typed=False, a=0, b=0)  # flags\n... def user_function(): pass\n</code></pre></p>","title":"custom_method function"},{"location":"api/utils/decorators/#vectorbt.utils.decorators.should_cache","text":"<pre><code>should_cache(\n    func_name,\n    instance,\n    func=None,\n    **flags\n)\n</code></pre> <p>Check whether to cache the method/property based on a range of conditions defined under <code>caching</code> in settings.</p> <p>Each condition has its own rank. A narrower condition has a lower (better) rank than a broader condition. All supplied keys are checked, and if any condition fails, it's assigned to the highest (worst) rank.</p> <p>Here's the condition ranking:</p> <p>0) <code>instance</code> and <code>func</code> 1) <code>instance</code> and <code>flags</code> 2) <code>instance</code> 3) <code>cls</code> and <code>func</code> 4) <code>cls</code> and <code>flags</code> 5) <code>cls</code> 6) <code>base_cls</code> and <code>func</code> 7) <code>base_cls</code> and <code>flags</code> 8) <code>base_cls</code> 9) <code>func</code> and <code>flags</code> 10) <code>func</code> 11) <code>flags</code></p> <p>This function goes through all conditions of type CacheCondition in <code>whitelist</code> and <code>blacklist</code> and finds the one with the lowest (best) rank. If the search yields the same rank for both lists, global caching flag <code>enabled</code> decides.</p> <p>Usage</p> <ul> <li>Let's evaluate various caching conditions:</li> </ul> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; class A:\n...     @cached_property(my_flag=True)\n...     def f(self):\n...         return None\n\n&gt;&gt;&gt; class B(A):\n...     @cached_property(my_flag=False)\n...     def f(self):\n...         return None\n\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; b = B()\n\n&gt;&gt;&gt; vbt.CacheCondition(instance=a, func='f')  # A.f\n&gt;&gt;&gt; vbt.CacheCondition(instance=b, func='f')  # B.f\n&gt;&gt;&gt; vbt.CacheCondition(instance=a, flags=dict(my_flag=True))  # A.f\n&gt;&gt;&gt; vbt.CacheCondition(instance=a, flags=dict(my_flag=False))  # none\n&gt;&gt;&gt; vbt.CacheCondition(instance=b, flags=dict(my_flag=False))  # B.f\n&gt;&gt;&gt; vbt.CacheCondition(instance=a)  # A.f\n&gt;&gt;&gt; vbt.CacheCondition(instance=b)  # B.f\n&gt;&gt;&gt; vbt.CacheCondition(cls=A)  # A.f\n&gt;&gt;&gt; vbt.CacheCondition(cls=B)  # B.f\n&gt;&gt;&gt; vbt.CacheCondition(base_cls=A)  # A.f and B.f\n&gt;&gt;&gt; vbt.CacheCondition(base_cls=B)  # B.f\n&gt;&gt;&gt; vbt.CacheCondition(base_cls=A, flags=dict(my_flag=False))  # B.f\n&gt;&gt;&gt; vbt.CacheCondition(func=A.f)  # A.f\n&gt;&gt;&gt; vbt.CacheCondition(func=B.f)  # B.f\n&gt;&gt;&gt; vbt.CacheCondition(func='f')  # A.f and B.f\n&gt;&gt;&gt; vbt.CacheCondition(func='f', flags=dict(my_flag=False))  # B.f\n&gt;&gt;&gt; vbt.CacheCondition(flags=dict(my_flag=True))  # A.f\n</code></pre>","title":"should_cache function"},{"location":"api/utils/decorators/#vectorbt.utils.decorators.CacheCondition","text":"<pre><code>CacheCondition(\n    instance=None,\n    func=None,\n    cls=None,\n    base_cls=None,\n    flags=None,\n    rank=None\n)\n</code></pre> <p>Caching condition for the use in should_cache().</p> <p>Superclasses</p> <ul> <li><code>builtins.tuple</code></li> </ul>","title":"CacheCondition class"},{"location":"api/utils/decorators/#vectorbt.utils.decorators.CacheCondition.base_cls","text":"<p>Base class of the class or its name (case-sensitive).</p>","title":"base_cls property"},{"location":"api/utils/decorators/#vectorbt.utils.decorators.CacheCondition.cls","text":"<p>Class of the instance or its name (case-sensitive).</p>","title":"cls property"},{"location":"api/utils/decorators/#vectorbt.utils.decorators.CacheCondition.flags","text":"<p>Flags to check for in method/property's flags.</p>","title":"flags property"},{"location":"api/utils/decorators/#vectorbt.utils.decorators.CacheCondition.func","text":"<p>Method/property or its name (case-sensitive).</p>","title":"func property"},{"location":"api/utils/decorators/#vectorbt.utils.decorators.CacheCondition.instance","text":"<p>Class instance the method/property is bound to.</p>","title":"instance property"},{"location":"api/utils/decorators/#vectorbt.utils.decorators.CacheCondition.rank","text":"<p>Rank to override the default rank.</p>","title":"rank property"},{"location":"api/utils/decorators/#vectorbt.utils.decorators.cached_methodT","text":"<pre><code>cached_methodT(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Base class for protocol classes. Protocol classes are defined as::</p> <pre><code>class Proto(Protocol):\n    def meth(self) -&gt; int:\n        ...\n</code></pre> <p>Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example::</p> <p>    class C</p> <pre><code>def meth(self) -&gt; int:\n    return 0\n</code></pre> <p>def func(x: Proto) -&gt; int:     return x.meth()</p> <p>func(C())  # Passes static type check</p> <p>See PEP 544 for details. Protocol classes decorated with @typing_extensions.runtime act as simple-minded runtime protocol that checks only the presence of given attributes, ignoring their type signatures.</p> <p>Protocol classes can be generic, they are defined as::</p> <pre><code>class GenProto(Protocol[T]):\n    def meth(self) -&gt; T:\n        ...\n</code></pre> <p>Superclasses</p> <ul> <li>custom_methodT</li> <li><code>typing_extensions.Protocol</code></li> </ul>","title":"cached_methodT class"},{"location":"api/utils/decorators/#vectorbt.utils.decorators.cached_methodT.attrname","text":"","title":"attrname class variable"},{"location":"api/utils/decorators/#vectorbt.utils.decorators.cached_methodT.clear_cache","text":"","title":"clear_cache class variable"},{"location":"api/utils/decorators/#vectorbt.utils.decorators.cached_methodT.lock","text":"","title":"lock class variable"},{"location":"api/utils/decorators/#vectorbt.utils.decorators.cached_methodT.maxsize","text":"","title":"maxsize class variable"},{"location":"api/utils/decorators/#vectorbt.utils.decorators.cached_methodT.name","text":"","title":"name class variable"},{"location":"api/utils/decorators/#vectorbt.utils.decorators.cached_methodT.typed","text":"","title":"typed class variable"},{"location":"api/utils/decorators/#vectorbt.utils.decorators.cached_property","text":"<pre><code>cached_property(\n    func,\n    **flags\n)\n</code></pre> <p>Extends custom_property with caching.</p> <p>Similar to <code>functools.cached_property</code>, but without replacing the original attribute to be able to re-compute whenever needed.</p> <p>Disables caching if should_cache() yields False.</p> <p>Cache can be cleared by calling <code>clear_cache</code> with instance as argument.</p> <p>!!! note:     Assumes that the instance (provided as <code>self</code>) won't change. If calculation depends     upon object attributes that can be changed, it won't notice the change.</p> <p>Superclasses</p> <ul> <li>custom_property</li> </ul>","title":"cached_property class"},{"location":"api/utils/decorators/#vectorbt.utils.decorators.cached_property.attrname","text":"<p>Get name of cached attribute.</p>","title":"attrname property"},{"location":"api/utils/decorators/#vectorbt.utils.decorators.cached_property.clear_cache","text":"<pre><code>cached_property.clear_cache(\n    instance\n)\n</code></pre> <p>Clear the cache for this property belonging to <code>instance</code>.</p>","title":"clear_cache method"},{"location":"api/utils/decorators/#vectorbt.utils.decorators.class_or_instancemethod","text":"<pre><code>class_or_instancemethod(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Function decorator that binds <code>self</code> to a class if the function is called as class method, otherwise to an instance.</p> <p>Superclasses</p> <ul> <li><code>builtins.classmethod</code></li> </ul>","title":"class_or_instancemethod class"},{"location":"api/utils/decorators/#vectorbt.utils.decorators.class_or_instanceproperty","text":"<pre><code>class_or_instanceproperty(\n    func\n)\n</code></pre> <p>Property that binds <code>self</code> to a class if the function is called as class method, otherwise to an instance.</p>","title":"class_or_instanceproperty class"},{"location":"api/utils/decorators/#vectorbt.utils.decorators.classproperty","text":"<pre><code>classproperty(\n    func\n)\n</code></pre> <p>Property that can be called on a class.</p>","title":"classproperty class"},{"location":"api/utils/decorators/#vectorbt.utils.decorators.custom_methodT","text":"<pre><code>custom_methodT(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Base class for protocol classes. Protocol classes are defined as::</p> <pre><code>class Proto(Protocol):\n    def meth(self) -&gt; int:\n        ...\n</code></pre> <p>Such classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example::</p> <p>    class C</p> <pre><code>def meth(self) -&gt; int:\n    return 0\n</code></pre> <p>def func(x: Proto) -&gt; int:     return x.meth()</p> <p>func(C())  # Passes static type check</p> <p>See PEP 544 for details. Protocol classes decorated with @typing_extensions.runtime act as simple-minded runtime protocol that checks only the presence of given attributes, ignoring their type signatures.</p> <p>Protocol classes can be generic, they are defined as::</p> <pre><code>class GenProto(Protocol[T]):\n    def meth(self) -&gt; T:\n        ...\n</code></pre> <p>Superclasses</p> <ul> <li><code>typing_extensions.Protocol</code></li> </ul> <p>Subclasses</p> <ul> <li>cached_methodT</li> </ul>","title":"custom_methodT class"},{"location":"api/utils/decorators/#vectorbt.utils.decorators.custom_methodT.flags","text":"","title":"flags class variable"},{"location":"api/utils/decorators/#vectorbt.utils.decorators.custom_methodT.func","text":"","title":"func class variable"},{"location":"api/utils/decorators/#vectorbt.utils.decorators.custom_property","text":"<pre><code>custom_property(\n    func,\n    **flags\n)\n</code></pre> <p>Custom property that stores function and flags as attributes.</p> <p>Can be called both as <pre><code>&gt;&gt;&gt; @custom_property\n... def user_function(self): pass\n</code></pre> and <pre><code>&gt;&gt;&gt; @custom_property(a=0, b=0)  # flags\n... def user_function(self): pass\n</code></pre></p>  <p>Note</p> <p>custom_property instances belong to classes, not class instances. Thus changing the property, for example, by disabling caching, will do the same for each instance of the class where the property has been defined.</p>  <p>Subclasses</p> <ul> <li>cached_property</li> </ul>","title":"custom_property class"},{"location":"api/utils/docs/","text":"<p>Utilities for documentation.</p>","title":"docs"},{"location":"api/utils/docs/#vectorbt.utils.docs.prepare_for_doc","text":"<pre><code>prepare_for_doc(\n    obj,\n    replace=None,\n    path=None\n)\n</code></pre> <p>Prepare object for use in documentation.</p>","title":"prepare_for_doc function"},{"location":"api/utils/docs/#vectorbt.utils.docs.to_doc","text":"<pre><code>to_doc(\n    obj,\n    replace=None,\n    path=None,\n    **kwargs\n)\n</code></pre> <p>Convert object to a JSON string.</p>","title":"to_doc function"},{"location":"api/utils/docs/#vectorbt.utils.docs.Documented","text":"<pre><code>Documented()\n</code></pre> <p>Abstract class for documenting self.</p>  <p>Note</p> <p>Won't get converted into a string in prepare_for_doc().</p>  <p>Subclasses</p> <ul> <li>Config</li> <li>Configured</li> </ul>","title":"Documented class"},{"location":"api/utils/docs/#vectorbt.utils.docs.Documented.to_doc","text":"<pre><code>Documented.to_doc(\n    **kwargs\n)\n</code></pre> <p>Convert to a doc.</p>","title":"to_doc method"},{"location":"api/utils/docs/#vectorbt.utils.docs.SafeToStr","text":"<pre><code>SafeToStr()\n</code></pre> <p>Class that can be safely converted into a string in prepare_for_doc().</p> <p>Subclasses</p> <ul> <li>Rep</li> <li>RepEval</li> <li>RepFunc</li> <li>Sub</li> </ul>","title":"SafeToStr class"},{"location":"api/utils/enum_/","text":"<p>Enum utilities.</p> <p>In vectorbt, enums are represented by instances of named tuples to be easily used in Numba. Their values start with 0, while -1 means there is no value.</p>","title":"enum_"},{"location":"api/utils/enum_/#vectorbt.utils.enum_.map_enum_fields","text":"<pre><code>map_enum_fields(\n    field,\n    enum,\n    ignore_type=builtins.int,\n    **kwargs\n)\n</code></pre> <p>Map fields to values.</p> <p>See apply_mapping().</p>","title":"map_enum_fields function"},{"location":"api/utils/enum_/#vectorbt.utils.enum_.map_enum_values","text":"<pre><code>map_enum_values(\n    value,\n    enum,\n    ignore_type=builtins.str,\n    **kwargs\n)\n</code></pre> <p>Map values to fields.</p> <p>See apply_mapping().</p>","title":"map_enum_values function"},{"location":"api/utils/figure/","text":"<p>Utilities for constructing and displaying figures.</p>","title":"figure"},{"location":"api/utils/figure/#vectorbt.utils.figure.get_domain","text":"<pre><code>get_domain(\n    ref,\n    fig\n)\n</code></pre> <p>Get domain of a coordinate axis.</p>","title":"get_domain function"},{"location":"api/utils/figure/#vectorbt.utils.figure.make_figure","text":"<pre><code>make_figure(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Make new figure.</p> <p>Returns either Figure or FigureWidget, depending on <code>use_widgets</code> defined under <code>plotting</code> in settings.</p>","title":"make_figure function"},{"location":"api/utils/figure/#vectorbt.utils.figure.make_subplots","text":"<pre><code>make_subplots(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Makes subplots and passes them to FigureWidget.</p>","title":"make_subplots function"},{"location":"api/utils/figure/#vectorbt.utils.figure.Figure","text":"<pre><code>Figure(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Figure.</p> <p>Extends <code>plotly.graph_objects.Figure</code>.</p> <p>Superclasses</p> <ul> <li>FigureMixin</li> <li><code>plotly.basedatatypes.BaseFigure</code></li> <li><code>plotly.graph_objs._figure.Figure</code></li> </ul> <p>Inherited members</p> <ul> <li>FigureMixin.show_png()</li> <li>FigureMixin.show_svg()</li> </ul>","title":"Figure class"},{"location":"api/utils/figure/#vectorbt.utils.figure.Figure.show","text":"<pre><code>Figure.show(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Show the figure.</p>","title":"show method"},{"location":"api/utils/figure/#vectorbt.utils.figure.FigureMixin","text":"<pre><code>FigureMixin()\n</code></pre> <p>Subclasses</p> <ul> <li>Figure</li> <li>FigureWidget</li> </ul>","title":"FigureMixin class"},{"location":"api/utils/figure/#vectorbt.utils.figure.FigureMixin.show","text":"<pre><code>FigureMixin.show(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Display the figure in PNG format.</p>","title":"show method"},{"location":"api/utils/figure/#vectorbt.utils.figure.FigureMixin.show_png","text":"<pre><code>FigureMixin.show_png(\n    **kwargs\n)\n</code></pre> <p>Display the figure in PNG format.</p>","title":"show_png method"},{"location":"api/utils/figure/#vectorbt.utils.figure.FigureMixin.show_svg","text":"<pre><code>FigureMixin.show_svg(\n    **kwargs\n)\n</code></pre> <p>Display the figure in SVG format.</p>","title":"show_svg method"},{"location":"api/utils/figure/#vectorbt.utils.figure.FigureWidget","text":"<pre><code>FigureWidget(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Figure widget.</p> <p>Extends <code>plotly.graph_objects.FigureWidget</code>.</p> <p>Superclasses</p> <ul> <li>FigureMixin</li> <li><code>ipywidgets.widgets.domwidget.DOMWidget</code></li> <li><code>ipywidgets.widgets.widget.LoggingHasTraits</code></li> <li><code>ipywidgets.widgets.widget.Widget</code></li> <li><code>plotly.basedatatypes.BaseFigure</code></li> <li><code>plotly.basewidget.BaseFigureWidget</code></li> <li><code>plotly.graph_objs._figurewidget.FigureWidget</code></li> <li><code>traitlets.traitlets.HasDescriptors</code></li> <li><code>traitlets.traitlets.HasTraits</code></li> </ul> <p>Inherited members</p> <ul> <li>FigureMixin.show_png()</li> <li>FigureMixin.show_svg()</li> </ul>","title":"FigureWidget class"},{"location":"api/utils/figure/#vectorbt.utils.figure.FigureWidget.show","text":"<pre><code>FigureWidget.show(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Show the figure.</p>","title":"show method"},{"location":"api/utils/image_/","text":"<p>Utilities for images.</p>","title":"image_"},{"location":"api/utils/image_/#vectorbt.utils.image_.hstack_image_arrays","text":"<pre><code>hstack_image_arrays(\n    a,\n    b\n)\n</code></pre> <p>Stack NumPy images horizontally.</p>","title":"hstack_image_arrays function"},{"location":"api/utils/image_/#vectorbt.utils.image_.save_animation","text":"<pre><code>save_animation(\n    fname,\n    index,\n    plot_func,\n    *args,\n    delta=None,\n    step=1,\n    fps=3,\n    writer_kwargs=None,\n    show_progress=True,\n    tqdm_kwargs=None,\n    to_image_kwargs=None,\n    **kwargs\n)\n</code></pre> <p>Save animation to a file.</p> <p>Args</p>  <code>fname</code> :\u2002<code>str</code> File name. <code>index</code> :\u2002<code>iterable</code> Index to iterate over. <code>plot_func</code> :\u2002<code>callable</code>  <p>Plotting function.</p> <p>Should take subset of <code>index</code>, <code>*args</code>, and <code>**kwargs</code>, and return either a Plotly figure, image that can be read by <code>imageio.imread</code>, or a NumPy array.</p>  <code>*args</code> Positional arguments passed to <code>plot_func</code>. <code>delta</code> :\u2002<code>int</code> Window size of each iteration. <code>step</code> :\u2002<code>int</code> Step of each iteration. <code>fps</code> :\u2002<code>int</code> Frames per second. <code>writer_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>imageio.get_writer</code>. <code>show_progress</code> :\u2002<code>bool</code> Whether to show the progress bar. <code>tqdm_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>tqdm</code>. <code>to_image_kwargs</code> :\u2002<code>dict</code> Keyword arguments passed to <code>plotly.graph_objects.Figure.to_image</code>. <code>**kwargs</code> Keyword arguments passed to <code>plot_func</code>.","title":"save_animation function"},{"location":"api/utils/image_/#vectorbt.utils.image_.vstack_image_arrays","text":"<pre><code>vstack_image_arrays(\n    a,\n    b\n)\n</code></pre> <p>Stack NumPy images vertically.</p>","title":"vstack_image_arrays function"},{"location":"api/utils/mapping/","text":"<p>Mapping utilities.</p>","title":"mapping"},{"location":"api/utils/mapping/#vectorbt.utils.mapping.apply_mapping","text":"<pre><code>apply_mapping(\n    obj,\n    mapping_like=None,\n    reverse=False,\n    ignore_case=True,\n    ignore_underscores=True,\n    ignore_type=None,\n    ignore_missing=False,\n    na_sentinel=None\n)\n</code></pre> <p>Apply mapping on object using a mapping-like object.</p> <p>Args</p>  <code>obj</code> :\u2002<code>any</code>  <p>Any object.</p> <p>Can take a scalar, tuple, list, set, frozenset, NumPy array, Index, Series, and DataFrame.</p>  <code>mapping_like</code> :\u2002<code>mapping_like</code>  <p>Any mapping-like object.</p> <p>See to_mapping().</p>  <code>reverse</code> :\u2002<code>bool</code> See <code>reverse</code> in to_mapping(). <code>ignore_case</code> :\u2002<code>bool</code> Whether to ignore the case if the key is a string. <code>ignore_underscores</code> :\u2002<code>bool</code> Whether to ignore underscores if the key is a string. <code>ignore_type</code> :\u2002<code>dtype_like</code> or <code>tuple</code> One or multiple types or data types to ignore. <code>ignore_missing</code> :\u2002<code>bool</code> Whether to ignore missing values. <code>na_sentinel</code> :\u2002<code>any</code> Value to mark \u201cnot found\u201d.","title":"apply_mapping function"},{"location":"api/utils/mapping/#vectorbt.utils.mapping.reverse_mapping","text":"<pre><code>reverse_mapping(\n    mapping\n)\n</code></pre> <p>Reverse a mapping.</p> <p>Returns a dict.</p>","title":"reverse_mapping function"},{"location":"api/utils/mapping/#vectorbt.utils.mapping.to_mapping","text":"<pre><code>to_mapping(\n    mapping_like,\n    reverse=False\n)\n</code></pre> <p>Convert mapping-like object to a mapping.</p> <p>Enable <code>reverse</code> to apply reverse_mapping() on the result dict.</p>","title":"to_mapping function"},{"location":"api/utils/math_/","text":"<p>Math utilities.</p>","title":"math_"},{"location":"api/utils/math_/#vectorbt.utils.math_.add_nb","text":"<pre><code>add_nb(\n    a,\n    b,\n    rel_tol=1e-09,\n    abs_tol=1e-12\n)\n</code></pre> <p>Add two floats.</p>","title":"add_nb function"},{"location":"api/utils/math_/#vectorbt.utils.math_.is_addition_zero_nb","text":"<pre><code>is_addition_zero_nb(\n    a,\n    b,\n    rel_tol=1e-09,\n    abs_tol=1e-12\n)\n</code></pre> <p>Tell whether addition of two values yields zero.</p>","title":"is_addition_zero_nb function"},{"location":"api/utils/math_/#vectorbt.utils.math_.is_close_nb","text":"<pre><code>is_close_nb(\n    a,\n    b,\n    rel_tol=1e-09,\n    abs_tol=1e-12\n)\n</code></pre> <p>Tell whether two values are approximately equal.</p>","title":"is_close_nb function"},{"location":"api/utils/math_/#vectorbt.utils.math_.is_close_or_less_nb","text":"<pre><code>is_close_or_less_nb(\n    a,\n    b,\n    rel_tol=1e-09,\n    abs_tol=1e-12\n)\n</code></pre> <p>Tell whether the first value is approximately less than or equal to the second value.</p>","title":"is_close_or_less_nb function"},{"location":"api/utils/math_/#vectorbt.utils.math_.is_less_nb","text":"<pre><code>is_less_nb(\n    a,\n    b,\n    rel_tol=1e-09,\n    abs_tol=1e-12\n)\n</code></pre> <p>Tell whether the first value is approximately less than the second value.</p>","title":"is_less_nb function"},{"location":"api/utils/module_/","text":"<p>Utilities for modules.</p>","title":"module_"},{"location":"api/utils/module_/#vectorbt.utils.module_.import_submodules","text":"<pre><code>import_submodules(\n    package\n)\n</code></pre> <p>Import all submodules of a module, recursively, including subpackages.</p> <p>If package defines <code>__blacklist__</code>, does not import modules that match names from this list.</p>","title":"import_submodules function"},{"location":"api/utils/module_/#vectorbt.utils.module_.is_from_module","text":"<pre><code>is_from_module(\n    obj,\n    module\n)\n</code></pre> <p>Return whether <code>obj</code> is from module <code>module</code>.</p>","title":"is_from_module function"},{"location":"api/utils/module_/#vectorbt.utils.module_.list_module_keys","text":"<pre><code>list_module_keys(\n    module_name,\n    whitelist=None,\n    blacklist=None\n)\n</code></pre> <p>List the names of all public functions and classes defined in the module <code>module_name</code>.</p> <p>Includes the names listed in <code>whitelist</code> and excludes the names listed in <code>blacklist</code>.</p>","title":"list_module_keys function"},{"location":"api/utils/params/","text":"<p>Utilities for working with parameters.</p>","title":"params"},{"location":"api/utils/params/#vectorbt.utils.params.broadcast_params","text":"<pre><code>broadcast_params(\n    param_list,\n    to_n=None\n)\n</code></pre> <p>Broadcast parameters in <code>param_list</code>.</p>","title":"broadcast_params function"},{"location":"api/utils/params/#vectorbt.utils.params.create_param_combs","text":"<pre><code>create_param_combs(\n    op_tree,\n    depth=0\n)\n</code></pre> <p>Create arbitrary parameter combinations from the operation tree <code>op_tree</code>.</p> <p><code>op_tree</code> is a tuple with nested instructions to generate parameters. The first element of the tuple should be a callable that takes remaining elements as arguments. If one of the elements is a tuple itself and its first argument is a callable, it will be unfolded in the same way as above.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from itertools import combinations, product\n\n&gt;&gt;&gt; create_param_combs((product, (combinations, [0, 1, 2, 3], 2), [4, 5]))\n[[0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2],\n [1, 1, 2, 2, 3, 3, 2, 2, 3, 3, 3, 3],\n [4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5]]\n</code></pre>","title":"create_param_combs function"},{"location":"api/utils/params/#vectorbt.utils.params.create_param_product","text":"<pre><code>create_param_product(\n    param_list\n)\n</code></pre> <p>Make Cartesian product out of all params in <code>param_list</code>.</p>","title":"create_param_product function"},{"location":"api/utils/params/#vectorbt.utils.params.flatten_param_tuples","text":"<pre><code>flatten_param_tuples(\n    param_tuples\n)\n</code></pre> <p>Flattens a nested list of iterables using unzipping.</p>","title":"flatten_param_tuples function"},{"location":"api/utils/params/#vectorbt.utils.params.to_typed_list","text":"<pre><code>to_typed_list(\n    lst\n)\n</code></pre> <p>Cast Python list to typed list.</p> <p>Direct construction is flawed in Numba 0.52.0. See https://github.com/numba/numba/issues/6651.</p>","title":"to_typed_list function"},{"location":"api/utils/random_/","text":"<p>Utilities for random number generation.</p>","title":"random_"},{"location":"api/utils/random_/#vectorbt.utils.random_.set_seed","text":"<pre><code>set_seed(\n    seed\n)\n</code></pre> <p>Set seed.</p>","title":"set_seed function"},{"location":"api/utils/random_/#vectorbt.utils.random_.set_seed_nb","text":"<pre><code>set_seed_nb(\n    seed\n)\n</code></pre> <p>Set seed in numba.</p>","title":"set_seed_nb function"},{"location":"api/utils/requests_/","text":"<p>Utilities for requests.</p>","title":"requests_"},{"location":"api/utils/requests_/#vectorbt.utils.requests_.requests_retry_session","text":"<pre><code>requests_retry_session(\n    retries=3,\n    backoff_factor=0.3,\n    status_forcelist=(500, 502, 504),\n    session=None\n)\n</code></pre> <p>Retry <code>retries</code> times if unsuccessful.</p>","title":"requests_retry_session function"},{"location":"api/utils/requests_/#vectorbt.utils.requests_.text_to_giphy_url","text":"<pre><code>text_to_giphy_url(\n    text,\n    api_key=None,\n    weirdness=None\n)\n</code></pre> <p>Translate text to GIF.</p> <p>See https://engineering.giphy.com/contextually-aware-search-giphy-gets-work-specific/.</p>","title":"text_to_giphy_url function"},{"location":"api/utils/schedule_/","text":"<p>Utilities for scheduling jobs.</p>","title":"schedule_"},{"location":"api/utils/schedule_/#vectorbt.utils.schedule_.AsyncJob","text":"<pre><code>AsyncJob(\n    interval,\n    scheduler=None\n)\n</code></pre> <p>A periodic job as used by :class:<code>Scheduler</code>.</p> <p>:param interval: A quantity of a certain time unit :param scheduler: The :class:<code>Scheduler &lt;Scheduler&gt;</code> instance that                   this job will register itself with once it has                   been fully configured in :meth:<code>Job.do()</code>.</p> <p>Every job runs at a given fixed time interval that is defined by:</p> <ul> <li>a :meth:<code>time unit &lt;Job.second&gt;</code></li> <li>a quantity of <code>time units</code> defined by <code>interval</code></li> </ul> <p>A job is usually created and returned by :meth:<code>Scheduler.every</code> method, which also defines its <code>interval</code>.</p> <p>Superclasses</p> <ul> <li><code>schedule.Job</code></li> </ul>","title":"AsyncJob class"},{"location":"api/utils/schedule_/#vectorbt.utils.schedule_.AsyncJob.async_run","text":"<pre><code>AsyncJob.async_run()\n</code></pre> <p>Async <code>Job.run</code>.</p>","title":"async_run method"},{"location":"api/utils/schedule_/#vectorbt.utils.schedule_.AsyncScheduler","text":"<pre><code>AsyncScheduler()\n</code></pre> <p>Objects instantiated by the :class:<code>Scheduler &lt;Scheduler&gt;</code> are factories to create jobs, keep record of scheduled jobs and handle their execution.</p> <p>Superclasses</p> <ul> <li><code>schedule.Scheduler</code></li> </ul>","title":"AsyncScheduler class"},{"location":"api/utils/schedule_/#vectorbt.utils.schedule_.AsyncScheduler.async_run_all","text":"<pre><code>AsyncScheduler.async_run_all(\n    delay_seconds=0\n)\n</code></pre> <p>Async <code>Scheduler.run_all</code>.</p>","title":"async_run_all method"},{"location":"api/utils/schedule_/#vectorbt.utils.schedule_.AsyncScheduler.async_run_pending","text":"<pre><code>AsyncScheduler.async_run_pending()\n</code></pre> <p>Async <code>Scheduler.run_pending</code>.</p>","title":"async_run_pending method"},{"location":"api/utils/schedule_/#vectorbt.utils.schedule_.AsyncScheduler.every","text":"<pre><code>AsyncScheduler.every(\n    interval=1\n)\n</code></pre> <p>Schedule a new periodic job of type AsyncJob.</p>","title":"every method"},{"location":"api/utils/schedule_/#vectorbt.utils.schedule_.CancelledError","text":"<pre><code>CancelledError(\n    *args,\n    **kwargs\n)\n</code></pre> <p>Thrown for the operation to be cancelled.</p> <p>Superclasses</p> <ul> <li><code>builtins.BaseException</code></li> <li><code>builtins.Exception</code></li> <li><code>concurrent.futures._base.CancelledError</code></li> <li><code>concurrent.futures._base.Error</code></li> </ul>","title":"CancelledError class"},{"location":"api/utils/schedule_/#vectorbt.utils.schedule_.ScheduleManager","text":"<pre><code>ScheduleManager(\n    scheduler=None\n)\n</code></pre> <p>Class that manages <code>schedule.Scheduler</code>.</p>","title":"ScheduleManager class"},{"location":"api/utils/schedule_/#vectorbt.utils.schedule_.ScheduleManager.units","text":"","title":"units class variable"},{"location":"api/utils/schedule_/#vectorbt.utils.schedule_.ScheduleManager.weekdays","text":"","title":"weekdays class variable"},{"location":"api/utils/schedule_/#vectorbt.utils.schedule_.ScheduleManager.async_task","text":"<p>Current async task.</p>","title":"async_task property"},{"location":"api/utils/schedule_/#vectorbt.utils.schedule_.ScheduleManager.async_task_running","text":"<p>Whether the async task is running.</p>","title":"async_task_running property"},{"location":"api/utils/schedule_/#vectorbt.utils.schedule_.ScheduleManager.scheduler","text":"<p>Scheduler.</p>","title":"scheduler property"},{"location":"api/utils/schedule_/#vectorbt.utils.schedule_.ScheduleManager.async_start","text":"<pre><code>ScheduleManager.async_start(\n    sleep=1\n)\n</code></pre> <p>Async run pending jobs in a loop.</p>","title":"async_start method"},{"location":"api/utils/schedule_/#vectorbt.utils.schedule_.ScheduleManager.done_callback","text":"<pre><code>ScheduleManager.done_callback(\n    async_task\n)\n</code></pre> <p>Callback run when the async task is finished.</p>","title":"done_callback method"},{"location":"api/utils/schedule_/#vectorbt.utils.schedule_.ScheduleManager.every","text":"<pre><code>ScheduleManager.every(\n    *args,\n    to=None,\n    tags=None\n)\n</code></pre> <p>Create a new job that runs every <code>interval</code> units of time.</p> <p><code>*args</code> can include at most four different arguments: <code>interval</code>, <code>unit</code>, <code>start_day</code>, and <code>at</code>, in the strict order:</p> <ul> <li><code>interval</code>: integer or <code>datetime.timedelta</code></li> <li><code>unit</code>: ScheduleManager.units</li> <li><code>start_day</code>: ScheduleManager.weekdays</li> <li><code>at</code>: string or <code>datetime.time</code>.</li> </ul> <p>See the package <code>schedule</code> for more details.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; import datetime\n&gt;&gt;&gt; import pytz\n&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; def job_func(message=\"I'm working...\"):\n...     print(message)\n\n&gt;&gt;&gt; my_manager = vbt.ScheduleManager()\n\n&gt;&gt;&gt; # add jobs\n&gt;&gt;&gt; my_manager.every().do(job_func, message=\"Hello\")\nEvery 1 second do job_func(message='Hello') (last run: [never], next run: 2021-03-18 19:06:47)\n\n&gt;&gt;&gt; my_manager.every(10, 'minutes').do(job_func)\nEvery 10 minutes do job_func() (last run: [never], next run: 2021-03-18 19:16:46)\n\n&gt;&gt;&gt; my_manager.every('hour').do(job_func)\nEvery 1 hour do job_func() (last run: [never], next run: 2021-03-18 20:06:46)\n\n&gt;&gt;&gt; my_manager.every('10:30').do(job_func)\nEvery 1 day at 10:30:00 do job_func() (last run: [never], next run: 2021-03-19 10:30:00)\n\n&gt;&gt;&gt; my_manager.every('day', '10:30').do(job_func)\nEvery 1 day at 10:30:00 do job_func() (last run: [never], next run: 2021-03-19 10:30:00)\n\n&gt;&gt;&gt; my_manager.every('day', datetime.time(9, 30, tzinfo=pytz.utc)).do(job_func)\nEvery 1 day at 10:30:00 do job_func() (last run: [never], next run: 2021-03-19 10:30:00)\n\n&gt;&gt;&gt; my_manager.every('monday').do(job_func)\nEvery 1 week do job_func() (last run: [never], next run: 2021-03-22 19:06:46)\n\n&gt;&gt;&gt; my_manager.every('wednesday', '13:15').do(job_func)\nEvery 1 week at 13:15:00 do job_func() (last run: [never], next run: 2021-03-24 13:15:00)\n\n&gt;&gt;&gt; my_manager.every('minute', ':17').do(job_func)\nEvery 1 minute at 00:00:17 do job_func() (last run: [never], next run: 2021-03-18 19:07:17)\n\n&gt;&gt;&gt; my_manager.start()\n</code></pre> <p>You can still use the chained approach as done by <code>schedule</code>:</p> <pre><code>&gt;&gt;&gt; my_manager.every().minute.at(':17').do(job_func)\nEvery 1 minute at 00:00:17 do job_func() (last run: [never], next run: 2021-03-18 19:07:17)\n</code></pre>","title":"every method"},{"location":"api/utils/schedule_/#vectorbt.utils.schedule_.ScheduleManager.start","text":"<pre><code>ScheduleManager.start(\n    sleep=1\n)\n</code></pre> <p>Run pending jobs in a loop.</p>","title":"start method"},{"location":"api/utils/schedule_/#vectorbt.utils.schedule_.ScheduleManager.start_in_background","text":"<pre><code>ScheduleManager.start_in_background(\n    **kwargs\n)\n</code></pre> <p>Run ScheduleManager.async_start() in the background.</p>","title":"start_in_background method"},{"location":"api/utils/schedule_/#vectorbt.utils.schedule_.ScheduleManager.stop","text":"<pre><code>ScheduleManager.stop()\n</code></pre> <p>Stop the async task.</p>","title":"stop method"},{"location":"api/utils/tags/","text":"<p>Utilities for working with tags.</p>","title":"tags"},{"location":"api/utils/tags/#vectorbt.utils.tags.match_tags","text":"<pre><code>match_tags(\n    tags,\n    in_tags\n)\n</code></pre> <p>Match tags in <code>tags</code> to that in <code>in_tags</code>.</p> <p>Multiple tags in <code>tags</code> are combined using OR rule, that is, returns True if any of them is found in <code>in_tags</code>. If any tag is not an identifier, evaluates it as a boolean expression. All tags in <code>in_tags</code> should be identifiers.</p> <p>Usage</p> <pre><code>&gt;&gt;&gt; from vectorbt.utils.tags import match_tags\n\n&gt;&gt;&gt; match_tags('hello', 'hello')\nTrue\n&gt;&gt;&gt; match_tags('hello', 'world')\nFalse\n&gt;&gt;&gt; match_tags(['hello', 'world'], 'world')\nTrue\n&gt;&gt;&gt; match_tags('hello', ['hello', 'world'])\nTrue\n&gt;&gt;&gt; match_tags('hello and world', ['hello', 'world'])\nTrue\n&gt;&gt;&gt; match_tags('hello and not world', ['hello', 'world'])\nFalse\n</code></pre>","title":"match_tags function"},{"location":"api/utils/template/","text":"<p>Utilities for working with templates.</p>","title":"template"},{"location":"api/utils/template/#vectorbt.utils.template.deep_substitute","text":"<pre><code>deep_substitute(\n    obj,\n    mapping=None,\n    safe=False,\n    make_copy=True\n)\n</code></pre> <p>Traverses the object recursively and, if any template found, substitutes it using a mapping.</p> <p>Traverses tuples, lists, dicts and (frozen-)sets. Does not look for templates in keys.</p> <p>If <code>safe</code> is True, won't raise an error but return the original template.</p>  <p>Note</p> <p>If the object is deep (such as a dict or a list), creates a copy of it if any template found inside, thus loosing the reference to the original. Make sure to do a deep or hybrid copy of the object before proceeding for consistent behavior, or disable <code>make_copy</code> to override the original in place.</p>  <p>Usage</p> <pre><code>&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; vbt.deep_substitute(vbt.Sub('$key', {'key': 100}))\n100\n&gt;&gt;&gt; vbt.deep_substitute(vbt.Sub('$key', {'key': 100}), {'key': 200})\n200\n&gt;&gt;&gt; vbt.deep_substitute(vbt.Sub('$key$key'), {'key': 100})\n100100\n&gt;&gt;&gt; vbt.deep_substitute(vbt.Rep('key'), {'key': 100})\n100\n&gt;&gt;&gt; vbt.deep_substitute([vbt.Rep('key'), vbt.Sub('$key$key')], {'key': 100})\n[100, '100100']\n&gt;&gt;&gt; vbt.deep_substitute(vbt.RepFunc(lambda key: key == 100), {'key': 100})\nTrue\n&gt;&gt;&gt; vbt.deep_substitute(vbt.RepEval('key == 100'), {'key': 100})\nTrue\n&gt;&gt;&gt; vbt.deep_substitute(vbt.RepEval('key == 100', safe=False))\nNameError: name 'key' is not defined\n&gt;&gt;&gt; vbt.deep_substitute(vbt.RepEval('key == 100', safe=True))\n&lt;vectorbt.utils.template.RepEval at 0x7fe3ad2ab668&gt;\n</code></pre>","title":"deep_substitute function"},{"location":"api/utils/template/#vectorbt.utils.template.has_templates","text":"<pre><code>has_templates(\n    obj\n)\n</code></pre> <p>Check if the object has any templates.</p>","title":"has_templates function"},{"location":"api/utils/template/#vectorbt.utils.template.Rep","text":"<pre><code>Rep(\n    key,\n    mapping=None\n)\n</code></pre> <p>Key to be replaced with the respective value from <code>mapping</code>.</p> <p>Superclasses</p> <ul> <li>SafeToStr</li> </ul>","title":"Rep class"},{"location":"api/utils/template/#vectorbt.utils.template.Rep.key","text":"<p>Key to be replaced.</p>","title":"key property"},{"location":"api/utils/template/#vectorbt.utils.template.Rep.mapping","text":"<p>Mapping object passed to the initializer.</p>","title":"mapping property"},{"location":"api/utils/template/#vectorbt.utils.template.Rep.replace","text":"<pre><code>Rep.replace(\n    mapping=None\n)\n</code></pre> <p>Replace Rep.key using <code>mapping</code>.</p> <p>Merges <code>mapping</code> and Rep.mapping.</p>","title":"replace method"},{"location":"api/utils/template/#vectorbt.utils.template.RepEval","text":"<pre><code>RepEval(\n    expression,\n    mapping=None\n)\n</code></pre> <p>Expression to be evaluated with <code>mapping</code> used as locals.</p> <p>Superclasses</p> <ul> <li>SafeToStr</li> </ul>","title":"RepEval class"},{"location":"api/utils/template/#vectorbt.utils.template.RepEval.expression","text":"<p>Expression to be evaluated.</p>","title":"expression property"},{"location":"api/utils/template/#vectorbt.utils.template.RepEval.mapping","text":"<p>Mapping object passed to the initializer.</p>","title":"mapping property"},{"location":"api/utils/template/#vectorbt.utils.template.RepEval.eval","text":"<pre><code>RepEval.eval(\n    mapping=None\n)\n</code></pre> <p>Evaluate RepEval.expression using <code>mapping</code>.</p> <p>Merges <code>mapping</code> and RepEval.mapping.</p>","title":"eval method"},{"location":"api/utils/template/#vectorbt.utils.template.RepFunc","text":"<pre><code>RepFunc(\n    func,\n    mapping=None\n)\n</code></pre> <p>Function to be called with argument names from <code>mapping</code>.</p> <p>Superclasses</p> <ul> <li>SafeToStr</li> </ul>","title":"RepFunc class"},{"location":"api/utils/template/#vectorbt.utils.template.RepFunc.func","text":"<p>Replacement function to be called.</p>","title":"func property"},{"location":"api/utils/template/#vectorbt.utils.template.RepFunc.mapping","text":"<p>Mapping object passed to the initializer.</p>","title":"mapping property"},{"location":"api/utils/template/#vectorbt.utils.template.RepFunc.call","text":"<pre><code>RepFunc.call(\n    mapping=None\n)\n</code></pre> <p>Call RepFunc.func using <code>mapping</code>.</p> <p>Merges <code>mapping</code> and RepFunc.mapping.</p>","title":"call method"},{"location":"api/utils/template/#vectorbt.utils.template.Sub","text":"<pre><code>Sub(\n    template,\n    mapping=None\n)\n</code></pre> <p>Template to substitute parts of the string with the respective values from <code>mapping</code>.</p> <p>Returns a string.</p> <p>Superclasses</p> <ul> <li>SafeToStr</li> </ul>","title":"Sub class"},{"location":"api/utils/template/#vectorbt.utils.template.Sub.mapping","text":"<p>Mapping object passed to the initializer.</p>","title":"mapping property"},{"location":"api/utils/template/#vectorbt.utils.template.Sub.template","text":"<p>Template to be processed.</p>","title":"template property"},{"location":"api/utils/template/#vectorbt.utils.template.Sub.substitute","text":"<pre><code>Sub.substitute(\n    mapping=None\n)\n</code></pre> <p>Substitute parts of Sub.template using <code>mapping</code>.</p> <p>Merges <code>mapping</code> and Sub.mapping.</p>","title":"substitute method"},{"location":"getting-started/contributing/","text":"<p>Pull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.</p> <p>First, you need to install vectorbt from the repository:</p> <pre><code>pip uninstall vectorbt\ngit clone https://github.com/polakowo/vectorbt.git\ncd vectorbt\npip install -e .\n</code></pre> <p>After making changes, make sure you did not break any functionality:</p> <pre><code>pytest\n</code></pre> <p>Make sure to update tests as appropriate.</p>","title":"Contributing"},{"location":"getting-started/features/","text":"","title":"Features"},{"location":"getting-started/features/#pandas","text":"<ul> <li> Pandas acceleration: Compiled versions of most popular pandas functions, such as mapping, reducing, rolling, grouping, and resamping. For best performance, most operations are done strictly using NumPy and Numba. Attaches a custom accessor on top of pandas to easily switch between pandas and vectorbt functionality.</li> </ul> Compute a rolling z-score<pre><code>&gt;&gt;&gt; import vectorbt as vbt\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from numba import njit\n\n&gt;&gt;&gt; big_ts = pd.DataFrame(np.random.uniform(size=(1000, 1000)))\n\n# pandas\n&gt;&gt;&gt; @njit\n... def zscore_nb(x):\n...     return (x[-1] - np.mean(x)) / np.std(x)\n\n&gt;&gt;&gt; %timeit big_ts.rolling(2).apply(zscore_nb, raw=True)\n482 ms \u00b1 393 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n\n# vectorbt\n&gt;&gt;&gt; @njit\n... def vbt_zscore_nb(i, col, x):\n...     return zscore_nb(x)\n\n&gt;&gt;&gt; %timeit big_ts.vbt.rolling_apply(2, vbt_zscore_nb)\n33.1 ms \u00b1 1.17 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</code></pre> <ul> <li> Flexible broadcasting: Mechanism for broadcasting array-like objects of arbitrary shapes, including pandas objects with MultiIndex.</li> </ul> Broadcast pandas objects properly<pre><code>&gt;&gt;&gt; sr = pd.Series([1, 2, 3], index=['x', 'y', 'z'])\n&gt;&gt;&gt; df = pd.DataFrame([[4, 5, 6]], index=['x', 'y', 'z'], columns=['a', 'b', 'c'])\n\n# pandas\n&gt;&gt;&gt; sr + df\n    a   b   c   x   y   z\nx NaN NaN NaN NaN NaN NaN\ny NaN NaN NaN NaN NaN NaN\nz NaN NaN NaN NaN NaN NaN\n\n# vectorbt\n&gt;&gt;&gt; sr.vbt + df\n   a  b  c\nx  5  6  7\ny  6  7  8\nz  7  8  9\n</code></pre> <ul> <li> Pandas utilities: Grouping columns, wrapping NumPy arrays, transforming pandas objects and their indexes, and more.</li> </ul> Build a symmetric matrix<pre><code>&gt;&gt;&gt; pd.Series([1, 2, 3]).vbt.make_symmetric()\n     0    1    2\n0  1.0  2.0  3.0\n1  2.0  NaN  NaN\n2  3.0  NaN  NaN\n</code></pre>","title":"Pandas"},{"location":"getting-started/features/#data","text":"<ul> <li> Data acquisition: Supports various data providers, such as Yahoo Finance, Binance, CCXT and Alpaca. Can merge multiple symbols with different index, as well as update them.</li> </ul> Download Alpaca data<pre><code>&gt;&gt;&gt; alpaca_data = vbt.AlpacaData.download(\n...     \"AAPL\",\n...     start='2 hours ago UTC',\n...     end='15 minutes ago UTC',\n...     interval='1m'\n... )\n&gt;&gt;&gt; alpaca_data.get()\n                           Open      High       Low     Close      Volume\ntimestamp                                                                \n2021-12-27 14:04:00+00:00  177.0500  177.0500  177.0500  177.0500    1967\n2021-12-27 14:05:00+00:00  177.0500  177.0500  177.0300  177.0500    3218\n2021-12-27 14:06:00+00:00  177.0400  177.0400  177.0400  177.0400     873\n...                             ...       ...       ...       ...     ...\n2021-12-27 15:46:00+00:00  177.9500  178.0000  177.8289  177.8850  162778\n2021-12-27 15:47:00+00:00  177.8810  177.9600  177.8400  177.9515  123284\n2021-12-27 15:48:00+00:00  177.9600  178.0500  177.9600  178.0100  159700\n\n[105 rows x 5 columns]\n</code></pre> <ul> <li> Data generation: Supports various (random) data generators, such as GBM.</li> </ul> Generate random data using Geometric Brownian Motion<pre><code>&gt;&gt;&gt; gbm_data = vbt.GBMData.download(\n...     list(range(5)),\n...     start='2020-01-01',\n...     end='2021-01-01'\n... )\n&gt;&gt;&gt; gbm_data.plot(showlegend=False)\n</code></pre> <p></p> <ul> <li> Scheduled data updates: Can periodically update any previously downloaded data.</li> </ul> Append random data every 5 seconds<pre><code>&gt;&gt;&gt; class MyDataUpdater(vbt.DataUpdater):\n...     def update(self, count_limit=None):\n...         prev_index_len = len(self.data.wrapper.index)\n...         super().update()\n...         new_index_len = len(self.data.wrapper.index)\n...         print(f\"Data updated with {new_index_len - prev_index_len} data points\")\n\n&gt;&gt;&gt; data = vbt.GBMData.download('SYMBOL', start='1 minute ago', freq='1s')\n&gt;&gt;&gt; my_updater = MyDataUpdater(data)\n&gt;&gt;&gt; my_updater.update_every(5, 'seconds')\nData updated with 5 data points\nData updated with 5 data points\n...\n</code></pre> <ul> <li> Data preparation: Transformation, rescaling, and normalization of data. Custom splitters for cross-validation. Supports Scikit-Learn splitters, such as for K-Folds cross-validation.</li> </ul> Split time series data<pre><code>&gt;&gt;&gt; from datetime import datetime, timedelta\n\n&gt;&gt;&gt; index = [datetime(2020, 1, 1) + timedelta(days=i) for i in range(10)]\n&gt;&gt;&gt; sr = pd.Series(np.arange(len(index)), index=index)\n&gt;&gt;&gt; sr.vbt.rolling_split(\n...     window_len=5, \n...     set_lens=(1, 1), \n...     left_to_right=False, \n...     plot=True, \n...     trace_names=['train', 'valid', 'test'])\n</code></pre> <p></p> <ul> <li> Labeling for ML: Discrete and continuous label generation for effective training of ML models.</li> </ul> Identify local extrema<pre><code>&gt;&gt;&gt; price = np.cumprod(np.random.uniform(-0.1, 0.1, size=100) + 1)\n&gt;&gt;&gt; vbt.LEXLB.run(price, 0.2, 0.2).plot()\n</code></pre> <p></p>","title":"Data"},{"location":"getting-started/features/#indicators","text":"<ul> <li> Technical indicators: Most popular technical indicators with full Numba support, including Moving Average, Bollinger Bands, RSI, Stochastic, MACD, and more. Out-of-the-box support for 99% indicators in Technical Analysis Library, Pandas TA, and TA-Lib thanks to built-in parsers. Each indicator is wrapped with the vectorbt's indicator engine and thus accepts arbitrary hyperparameter combinations - from arrays to Cartesian products.</li> </ul> Compute 2 moving averages at once<pre><code>&gt;&gt;&gt; price = pd.Series([1, 2, 3, 4, 5], dtype=float)\n\n# built-in\n&gt;&gt;&gt; vbt.MA.run(price, [2, 3]).ma\nma_window    2    3\n0          NaN  NaN\n1          1.5  NaN\n2          2.5  2.0\n3          3.5  3.0\n4          4.5  4.0\n\n# ta support\n&gt;&gt;&gt; vbt.ta('SMAIndicator').run(price, [2, 3]).sma_indicator\nsmaindicator_window    2    3\n0                    NaN  NaN\n1                    1.5  NaN\n2                    2.5  2.0\n3                    3.5  3.0\n4                    4.5  4.0\n\n# pandas-ta support\n&gt;&gt;&gt; vbt.pandas_ta('SMA').run(price, [2, 3]).sma\nsma_length    2    3\n0           NaN  NaN\n1           1.5  NaN\n2           2.5  2.0\n3           3.5  3.0\n4           4.5  4.0\n\n# TA-Lib support\n&gt;&gt;&gt; vbt.talib('SMA').run(price, [2, 3]).real\nsma_timeperiod    2    3\n0               NaN  NaN\n1               1.5  NaN\n2               2.5  2.0\n3               3.5  3.0\n4               4.5  4.0\n</code></pre> <ul> <li> Indicator factory: Sophisticated factory for building custom technical indicators of any complexity. Takes a function and does all the magic for you: generates an indicator skeleton that takes inputs and parameters of any shape and type, and runs the vectorbt's indicator engine. The easiest and most flexible way to create indicators you will find in open source.</li> </ul> Construct a random indicator<pre><code>&gt;&gt;&gt; @njit\n... def apply_func_nb(input_shape, start, mu, sigma):\n...     rand_returns = np.random.normal(mu, sigma, input_shape)\n...     return start * vbt.nb.nancumprod_nb(rand_returns + 1)\n\n&gt;&gt;&gt; RandomInd = vbt.IndicatorFactory(\n...     param_names=['start', 'mu', 'sigma'],\n...     output_names=['output']\n... ).from_apply_func(\n...     apply_func_nb,\n...     require_input_shape=True,\n...     seed=42\n... )\n\n&gt;&gt;&gt; RandomInd.run(5, [100, 200], [-0.01, 0.01], 0.01).output\ncustom_start        100         200\ncustom_mu         -0.01        0.01\ncustom_sigma       0.01        0.01\n0             99.496714  201.531726\n1             98.364179  206.729658\n2             98.017630  210.383470\n3             98.530292  211.499608\n4             97.314277  214.762117\n</code></pre>","title":"Indicators"},{"location":"getting-started/features/#signals","text":"<ul> <li> Signal analysis: Generation, mapping and reducing, ranking, and distribution analysis of entry and exit signals.</li> </ul> Measure each partition of True values<pre><code>&gt;&gt;&gt; mask_sr = pd.Series([True, True, True, False, True, True])\n&gt;&gt;&gt; mask_sr.vbt.signals.partition_ranges().duration.values\narray([3, 2])\n</code></pre> <ul> <li> Signal generators: Random and stop loss (SL, TSL, TP, etc.) signal generators with full Numba support.</li> </ul> Test multiple entry and exit probabilities<pre><code>&gt;&gt;&gt; rprobnx = vbt.RPROBNX.run(\n...     input_shape=(5,),\n...     entry_prob=[0.5, 1.],\n...     exit_prob=[0.5, 1.],\n...     param_product=True,\n...     seed=42)\n\n&gt;&gt;&gt; rprobnx.entries\nrprobnx_entry_prob    0.5    0.5    1.0    0.5\nrprobnx_exit_prob     0.5    1.0    0.5    1.0\n0                    True   True   True   True\n1                   False  False  False  False\n2                   False  False  False   True\n3                   False  False  False  False\n4                   False  False   True   True\n\n&gt;&gt;&gt; rprobnx.exits\nrprobnx_entry_prob    0.5    0.5    1.0    1.0\nrprobnx_exit_prob     0.5    1.0    0.5    1.0\n0                   False  False  False  False\n1                   False   True  False   True\n2                   False  False  False  False\n3                   False  False   True   True\n4                    True  False  False  False\n</code></pre> <ul> <li> Signal factory: Signal factory based on indicator factory specialized for iterative signal generation.</li> </ul> Place entries and exits using custom functions<pre><code>&gt;&gt;&gt; @njit\n... def entry_choice_func(from_i, to_i, col):\n...     return np.array([col])\n\n&gt;&gt;&gt; @njit\n... def exit_choice_func(from_i, to_i, col):\n...     return np.array([to_i - 1])\n\n&gt;&gt;&gt; MySignals = vbt.SignalFactory().from_choice_func(\n...     entry_choice_func=entry_choice_func,\n...     exit_choice_func=exit_choice_func,\n...     entry_kwargs=dict(wait=1),\n...     exit_kwargs=dict(wait=0)\n... )\n\n&gt;&gt;&gt; my_sig = MySignals.run(input_shape=(3, 3))\n&gt;&gt;&gt; my_sig.entries\n       0      1      2\n0   True  False  False\n1  False   True  False\n2  False  False   True\n&gt;&gt;&gt; my_sig.exits\n       0      1      2\n0  False  False  False\n1  False  False  False\n2   True   True   True\n</code></pre>","title":"Signals"},{"location":"getting-started/features/#modeling","text":"<ul> <li> Portfolio modeling: The fastest backtesting engine in open source: fills 1,000,000 orders in 70-100ms on Apple M1. Flexible and powerful simulation functions for portfolio modeling, highly optimized for highest performance and lowest memory footprint. Supports two major simulation modes: 1) vectorized backtesting using user-provided arrays, such as orders, signals, and records, and 2) event-driven backtesting using user-defined callbacks. Supports shorting and individual as well as multi-asset mixed portfolios. Combines many features across vectorbt into a single behemoth class.</li> </ul> Test the Golden Cross<pre><code>&gt;&gt;&gt; price = vbt.YFData.download('BTC-USD', start='2018-01-01').get('Close')\n&gt;&gt;&gt; fast_ma = vbt.MA.run(price, 50, short_name='fast_ma')\n&gt;&gt;&gt; slow_ma = vbt.MA.run(price, 200, short_name='slow_ma')\n&gt;&gt;&gt; entries = fast_ma.ma_crossed_above(slow_ma)\n&gt;&gt;&gt; exits = fast_ma.ma_crossed_below(slow_ma)\n&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(price, entries, exits, fees=0.005)\n\n&gt;&gt;&gt; pf.orders.records_readable\n   Order Id  Column                 Timestamp      Size         Price  \\\\\n0         0       0 2019-04-24 00:00:00+00:00  0.018208   5464.866699   \n1         1       0 2019-10-26 00:00:00+00:00  0.018208   9244.972656   \n2         2       0 2020-02-19 00:00:00+00:00  0.017300   9633.386719   \n3         3       0 2020-03-25 00:00:00+00:00  0.017300   6681.062988   \n4         4       0 2020-05-21 00:00:00+00:00  0.012600   9081.761719   \n5         5       0 2021-06-19 00:00:00+00:00  0.012600  35615.871094   \n6         6       0 2021-09-15 00:00:00+00:00  0.009222  48176.347656   \n\n       Fees  Side  \n0  0.497512   Buy  \n1  0.841647  Sell  \n2  0.833272   Buy  \n3  0.577901  Sell  \n4  0.572151   Buy  \n5  2.243800  Sell  \n6  2.221473   Buy  \n\n&gt;&gt;&gt; fig = price.vbt.plot(trace_kwargs=dict(name='Close'))\n&gt;&gt;&gt; fast_ma.ma.vbt.plot(trace_kwargs=dict(name='Fast MA'), fig=fig)\n&gt;&gt;&gt; slow_ma.ma.vbt.plot(trace_kwargs=dict(name='Slow MA'), fig=fig)\n&gt;&gt;&gt; pf.positions.plot(close_trace_kwargs=dict(visible=False), fig=fig)\n</code></pre> <p></p>","title":"Modeling"},{"location":"getting-started/features/#analysis","text":"<ul> <li> Performance metrics: Numba-compiled versions of metrics from empyrical and their rolling versions. Adapter for QuantStats.</li> </ul> Visualize performance using QuantStats<pre><code>&gt;&gt;&gt; price = vbt.YFData.download('BTC-USD').get('Close')\n&gt;&gt;&gt; returns = price.vbt.to_returns()\n&gt;&gt;&gt; returns.vbt.returns.qs.plot_snapshot()\n</code></pre> <p></p> <ul> <li> Stats builder: Class for building statistics out of custom metrics. Implements a preset of tailored statistics for many backtesting components, such as signals, returns, and portfolio.</li> </ul> Analyze the distribution of signals in a mask<pre><code>&gt;&gt;&gt; index = [datetime(2020, 1, 1) + timedelta(days=i) for i in range(7)]\n&gt;&gt;&gt; mask = pd.Series([False, True, True, True, False, True, False])\n&gt;&gt;&gt; mask.vbt.signals(freq='d').stats()\nStart                                               0\nEnd                                                 6\nPeriod                                7 days 00:00:00\nTotal                                               4\nRate [%]                                    57.142857\nFirst Index                                         1\nLast Index                                          5\nNorm Avg Index [-1, 1]                      -0.083333\nDistance: Min                         1 days 00:00:00\nDistance: Max                         2 days 00:00:00\nDistance: Mean                        1 days 08:00:00\nDistance: Std               0 days 13:51:23.063257983\nTotal Partitions                                    2\nPartition Rate [%]                               50.0\nPartition Length: Min                 1 days 00:00:00\nPartition Length: Max                 3 days 00:00:00\nPartition Length: Mean                2 days 00:00:00\nPartition Length: Std       1 days 09:56:28.051789035\nPartition Distance: Min               2 days 00:00:00\nPartition Distance: Max               2 days 00:00:00\nPartition Distance: Mean              2 days 00:00:00\nPartition Distance: Std                           NaT\ndtype: object\n</code></pre> <ul> <li> Records and mapped arrays: In-house data structures for analyzing complex data, such as simulation logs. Fully compiled with Numba.</li> </ul> Parse 5 highest slippage values from logs<pre><code>&gt;&gt;&gt; price = vbt.YFData.download('BTC-USD').get('Close')\n&gt;&gt;&gt; slippage = np.random.uniform(0, 0.005, size=close.shape[0])\n&gt;&gt;&gt; logs = vbt.Portfolio.from_random_signals(price, n=5, slippage=slippage, log=True).logs\n\n&gt;&gt;&gt; req_price_ma = logs.map_field('req_price')\n&gt;&gt;&gt; res_price_ma = logs.map_field('res_price')\n&gt;&gt;&gt; slippage_ma = (res_price_ma - req_price_ma) / req_price_ma\n&gt;&gt;&gt; slippage_ma = slippage_ma.replace(arr=np.abs(slippage_ma.values))\n&gt;&gt;&gt; top_slippage_pd = slippage_ma.top_n(5).to_pd()\n&gt;&gt;&gt; top_slippage_pd[~top_slippage_pd.isnull()]\nDate\n2017-12-25 00:00:00+00:00    0.001534\n2018-06-03 00:00:00+00:00    0.004354\n2018-12-03 00:00:00+00:00    0.004663\n2019-09-20 00:00:00+00:00    0.004217\n2020-11-28 00:00:00+00:00    0.000775\ndtype: float64\n</code></pre> <ul> <li> Trade analysis: Retrospective analysis of trades from various view points. Supports entry trades, exit trades, and positions.</li> </ul> Get the projected return of each buy order<pre><code>&gt;&gt;&gt; price = vbt.YFData.download('BTC-USD').get('Close')\n&gt;&gt;&gt; entry_trades = vbt.Portfolio.from_random_signals(price, n=5).entry_trades\n&gt;&gt;&gt; returns_pd = entry_trades.returns.to_pd()\n&gt;&gt;&gt; returns_pd[~returns_pd.isnull()]\nDate\n2017-11-12 00:00:00+00:00    0.742975\n2019-08-30 00:00:00+00:00   -0.081744\n2020-04-21 00:00:00+00:00    0.489072\n2020-09-13 00:00:00+00:00    0.262251\n2021-03-07 00:00:00+00:00   -0.382155\ndtype: float64\n</code></pre> <ul> <li> Drawdown analysis: Drawdown statistics of any numeric time series.</li> </ul> Plot 3 deepest price dips<pre><code>&gt;&gt;&gt; price = vbt.YFData.download('BTC-USD').get('Close')\n&gt;&gt;&gt; price.vbt.drawdowns.plot(top_n=3)\n</code></pre> <p></p>","title":"Analysis"},{"location":"getting-started/features/#plotting","text":"<ul> <li> Data visualization: Numerous flexible data plotting functions distributed across vectorbt.</li> </ul> Plot time series against each other<pre><code>&gt;&gt;&gt; sr1 = pd.Series(np.cumprod(np.random.normal(0, 0.01, 100) + 1))\n&gt;&gt;&gt; sr2 = pd.Series(np.cumprod(np.random.normal(0, 0.01, 100) + 1))\n&gt;&gt;&gt; sr1.vbt.plot_against(sr2)\n</code></pre> <p></p> <ul> <li> Figures and widgets: Custom interactive figures and widgets using Plotly, such as Heatmap and Volume. All custom widgets have dedicated methods for efficiently updating their state.</li> </ul> Plot a volume<pre><code>&gt;&gt;&gt; volume_widget = vbt.plotting.Volume(\n...     data=np.random.randint(1, 10, size=(3, 3, 3)),\n...     x_labels=['a', 'b', 'c'],\n...     y_labels=['d', 'e', 'f'],\n...     z_labels=['g', 'h', 'i']\n... )\n&gt;&gt;&gt; volume_widget.fig\n</code></pre> <p></p> <ul> <li> Plots builder: Class for building plots out of custom subplots. Implements a preset of tailored subplots for many backtesting components, such as signals, returns, and portfolio.</li> </ul> Plot various portfolio balances<pre><code>&gt;&gt;&gt; price = vbt.YFData.download('BTC-USD').get('Close')\n&gt;&gt;&gt; pf = vbt.Portfolio.from_random_signals(price, n=5)\n&gt;&gt;&gt; pf.plot(subplots=['cash', 'assets', 'value']).show_svg()\n</code></pre> <p></p>","title":"Plotting"},{"location":"getting-started/features/#extra","text":"<ul> <li> Notifications: Telegram bot based on Python Telegram Bot.</li> </ul> Launch a bot that returns the latest ticker on Binance<pre><code>&gt;&gt;&gt; from telegram.ext import CommandHandler\n&gt;&gt;&gt; import ccxt\n\n&gt;&gt;&gt; class BinanceTickerBot(vbt.TelegramBot):\n...     @property\n...     def custom_handlers(self):\n...         return CommandHandler('get', self.get),\n...\n...     @property\n...     def help_message(self):\n...         return \"Type /get [symbol] to get the latest ticker on Binance.\"\n...\n...     def get(self, update, context):\n...         chat_id = update.effective_chat.id\n...         try:\n...             ticker = ccxt.binance().fetchTicker(context.args[0])\n...         except Exception as e:\n...             self.send_message(chat_id, str(e))\n...             return\n...         self.send_message(chat_id, str(ticker['last']))\n\n&gt;&gt;&gt; bot = BinanceTickerBot(token='YOUR_TOKEN')\n&gt;&gt;&gt; bot.start()\n</code></pre> <ul> <li> General utilities: Scheduling using schedule, templates, decorators, configs, and more.</li> </ul> Every 10 seconds display the latest Bitcoin trades on Binance<pre><code>&gt;&gt;&gt; from vectorbt.utils.datetime_ import datetime_to_ms, to_tzaware_datetime, get_utc_tz\n&gt;&gt;&gt; from IPython.display import SVG, display, clear_output\n\n&gt;&gt;&gt; exchange = ccxt.binance()\n\n&gt;&gt;&gt; def job_func():\n...     since = datetime_to_ms(to_tzaware_datetime('10 seconds ago UTC', tz=get_utc_tz()))\n...     trades = exchange.fetch_trades('BTC/USDT', since)\n...     price = pd.Series({t['datetime']: t['price'] for t in trades})\n...     svg = price.vbt.plot().to_image(format=\"svg\")\n...     clear_output()\n...     display(SVG(svg))\n\n&gt;&gt;&gt; scheduler = vbt.ScheduleManager()\n&gt;&gt;&gt; scheduler.every(10, 'seconds').do(job_func)\n&gt;&gt;&gt; scheduler.start()\n</code></pre> <p></p> <ul> <li> Caching: Property and method decorators for caching most frequently used objects.</li> </ul> Create a cached method and disable it globally<pre><code>&gt;&gt;&gt; import time\n&gt;&gt;&gt; start = time.time()\n\n&gt;&gt;&gt; class MyClass:\n...     @vbt.cached_method\n...     def get_elapsed(self):\n...         return time.time() - start\n\n&gt;&gt;&gt; my_inst = MyClass()\n&gt;&gt;&gt; my_inst.get_elapsed()\n0.00010895729064941406\n\n&gt;&gt;&gt; my_inst.get_elapsed()\n0.00010895729064941406\n\n&gt;&gt;&gt; get_elapsed_cond = vbt.CacheCondition(instance=my_inst, func='get_elapsed')\n&gt;&gt;&gt; vbt.settings.caching['blacklist'].append(get_elapsed_cond)\n&gt;&gt;&gt; my_inst.get_elapsed()\n0.01081395149230957\n</code></pre> <ul> <li> Persistance: Most Python objects including data and portfolio can be saved to a file and retrieved back using Dill.</li> </ul> Simulate, save, and load back a portfolio<pre><code>&gt;&gt;&gt; price = vbt.YFData.download('BTC-USD').get('Close')\n&gt;&gt;&gt; pf = vbt.Portfolio.from_random_signals(price, n=5)\n&gt;&gt;&gt; pf.save('my_pf.pkl')\n\n&gt;&gt;&gt; pf = vbt.Portfolio.load('my_pf.pkl')\n&gt;&gt;&gt; pf.total_return()\n5.96813681074424\n</code></pre>","title":"Extra"},{"location":"getting-started/installation/","text":"<p>You can install vectorbt with pip, the Python package manager, or with Docker.</p>","title":"Installation"},{"location":"getting-started/installation/#with-pip","text":"<pre><code>pip install -U vectorbt\n</code></pre> <p>To also install optional dependencies:</p> <pre><code>pip install -U \"vectorbt[full]\"\n</code></pre>","title":"With pip"},{"location":"getting-started/installation/#with-docker","text":"<p>You can pull the most recent Docker image if you have Docker installed.</p> <pre><code>docker run --rm -p 8888:8888 -v \"$PWD\":/home/jovyan/work polakowo/vectorbt\n</code></pre> <p>This command pulls the latest <code>polakowo/vectorbt</code> image from Docker Hub. It then starts a container running  a Jupyter Notebook server and exposes the server on host port 8888. Visiting <code>http://127.0.0.1:8888/?token=&lt;token&gt;</code>  in a browser loads JupyterLab, where token is the secret token printed in the console. Docker destroys  the container after notebook server exit, but any files written to the working directory in the container  remain intact in the working directory on the host. See Jupyter Docker Stacks - Quick Start.</p> <p>There are two types of images: </p> <ul> <li>polakowo/vectorbt: vanilla version (default)</li> <li>polakowo/vectorbt-full: full version (with optional dependencies)</li> </ul> <p>Each Docker image is based on jupyter/scipy-notebook  and comes with Jupyter environment, vectorbt, and other scientific packages installed.</p>","title":"With Docker"},{"location":"getting-started/installation/#with-git","text":"<p>Of course, you can pull vectorbt directly from <code>git</code>:</p> <pre><code>git clone git@github.com:polakowo/vectorbt.git vectorbt\n</code></pre> <p>Install the package:</p> <pre><code>pip install -e vectorbt\n</code></pre>","title":"With git"},{"location":"getting-started/installation/#troubleshooting","text":"<ul> <li>TA-Lib support</li> <li>Jupyter Notebook and JupyterLab support</li> </ul>","title":"Troubleshooting"},{"location":"getting-started/resources/","text":"<p>Here's a collection of resources to get started.</p>","title":"Resources"},{"location":"getting-started/resources/#notebooks","text":"<ul> <li>Performance analysis of Moving Average Crossover</li> <li>Performance analysis of stop signals</li> <li>Backtesting per trading session</li> <li>Portfolio optimization</li> <li>Plotting MACD parameters as 3D volume</li> <li>Walk-forward optimization</li> <li>Running Telegram signal bot</li> <li>Porting RSI strategy from backtrader</li> <li>Pairs trading (vs backtrader)</li> </ul> <p>Note: you must run the notebook to play with the widgets.</p>","title":"Notebooks"},{"location":"getting-started/resources/#dashboards","text":"<ul> <li>Detecting and backtesting common candlestick patterns</li> </ul>","title":"Dashboards"},{"location":"getting-started/resources/#articles","text":"<ul> <li>Stop Loss, Trailing Stop, or Take Profit? 2 Million Backtests Shed Light</li> </ul>","title":"Articles"},{"location":"getting-started/resources/#getting-help","text":"<ul> <li>If you need supervision or any help with your implementation, join a private chat</li> <li>For questions on Numba and other parts, the best place to go to is StackOverflow</li> <li>If you have general questions, start a new GitHub Discussion</li> <li>Alternatively, you can ask on Gitter</li> <li>If you found what appears to be a bug, please create a new issue</li> <li>For other inquiries, please contact the author</li> </ul>","title":"Getting Help"},{"location":"getting-started/usage/","text":"<p>vectorbt allows you to easily backtest strategies with a couple of lines of Python code.</p> <ul> <li>Here is how much profit we would have made if we invested $100 into Bitcoin in 2014:</li> </ul> <pre><code>import vectorbt as vbt\n\nprice = vbt.YFData.download('BTC-USD').get('Close')\n\npf = vbt.Portfolio.from_holding(price, init_cash=100)\npf.total_profit()\n</code></pre> <pre><code>8961.008555963961\n</code></pre> <ul> <li>Buy whenever 10-day SMA crosses above 50-day SMA and sell when opposite:</li> </ul> <pre><code>fast_ma = vbt.MA.run(price, 10)\nslow_ma = vbt.MA.run(price, 50)\nentries = fast_ma.ma_crossed_above(slow_ma)\nexits = fast_ma.ma_crossed_below(slow_ma)\n\npf = vbt.Portfolio.from_signals(price, entries, exits, init_cash=100)\npf.total_profit()\n</code></pre> <pre><code>16423.251963801864\n</code></pre> <ul> <li>Generate 1,000 strategies with random signals and test them on BTC and ETH:</li> </ul> <pre><code>import numpy as np\n\nsymbols = [\"BTC-USD\", \"ETH-USD\"]\nprice = vbt.YFData.download(symbols, missing_index='drop').get('Close')\n\nn = np.random.randint(10, 101, size=1000).tolist()\npf = vbt.Portfolio.from_random_signals(price, n=n, init_cash=100, seed=42)\n\nmean_expectancy = pf.trades.expectancy().groupby(['randnx_n', 'symbol']).mean()\nfig = mean_expectancy.unstack().vbt.scatterplot(xaxis_title='randnx_n', yaxis_title='mean_expectancy')\nfig.show()\n</code></pre> <p></p> <ul> <li>For fans of hyperparameter optimization: here is a snippet for testing 10,000 window combinations of a  dual SMA crossover strategy on BTC, USD, and LTC:</li> </ul> <pre><code>symbols = [\"BTC-USD\", \"ETH-USD\", \"LTC-USD\"]\nprice = vbt.YFData.download(symbols, missing_index='drop').get('Close')\n\nwindows = np.arange(2, 101)\nfast_ma, slow_ma = vbt.MA.run_combs(price, window=windows, r=2, short_names=['fast', 'slow'])\nentries = fast_ma.ma_crossed_above(slow_ma)\nexits = fast_ma.ma_crossed_below(slow_ma)\n\npf_kwargs = dict(size=np.inf, fees=0.001, freq='1D')\npf = vbt.Portfolio.from_signals(price, entries, exits, **pf_kwargs)\n\nfig = pf.total_return().vbt.heatmap(\n    x_level='fast_window', y_level='slow_window', slider_level='symbol', symmetric=True,\n    trace_kwargs=dict(colorbar=dict(title='Total return', tickformat='%')))\nfig.show()\n</code></pre> <p></p> <p>Digging into each strategy configuration is as simple as indexing with pandas:</p> <pre><code>pf[(10, 20, 'ETH-USD')].stats()\n</code></pre> <pre><code>Start                          2015-08-07 00:00:00+00:00\nEnd                            2021-08-01 00:00:00+00:00\nPeriod                                2183 days 00:00:00\nStart Value                                        100.0\nEnd Value                                  620402.791485\nTotal Return [%]                           620302.791485\nBenchmark Return [%]                        92987.961948\nMax Gross Exposure [%]                             100.0\nTotal Fees Paid                             10991.676981\nMax Drawdown [%]                               70.734951\nMax Drawdown Duration                  760 days 00:00:00\nTotal Trades                                          54\nTotal Closed Trades                                   53\nTotal Open Trades                                      1\nOpen Trade PnL                              67287.940601\nWin Rate [%]                                   52.830189\nBest Trade [%]                               1075.803607\nWorst Trade [%]                               -29.593414\nAvg Winning Trade [%]                          95.695343\nAvg Losing Trade [%]                          -11.890246\nAvg Winning Trade Duration    35 days 23:08:34.285714286\nAvg Losing Trade Duration                8 days 00:00:00\nProfit Factor                                   2.651143\nExpectancy                                   10434.24247\nSharpe Ratio                                    2.041211\nCalmar Ratio                                      4.6747\nOmega Ratio                                     1.547013\nSortino Ratio                                   3.519894\nName: (10, 20, ETH-USD), dtype: object\n</code></pre> <p>The same for plotting:</p> <pre><code>pf[(10, 20, 'ETH-USD')].plot().show()\n</code></pre> <p></p> <p>It's not all about backtesting - vectorbt can be used to facilitate financial data analysis and visualization.</p> <ul> <li>Let's generate a GIF that animates the %B and bandwidth of Bollinger Bands for different symbols:</li> </ul> <pre><code>symbols = [\"BTC-USD\", \"ETH-USD\", \"ADA-USD\"]\nprice = vbt.YFData.download(symbols, period='6mo', missing_index='drop').get('Close')\nbbands = vbt.BBANDS.run(price)\n\ndef plot(index, bbands):\n    bbands = bbands.loc[index]\n    fig = vbt.make_subplots(\n        rows=2, cols=1, shared_xaxes=True, vertical_spacing=0.15,\n        subplot_titles=('%B', 'Bandwidth'))\n    fig.update_layout(template='vbt_dark', showlegend=False, width=750, height=400)\n    bbands.percent_b.vbt.ts_heatmap(\n        trace_kwargs=dict(zmin=0, zmid=0.5, zmax=1, colorscale='Spectral', colorbar=dict(\n            y=(fig.layout.yaxis.domain[0] + fig.layout.yaxis.domain[1]) / 2, len=0.5\n        )), add_trace_kwargs=dict(row=1, col=1), fig=fig)\n    bbands.bandwidth.vbt.ts_heatmap(\n        trace_kwargs=dict(colorbar=dict(\n            y=(fig.layout.yaxis2.domain[0] + fig.layout.yaxis2.domain[1]) / 2, len=0.5\n        )), add_trace_kwargs=dict(row=2, col=1), fig=fig)\n    return fig\n\nvbt.save_animation('bbands.gif', bbands.wrapper.index, plot, bbands, delta=90, step=3, fps=3)\n</code></pre> <pre><code>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 31/31 [00:21&lt;00:00,  1.21it/s]\n</code></pre> <p></p> <p>And this is just the tip of the iceberg of what's possible. Check out Resources to learn more.</p>","title":"Usage"},{"location":"terms/","text":"<p>This work is fair-code distributed under  Apache 2.0 with Commons Clause license.  The source code is open and everyone (individuals and organizations) can use it for free.  However, it is not allowed to sell products and services that are mostly just this software.</p> <p>If you have any questions about this or want to apply for a license exception,  please contact the author.</p> <p>Installing optional dependencies may be subject to a more restrictive license.</p>","title":"Terms"},{"location":"terms/license/","text":"","title":"License"},{"location":"terms/license/#commons-clause","text":"<p>\u201cCommons Clause\u201d License Condition v1.0</p> <p>The Software is provided to you by the Licensor under the License, as defined below, subject to the following condition.</p> <p>Without limiting other conditions in the License, the grant of rights under the License will not include, and the License does not grant to you, the right to Sell the Software.</p> <p>For purposes of the foregoing, \u201cSell\u201d means practicing any or all of the rights granted to you under the License to provide to third parties, for a fee or other consideration (including without limitation fees for hosting or consulting/ support services related to the Software), a product or service whose value derives, entirely or substantially, from the functionality of the Software. Any license notice or attribution required by the License must also include this Commons Clause License Condition notice.</p> <p>Software: vectorbt</p> <p>License: Apache 2.0 with Commons Clause</p> <p>Licensor: Oleg Polakow</p>","title":"Commons Clause"},{"location":"terms/license/#apache-20","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright 2020 Oleg Polakow</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>","title":"Apache 2.0"}]}