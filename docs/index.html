<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>vectorbt API documentation</title>
<meta name="description" content="Ultimate Python library for time series analysis and backtesting at scale …" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8}.hljs{padding:1.25rem 1.5rem;margin-left:-15px;margin-right:-15px;border:1px solid #eee;border-radius:6px;background:#282c34 !important;color:#9da29e !important}.python{color:#c5c8c6 !important}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word;font-size:90%}h1 code{background:transparent}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #e82}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}#search_input{display:inline-block;width:100%;height:40px;padding:.375rem .75rem;font-size:1rem;line-height:1.5;color:white;background:#282c34 !important;border:none;border-radius:6px;border-bottom:1px solid #e82;outline:none}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none;border-radius:6px}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#e82}#sidebar{background:#3B4556}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex;color:#abb2bf}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-142521178-3', 'auto'); ga('send', 'pageview');
</script><script async src='https://www.google-analytics.com/analytics.js'></script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#e82}.homelink img{max-width:128px;max-height:128px;margin:auto;margin-bottom:.3em}</style>
<link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-16x16.png">
<link rel="manifest" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/site.webmanifest">
<link rel="mask-icon" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>vectorbt</code></h1>
</header>
<section id="section-intro">
<p>Ultimate Python library for time series analysis and backtesting at scale.</p>
<p>While there are many great backtesting packages for Python, vectorbt combines an extremely fast backtester
and a data science tool: it excels at processing performance and offers interactive tools to explore complex
phenomena in trading. With it, you can traverse a huge number of strategy configurations, time periods, and
instruments in little time, to explore where your strategy performs best and to uncover hidden patterns in data.
Accessing and analyzing this information for yourself could give you an information advantage in your own trading.</p>
<h2 id="how-it-works">How it works?</h2>
<p>vectorbt was implemented to address common performance shortcomings of backtesting libraries.
It builds upon the idea that each instance of a trading strategy can be represented in a vectorized form,
so multiple strategy instances can be packed into a single multi-dimensional array, processed in a highly
efficient manner, and compared easily. It overhauls the traditional OOP approach that represents strategies
as classes or other data structures, which are easier to write and extend compared to vectors, but harder to
analyze and also require additional effort to do it quickly.</p>
<p>Thanks to the time-series nature of trading data, most of the aspects related to backtesting can be translated
into vectors. Instead of processing one element at a time, vectorization allows us to avoid naive
looping and perform the same operation on all elements at the same time. The path-dependency problem
related to vectorization is solved by using Numba - it allows both writing iterative code and compiling slow
Python loops to be run at the native machine code speed.</p>
<h2 id="performance">Performance</h2>
<p>While it might seem tempting to perform all sorts of computations with pandas alone, the NumPy+Numba combo
outperforms pandas significantly:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; big_ts = pd.DataFrame(np.random.uniform(size=(1000, 1000)))

&gt;&gt;&gt; %timeit big_ts.pct_change()
280 ms ± 12.6 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit big_ts.vbt.pct_change()
5.95 ms ± 380 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</code></pre>
<p>But also pandas functions already compiled with Cython/Numba are often slower:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; %timeit big_ts.expanding().max()
48.4 ms ± 557 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)

&gt;&gt;&gt; %timeit big_ts.vbt.expanding_max()
8.82 ms ± 121 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</code></pre>
<p>Moreover, pandas functions cannot be accessed within user-defined Numba code, since Numba cannot do any
compilation on pandas objects. Take for example generating trailing stop orders: to calculate expanding
maximum for each order, we cannot simply do <code>df.expanding().max()</code> from within Numba, but we must write
and compile our own expanding max function wrapped with <code>@njit</code>. That's why vectorbt provides an arsenal
of Numba-compiled functions for any sort of task.</p>
<h2 id="usability">Usability</h2>
<p>From the user's perspective, working with NumPy and Numba alone is not easy, since important information
in form of index and columns and all typing checks must be explicitly handled by the user,
making analysis prone to errors. That's why vectorbt introduces a namespace (accessor) to pandas objects
(see <a href="https://pandas.pydata.org/pandas-docs/stable/development/extending.html">extending pandas</a>).
This way, user can easily switch between pandas and vectorbt functionality. Moreover, each vectorbt
method is flexible towards input and can work on both Series and DataFrames.</p>
<p>Another argument against using exclusively NumPy is iterative code: sometimes vectorized implementation is hard
to read or cannot be properly defined at all, and one must rely on an iterative approach instead -
processing data in an element-by-element fashion. That's where Numba comes into play.</p>
<p>The <a href="https://github.com/polakowo/vectorbt/tree/9f270820dd3e5dc4ff5468dbcc14a29c4f45f557">previous versions</a>
of vectorbt were written in pure NumPy, which resulted in more performance but less usability.</p>
<h3 id="indexing">Indexing</h3>
<p>vectorbt makes use of <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/advanced.html">hierarchical indexing</a>
to store valuable information on each backtest. Take a simple crossover strategy as example:
it depends on the size of the fast and slow windows, and other hyperparameters such as whether
it is SMA or EMA. Each of these hyperparameters becomes an additional dimension for manipulating data
and gets stored as a separate column level. Below is an example of a column hierarchy for MACD:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; macd = vbt.MACD.run(
...     pd.Series([1, 2, 3, 4, 3, 2, 1]),
...     fast_window=(2, 3),
...     slow_window=(3, 4),
...     signal_window=(2, 3),
...     macd_ewm=(True, False),
...     signal_ewm=(False, True)
... )

&gt;&gt;&gt; macd.signal
macd_fast_window           2         3
macd_slow_window           3         4
macd_signal_window         2         3
macd_macd_ewm           True     False
macd_signal_ewm        False      True
0                        NaN       NaN
1                        NaN       NaN
2                        NaN       NaN
3                   0.349537       NaN
4                   0.251929       NaN
5                  -0.014982  0.208333
6                  -0.221140 -0.145833
</code></pre>
<p>Columns here capture different strategy configurations that can now be easily analyzed and compared.
We might, for example, consider grouping our performance by <code>macd_fast_window</code> to see how the size of
the fast window impacts profitability of the strategy.</p>
<p>The other advantage of vectorbt is that it ensures that the column hierarchy is preserved across
the whole backtesting pipeline - from signal generation to performance modeling.</p>
<h3 id="broadcasting">Broadcasting</h3>
<p>vectobt borrows broadcasting rules from NumPy. For example, consider the following objects:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; sr = pd.Series([1, 2, 3], index=['x', 'y', 'z'])
&gt;&gt;&gt; sr
x    1
y    2
z    3
dtype: int64

&gt;&gt;&gt; df = pd.DataFrame([[4, 5, 6]], index=['x', 'y', 'z'], columns=['a', 'b', 'c'])
&gt;&gt;&gt; df
   a  b  c
x  4  5  6
y  4  5  6
z  4  5  6
</code></pre>
<p>Despite both having the same index, pandas won't add them correctly:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; sr + df  # pandas
    a   b   c   x   y   z
x NaN NaN NaN NaN NaN NaN
y NaN NaN NaN NaN NaN NaN
z NaN NaN NaN NaN NaN NaN
</code></pre>
<p>And here is the expected result using vectorbt:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; sr.vbt + df  # vectorbt
   a  b  c
x  5  6  7
y  6  7  8
z  7  8  9
</code></pre>
<p>In case where index or columns in both objects are different, they are stacked upon each other:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; df2 = pd.DataFrame([[4, 5, 6]], index=['x', 'y', 'z'], columns=['a2', 'b2', 'c2'])
&gt;&gt;&gt; df2
   a2  b2  c2
x   4   5   6
y   4   5   6
z   4   5   6

&gt;&gt;&gt; df + df2  # pandas
    a  a2   b  b2   c  c2
x NaN NaN NaN NaN NaN NaN
y NaN NaN NaN NaN NaN NaN
z NaN NaN NaN NaN NaN NaN

&gt;&gt;&gt; df.vbt + df2  # vectorbt
   a   b   c
  a2  b2  c2
x  8  10  12
y  8  10  12
z  8  10  12
</code></pre>
<p>This way, we can perform operations on objects of arbitrary broadcastable shapes and still
preserve their individual information. This is handy for combining DataFrames with lots of metadata,
such as indicators or signals with many hyperparameters.</p>
<p>Another feature of vectorbt is that it can broadcast objects with incompatible shapes but common
multi-index levels - those having the same name, or being without name but having overlapping values.</p>
<p>For example:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; df3 = pd.DataFrame(
...     [[7, 8, 9, 10, 11, 12]],
...     index=['x', 'y', 'z'],
...     columns=pd.MultiIndex.from_tuples([
...         (1, 'a'),
...         (1, 'b'),
...         (1, 'c'),
...         (2, 'a'),
...         (2, 'b'),
...         (2, 'c'),
...     ]))
&gt;&gt;&gt; df3
   1         2
   a  b  c   a   b   c
x  7  8  9  10  11  12
y  7  8  9  10  11  12
z  7  8  9  10  11  12

&gt;&gt;&gt; df + df3  # pandas
ValueError: cannot join with no overlapping index names

&gt;&gt;&gt; df.vbt + df3  # vectorbt
    1           2
    a   b   c   a   b   c
x  11  13  15  14  16  18
y  11  13  15  14  16  18
z  11  13  15  14  16  18
</code></pre>
<h2 id="example">Example</h2>
<p>To better understand how these concepts fit together, consider the following example.</p>
<p>We have a complex strategy that has lots of (hyper-)parameters that have to be tuned. While
brute-forcing all combinations seems to be a rather unrealistic attempt, we can still interpolate, and
vectorbt makes exactly this possible. It doesn't care whether we have one strategy instance or millions.
As soon as their vectors can be concatenated into a matrix and we have enough memory, we can analyze
them in one go.</p>
<p>Let's start with fetching the daily price of Bitcoin:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; # Prepare data
&gt;&gt;&gt; start = datetime(2019, 1, 1)
&gt;&gt;&gt; end = datetime(2020, 1, 1)
&gt;&gt;&gt; btc_price = vbt.YFData.download('BTC-USD', start=start, end=end).get('Close')

&gt;&gt;&gt; btc_price
Date
2019-01-01    3843.520020
2019-01-02    3943.409424
2019-01-03    3836.741211
...                   ...
2019-12-30    7292.995117
2019-12-31    7193.599121
2020-01-01    7200.174316
Name: Close, Length: 366, dtype: float64
</code></pre>
<p>We are going to test a simple Dual Moving Average Crossover (DMAC) strategy. For this, we are going to
use <code><a title="vectorbt.indicators.basic.MA" href="indicators/basic.html#vectorbt.indicators.basic.MA">MA</a></code> class for calculating moving averages and generating signals.</p>
<p>Our first test is rather simple: buy when the 10-day moving average crosses above the 20-day moving
average, and sell when opposite.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; fast_ma = vbt.MA.run(btc_price, 10, short_name='fast')
&gt;&gt;&gt; slow_ma = vbt.MA.run(btc_price, 20, short_name='slow')

&gt;&gt;&gt; entries = fast_ma.ma_above(slow_ma, crossover=True)
&gt;&gt;&gt; entries
Date
2019-01-01    False
2019-01-02    False
2019-01-03    False
...             ...
2019-12-30    False
2019-12-31    False
2020-01-01    False
Length: 366, dtype: bool

&gt;&gt;&gt; exits = fast_ma.ma_below(slow_ma, crossover=True)
&gt;&gt;&gt; exits
Date
2019-01-01    False
2019-01-02    False
2019-01-03    False
...             ...
2019-12-30    False
2019-12-31    False
2020-01-01    False
Length: 366, dtype: bool

&gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(btc_price, entries, exits)
&gt;&gt;&gt; portfolio.total_return()
0.636680693047752
</code></pre>
<p>One strategy instance of DMAC produced one column in signals and one performance value.</p>
<p>Adding one more strategy instance is as simple as adding a new column. Here we are passing an array of
window sizes instead of a single value. For each window size in this array, it computes a moving
average over the entire price series and stores it as a distinct column.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Multiple strategy instances: (10, 30) and (20, 30)
&gt;&gt;&gt; fast_ma = vbt.MA.run(btc_price, [10, 20], short_name='fast')
&gt;&gt;&gt; slow_ma = vbt.MA.run(btc_price, [30, 30], short_name='slow')

&gt;&gt;&gt; entries = fast_ma.ma_above(slow_ma, crossover=True)
&gt;&gt;&gt; entries
fast_window     10     20
slow_window     30     30
Date
2019-01-01   False  False
2019-01-02   False  False
2019-01-03   False  False
...            ...    ...
2019-12-30   False  False
2019-12-31   False  False
2020-01-01   False  False

[366 rows x 2 columns]

&gt;&gt;&gt; exits = fast_ma.ma_below(slow_ma, crossover=True)
&gt;&gt;&gt; exits
fast_window     10     20
slow_window     30     30
Date
2019-01-01   False  False
2019-01-02   False  False
2019-01-03   False  False
...            ...    ...
2019-12-30   False  False
2019-12-31   False  False
2020-01-01   False  False

[366 rows x 2 columns]

&gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(btc_price, entries, exits)
&gt;&gt;&gt; portfolio.total_return()
fast_window  slow_window
10           30             0.848840
20           30             0.543411
Name: total_return, dtype: float64
</code></pre>
<p>For the sake of convenience, vectorbt has created the column levels <code>fast_window</code> and <code>slow_window</code> for us
to easily distinguish which window size corresponds to which column.</p>
<p>Notice how signal generation part remains the same for each example - most functions in vectorbt work on
time series of any shape. This allows creation of analysis pipelines that are universal to input data.</p>
<p>The representation of different features as columns offers endless possibilities for backtesting.
We could, for example, go a step further and conduct the same tests for Ethereum. To compare both instruments,
combine price series for Bitcoin and Ethereum into one DataFrame and run the same backtesting pipeline.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Multiple strategy instances and instruments
&gt;&gt;&gt; eth_price = vbt.YFData.download('ETH-USD', start=start, end=end).get('Close')
&gt;&gt;&gt; comb_price = btc_price.vbt.concat(eth_price,
...     keys=pd.Index(['BTC', 'ETH'], name='symbol'))
&gt;&gt;&gt; comb_price.vbt.drop_levels(-1, inplace=True)
&gt;&gt;&gt; comb_price
symbol              BTC         ETH
Date
2019-01-01  3843.520020  140.819412
2019-01-02  3943.409424  155.047684
2019-01-03  3836.741211  149.135010
...                 ...         ...
2019-12-30  7292.995117  132.633484
2019-12-31  7193.599121  129.610855
2020-01-01  7200.174316  130.802002

[366 rows x 2 columns]

&gt;&gt;&gt; fast_ma = vbt.MA.run(comb_price, [10, 20], short_name='fast')
&gt;&gt;&gt; slow_ma = vbt.MA.run(comb_price, [30, 30], short_name='slow')

&gt;&gt;&gt; entries = fast_ma.ma_above(slow_ma, crossover=True)
&gt;&gt;&gt; entries
fast_window            10            20
slow_window            30            30
symbol         BTC    ETH    BTC    ETH
Date
2019-01-01   False  False  False  False
2019-01-02   False  False  False  False
2019-01-03   False  False  False  False
...            ...    ...    ...    ...
2019-12-30   False  False  False  False
2019-12-31   False  False  False  False
2020-01-01   False  False  False  False

[366 rows x 4 columns]

&gt;&gt;&gt; exits = fast_ma.ma_below(slow_ma, crossover=True)
&gt;&gt;&gt; exits
fast_window            10            20
slow_window            30            30
symbol         BTC    ETH    BTC    ETH
Date
2019-01-01   False  False  False  False
2019-01-02   False  False  False  False
2019-01-03   False  False  False  False
...            ...    ...    ...    ...
2019-12-30   False  False  False  False
2019-12-31   False  False  False  False
2020-01-01   False  False  False  False

[366 rows x 4 columns]

&gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(comb_price, entries, exits)
&gt;&gt;&gt; portfolio.total_return()
fast_window  slow_window  symbol
10           30           BTC       0.848840
                          ETH       0.244204
20           30           BTC       0.543411
                          ETH      -0.319102
Name: total_return, dtype: float64

&gt;&gt;&gt; mean_return = portfolio.total_return().groupby('symbol').mean()
&gt;&gt;&gt; mean_return.vbt.barplot(xaxis_title='Symbol', yaxis_title='Mean total return')
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/index_by_symbol.png"></p>
<p>Not only strategies and instruments can act as separate features, but also time. If we want to find out
when our strategy performs best, it's reasonable to test it over multiple time periods. vectorbt allows
us to split one time period into many, given they have the same length and frequency, and represent
them as distinct columns. For example, let's split the whole time period into two equal time periods
and backest them at once.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Multiple strategy instances, instruments, and time periods
&gt;&gt;&gt; mult_comb_price, _ = comb_price.vbt.range_split(n=2)
&gt;&gt;&gt; mult_comb_price
split_idx                         0                         1
symbol              BTC         ETH           BTC         ETH
0           3843.520020  140.819412  11961.269531  303.099976
1           3943.409424  155.047684  11215.437500  284.523224
2           3836.741211  149.135010  10978.459961  287.997528
...                 ...         ...           ...         ...
180        10817.155273  290.695984   7292.995117  132.633484
181        10583.134766  293.641113   7193.599121  129.610855
182        10801.677734  291.596436   7200.174316  130.802002

[183 rows x 4 columns]

&gt;&gt;&gt; fast_ma = vbt.MA.run(mult_comb_price, [10, 20], short_name='fast')
&gt;&gt;&gt; slow_ma = vbt.MA.run(mult_comb_price, [30, 30], short_name='slow')

&gt;&gt;&gt; entries = fast_ma.ma_above(slow_ma, crossover=True)
&gt;&gt;&gt; exits = fast_ma.ma_below(slow_ma, crossover=True)

&gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(mult_comb_price, entries, exits, freq='1D')
&gt;&gt;&gt; portfolio.total_return()
fast_window  slow_window  split_idx  symbol
10           30           0          BTC       1.632259
                                     ETH       0.946786
                          1          BTC      -0.288720
                                     ETH      -0.308387
20           30           0          BTC       1.721449
                                     ETH       0.343274
                          1          BTC      -0.418280
                                     ETH      -0.257947
Name: total_return, dtype: float64
</code></pre>
<p>Notice how index is no more datetime-like, since it captures multiple time periods.
That's why it's required here to pass the frequency <code>freq</code> to the <code><a title="vectorbt.portfolio.base.Portfolio" href="portfolio/base.html#vectorbt.portfolio.base.Portfolio">Portfolio</a></code>
class method in order to be able to compute performance metrics such as the Sharpe ratio.</p>
<p>The index hierarchy of the final performance series can be then used to group the performance
by any feature, such as window pair, symbol, and time period.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; mean_return = portfolio.total_return().groupby(['split_idx', 'symbol']).mean()
&gt;&gt;&gt; mean_return.unstack(level=-1).vbt.barplot(
...     xaxis_title='Split index',
...     yaxis_title='Mean total return',
...     legend_title_text='Symbol')
</code></pre>
<p><img alt="" src="/vectorbt/docs/img/index_by_any.png"></p>
<p>There is much more to backtesting than simply stacking columns: vectorbt offers functions for
most parts of a backtesting pipeline, from building indicators and generating signals, to
modeling portfolio performance and visualizing results.</p>
<h2 id="resources">Resources</h2>
<h3 id="notebooks">Notebooks</h3>
<ul>
<li><a href="https://nbviewer.jupyter.org/github/polakowo/vectorbt/blob/master/examples/BitcoinDMAC.ipynb">Assessing performance of DMAC on Bitcoin</a></li>
<li><a href="https://nbviewer.jupyter.org/github/polakowo/vectorbt/blob/master/examples/StopSignals.ipynb">Comparing effectiveness of stop signals</a></li>
<li><a href="https://nbviewer.jupyter.org/github/polakowo/vectorbt/blob/master/examples/TradingSessions.ipynb">Backtesting per trading session</a></li>
<li><a href="https://nbviewer.jupyter.org/github/polakowo/vectorbt/blob/master/examples/PortfolioOptimization.ipynb">Portfolio optimization</a></li>
<li><a href="https://nbviewer.jupyter.org/github/polakowo/vectorbt/blob/master/examples/MACDVolume.ipynb">Plotting MACD parameters as 3D volume</a></li>
<li><a href="https://nbviewer.jupyter.org/github/polakowo/vectorbt/blob/master/examples/WalkForwardOptimization.ipynb">Walk-forward optimization</a></li>
<li><a href="https://nbviewer.jupyter.org/github/polakowo/vectorbt/blob/master/examples/TelegramSignals.ipynb">Running Telegram bot to send signals</a></li>
<li><a href="https://nbviewer.jupyter.org/github/polakowo/vectorbt/blob/master/examples/PortingBTStrategy.ipynb">Porting a backtrader strategy</a></li>
</ul>
<p>Note: you must run the notebook to play with the widgets.</p>
<h3 id="dashboards">Dashboards</h3>
<ul>
<li><a href="https://github.com/polakowo/vectorbt/tree/master/apps/candlestick-patterns">Detecting and backtesting common candlestick patterns</a></li>
</ul>
<h3 id="articles">Articles</h3>
<ul>
<li><a href="https://polakowo.medium.com/stop-loss-trailing-stop-or-take-profit-2-million-backtests-shed-light-dde23bda40be">Stop Loss, Trailing Stop, or Take Profit? 2 Million Backtests Shed Light</a></li>
</ul>
<h2 id="disclaimer">Disclaimer</h2>
<p>This software is for educational purposes only. Do not risk money which you are afraid to lose.
USE THE SOFTWARE AT YOUR OWN RISK. THE AUTHORS AND ALL AFFILIATES ASSUME NO RESPONSIBILITY FOR YOUR TRADING RESULTS.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Ultimate Python library for time series analysis and backtesting at scale.

While there are many great backtesting packages for Python, vectorbt combines an extremely fast backtester 
and a data science tool: it excels at processing performance and offers interactive tools to explore complex 
phenomena in trading. With it, you can traverse a huge number of strategy configurations, time periods, and 
instruments in little time, to explore where your strategy performs best and to uncover hidden patterns in data. 
Accessing and analyzing this information for yourself could give you an information advantage in your own trading.

## How it works?

vectorbt was implemented to address common performance shortcomings of backtesting libraries.
It builds upon the idea that each instance of a trading strategy can be represented in a vectorized form,
so multiple strategy instances can be packed into a single multi-dimensional array, processed in a highly
efficient manner, and compared easily. It overhauls the traditional OOP approach that represents strategies
as classes or other data structures, which are easier to write and extend compared to vectors, but harder to 
analyze and also require additional effort to do it quickly.

Thanks to the time-series nature of trading data, most of the aspects related to backtesting can be translated
into vectors. Instead of processing one element at a time, vectorization allows us to avoid naive
looping and perform the same operation on all elements at the same time. The path-dependency problem
related to vectorization is solved by using Numba - it allows both writing iterative code and compiling slow
Python loops to be run at the native machine code speed.

## Performance

While it might seem tempting to perform all sorts of computations with pandas alone, the NumPy+Numba combo
outperforms pandas significantly:

```python-repl
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; big_ts = pd.DataFrame(np.random.uniform(size=(1000, 1000)))

&gt;&gt;&gt; %timeit big_ts.pct_change()
280 ms ± 12.6 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit big_ts.vbt.pct_change()
5.95 ms ± 380 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

But also pandas functions already compiled with Cython/Numba are often slower:

```python-repl
&gt;&gt;&gt; %timeit big_ts.expanding().max()
48.4 ms ± 557 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)

&gt;&gt;&gt; %timeit big_ts.vbt.expanding_max()
8.82 ms ± 121 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

Moreover, pandas functions cannot be accessed within user-defined Numba code, since Numba cannot do any
compilation on pandas objects. Take for example generating trailing stop orders: to calculate expanding
maximum for each order, we cannot simply do `df.expanding().max()` from within Numba, but we must write
and compile our own expanding max function wrapped with `@njit`. That&#39;s why vectorbt provides an arsenal
of Numba-compiled functions for any sort of task.

## Usability

From the user&#39;s perspective, working with NumPy and Numba alone is not easy, since important information
in form of index and columns and all typing checks must be explicitly handled by the user,
making analysis prone to errors. That&#39;s why vectorbt introduces a namespace (accessor) to pandas objects
(see [extending pandas](https://pandas.pydata.org/pandas-docs/stable/development/extending.html)).
This way, user can easily switch between pandas and vectorbt functionality. Moreover, each vectorbt
method is flexible towards input and can work on both Series and DataFrames.

Another argument against using exclusively NumPy is iterative code: sometimes vectorized implementation is hard
to read or cannot be properly defined at all, and one must rely on an iterative approach instead -
processing data in an element-by-element fashion. That&#39;s where Numba comes into play.

The [previous versions](https://github.com/polakowo/vectorbt/tree/9f270820dd3e5dc4ff5468dbcc14a29c4f45f557)
of vectorbt were written in pure NumPy, which resulted in more performance but less usability.

### Indexing

vectorbt makes use of [hierarchical indexing](https://pandas.pydata.org/pandas-docs/stable/user_guide/advanced.html)
to store valuable information on each backtest. Take a simple crossover strategy as example:
it depends on the size of the fast and slow windows, and other hyperparameters such as whether
it is SMA or EMA. Each of these hyperparameters becomes an additional dimension for manipulating data
and gets stored as a separate column level. Below is an example of a column hierarchy for MACD:

```python-repl
&gt;&gt;&gt; macd = vbt.MACD.run(
...     pd.Series([1, 2, 3, 4, 3, 2, 1]),
...     fast_window=(2, 3),
...     slow_window=(3, 4),
...     signal_window=(2, 3),
...     macd_ewm=(True, False),
...     signal_ewm=(False, True)
... )

&gt;&gt;&gt; macd.signal
macd_fast_window           2         3
macd_slow_window           3         4
macd_signal_window         2         3
macd_macd_ewm           True     False
macd_signal_ewm        False      True
0                        NaN       NaN
1                        NaN       NaN
2                        NaN       NaN
3                   0.349537       NaN
4                   0.251929       NaN
5                  -0.014982  0.208333
6                  -0.221140 -0.145833
```

Columns here capture different strategy configurations that can now be easily analyzed and compared.
We might, for example, consider grouping our performance by `macd_fast_window` to see how the size of
the fast window impacts profitability of the strategy.

The other advantage of vectorbt is that it ensures that the column hierarchy is preserved across
the whole backtesting pipeline - from signal generation to performance modeling.

### Broadcasting

vectobt borrows broadcasting rules from NumPy. For example, consider the following objects:

```python-repl
&gt;&gt;&gt; sr = pd.Series([1, 2, 3], index=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;])
&gt;&gt;&gt; sr
x    1
y    2
z    3
dtype: int64

&gt;&gt;&gt; df = pd.DataFrame([[4, 5, 6]], index=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;], columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])
&gt;&gt;&gt; df
   a  b  c
x  4  5  6
y  4  5  6
z  4  5  6
```

Despite both having the same index, pandas won&#39;t add them correctly:

```python-repl
&gt;&gt;&gt; sr + df  # pandas
    a   b   c   x   y   z
x NaN NaN NaN NaN NaN NaN
y NaN NaN NaN NaN NaN NaN
z NaN NaN NaN NaN NaN NaN
```

And here is the expected result using vectorbt:

```python-repl
&gt;&gt;&gt; sr.vbt + df  # vectorbt
   a  b  c
x  5  6  7
y  6  7  8
z  7  8  9
```

In case where index or columns in both objects are different, they are stacked upon each other:

```python-repl
&gt;&gt;&gt; df2 = pd.DataFrame([[4, 5, 6]], index=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;], columns=[&#39;a2&#39;, &#39;b2&#39;, &#39;c2&#39;])
&gt;&gt;&gt; df2
   a2  b2  c2
x   4   5   6
y   4   5   6
z   4   5   6

&gt;&gt;&gt; df + df2  # pandas
    a  a2   b  b2   c  c2
x NaN NaN NaN NaN NaN NaN
y NaN NaN NaN NaN NaN NaN
z NaN NaN NaN NaN NaN NaN

&gt;&gt;&gt; df.vbt + df2  # vectorbt
   a   b   c
  a2  b2  c2
x  8  10  12
y  8  10  12
z  8  10  12
```

This way, we can perform operations on objects of arbitrary broadcastable shapes and still
preserve their individual information. This is handy for combining DataFrames with lots of metadata,
such as indicators or signals with many hyperparameters.

Another feature of vectorbt is that it can broadcast objects with incompatible shapes but common
multi-index levels - those having the same name, or being without name but having overlapping values.

For example:

```python-repl
&gt;&gt;&gt; df3 = pd.DataFrame(
...     [[7, 8, 9, 10, 11, 12]],
...     index=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;],
...     columns=pd.MultiIndex.from_tuples([
...         (1, &#39;a&#39;),
...         (1, &#39;b&#39;),
...         (1, &#39;c&#39;),
...         (2, &#39;a&#39;),
...         (2, &#39;b&#39;),
...         (2, &#39;c&#39;),
...     ]))
&gt;&gt;&gt; df3
   1         2
   a  b  c   a   b   c
x  7  8  9  10  11  12
y  7  8  9  10  11  12
z  7  8  9  10  11  12

&gt;&gt;&gt; df + df3  # pandas
ValueError: cannot join with no overlapping index names

&gt;&gt;&gt; df.vbt + df3  # vectorbt
    1           2
    a   b   c   a   b   c
x  11  13  15  14  16  18
y  11  13  15  14  16  18
z  11  13  15  14  16  18
```

## Example

To better understand how these concepts fit together, consider the following example.

We have a complex strategy that has lots of (hyper-)parameters that have to be tuned. While
brute-forcing all combinations seems to be a rather unrealistic attempt, we can still interpolate, and
vectorbt makes exactly this possible. It doesn&#39;t care whether we have one strategy instance or millions.
As soon as their vectors can be concatenated into a matrix and we have enough memory, we can analyze
them in one go.

Let&#39;s start with fetching the daily price of Bitcoin:

```python-repl
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; import vectorbt as vbt

&gt;&gt;&gt; # Prepare data
&gt;&gt;&gt; start = datetime(2019, 1, 1)
&gt;&gt;&gt; end = datetime(2020, 1, 1)
&gt;&gt;&gt; btc_price = vbt.YFData.download(&#39;BTC-USD&#39;, start=start, end=end).get(&#39;Close&#39;)

&gt;&gt;&gt; btc_price
Date
2019-01-01    3843.520020
2019-01-02    3943.409424
2019-01-03    3836.741211
...                   ...
2019-12-30    7292.995117
2019-12-31    7193.599121
2020-01-01    7200.174316
Name: Close, Length: 366, dtype: float64
```

We are going to test a simple Dual Moving Average Crossover (DMAC) strategy. For this, we are going to
use `vectorbt.indicators.basic.MA` class for calculating moving averages and generating signals.

Our first test is rather simple: buy when the 10-day moving average crosses above the 20-day moving
average, and sell when opposite.

```python-repl
&gt;&gt;&gt; fast_ma = vbt.MA.run(btc_price, 10, short_name=&#39;fast&#39;)
&gt;&gt;&gt; slow_ma = vbt.MA.run(btc_price, 20, short_name=&#39;slow&#39;)

&gt;&gt;&gt; entries = fast_ma.ma_above(slow_ma, crossover=True)
&gt;&gt;&gt; entries
Date
2019-01-01    False
2019-01-02    False
2019-01-03    False
...             ...
2019-12-30    False
2019-12-31    False
2020-01-01    False
Length: 366, dtype: bool

&gt;&gt;&gt; exits = fast_ma.ma_below(slow_ma, crossover=True)
&gt;&gt;&gt; exits
Date
2019-01-01    False
2019-01-02    False
2019-01-03    False
...             ...
2019-12-30    False
2019-12-31    False
2020-01-01    False
Length: 366, dtype: bool

&gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(btc_price, entries, exits)
&gt;&gt;&gt; portfolio.total_return()
0.636680693047752
```

One strategy instance of DMAC produced one column in signals and one performance value.

Adding one more strategy instance is as simple as adding a new column. Here we are passing an array of
window sizes instead of a single value. For each window size in this array, it computes a moving
average over the entire price series and stores it as a distinct column.

```python-repl
&gt;&gt;&gt; # Multiple strategy instances: (10, 30) and (20, 30)
&gt;&gt;&gt; fast_ma = vbt.MA.run(btc_price, [10, 20], short_name=&#39;fast&#39;)
&gt;&gt;&gt; slow_ma = vbt.MA.run(btc_price, [30, 30], short_name=&#39;slow&#39;)

&gt;&gt;&gt; entries = fast_ma.ma_above(slow_ma, crossover=True)
&gt;&gt;&gt; entries
fast_window     10     20
slow_window     30     30
Date
2019-01-01   False  False
2019-01-02   False  False
2019-01-03   False  False
...            ...    ...
2019-12-30   False  False
2019-12-31   False  False
2020-01-01   False  False

[366 rows x 2 columns]

&gt;&gt;&gt; exits = fast_ma.ma_below(slow_ma, crossover=True)
&gt;&gt;&gt; exits
fast_window     10     20
slow_window     30     30
Date
2019-01-01   False  False
2019-01-02   False  False
2019-01-03   False  False
...            ...    ...
2019-12-30   False  False
2019-12-31   False  False
2020-01-01   False  False

[366 rows x 2 columns]

&gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(btc_price, entries, exits)
&gt;&gt;&gt; portfolio.total_return()
fast_window  slow_window
10           30             0.848840
20           30             0.543411
Name: total_return, dtype: float64
```

For the sake of convenience, vectorbt has created the column levels `fast_window` and `slow_window` for us
to easily distinguish which window size corresponds to which column.

Notice how signal generation part remains the same for each example - most functions in vectorbt work on
time series of any shape. This allows creation of analysis pipelines that are universal to input data.

The representation of different features as columns offers endless possibilities for backtesting.
We could, for example, go a step further and conduct the same tests for Ethereum. To compare both instruments,
combine price series for Bitcoin and Ethereum into one DataFrame and run the same backtesting pipeline.

```python-repl
&gt;&gt;&gt; # Multiple strategy instances and instruments
&gt;&gt;&gt; eth_price = vbt.YFData.download(&#39;ETH-USD&#39;, start=start, end=end).get(&#39;Close&#39;)
&gt;&gt;&gt; comb_price = btc_price.vbt.concat(eth_price,
...     keys=pd.Index([&#39;BTC&#39;, &#39;ETH&#39;], name=&#39;symbol&#39;))
&gt;&gt;&gt; comb_price.vbt.drop_levels(-1, inplace=True)
&gt;&gt;&gt; comb_price
symbol              BTC         ETH
Date
2019-01-01  3843.520020  140.819412
2019-01-02  3943.409424  155.047684
2019-01-03  3836.741211  149.135010
...                 ...         ...
2019-12-30  7292.995117  132.633484
2019-12-31  7193.599121  129.610855
2020-01-01  7200.174316  130.802002

[366 rows x 2 columns]

&gt;&gt;&gt; fast_ma = vbt.MA.run(comb_price, [10, 20], short_name=&#39;fast&#39;)
&gt;&gt;&gt; slow_ma = vbt.MA.run(comb_price, [30, 30], short_name=&#39;slow&#39;)

&gt;&gt;&gt; entries = fast_ma.ma_above(slow_ma, crossover=True)
&gt;&gt;&gt; entries
fast_window            10            20
slow_window            30            30
symbol         BTC    ETH    BTC    ETH
Date
2019-01-01   False  False  False  False
2019-01-02   False  False  False  False
2019-01-03   False  False  False  False
...            ...    ...    ...    ...
2019-12-30   False  False  False  False
2019-12-31   False  False  False  False
2020-01-01   False  False  False  False

[366 rows x 4 columns]

&gt;&gt;&gt; exits = fast_ma.ma_below(slow_ma, crossover=True)
&gt;&gt;&gt; exits
fast_window            10            20
slow_window            30            30
symbol         BTC    ETH    BTC    ETH
Date
2019-01-01   False  False  False  False
2019-01-02   False  False  False  False
2019-01-03   False  False  False  False
...            ...    ...    ...    ...
2019-12-30   False  False  False  False
2019-12-31   False  False  False  False
2020-01-01   False  False  False  False

[366 rows x 4 columns]

&gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(comb_price, entries, exits)
&gt;&gt;&gt; portfolio.total_return()
fast_window  slow_window  symbol
10           30           BTC       0.848840
                          ETH       0.244204
20           30           BTC       0.543411
                          ETH      -0.319102
Name: total_return, dtype: float64

&gt;&gt;&gt; mean_return = portfolio.total_return().groupby(&#39;symbol&#39;).mean()
&gt;&gt;&gt; mean_return.vbt.barplot(xaxis_title=&#39;Symbol&#39;, yaxis_title=&#39;Mean total return&#39;)
```

![](/vectorbt/docs/img/index_by_symbol.png)

Not only strategies and instruments can act as separate features, but also time. If we want to find out
when our strategy performs best, it&#39;s reasonable to test it over multiple time periods. vectorbt allows
us to split one time period into many, given they have the same length and frequency, and represent
them as distinct columns. For example, let&#39;s split the whole time period into two equal time periods
and backest them at once.

```python-repl
&gt;&gt;&gt; # Multiple strategy instances, instruments, and time periods
&gt;&gt;&gt; mult_comb_price, _ = comb_price.vbt.range_split(n=2)
&gt;&gt;&gt; mult_comb_price
split_idx                         0                         1
symbol              BTC         ETH           BTC         ETH
0           3843.520020  140.819412  11961.269531  303.099976
1           3943.409424  155.047684  11215.437500  284.523224
2           3836.741211  149.135010  10978.459961  287.997528
...                 ...         ...           ...         ...
180        10817.155273  290.695984   7292.995117  132.633484
181        10583.134766  293.641113   7193.599121  129.610855
182        10801.677734  291.596436   7200.174316  130.802002

[183 rows x 4 columns]

&gt;&gt;&gt; fast_ma = vbt.MA.run(mult_comb_price, [10, 20], short_name=&#39;fast&#39;)
&gt;&gt;&gt; slow_ma = vbt.MA.run(mult_comb_price, [30, 30], short_name=&#39;slow&#39;)

&gt;&gt;&gt; entries = fast_ma.ma_above(slow_ma, crossover=True)
&gt;&gt;&gt; exits = fast_ma.ma_below(slow_ma, crossover=True)

&gt;&gt;&gt; portfolio = vbt.Portfolio.from_signals(mult_comb_price, entries, exits, freq=&#39;1D&#39;)
&gt;&gt;&gt; portfolio.total_return()
fast_window  slow_window  split_idx  symbol
10           30           0          BTC       1.632259
                                     ETH       0.946786
                          1          BTC      -0.288720
                                     ETH      -0.308387
20           30           0          BTC       1.721449
                                     ETH       0.343274
                          1          BTC      -0.418280
                                     ETH      -0.257947
Name: total_return, dtype: float64
```

Notice how index is no more datetime-like, since it captures multiple time periods.
That&#39;s why it&#39;s required here to pass the frequency `freq` to the `vectorbt.portfolio.base.Portfolio`
class method in order to be able to compute performance metrics such as the Sharpe ratio.

The index hierarchy of the final performance series can be then used to group the performance
by any feature, such as window pair, symbol, and time period.

```python-repl
&gt;&gt;&gt; mean_return = portfolio.total_return().groupby([&#39;split_idx&#39;, &#39;symbol&#39;]).mean()
&gt;&gt;&gt; mean_return.unstack(level=-1).vbt.barplot(
...     xaxis_title=&#39;Split index&#39;,
...     yaxis_title=&#39;Mean total return&#39;,
...     legend_title_text=&#39;Symbol&#39;)
```

![](/vectorbt/docs/img/index_by_any.png)

There is much more to backtesting than simply stacking columns: vectorbt offers functions for
most parts of a backtesting pipeline, from building indicators and generating signals, to
modeling portfolio performance and visualizing results.

## Resources

### Notebooks

- [Assessing performance of DMAC on Bitcoin](https://nbviewer.jupyter.org/github/polakowo/vectorbt/blob/master/examples/BitcoinDMAC.ipynb)
- [Comparing effectiveness of stop signals](https://nbviewer.jupyter.org/github/polakowo/vectorbt/blob/master/examples/StopSignals.ipynb)
- [Backtesting per trading session](https://nbviewer.jupyter.org/github/polakowo/vectorbt/blob/master/examples/TradingSessions.ipynb)
- [Portfolio optimization](https://nbviewer.jupyter.org/github/polakowo/vectorbt/blob/master/examples/PortfolioOptimization.ipynb)
- [Plotting MACD parameters as 3D volume](https://nbviewer.jupyter.org/github/polakowo/vectorbt/blob/master/examples/MACDVolume.ipynb)
- [Walk-forward optimization](https://nbviewer.jupyter.org/github/polakowo/vectorbt/blob/master/examples/WalkForwardOptimization.ipynb)
- [Running Telegram bot to send signals](https://nbviewer.jupyter.org/github/polakowo/vectorbt/blob/master/examples/TelegramSignals.ipynb)
- [Porting a backtrader strategy](https://nbviewer.jupyter.org/github/polakowo/vectorbt/blob/master/examples/PortingBTStrategy.ipynb)

Note: you must run the notebook to play with the widgets.

### Dashboards

- [Detecting and backtesting common candlestick patterns](https://github.com/polakowo/vectorbt/tree/master/apps/candlestick-patterns)

### Articles

- [Stop Loss, Trailing Stop, or Take Profit? 2 Million Backtests Shed Light](https://polakowo.medium.com/stop-loss-trailing-stop-or-take-profit-2-million-backtests-shed-light-dde23bda40be)

## Disclaimer

This software is for educational purposes only. Do not risk money which you are afraid to lose.
USE THE SOFTWARE AT YOUR OWN RISK. THE AUTHORS AND ALL AFFILIATES ASSUME NO RESPONSIBILITY FOR YOUR TRADING RESULTS.
&#34;&#34;&#34;

import importlib
import pkgutil

# Most important modules
from vectorbt.generic import nb, plotting

# Most important classes
from vectorbt.utils import *
from vectorbt.base import *
from vectorbt.data import *
from vectorbt.generic import *
from vectorbt.indicators import *
from vectorbt.signals import *
from vectorbt.records import *
from vectorbt.portfolio import *
from vectorbt.labels import *

# silence NumbaExperimentalFeatureWarning
import warnings
from numba.core.errors import NumbaExperimentalFeatureWarning

warnings.filterwarnings(&#34;ignore&#34;, category=NumbaExperimentalFeatureWarning)


def import_submodules(package):
    &#34;&#34;&#34;Import all submodules of a module, recursively, including subpackages.&#34;&#34;&#34;
    if isinstance(package, str):
        package = importlib.import_module(package)
    results = {}
    for _, name, is_pkg in pkgutil.walk_packages(package.__path__, package.__name__ + &#39;.&#39;):
        results[name] = importlib.import_module(name)
        if is_pkg:
            results.update(import_submodules(name))
    return results


import_submodules(__name__)</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="vectorbt.base" href="base/index.html">vectorbt.base</a></code></dt>
<dd>
<div class="desc"><p>Modules with base classes and utilities for pandas objects, such as broadcasting.</p></div>
</dd>
<dt><code class="name"><a title="vectorbt.data" href="data/index.html">vectorbt.data</a></code></dt>
<dd>
<div class="desc"><p>Modules for working with data sources.</p></div>
</dd>
<dt><code class="name"><a title="vectorbt.generic" href="generic/index.html">vectorbt.generic</a></code></dt>
<dd>
<div class="desc"><p>Modules for working with any time series …</p></div>
</dd>
<dt><code class="name"><a title="vectorbt.indicators" href="indicators/index.html">vectorbt.indicators</a></code></dt>
<dd>
<div class="desc"><p>Modules for building and running indicators …</p></div>
</dd>
<dt><code class="name"><a title="vectorbt.labels" href="labels/index.html">vectorbt.labels</a></code></dt>
<dd>
<div class="desc"><p>Modules for building and running look-ahead indicators and label generators.</p></div>
</dd>
<dt><code class="name"><a title="vectorbt.ohlcv" href="ohlcv/index.html">vectorbt.ohlcv</a></code></dt>
<dd>
<div class="desc"><p>Modules for working with OHLCV data.</p></div>
</dd>
<dt><code class="name"><a title="vectorbt.portfolio" href="portfolio/index.html">vectorbt.portfolio</a></code></dt>
<dd>
<div class="desc"><p>Modules for working with portfolios.</p></div>
</dd>
<dt><code class="name"><a title="vectorbt.px_accessors" href="px_accessors.html">vectorbt.px_accessors</a></code></dt>
<dd>
<div class="desc"><p>Plotly Express pandas accessors.</p></div>
</dd>
<dt><code class="name"><a title="vectorbt.records" href="records/index.html">vectorbt.records</a></code></dt>
<dd>
<div class="desc"><p>Modules for working with records …</p></div>
</dd>
<dt><code class="name"><a title="vectorbt.returns" href="returns/index.html">vectorbt.returns</a></code></dt>
<dd>
<div class="desc"><p>Modules for working with returns …</p></div>
</dd>
<dt><code class="name"><a title="vectorbt.root_accessors" href="root_accessors.html">vectorbt.root_accessors</a></code></dt>
<dd>
<div class="desc"><p>Root pandas accessors …</p></div>
</dd>
<dt><code class="name"><a title="vectorbt.settings" href="settings.html">vectorbt.settings</a></code></dt>
<dd>
<div class="desc"><p>Global defaults …</p></div>
</dd>
<dt><code class="name"><a title="vectorbt.signals" href="signals/index.html">vectorbt.signals</a></code></dt>
<dd>
<div class="desc"><p>Modules for working with signals, such as entry and exit signals.</p></div>
</dd>
<dt><code class="name"><a title="vectorbt.utils" href="utils/index.html">vectorbt.utils</a></code></dt>
<dd>
<div class="desc"><p>Modules with utilities that are used throughout vectorbt.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vectorbt.import_submodules"><code class="name flex">
<span>def <span class="ident fname">import_submodules</span></span>(<span>package)</span>
</code></dt>
<dd>
<div class="desc"><p>Import all submodules of a module, recursively, including subpackages.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_submodules(package):
    &#34;&#34;&#34;Import all submodules of a module, recursively, including subpackages.&#34;&#34;&#34;
    if isinstance(package, str):
        package = importlib.import_module(package)
    results = {}
    for _, name, is_pkg in pkgutil.walk_packages(package.__path__, package.__name__ + &#39;.&#39;):
        results[name] = importlib.import_module(name)
        if is_pkg:
            results.update(import_submodules(name))
    return results</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAIAAABMXPacAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABmtJREFUeNrsnD1vFEkQhtve+fIuax9gDDIHQubDSMiQOEByjERGxg+4iL9DRI6A4IhAAkLIIeV0BwEICQJbwpbshRXegDbmkAW2p96erp7qpiqxg9mveWuq3nqme8aWrlw3Gu3FuJ4CFUAF0FABVAANFUAF0FABVAANFUAF0FABVAANFUAF0FABko/M7WULqysLq8v046uryLsfM2aKeuyHlerhs2PQl79x8e33/yaMOQm80H6Q/Tj68Z2s6GQ5iwCXl99fe/eK+j2Om/5Z5N2XjJmmHvvi5R/3n/ShL//X2Zff/ztvzDz1VeuD7ObtI8YM6B/U7RdcJWhufY1+8NiE1Ov/BJb+WHEf79Smfwo9YP0TdhEvHv0/dWzx6QIvvPPoT+iDiomelCY8fgh8wTRw7H9vDwRI/6fPp6Hqb9M/LypGAaAODAvAGfMHN7b+TGEyo+mfl1S1fjsbOlmMvjUx4CU2922rB3re2FhedgUJgDXhKezNnyOnxsbsgaHJMfd56+9TWPWvulYDRgEgC7RtQ5GrlzcbZntDcxpp8oPMNgBstiqQbuHwG3qjzXhLUN+WINB9Wg2A/Ckq24FjRhHgFYC6oPlLGxLcZyMBjn4eYJfkGcYeAKUnt/vM8hJKf0cBZoYDE2csnltjdZ+2/cJDUtSeEkpPtL6h7pOC3jw14U2gCWMWyMZh5BwtYwLMn9rgc5/04SuoDRVF4iZ7Iyb3SWcPSZUglMTNHhnS2y/U3lHzE04AGAQhLgj1oHQBoPqzxR6c0t9RAF4SxzkJ92klyPZeqL07mJ9EShAaxCYMuU8IvbUgANaEwR+Ckjii+4Tarx2+6OjNgwC8JK7LmAqLF9a8p3+T9usoQNQkjuI+oXu/KHoT3wM4SRylAcDus2p6zcICoCQOK0GcJI4yhUHus5MV450stAAoiZMzCdcOAaj7LJtV/+htKEriagWA2q/NfQf05qMJIyQOnsI4Sdz+UxjqPptX/xA2VNaClH2bMGR+nNFbUiUIJXEe609eeetsvALAHZiNxNWmP91QfUNv7Qkwt77K5UENI4nbvwFA6Q8t+9FJuN4CWfcJXUxN0JvsHsBJ4o7P7CnAA5A9eEx/WADeBSmcJK7fHe3lPiH/U/gYvtwFmBl+itQy7dWEA6M32SWIeU2cB/dZ+ucqmAC9zS/Q8XJI3K43AyD36bbsx7MAcxvY3Ri5u8Nc3CfLj4l1EoZI3K4NwFYwehGzpT/Ly8gEkEPidp3CsPT3bX4cBVj4uMIoQMApDLr16BG9pVOCIBL36xR29zFkfirGOsH31nJI3K9T2IOn1PRvuOzHtwuKk8T91IShRz74RW+N54Ak1qRA8CcrKtYvI6YHcJK4nVOYrV30bRcc7MFdgHhJnED36SJApCRuZwOA3OfWsh/m9JdUgthI3M4pDHKfJX/6YwJESuJ2TmF098mE3hoJECmJ+zGFQZt+WYev6CdhCET/mMLo7ZeVPQQSgJXEOSxIgTb9FkGqPyxApCRuO+jLnpvsuPtdShAUdgqDNv36WvTZsgCsJO7FP9jWMPqtR2701swFRUjithsAvf023HHHPAdESOLsFAa5z5DtV1IPAC/6f9+Qx+DuiJ7+AdCbuwCiSBz9dpi9AgD3Gbb9YgJESuIw9NbJ5ArAG2AHRjcnUaIMXv0xAUSROPhBWbVnwdOOO0YBElsTJ6H6xzoJw49JrD0FAdFbIAHkkDhSA6ravFqpAkRN4mrYQxGDAKkG97KfdgSAOzDSAlESV1N/ym67GUB2QawkrqWT4H3HHecckOJzmoqWhi9hPQAcgOgkbv9weNB2awLIely6p0dEtDh8wQLEuzt1zy4VatlPgjbUC4krKimohCQAL4mbBgVoTOL4dtxxCZAYiZNgfmItQc1JXLvoLYQAMAiaBI5tTuKCLfr0KQAviQtoRsIv+0nQBTVjDxOtswd2ASSTuLwSZw9oLigJEtfKsh9Pc0ASJE6U+xTTA0KRuDA77lgESIPElSLTnyRAAiRODnqL3oa6kThpwxcmAErisEGMn8RJYw+wACiJk7YmpZBa/eMrQQ4kzs69cshzCAHgMZiZxLW+7KfeNNYesVz17p2+QK8/xWvk84fAJGwbAOompaG3XVJ26cp1o6E9QAXQUAFUAA0VQAXQUAFUAA0VQAXQUAFUAA0VQAXQUAFUAA2++CrAAE3lth2zPPJAAAAAAElFTkSuQmCC"/>
vectorbt</a>
</header>
<div class="search-container">
<input
id="search_input"
type="text"
placeholder="Search"
title="Search"
/>
</div>
<div class="scrollable-index">
<h1 class="index-caption">Index</h1>
<div class="toc">
<ul>
<li><a href="#how-it-works">How it works?</a></li>
<li><a href="#performance">Performance</a></li>
<li><a href="#usability">Usability</a><ul>
<li><a href="#indexing">Indexing</a></li>
<li><a href="#broadcasting">Broadcasting</a></li>
</ul>
</li>
<li><a href="#example">Example</a></li>
<li><a href="#resources">Resources</a><ul>
<li><a href="#notebooks">Notebooks</a></li>
<li><a href="#dashboards">Dashboards</a></li>
<li><a href="#articles">Articles</a></li>
</ul>
</li>
<li><a href="#disclaimer">Disclaimer</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="vectorbt.base" href="base/index.html">vectorbt.base</a></code></li>
<li><code><a title="vectorbt.data" href="data/index.html">vectorbt.data</a></code></li>
<li><code><a title="vectorbt.generic" href="generic/index.html">vectorbt.generic</a></code></li>
<li><code><a title="vectorbt.indicators" href="indicators/index.html">vectorbt.indicators</a></code></li>
<li><code><a title="vectorbt.labels" href="labels/index.html">vectorbt.labels</a></code></li>
<li><code><a title="vectorbt.ohlcv" href="ohlcv/index.html">vectorbt.ohlcv</a></code></li>
<li><code><a title="vectorbt.portfolio" href="portfolio/index.html">vectorbt.portfolio</a></code></li>
<li><code><a title="vectorbt.px_accessors" href="px_accessors.html">vectorbt.px_accessors</a></code></li>
<li><code><a title="vectorbt.records" href="records/index.html">vectorbt.records</a></code></li>
<li><code><a title="vectorbt.returns" href="returns/index.html">vectorbt.returns</a></code></li>
<li><code><a title="vectorbt.root_accessors" href="root_accessors.html">vectorbt.root_accessors</a></code></li>
<li><code><a title="vectorbt.settings" href="settings.html">vectorbt.settings</a></code></li>
<li><code><a title="vectorbt.signals" href="signals/index.html">vectorbt.signals</a></code></li>
<li><code><a title="vectorbt.utils" href="utils/index.html">vectorbt.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="vectorbt.import_submodules" href="#vectorbt.import_submodules">import_submodules</a></code></li>
</ul>
</li>
</ul>
</div>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
</body>
</html>